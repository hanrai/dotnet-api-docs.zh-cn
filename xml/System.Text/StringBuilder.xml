<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f0722363fbfdd2ec97d724d1e4aca1d1cd7c4efa" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69540468" /></Metadata><TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StringBuilder&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class StringBuilder sealed : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type StringBuilder = class&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可变字符字符串。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类表示一个类似字符串的对象, 其值为可变字符序列。  
  
 本节内容：  
  
-   [String 和 StringBuilder 类型](#StringAndSB)  
  
-   [StringBuilder 的工作方式](#HowWorks)  
  
-   [内存分配](#Memory)  
  
-   [实例化 StringBuilder 对象](#Instantiating)  
  
-   [调用 StringBuilder 方法](#Calling)  
  
-   [执行 StringBuilder 操作](#Operations)  
  
    -   [迭代 StringBuilder 字符](#Iterating)  
  
    -   [向 StringBuilder 对象添加文本](#Adding)  
  
    -   [从 StringBuilder 对象中删除文本](#Deleting)  
  
    -   [修改 StringBuilder 对象中的文本](#Modifying)  
  
-   [在 StringBuilder 对象中搜索文本](#Searching)  
  
-   [将 StringBuilder 对象转换为字符串](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>String 和 StringBuilder 类型  
 尽管<xref:System.Text.StringBuilder> 和<xref:System.String>都表示字符序列, 但它们的实现方式不同。 <xref:System.String>是不可变类型。 也就是说, 出现的用于修改<xref:System.String>对象的每个操作实际上都会创建一个新的字符串。  
  
 例如, 在以下<xref:System.String.Concat%2A?displayProperty=nameWithType> C#示例中, 对方法的调用将显示为更改名为`value`的字符串变量的值。 事实上, 该<xref:System.String.Concat%2A>方法将返回一个`value`对象, 该对象具有与传递给该方法`value`的对象不同的值和地址。 请注意, 必须使用`/unsafe`编译器选项编译该示例。  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 对于执行大量字符串操作的例程 (如在循环中多次修改字符串的应用程序), 重复修改字符串可能会显著降低性能。 替代方法是使用<xref:System.Text.StringBuilder>, 它是一个可变字符串类。 可变性是指在创建类的实例后, 可以通过追加、移除、替换或插入字符来修改它。 <xref:System.Text.StringBuilder>对象维护缓冲区以容纳对字符串的扩展。 如果空间可用, 则会将新数据追加到缓冲区;否则, 将分配一个新的更大的缓冲区, 将原始缓冲区中的数据复制到新缓冲区, 然后将新数据追加到新缓冲区。  
  
> [!IMPORTANT]
>  尽管类通常<xref:System.String>比类提供更好的性能, 但你不应在<xref:System.String>每次需要操作字符串时自动将替换为<xref:System.Text.StringBuilder>。 <xref:System.Text.StringBuilder> 性能取决于字符串的大小、要为新字符串分配的内存量、正在执行应用程序的系统以及操作的类型。 应该准备好测试应用程序, 以确定实际是否<xref:System.Text.StringBuilder>提供显著的性能改进。  
  
 请考虑在<xref:System.String>以下情况下使用类:  
  
-   当你的应用将对字符串进行的更改数量很小时。 在这些情况下<xref:System.Text.StringBuilder> , 可能会提供可忽略或不<xref:System.String>会提高性能的性能。  
  
-   当你执行固定数量的串联操作时, 尤其是字符串文本。 在这种情况下, 编译器可能会将串联操作合并为单个操作。  
  
-   在生成字符串时, 必须执行大量的搜索操作。 类缺少搜索方法, `IndexOf`如或`StartsWith`。 <xref:System.Text.StringBuilder> 对于这些操作, 必须将<xref:System.Text.StringBuilder>对象转换<xref:System.Text.StringBuilder>为, 这可能会使使用不会带来性能优势。 <xref:System.String> 有关详细信息, 请参阅在[StringBuilder 对象中搜索文本](#Searching)部分。  
  
 请考虑在<xref:System.Text.StringBuilder>以下情况下使用类:  
  
-   希望应用在设计时对字符串进行未知数量的更改 (例如, 当使用循环来连接包含用户输入的随机数量的字符串时)。  
  
-   希望应用对字符串进行大量更改时。  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>StringBuilder 的工作方式  
 属性指示<xref:System.Text.StringBuilder>对象当前包含的字符数。 <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> 如果向<xref:System.Text.StringBuilder>对象添加字符, 则其长度将增加, 直到它等于<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>属性的大小, 该大小定义对象可以包含的字符数。 如果添加的字符数导致<xref:System.Text.StringBuilder>对象的长度超过其当前容量, 则分配新内存, <xref:System.Text.StringBuilder.Capacity%2A>属性的值翻倍, 新<xref:System.Text.StringBuilder>字符将添加到对象中, 并且其<xref:System.Text.StringBuilder.Length%2A>属性已调整。 <xref:System.Text.StringBuilder>对象的额外内存会动态分配, 直到达到<xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType>属性定义的值。 达到最大容量时, 不能为该<xref:System.Text.StringBuilder>对象分配更多的内存, 尝试添加字符或将其扩展到超出其最大容量后, 会引发<xref:System.OutOfMemoryException> <xref:System.ArgumentOutOfRangeException>或例外。  
  
 下面的示例演示了<xref:System.Text.StringBuilder>对象如何分配新内存并动态增加其容量, 因为分配给对象的字符串会展开。 该代码通过调用<xref:System.Text.StringBuilder>其默认 (无参数) 构造函数来创建对象。 此对象的默认容量为16个字符, 其最大容量超过2000000000个字符。 追加字符串 "This is a 句子"。 由于字符串长度 (19 个字符) 超过<xref:System.Text.StringBuilder>对象的默认容量, 导致新的内存分配。 对象的容量长度为32个字符, 添加新字符串, 并且对象的长度现在等于19个字符。 然后, 该代码将追加字符串 "This is 其他句子"。 <xref:System.Text.StringBuilder>对象的值11次。 每当追加操作导致<xref:System.Text.StringBuilder>对象的长度超过其容量时, 其现有容量就会加倍<xref:System.Text.StringBuilder.Append%2A> , 操作成功。  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>内存分配  
 <xref:System.Text.StringBuilder>对象的默认容量是16个字符, 默认的最大容量为<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 如果调用<xref:System.Text.StringBuilder.%23ctor>和构造函数, <xref:System.Text.StringBuilder.%23ctor%28System.String%29>则使用这些默认值。  
  
 可以通过以下方式显式定义<xref:System.Text.StringBuilder>对象的初始容量:  
  
-   通过在创建对象时<xref:System.Text.StringBuilder>调用`capacity`包含参数的任何构造函数。  
  
-   通过将新值<xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType>显式分配给属性来展开现有<xref:System.Text.StringBuilder>对象。 请注意, 如果新容量小于现有容量或大于<xref:System.Text.StringBuilder>对象的最大容量, 则属性引发异常。  
  
-   通过使用新<xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType>容量调用方法。 新容量不得大于<xref:System.Text.StringBuilder>对象的最大容量。 但是, 与对<xref:System.Text.StringBuilder.Capacity%2A>属性的赋值不同, <xref:System.Text.StringBuilder.EnsureCapacity%2A>如果所需的新容量小于现有容量, 则不会引发异常; 在这种情况下, 方法调用不起作用。  
  
 如果分配给构造函数调用中的<xref:System.Text.StringBuilder>对象的字符串长度超过默认容量或指定的容量, 则<xref:System.Text.StringBuilder.Capacity%2A>将属性设置为与`value`参数一起指定的字符串长度。  
  
 可以通过<xref:System.Text.StringBuilder> <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>调用构造函数来显式定义对象的最大容量。 不能通过为<xref:System.Text.StringBuilder.MaxCapacity%2A>属性分配新值来更改最大容量, 因为它是只读的。  
  
 如上一节所示, 只要现有容量不足, 就会分配额外的内存, 并且<xref:System.Text.StringBuilder>对象的容量将与<xref:System.Text.StringBuilder.MaxCapacity%2A>属性定义的值加倍。  
  
 通常, 默认容量和最大容量适用于大多数应用。 可以考虑在以下条件下设置这些值:  
  
-   如果<xref:System.Text.StringBuilder>对象的最终大小可能会变得非常大, 通常会超出几兆字节。 在这种情况下, 将初始<xref:System.Text.StringBuilder.Capacity%2A>属性设置为明显较高的值可能会提高性能, 从而无需过多的内存重新分配。  
  
-   如果你的应用在内存有限的系统上运行。 在这种情况下, 您可能需要考虑将<xref:System.Text.StringBuilder.MaxCapacity%2A>属性设置为<xref:System.Int32.MaxValue?displayProperty=nameWithType>小于您的应用程序处理可能导致它在内存约束的环境中执行的大型字符串。  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>实例化 StringBuilder 对象  
 可以通过调用<xref:System.Text.StringBuilder>下表中列出的六个重载类构造函数之一来实例化对象。 三个构造函数实例化<xref:System.Text.StringBuilder>一个对象, 该对象的值为空字符串, <xref:System.Text.StringBuilder.Capacity%2A>但<xref:System.Text.StringBuilder.MaxCapacity%2A>以不同的方式设置其和值。 其余三个构造函数定义<xref:System.Text.StringBuilder>一个对象, 该对象具有特定的字符串值和容量。 这三个构造函数<xref:System.Int32.MaxValue?displayProperty=nameWithType>中的两个使用默认的最大容量, 而第三个构造函数可设置最大容量。  
  
|构造函数|字符串值|容量|最大容量|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|由`capacity`参数定义|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|由`capacity`参数定义|由`maxCapacity`参数定义|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|由`value`参数定义|16或`value`。 <xref:System.String.Length%2A>, 以较大者为准|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|由`value`参数定义|由`capacity`参数或`value`定义。 <xref:System.String.Length%2A>, 以较大者为准。|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|由 `value` 定义。 <xref:System.String.Substring%2A>(`startIndex`, `length`)|由`capacity`参数或`value`定义。 <xref:System.String.Length%2A>, 以较大者为准。|由`maxCapacity`参数定义|  
  
 下面的示例使用三个构造函数重载来实例<xref:System.Text.StringBuilder>化对象。  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>调用 StringBuilder 方法  
 修改<xref:System.Text.StringBuilder>实例中的字符串的大多数方法都将返回对同一实例的引用。 这使您可以通过<xref:System.Text.StringBuilder>两种方式调用方法:  
  
-   可以进行单个方法调用并忽略返回值, 如下例所示。  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   可以在单个语句中执行一系列方法调用。 如果要编写一条链接连续操作的语句, 这会很方便。 下面的示例将上一示例中的三个方法调用合并为单个代码行。  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>执行 StringBuilder 操作  
 您可以使用<xref:System.Text.StringBuilder>类的方法来循环访问、添加、删除或修改<xref:System.Text.StringBuilder>对象中的字符。  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>迭代 StringBuilder 字符  
 可以通过<xref:System.Text.StringBuilder> <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>使用属性访问对象中的字符。 在C#中<xref:System.Text.StringBuilder.Chars%2A> , 是索引器; 在 Visual Basic 中, 它是<xref:System.Text.StringBuilder>类的默认属性。 这使您可以仅使用索引来设置或检索单个字符, 而无需显式引用<xref:System.Text.StringBuilder.Chars%2A>属性。 <xref:System.Text.StringBuilder>对象中的字符从索引 0 (零) 开始, 并继续到<xref:System.Text.StringBuilder.Length%2A>索引-1。  
  
 下面的示例阐释<xref:System.Text.StringBuilder.Chars%2A>了属性。 它将10个随机数追加到<xref:System.Text.StringBuilder>对象, 然后循环访问每个字符。 如果该字符的 Unicode 类别为<xref:System.Globalization.UnicodeCategory.DecimalDigitNumber?displayProperty=nameWithType>, 则它将数字减 1 (如果其值为 0, 则将数字更改为 9)。 此示例在更改各个字符的<xref:System.Text.StringBuilder>值之前和之后都显示对象的内容。  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>向 StringBuilder 对象添加文本  
 此<xref:System.Text.StringBuilder>类包括以下方法来扩展<xref:System.Text.StringBuilder>对象的内容:  
  
-   方法追加字符串、子字符串、字符数组、字符数组的一部分、多次重复的单个字符或基元数据类型<xref:System.Text.StringBuilder>到对象的字符串表示形式。 <xref:System.Text.StringBuilder.Append%2A>  
  
-   方法将行终止符或字符串及行结束符一起追加<xref:System.Text.StringBuilder>到对象。 <xref:System.Text.StringBuilder.AppendLine%2A>  
  
-   方法将<xref:System.Text.StringBuilder> [复合格式字符串](~/docs/standard/base-types/composite-formatting.md)追加到对象。 <xref:System.Text.StringBuilder.AppendFormat%2A> 结果字符串中包含的对象的字符串表示形式可以反映当前系统区域性或指定区域性的格式设置约定。  
  
-   方法在<xref:System.Text.StringBuilder>对象中的指定位置插入字符串、子串、字符串的多个重复项、字符数组、部分字符数组或基元数据类型的字符串表示形式。 <xref:System.Text.StringBuilder.Insert%2A> 位置由从零开始的索引定义。  
  
 下面的示例使用<xref:System.Text.StringBuilder.Append%2A>、 <xref:System.Text.StringBuilder.AppendLine%2A>、 <xref:System.Text.StringBuilder.AppendFormat%2A> <xref:System.Text.StringBuilder.Insert%2A>和方法展开对象的文本。<xref:System.Text.StringBuilder>  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>从 StringBuilder 对象中删除文本  
 <xref:System.Text.StringBuilder>类包括可以减少的当前大小的方法<xref:System.Text.StringBuilder>实例。 <xref:System.Text.StringBuilder.Clear%2A>方法中删除所有字符，并设置<xref:System.Text.StringBuilder.Length%2A>属性设置为零。 <xref:System.Text.StringBuilder.Remove%2A>方法中删除指定的数量的特定索引位置开始的字符。 此外，从末尾删除字符<xref:System.Text.StringBuilder>对象通过设置其<xref:System.Text.StringBuilder.Length%2A>属性的值小于当前实例的长度。  
  
 下面的示例从<xref:System.Text.StringBuilder>对象中删除一些文本、显示其生成的容量、最大容量和 length 属性值, 然后<xref:System.Text.StringBuilder.Clear%2A>调用方法从<xref:System.Text.StringBuilder>对象中删除所有字符。  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>修改 StringBuilder 对象中的文本  
 方法将替换整个<xref:System.Text.StringBuilder>对象或特定字符范围内出现的所有字符或字符串。 <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> 下面的示例使用<xref:System.Text.StringBuilder.Replace%2A>方法将<xref:System.Text.StringBuilder>对象中的所有惊叹号 (!) 替换为问号 (？)。  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>在 StringBuilder 对象中搜索文本  
 <xref:System.String.IndexOf%2A?displayProperty=nameWithType> <xref:System.String.StartsWith%2A?displayProperty=nameWithType> <xref:System.String.Contains%2A?displayProperty=nameWithType>类不包括与类<xref:System.String>提供的、和方法类似的方法, 这允许您在对象中搜索特定字符或子字符串。 <xref:System.Text.StringBuilder> 若要确定子字符串的存在或起始字符位置, 需要使用字符串<xref:System.String>搜索方法或正则表达式方法搜索某个值。 可通过四种方式实现此类搜索, 如下表所示。  
  
|采用|专业人员|各有利弊|  
|---------------|----------|----------|  
|搜索字符串值, 然后将其添加<xref:System.Text.StringBuilder>到对象。|适用于确定子字符串是否存在。|子字符串的索引位置非常重要时, 不能使用。|  
|调用<xref:System.Text.StringBuilder.ToString%2A>并搜索返回<xref:System.String>的对象。|如果将所有文本分配到<xref:System.Text.StringBuilder>对象, 然后开始对其进行修改, 则可轻松使用。|如果您必须在<xref:System.Text.StringBuilder.ToString%2A>将所有文本添加<xref:System.Text.StringBuilder>到对象之前进行修改, 则重复调用会很繁琐。<br /><br /> 如果要进行更改, 则必须记得从<xref:System.Text.StringBuilder>对象的文本末尾进行操作。|  
|<xref:System.Text.StringBuilder.Chars%2A>使用属性按顺序搜索字符范围。|如果您担心单个字符或小型子字符串, 此方法非常有用。|如果搜索的字符数很大或者搜索逻辑很复杂, 则这种情况很繁琐。<br /><br />通过重复方法调用, 导致非常大的对象性能非常差。  |  
|将对象转换<xref:System.String>为对象, <xref:System.String>并对对象执行修改。 <xref:System.Text.StringBuilder>|如果修改次数较小, 则此方法很有用。|如果修改的数量较大<xref:System.Text.StringBuilder> , 则会使类的性能优势抵消。|  
  
 让我们更详细地研究一下这些方法。  
  
-   如果搜索的目标是确定特定的子字符串是否存在 (也就是说, 如果不想对子字符串的位置感兴趣), 可以在将<xref:System.Text.StringBuilder>字符串存储到对象之前对其进行搜索。 下面的示例提供了一个可能的实现。 它定义一个`StringBuilderFinder`类, 该类的构造函数传递<xref:System.Text.StringBuilder>对对象的引用以及要在字符串中查找的子字符串。 在这种情况下, 该示例将尝试确定是否已记录温度为华氏温度或摄氏温度, 并将相应的引导文本添加<xref:System.Text.StringBuilder>到对象的开头。 随机数生成器用于选择以摄氏或华氏度为单位包含数据的数组。  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   调用方法将<xref:System.Text.StringBuilder>对象转换为<xref:System.String>对象。 <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> 您可以使用<xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>或<xref:System.String.StartsWith%2A?displayProperty=nameWithType>等方法搜索字符串, 也可以<xref:System.Text.RegularExpressions.Regex>使用正则表达式和类搜索模式。 <xref:System.Text.StringBuilder>由于和<xref:System.String>对象使用 utf-16 编码存储字符, 因此字符、子字符串和正则表达式匹配项的索引位置在这两个对象中是相同的。 这使您可以使用<xref:System.Text.StringBuilder>方法在<xref:System.String>对象中找到该文本的同一位置进行更改。  
  
    > [!NOTE]
    >  如果采用这种方法, 应从<xref:System.Text.StringBuilder>对象的末尾开始工作, 这样就不必反复<xref:System.Text.StringBuilder>将对象转换为字符串。  
  
     下面的示例阐释了这种方法。 它在<xref:System.Text.StringBuilder>对象中存储每个英文字母的四个匹配项。 然后, 它将文本转换为<xref:System.String>对象, 并使用正则表达式标识每个四字符序列的起始位置。 最后, 在除第一个序列外的每个四字符序列之前添加下划线, 并将序列的第一个字符转换为大写。  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   使用属性可按顺序<xref:System.Text.StringBuilder>在对象中搜索一定范围内的字符。 <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> 如果要搜索的字符数很大或者搜索逻辑特别复杂, 则这种方法可能不可行。 对于非常大的分块<xref:System.Text.StringBuilder>对象的基于字符索引的访问的性能影响, 请参阅<xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType>属性的文档。 
  
     下面的示例与上一个示例的功能相同, 但实现方式不同。 它使用<xref:System.Text.StringBuilder.Chars%2A>属性来检测某个字符值已更改的时间, 在该位置插入一个下划线, 并将新序列中的第一个字符转换为大写。  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   将所有未修改的文本存储<xref:System.Text.StringBuilder>在对象中, <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>调用方法将<xref:System.Text.StringBuilder>对象<xref:System.String>转换为对象, 然后对<xref:System.String>对象执行修改。 如果只有少量的修改, 可以使用此方法;否则, 使用不可变字符串的成本可能会抵消使用<xref:System.Text.StringBuilder>对象的性能优势。  
  
     下面的示例在功能上与前面两个示例相同, 但实现方式不同。 它将创建<xref:System.Text.StringBuilder>一个对象, 将其转换<xref:System.String>为对象, 然后使用正则表达式对该字符串执行所有剩余的修改。 <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType>方法使用 lambda 表达式对每个匹配项执行替换。  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>将 StringBuilder 对象转换为字符串  
 必须先将 <xref:System.Text.StringBuilder> 对象转换为 <xref:System.String> 对象，然后才能将 <xref:System.Text.StringBuilder> 对象表示的字符串传递给包含 <xref:System.String> 参数的方法，或在用户界面中显示它。 可以通过调用<xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType>方法来执行此转换。 有关说明, 请参阅前面的示例, 该示例调用<xref:System.Text.StringBuilder.ToString%2A>方法将<xref:System.Text.StringBuilder>对象转换为字符串, 以便可以将其传递给正则表达式方法。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder>类定义的多个方法。  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
    <altmember cref="T:System.String" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实例的字符串值设置为<xref:System.String.Empty?displayProperty=nameWithType>, 容量设置为特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用不带<xref:System.Text.StringBuilder.%23ctor%2A>参数的构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">此实例的建议起始大小。</param>
        <summary>使用指定的容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超出此`capacity`值, 则<xref:System.Text.StringBuilder>对象将分配额外的内存来存储它们。  
  
 此实例的字符串值设置为<xref:System.String.Empty?displayProperty=nameWithType>。 如果`capacity`为零, 则使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何使用指定的<xref:System.Text.StringBuilder.%23ctor%2A>容量调用构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</param>
        <summary>使用指定的字符串初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果 `value` 为 `null`，则新的 <xref:System.Text.StringBuilder> 将包含空字符串（即包含 <xref:System.String.Empty>）。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>具有指定字符串的构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, maxCapacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(int capacity, int maxCapacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (capacity, maxCapacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <param name="maxCapacity">当前字符串可包含的最大字符数。</param>
        <summary>初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例，该类起始于指定容量并且可增长到指定的最大容量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超出此`capacity`值, 则<xref:System.Text.StringBuilder>对象将分配额外的内存来存储它们。  
  
 如果`capacity`为零, 则使用特定于实现的默认容量。  
  
 `maxCapacity`属性定义当前实例可以容纳的最大字符数。 它的值被分配给<xref:System.Text.StringBuilder.MaxCapacity%2A>属性。 如果要在当前实例中存储的字符数超过此`maxCapacity`值, 则<xref:System.Text.StringBuilder>对象不会分配额外的内存, 而是引发异常。  
  
   
  
## Examples  
 下面的示例演示如何使用指定的<xref:System.Text.StringBuilder.%23ctor%2A>容量和最大容量调用构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxCapacity" /> 小于一，<paramref name="capacity" /> 小于零，或 <paramref name="capacity" /> 大于 <paramref name="maxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
        <altmember cref="P:System.Text.StringBuilder.MaxCapacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">用于初始化实例值的字符串。 如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>使用指定的字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超出此`capacity`值, 则<xref:System.Text.StringBuilder>对象将分配额外的内存来存储它们。  
  
 如果`capacity`为零, 则使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何使用初始字符串<xref:System.Text.StringBuilder.%23ctor%2A>和指定的容量调用构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As String, startIndex As Integer, length As Integer, capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StringBuilder(System::String ^ value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="F#" Value="new System.Text.StringBuilder : string * int * int * int -&gt; System.Text.StringBuilder" Usage="new System.Text.StringBuilder (value, startIndex, length, capacity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符串包含用于初始化此实例值的子字符串。 如果 <paramref name="value" /> 为 <see langword="null" />，则新的 <see cref="T:System.Text.StringBuilder" /> 将包含空字符串（即包含 <see cref="F:System.String.Empty" />）。</param>
        <param name="startIndex"><paramref name="value" /> 中子字符串开始的位置。</param>
        <param name="length">子字符串中的字符数。</param>
        <param name="capacity"><see cref="T:System.Text.StringBuilder" /> 的建议起始大小。</param>
        <summary>从指定的子字符串和容量初始化 <see cref="T:System.Text.StringBuilder" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `capacity`参数定义可存储在当前实例所分配的内存中的最大字符数。 它的值被分配给<xref:System.Text.StringBuilder.Capacity%2A>属性。 如果要存储在当前实例中的字符数超出此`capacity`值, 则<xref:System.Text.StringBuilder>对象将分配额外的内存来存储它们。  
  
 如果`capacity`为零, 则使用特定于实现的默认容量。  
  
   
  
## Examples  
 下面的示例演示如何调用<xref:System.Text.StringBuilder.%23ctor%2A>具有指定字符串的构造函数。  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 加 <paramref name="length" /> 不是 <paramref name="value" /> 中的位置。</exception>
        <altmember cref="P:System.Text.StringBuilder.Capacity" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Append">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(bool value);" />
      <MemberSignature Language="F#" Value="member this.Append : bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">要追加的布尔值。</param>
        <summary>向此实例追加指定的布尔值的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Boolean%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 方法调用方法来获取的`value`字符串表示形式。 <xref:System.Boolean.ToString?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Boolean%29> 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Append : byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Byte%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.Byte.ToString%28System.IFormatProvider%29> <xref:System.Text.StringBuilder.Append%28System.Byte%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value);" />
      <MemberSignature Language="F#" Value="member this.Append : char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">要追加的 UTF 16 编码的代码单元。</param>
        <summary>将指定的 <see cref="T:System.Char" /> 对象的字符串表示形式追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符数组。</param>
        <summary>向此实例追加指定数组中的 Unicode 字符的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定数组中的所有字符追加到当前实例, 其顺序与它们在中出现`value`的顺序相同。 如果`value` 为`null`, 则不进行任何更改。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Append : decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的十进制数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Decimal%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Decimal%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(double value);" />
      <MemberSignature Language="F#" Value="member this.Append : double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的双精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Double%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Double%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(short value);" />
      <MemberSignature Language="F#" Value="member this.Append : int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int16%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Int16%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(int value);" />
      <MemberSignature Language="F#" Value="member this.Append : int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int32%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Int32%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(long value);" />
      <MemberSignature Language="F#" Value="member this.Append : int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Int64%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 方法调用以获取当前区域性的的字符串表示形式。 `value` <xref:System.Text.StringBuilder.Append%28System.Int64%29> <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要追加的对象。</param>
        <summary>向此实例追加指定对象的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Object%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。 它定义了`Dog`一个类, 创建`Dog`一个对象, 并对<xref:System.Text.StringBuilder.Append%2A>方法进行了三次调用, 以创建一个包含狗名称和同类的字符串。  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 方法调用方法来获取的`value`字符串表示形式。 <xref:System.Object.ToString%2A?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Object%29> 如果`value` <xref:System.Text.StringBuilder>为`null`, 则不会对对象进行任何更改。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlyMemory`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlyMemory{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlyMemory(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlyMemory&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlyMemory&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlyMemory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要追加的只读字符内存区域。</param>
        <summary>向此实例追加指定的只读字符内存区域的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Append : ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">要追加的只读字符范围。</param>
        <summary>向此实例追加指定的只读字符范围的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Append : sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 8 位有符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.SByte%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.SByte%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(float value);" />
      <MemberSignature Language="F#" Value="member this.Append : single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的单精度浮点数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Single%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.Single.ToString%2A?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.Single%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>向此实例追加指定字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.String%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 如果`value` 为`null`, 则不进行任何更改。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串生成器。</param>
        <summary>向此实例追加指定的字符串生成器的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 16 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt16%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 方法调用方法来获取的`value`字符串表示形式。 <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.UInt16%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 32 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt32%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.UInt32%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Append : uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">要追加的值。</param>
        <summary>向此实例追加指定的 64 位无符号整数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.UInt64%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 方法调用方法为当前区域性`value`获取的字符串表示形式。 <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> <xref:System.Text.StringBuilder.Append%28System.UInt64%29> 若要控制的格式`value`, 请<xref:System.Text.StringBuilder.AppendFormat%2A>调用方法。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char, repeatCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char value, int repeatCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, repeatCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符。</param>
        <param name="repeatCount">要追加 <paramref name="value" /> 的次数。</param>
        <summary>向此实例追加 Unicode 字符的字符串表示形式指定数目的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="repeatCount" /> 小于零。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.OutOfMemoryException">内存不足。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(char* value, int valueCount);" />
      <MemberSignature Language="F#" Value="member this.Append : nativeptr&lt;char&gt; * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, valueCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="valueCount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">指向字符数组的指针。</param>
        <param name="valueCount">数组中的字符数。</param>
        <summary>将从指定地址开始的 Unicode 字符数组追加到此实例。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将`valueCount`从 address `value`开始的字符追加到当前实例。  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="valueCount" /> 小于零。  
  
- 或 - 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> 为 null 指针。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Append : char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">字符数组。</param>
        <param name="startIndex"><paramref name="value" /> 中的起始位置。</param>
        <param name="charCount">要追加的字符数。</param>
        <summary>向此实例追加指定的 Unicode 字符子数组的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定范围的字符追加到`value`当前实例中。 如果`value`为`null`和`startIndex`且均为零,则不进行任何更改。`count`  
  
 <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="charCount" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 小于零。  
  
或 
 <paramref name="startIndex" /> + <paramref name="charCount" /> 大于 <paramref name="value" /> 的长度。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">包含要追加的子字符串的字符串。</param>
        <param name="startIndex"><paramref name="value" /> 中子字符串开始的位置。</param>
        <param name="count">要追加的 <paramref name="value" /> 中的字符数。</param>
        <summary>向此实例追加指定子字符串的副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将指定范围的字符追加到`value`当前实例中。 如果`value`为`null`和`startIndex`且均为零,则不进行任何更改。`count`  
  
 <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29>方法修改此类的现有实例, 而不返回新的类实例。 因此, 你可以对现有引用调用方法或属性, 并且不必将返回值分配给<xref:System.Text.StringBuilder>对象, 如下面的示例所示。  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="count" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> + <paramref name="count" /> 大于 <paramref name="value" /> 的长度。  
  
- 或 - 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (System.Text.StringBuilder value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(class System.Text.StringBuilder value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Text.StringBuilder,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Append (value As StringBuilder, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Append(System::Text::StringBuilder ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Append : System.Text.StringBuilder * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Append (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Text.StringBuilder" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">包含要追加的子字符串的字符串生成器。</param>
        <param name="startIndex"><paramref name="value" /> 中子字符串开始的位置。</param>
        <param name="count">要追加的 <paramref name="value" /> 中的字符数。</param>
        <summary>向此实例追加指定字符串生成器中的子字符串副本。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendFormat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由相应的对象自变量的字符串表示形式替换。</summary>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都替换为 <paramref name="arg0" /> 的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将对象的值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 `format`参数包含与零个或多个索引占位符 (称为格式项) 混合的零个或多个文本的运行。 格式项的索引必须为 0, 以对应`arg0`于此方法的参数列表中的单个对象。 格式设置过程将每个格式项替换为的字符串`arg0`表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 如果*索引*位置中没有参数, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0`表示要设置格式的对象。 中`format`的每个格式项都替换为的字符串`arg0`表示形式。 如果格式项`formatString`包含并`arg0`实现<xref:System.IFormattable>接口, 则`arg0.ToString(formatString, null)`定义格式设置。 否则, `arg0.ToString()`会定义格式设置。  
  
 如果分配给`format`的字符串为 "感谢你向慈善组织捐赠 {0: # # # #} 个食物 和`arg0`是一个值为10的整数, 则返回值将为 "感谢你向慈善组织捐赠10罐食物"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于或等于 1。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将对象的值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 `format`参数包含与零个或多个索引占位符 (称为格式项) 混合的零个或多个文本的运行, 这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 如果*索引*位置中没有参数, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `args`表示要设置格式的对象。 中`format`的每个格式项都替换为中`args`相应对象的字符串表示形式。 `formatString`如果格式项包括, 并且中`args`的相应对象实现<xref:System.IFormattable>接口, 则`args[index].ToString(formatString, provider)`定义格式设置。 否则, `args[index].ToString()`会定义格式设置。  
  
 如果分配给`format`的字符串为 "感谢你向慈善组织捐赠 {0: # # # #} 个食物 和`arg0`是一个值为10的整数, 则返回值将为 "感谢你向慈善组织捐赠10罐食物"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 或 <paramref name="args" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
- 或 - 
格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为单个参数的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由 <paramref name="arg0" /> 的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将的`arg0`值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 `format`参数包含与零个或多个索引占位符 (称为格式项) 混合的零个或多个文本的运行。 每个格式项的索引必须为零 (0), 因为此方法包含一个带有单个参数的参数列表。 格式设置过程将每个格式项替换为的字符串`arg0`表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 在这种情况下, <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>因为方法在参数列表中有一个参数, 所以*index*的值必须始终为0。 如果不是, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 参数指定一个<xref:System.IFormatProvider>实现, 该实现可以为中`args`的对象提供格式设置信息。 `provider` `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>对象, 提供区域性特定的格式设置信息。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象, 它提供有关的`arg0`区域性特定格式设置信息。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象, 它提供有关的`arg0`区域性特定格式设置信息。  
  
-   <xref:System.IFormatProvider> 为`arg0`提供格式设置信息的自定义实现。 通常, 此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果参数为`null`, 则从当前区域性获取格式设置信息。 `provider`  
  
 `arg0`表示要设置格式的对象。 中`format`的每个格式项都替换为的字符串`arg0`表示形式。 如果格式项`formatString`包含并`arg0`实现<xref:System.IFormattable>接口, 则`arg0.ToString(formatString, provider)`定义格式设置。 否则, `arg0.ToString()`会定义格式设置。  
  
   
  
## Examples  
 下面包括对方法的<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29>两次调用。 两者都使用英语 (英国) 区域性的格式约定。 第一个在结果字符串中插入货币<xref:System.Decimal>值的字符串表示形式。 第二个将<xref:System.DateTime>值插入到结果字符串中的两个位置, 第一个是只包含短日期字符串, 第二个在短时间字符串中。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于等于一 (1)。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, ParamArray args As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="args">要设置其格式的对象的数组。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序由参数数组中相应参数的字符串表示形式替换。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将对象的值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 `format`参数包含与零个或多个索引占位符 (称为格式项) 混合的零个或多个文本的运行, 这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 如果*索引*位置中没有参数, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 参数指定一个<xref:System.IFormatProvider>实现, 该实现可以为中`args`的对象提供格式设置信息。 `provider` `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>对象, 提供区域性特定的格式设置信息。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象, 该对象为中`args`的数字值提供区域性特定的格式设置信息。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象, 该对象为中`args`的日期和时间值提供区域性特定的格式设置信息。  
  
-   为中<xref:System.IFormatProvider> `args`的一个或多个对象提供格式设置信息的自定义实现。 通常, 此类实现还实现<xref:System.ICustomFormatter>接口。 下一节中的第二个示例<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>演示了使用自定义<xref:System.IFormatProvider>实现的方法调用。  
  
 如果参数为`null`, 则从当前区域性获取格式提供程序信息。 `provider`  
  
 `args`表示要设置格式的对象。 中`format`的每个格式项都替换为中`args`相应对象的字符串表示形式。 `formatString`如果格式项包括, 并且中`args`的相应对象实现<xref:System.IFormattable>接口, 则`args[index].ToString(formatString, provider)`定义格式设置。 否则, `args[index].ToString()`会定义格式设置。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 下面的示例定义了一个<xref:System.IFormatProvider>名为`CustomerFormatter`的自定义实现, 该实现在第四个和第七个数字后设置一个包含连字符的10位客户编号 它被传递给<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>方法以创建一个字符串, 该字符串包含带格式的客户编号和客户名称。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于或等于 <paramref name="args" /> 数组的长度。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这两个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将对象的值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 参数包含与零个或多个索引占位符 (称为格式项) 混合的零个或多个文本的运行`arg0` , 这两个对象分别与此方法的参数列表中的两个对象相对应`arg1`。 `format` 格式设置过程将每个格式项替换为相应对象的字符串表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 如果*索引*位置中没有参数, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0`和`arg1`表示要设置格式的对象。 中`format`的每个格式项都替换为`arg0`或`arg1`的字符串表示形式。 如果格式`formatString`项包括, 并且相应的对象<xref:System.IFormattable>实现接口, 则`arg` *x* `.ToString(formatString, provider)`定义格式设置, 其中*x*是参数的索引。 否则, `arg`  x`.ToString()`定义格式设置。  
  
 如果分配给`format`的字符串为 "感谢你向慈善组织捐赠 {0: # # # #} 个食物 和`arg0`是一个值为10的整数, 则返回值将为 "感谢你向慈善组织捐赠10罐食物"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零），或者大于等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为两个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将对象的值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 `format`参数包含与零个或多个索引占位符 (称为格式项) 混合的零个或多个文本的运行, 这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 如果*索引*位置中没有参数, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 参数指定可为`arg0`和提供`arg1`格式设置信息的实现。<xref:System.IFormatProvider> `provider` `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>对象, 提供区域性特定的格式设置信息。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象, `arg0` 它`arg1`为提供区域性特定的格式设置信息, 如果它们是数字值, 则为。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象, 它为提供区域性特定的格式`arg0`设置`arg1`信息, 或者, 为日期和时间值。  
  
-   为`arg0`和<xref:System.IFormatProvider> 提供`arg1`格式设置信息的自定义实现。 通常, 此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果参数为`null`, 则从当前区域性获取格式提供程序信息。 `provider`  
  
 `arg0`和`arg1`表示要设置格式的对象。 中`format`的每个格式项都替换为具有相应索引的对象的字符串表示形式。 如果格式项包括`formatString` , 并且相应的参数实现了<xref:System.IFormattable>接口, 则参数的`ToString(formatString, provider)`方法会定义格式设置。 否则, 自变量的`ToString()`方法定义格式设置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29>方法来显示通用<xref:System.Collections.Generic.Dictionary%602>对象中存储的时间和温度数据。 请注意, 格式字符串具有三个格式项, 但仅有要设置格式的对象。 这是因为列表中的第一个对象 (日期和时间值) 由两个格式项使用:第一个格式项显示时间, 第二个格式项显示日期。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零）或者大于或等于 2。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和在 .NET Framework 4.0 及更高版本中, 当你通过<see cref="T:System.Text.StringBuilder" /> <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量可能会超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都替换为这三个参数中任意一个参数的字符串表示形式。</summary>
        <returns>对追加了 <paramref name="format" /> 的此实例的引用。 <paramref name="format" /> 中的每个格式项都由相应的对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将对象的值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 参数由零个或多个包含零个或多个索引占位符 (称为格式项, 它们对应`arg2`于`arg0` ), 这种方法的参数列表中的对象组成。 `format` 格式设置过程将每个格式项替换为相应对象的字符串表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 如果*索引*位置中没有参数, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 `arg0`、 `arg1`和`arg2`表示要设置格式的对象。 中`format`的每个格式项都替换为`arg0`、 `arg1`或`arg2`的字符串表示形式, 具体取决于格式项的索引。 如果格式项包括`formatString` , 并且中`.ToString(formatString, null)` <xref:System.IFormattable> `args`的相应对象实现接口, 则`arg` *x*定义格式设置, 其中*x*是参数的索引。 否则, `arg`  x`.ToString()`定义格式设置。  
  
 如果分配给`format`的字符串为 "感谢你向慈善组织捐赠 {0: # # # #} 个食物 和`arg0`是一个值为10的整数, 则返回值将为 "感谢你向慈善组织捐赠10罐食物"。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendFormat%2A>方法。  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
- 或 - 
格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendFormat (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendFormat(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="member this.AppendFormat : IFormatProvider * string * obj * obj * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendFormat (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">一个提供区域性特定的格式设置信息的对象。</param>
        <param name="format">复合格式字符串。</param>
        <param name="arg0">要设置格式的第一个对象。</param>
        <param name="arg1">要设置格式的第二个对象。</param>
        <param name="arg2">要设置格式的第三个对象。</param>
        <summary>向此实例追加通过处理复合格式字符串（包含零个或更多格式项）而返回的字符串。 每个格式项都使用指定的格式提供程序替换为三个参数中任一个的字符串表示形式。</summary>
        <returns>完成追加操作后对此实例的引用。 完成追加操作后，此实例包含执行该操作之前已存在的任何数据，并且有一个 <paramref name="format" /> 的副本作为后缀，其中任何格式规范都由相应对象参数的字符串表示形式替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用 .NET Framework 的[复合格式设置功能](~/docs/standard/base-types/composite-formatting.md)将对象的值转换为其文本表示形式, 并将该表示形式嵌入到当前<xref:System.Text.StringBuilder>对象中。  
  
 `format`参数包含与零个或多个索引占位符 (称为格式项) 混合的零个或多个文本的运行, 这些占位符与此方法的参数列表中的对象相对应。 格式设置过程将每个格式项替换为相应对象的字符串表示形式。  
  
 格式项的语法如下所示:  
  
 {*index*[,*length*] [:*格式字符串*]}  
  
 括号中的元素是可选的。 下表对每个元素进行了描述。  
  
|元素|说明|  
|-------------|-----------------|  
|*index*|要设置格式的对象的参数列表中的从零开始的位置。 如果由*index*指定的对象为`null`, 则会将格式<xref:System.String.Empty?displayProperty=nameWithType>项替换为。 如果*索引*位置中没有参数, <xref:System.FormatException>则会引发。|  
|、*length*|参数的字符串表示形式中的最小字符数。 如果为正, 则参数为右对齐; 否则为。如果为负, 则为左对齐。|  
|:*formatString*|参数支持的标准或自定义格式字符串。|  
  
> [!NOTE]
>  对于用于日期和时间值的标准和自定义格式字符串, 请参阅[标准日期和时间格式](~/docs/standard/base-types/standard-date-and-time-format-strings.md)字符串和[自定义日期和时间格式字符串](~/docs/standard/base-types/custom-date-and-time-format-strings.md)。 对于与数值一起使用的标准和自定义格式字符串, 请参阅[标准数字格式字符串](~/docs/standard/base-types/standard-numeric-format-strings.md)和[自定义数字格式字符串](~/docs/standard/base-types/custom-numeric-format-strings.md)。 对于用于枚举的标准格式字符串, 请参阅[枚举格式字符串](~/docs/standard/base-types/enumeration-format-strings.md)。  
  
 参数指定可为`arg0`和提供`arg1`格式设置信息的实现。<xref:System.IFormatProvider> `provider` `provider` 可以是以下任意形式：  
  
-   一个<xref:System.Globalization.CultureInfo>对象, 提供区域性特定的格式设置信息。  
  
-   一个<xref:System.Globalization.NumberFormatInfo>对象, `arg0` 它`arg1`为提供区域性特定的格式设置信息, 如果它们是数字值, 则为。  
  
-   一个<xref:System.Globalization.DateTimeFormatInfo>对象, 提供、或`arg0` `arg2`的区域性特定格式设置`arg1`信息, 如果它们是日期和时间值, 则为。  
  
-   提供、 <xref:System.IFormatProvider> `arg0`和`arg2`的格式设置信息的自定义实现。 `arg1` 通常, 此类实现还实现<xref:System.ICustomFormatter>接口。  
  
 如果参数为`null`, 则从当前区域性获取格式提供程序信息。 `provider`  
  
 `arg0`、 `arg1`和`arg2`表示要设置格式的对象。 中`format`的每个格式项都替换为具有相应索引的对象的字符串表示形式。 如果格式项包括`formatString` , 并且相应的参数实现了<xref:System.IFormattable>接口, 则参数的`ToString(formatString, provider)`方法会定义格式设置。 否则, 自变量的`ToString()`方法定义格式设置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29>方法来说明具有整数值的布尔`And`运算的结果。 请注意, 格式字符串包含六个格式项, 但该方法在其参数列表中只有三个项, 因为每个项都以两种不同的方式进行格式化。  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> 无效。  
  
或 
格式项的索引小于 0（零）或者大于或等于 3。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">扩展的字符串的长度将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">设置 .NET 中类型的格式</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">复合格式设置</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md">如何：定义和使用自定义数值格式提供程序</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">标准数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">自定义数字格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">标准日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">自定义日期和时间格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">标准 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">自定义的 TimeSpan 格式字符串</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">枚举格式字符串</related>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As Char, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As Object()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * obj[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin (separator As String, ParamArray values As String()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * string[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As Char, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : char * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendJoin(Of T) (separator As String, values As IEnumerable(Of T)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; System::Text::StringBuilder ^ AppendJoin(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.AppendJoin : string * seq&lt;'T&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendJoin (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AppendLine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将默认的行终止符（或指定字符串的副本和默认的行终止符）追加到此实例的末尾。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine();" />
      <MemberSignature Language="F#" Value="member this.AppendLine : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将默认的行终止符追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认的行终止符是<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>属性的当前值。  
  
 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.AppendLine%2A>方法。  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendLine (value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ AppendLine(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.AppendLine : string -&gt; System.Text.StringBuilder" Usage="stringBuilder.AppendLine value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要追加的字符串。</param>
        <summary>将后面跟有默认行终止符的指定字符串的副本追加到当前 <see cref="T:System.Text.StringBuilder" /> 对象的末尾。</summary>
        <returns>完成追加操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认的行终止符是<xref:System.Environment.NewLine%2A?displayProperty=nameWithType>属性的当前值。  
  
 此实例的容量会根据需要进行调整。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在 .net Core 和 .NET Framework 4.0 及更高版本<see cref="T:System.Text.StringBuilder" />中, 当通过<see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />调用构造函数实例化对象时, <see cref="T:System.Text.StringBuilder" />实例的长度和容量超出其<see cref="P:System.Text.StringBuilder.MaxCapacity" />知识产权. 当调用<see cref="M:System.Text.StringBuilder.Append(System.String)" />和方法追加小字符串时, <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />尤其如此。</para></block>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Capacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Capacity { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Capacity : int with get, set" Usage="System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可包含在当前实例所分配的内存中的最大字符数。</summary>
        <value>可包含在当前实例所分配的内存中的最大字符数。 其值可以从 <see cref="P:System.Text.StringBuilder.Length" /> 到 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A>不影响当前实例的字符串值。 <xref:System.Text.StringBuilder.Capacity%2A>可以减小, 只要它不小于<xref:System.Text.StringBuilder.Length%2A>。  
  
 需要时<xref:System.Text.StringBuilder.Capacity%2A>动态分配更多的空间, 并相应增加。 <xref:System.Text.StringBuilder> 出于性能原因, 可能<xref:System.Text.StringBuilder>会分配比所需内存更多的内存。 分配的内存量是特定于实现的。  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Text.StringBuilder.Capacity%2A>属性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为集运算指定的值小于此实例的当前长度。  
  
 或  
  
 为集运算指定的值大于最大容量。</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); void set(int index, char value); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char with get, set" Usage="System.Text.StringBuilder.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">字符的位置。</param>
        <summary>获取或设置此实例中指定字符位置处的字符。</summary>
        <value><paramref name="index" /> 位置处的 Unicode 字符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数是中字符的位置。 <xref:System.Text.StringBuilder> `index` 字符串中的第一个字符位于索引0处。 字符串的长度是它包含的字符数。 <xref:System.Text.StringBuilder>实例的最后一个可访问字符位于索引<xref:System.Text.StringBuilder.Length%2A> -1 处。  
  
 <xref:System.Text.StringBuilder.Chars%2A>是<xref:System.Text.StringBuilder>类的默认属性。 在C#中, 它是一个索引器。 这意味着, 可以从<xref:System.Text.StringBuilder.Chars%2A>属性中检索各个字符, 如下面的示例所示, 它对字符串中的字母、空格和标点符号的数目进行计数。  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  

### <a name="performance-and-character-based-indexing"></a>基于性能和字符的索引

[!INCLUDE[stringbuilder-performance-note](~/includes/stringbuilder-perf-note.md)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">设置字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <exception cref="T:System.IndexOutOfRangeException">获取字符时，<paramref name="index" /> 在此实例的范围之外。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; System.Text.StringBuilder" Usage="stringBuilder.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从当前 <see cref="T:System.Text.StringBuilder" /> 实例中移除所有字符。</summary>
        <returns>其 <see cref="P:System.Text.StringBuilder.Length" /> 为 0（零）的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Text.StringBuilder.Clear%2A> 是一种便捷方法，相当于将当前实例的<xref:System.Text.StringBuilder.Length%2A>属性设置为0（零）。  
  
## Examples

以下示例使用字符串实例化<xref:System.Text.StringBuilder>对象，调用<xref:System.Text.StringBuilder.Clear%2A>方法，然后将追加一个新的字符串。  
  
[!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
[!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, valuetype System.Span`1&lt;char&gt; destination, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Span{System.Char},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Span(Of Char), count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, Span&lt;char&gt; destination, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * Span&lt;char&gt; * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="stringBuilder.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destination" Type="System.Char[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">此实例中开始复制字符的位置。 索引是从零开始的。</param>
        <param name="destination">将从中复制字符的数组。</param>
        <param name="destinationIndex"><paramref name="destination" /> 中将从其开始复制字符的起始位置。 索引是从零开始的。</param>
        <param name="count">要复制的字符数。</param>
        <summary>将此实例的指定段中的字符复制到目标 <see cref="T:System.Char" /> 数组的指定段中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你需要将<xref:System.Text.StringBuilder>对象的连续部分有效地复制到数组时, 此方法旨在用于极少数情况。<xref:System.Text.StringBuilder.CopyTo%2A> 该数组应为固定大小、预分配、可重用并且可能可全局访问。  
  
 例如, 你的应用程序可以<xref:System.Text.StringBuilder> <xref:System.Text.StringBuilder.CopyTo%2A>使用大量字符来填充对象, 然后使用方法将<xref:System.Text.StringBuilder>对象的小型连续部分复制到处理这些部分的数组。 在处理<xref:System.Text.StringBuilder>对象中的所有数据时, <xref:System.Text.StringBuilder>对象的大小设置为零, 并重复周期。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.CopyTo%2A>方法。  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />、<paramref name="destinationIndex" /> 或 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="sourceIndex" /> 大于此实例的长度。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="sourceIndex" /> + <paramref name="count" /> 大于此实例的长度。  
  
或 
 <paramref name="destinationIndex" /> + <paramref name="count" /> 大于 <paramref name="destination" /> 的长度。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="stringBuilder.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">要确保的最小容量。</param>
        <summary>确保 <see cref="T:System.Text.StringBuilder" /> 的此实例的容量至少是指定值。</summary>
        <returns>此实例的新容量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前容量小于`capacity`参数, 则将此实例的内存重新分配为至少`capacity`容纳数量的字符; 否则, 不会更改任何内存。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.EnsureCapacity%2A>方法。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="capacity" /> 小于零。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(valuetype System.ReadOnlySpan`1&lt;char&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (span As ReadOnlySpan(Of Char)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(ReadOnlySpan&lt;char&gt; span);" />
      <MemberSignature Language="F#" Value="override this.Equals : ReadOnlySpan&lt;char&gt; -&gt; bool" Usage="stringBuilder.Equals span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="span">与当前实例进行比较的字符范围。</param>
        <summary>返回一个值，该值指示此实例中的字符是否等于指定的只读字符范围中的字符。</summary>
        <returns>如果此实例中的字符与 <paramref name="span" /> 相同，为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

方法执行序号比较, 以确定当前`span`实例中的字符是否相等。 `Equals`

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (sb As StringBuilder) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::Text::StringBuilder ^ sb);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Text.StringBuilder -&gt; bool" Usage="stringBuilder.Equals sb" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">与此实例进行比较的对象，或为 <see langword="null" />。</param>
        <summary>返回一个值，该值指示此实例是否等于指定的对象。</summary>
        <returns>如果此实例和 <paramref name="sb" /> 具有相等的字符串、<see cref="P:System.Text.StringBuilder.Capacity" /> 和 <see cref="P:System.Text.StringBuilder.MaxCapacity" /> 值，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks

**.NET Framework 和 .NET Core 2.2 及更早版本:** 当前实例`sb` , 如果它们具有相等的字符串、 <xref:System.Text.StringBuilder.Capacity>和<xref:System.Text.StringBuilder.MaxCapacity>值, 则相等。 `Equals`方法使用序号比较来确定字符串是否相等。

**.NET Core 3.0 及更高版本:** 如果分配给这`sb`两个<xref:System.Text.StringBuilder>对象的字符串相同, 则当前实例和相等。  若要确定相等性`Equals` , 方法使用序号比较。 在比较<xref:System.Text.StringBuilder.MaxCapacity>中不使用和属性值。<xref:System.Text.StringBuilder.Capacity>

## Examples  
 下面的代码使用<xref:System.Text.StringBuilder.Equals%2A>方法检查两个<xref:System.Text.StringBuilder>对象是否相等。 在对每个对象进行少量更改后, 将重复调用方法, 并将结果显示到控制台。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChunks">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder.ChunkEnumerator GetChunks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringBuilder/ChunkEnumerator GetChunks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.GetChunks" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChunks () As StringBuilder.ChunkEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder::ChunkEnumerator GetChunks();" />
      <MemberSignature Language="F#" Value="member this.GetChunks : unit -&gt; System.Text.StringBuilder.ChunkEnumerator" Usage="stringBuilder.GetChunks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder+ChunkEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个对象，该对象可用于循环访问从此 <see cref="T:System.Text.StringBuilder" /> 实例创建的 <see langword="ReadOnlyMemory&lt;Char&gt;" /> 中表示的字符区块。</summary>
        <returns><see langword="ReadOnlyMemory&lt;Char&gt;" /> 中区块的枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

可以用如下代码来循环访问内存范围内的块: 

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
    foreach(char ch in chunk.Span)
        { /* operations on ch */ }
```
            
此方法的目的是有效地提取*常量* <xref:System.Text.StringBuilder>的数据。 如果在<xref:System.Text.StringBuilder>块区枚举不完整时修改了, 则结果是不确定的。 <xref:System.Text.StringBuilder>也不是线程安全的, 因此在并发线程上对其进行操作是非法的。

如果修改了, 则返回的<xref:System.ReadOnlyMemory%601>块不会保持不变, 因此, 不会将它们缓存供以后使用。 <xref:System.Text.StringBuilder>
             
从创建<xref:System.ReadOnlyMemory%601.Span?displayProperty=nameWithType> (正如在上一示例中执行的操作) 非常昂贵, 因此, 如果需要在嵌套`for`语句中使用局部变量, 请为范围创建一个本地变量。 <xref:System.ReadOnlyMemory%601> <xref:System.ReadOnlySpan%601> 例如: 

```csharp
foreach (ReadOnlyMemory<char> chunk in sb.GetChunks())
{
    var span = chunk.Span;
    for(int i = 0; i < span.Length; i++)
    { 
        /* operations on span[i] */ 
    }
}
```

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Insert">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将指定对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Boolean) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, bool value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * bool -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将布尔值的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 根据需要调整容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Byte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Byte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * byte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, char value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 Unicode 字符的字符串表示形式插入到此实例中的指定位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.Char" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char()) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符数组。</param>
        <summary>将指定的 Unicode 字符数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
 如果`value`为`null` ,<xref:System.Text.StringBuilder>则不会更改。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Decimal) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Decimal value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * decimal -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将十进制数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Decimal" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Double) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, double value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * double -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将双精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Short) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, short value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 16 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, int value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 32 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Long) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, long value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * int64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Object) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * obj -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的对象，或 <see langword="null" />。</param>
        <summary>将对象的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
 如果`value` 为`null`, 则此实例的值将保持不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ReadOnlySpan(Of Char)) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * ReadOnlySpan&lt;char&gt; -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As SByte) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::SByte value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * sbyte -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将指定的 8 位带符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 根据需要调整容量。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.SByte" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Single) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, float value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * single -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将单精度浮点数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.Single" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <summary>将字符串插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将移动现有字符以便为新文本留出空间。 根据需要调整容量。  
  
 如果<xref:System.Text.StringBuilder> 为,`null`或者`null`不是但其长度为零,则不会更改的此实例。`value` `value`  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的当前长度。  
  
或 
此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UShort) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint16 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 16 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.UInt16" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As UInteger) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint32 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 32 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.UInt32" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As ULong) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * uint64 -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的值。</param>
        <summary>将 64 位无符号整数的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType>用于获取的`value`字符串表示形式。 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的长度。</exception>
        <exception cref="T:System.OutOfMemoryException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <block subset="none" type="usage"><para>在和早期版本中, <see cref="T:System.ArgumentOutOfRangeException" />如果插入<paramref name="value" />会导致对象的总长度超过<see cref="P:System.Text.StringBuilder.MaxCapacity" />, 则调用此方法将引发。 [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] 从开始<see cref="T:System.OutOfMemoryException" />, 方法将引发。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</para></block>
        <altmember cref="T:System.UInt64" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As String, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, System::String ^ value, int count);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">要插入的字符串。</param>
        <param name="count">要插入 <paramref name="value" /> 的次数。</param>
        <summary>将指定字符串的一个或更多副本插入到此实例中的指定字符位置。</summary>
        <returns>完成插入后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
 如果<xref:System.Text.StringBuilder> `count`为, 则不会更改此对象,但该对象的长度为零,或者为零。`null` `value` `null` `value`  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零或大于此实例的当前长度。  
  
或 
 <paramref name="count" /> 小于零。</exception>
        <exception cref="T:System.OutOfMemoryException">此 <see cref="T:System.Text.StringBuilder" /> 对象的当前长度加上 <paramref name="value" /> 的长度乘以 <paramref name="count" />，超过了 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (index As Integer, value As Char(), startIndex As Integer, charCount As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Insert(int index, cli::array &lt;char&gt; ^ value, int startIndex, int charCount);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * char[] * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Insert (index, value, startIndex, charCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">此实例中开始插入的位置。</param>
        <param name="value">字符数组。</param>
        <param name="startIndex"><paramref name="value" /> 内的起始索引。</param>
        <param name="charCount">要插入的字符数。</param>
        <summary>将指定的 Unicode 字符子数组的字符串表示形式插入到此实例中的指定字符位置。</summary>
        <returns>完成插入操作后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将移动现有字符以便为新文本留出空间。 此实例的容量会根据需要进行调整。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Insert%2A>方法。  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />，且 <paramref name="startIndex" /> 和 <paramref name="charCount" /> 不为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" />、<paramref name="startIndex" /> 或 <paramref name="charCount" /> 小于零。  
  
或 
 <paramref name="index" /> 大于此实例的长度。  
  
或 
 <paramref name="startIndex" /> 加 <paramref name="charCount" /> 不是 <paramref name="value" /> 中的位置。  
  
- 或 - 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberSignature Language="VB.NET" Value="Public Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Length : int with get, set" Usage="System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前 <see cref="T:System.Text.StringBuilder" /> 对象的长度。</summary>
        <value>此实例的长度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder>对象的长度由其<xref:System.Char>对象数定义。  
  
 与属性一样<xref:System.Text.StringBuilder.Length%2A> , 属性指示当前字符串对象的长度。 <xref:System.String.Length%2A?displayProperty=nameWithType> 与属性不同, 属性是只读的<xref:System.Text.StringBuilder.Length%2A> , 它允许您修改存储<xref:System.Text.StringBuilder>在对象中的字符串的长度。 <xref:System.String.Length%2A?displayProperty=nameWithType>  
  
 如果指定的长度小于当前长度, 则当前<xref:System.Text.StringBuilder>对象将被截断为指定长度。 如果指定的长度大于当前长度, 则当前<xref:System.Text.StringBuilder>对象的字符串值的末尾将用 Unicode NULL 字符 (U + 0000) 填充。  
  
 如果指定的长度大于当前容量, 则会增加<xref:System.Text.StringBuilder.Capacity%2A> , 使其大于或等于指定的长度。  
  
   
  
## Examples  
 下面的示例演示了<xref:System.Text.StringBuilder.Length%2A>属性。  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">为集运算指定的值小于零或大于 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MaxCapacity As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxCapacity { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxCapacity : int" Usage="System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此实例的最大容量。</summary>
        <value>此实例可容纳的最大字符数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现的最大容量为<xref:System.Int32.MaxValue?displayProperty=nameWithType>。 不过, 此值是特定于实现的, 并且在其他或更高的实现中可能不同。 可以通过<xref:System.Text.StringBuilder> <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>调用构造函数来显式设置对象的最大容量。  
  
在 .net Core 和 .NET Framework 4.0 及更高版本<xref:System.Text.StringBuilder>中, 当通过<xref:System.Text.StringBuilder.%23ctor(System.Int32,System.Int32)>调用构造函数实例化对象时, <xref:System.Text.StringBuilder>实例的长度和容量超出其<xref:System.Text.StringBuilder.MaxCapacity>知识产权. 当调用<xref:System.Text.StringBuilder.Append(System.String)>和方法追加小字符串时, <xref:System.Text.StringBuilder.AppendFormat(System.String,System.Object)>尤其如此。
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, length As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Remove(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Remove (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例中开始移除操作的从零开始的位置。</param>
        <param name="length">要删除的字符数。</param>
        <summary>将指定范围的字符从此实例中移除。</summary>
        <returns>切除操作完成后对此实例的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当前方法从当前实例中删除指定范围内的字符。 `startIndex`位于 ( +  `startIndex`) 的字符将移到, 当前实例的字符串值将缩短`length`。`length` 当前实例的容量不受影响。  
  
> [!NOTE]
>  方法修改当前<xref:System.Text.StringBuilder>实例的值并返回该实例。 <xref:System.Text.StringBuilder.Remove%2A> 它不创建并返回新<xref:System.Text.StringBuilder>的对象。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Remove%2A>方法。  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">如果 <paramref name="startIndex" /> 或 <paramref name="length" /> 小于零，或者 <paramref name="startIndex" /> + <paramref name="length" /> 大于此实例的长度。</exception>
        <altmember cref="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将此实例中出现的所有指定字符或字符串替换为其他的指定字符或字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <paramref name="oldChar" /> 的字符。</param>
        <summary>将此实例中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、区分大小写的比较, 以标识当前`oldChar`实例中的匹配项。 替换后, 当前<xref:System.Text.StringBuilder>实例的大小将保持不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <paramref name="oldValue" /> 的字符串或 <see langword="null" />。</param>
        <summary>将此实例中出现的所有指定字符串的替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、区分大小写的比较, 以标识当前`oldValue`实例中的匹配项。 如果`newValue`为`null` `oldValue`或,<xref:System.String.Empty?displayProperty=nameWithType>则删除的所有匹配项。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldChar, newChar, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">要替换的字符。</param>
        <param name="newChar">替换 <paramref name="oldChar" /> 的字符。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符替换为其他指定字符。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> -1 范围内的 <paramref name="oldChar" /> 被 <paramref name="newChar" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、区分大小写的比较, 以标识当前`oldChar`实例中的匹配项。 替换后, 当前<xref:System.Text.StringBuilder>对象的大小不变。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> + <paramref name="count" /> 大于此实例的值的长度。  
  
- 或 - 
 <paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, startIndex As Integer, count As Integer) As StringBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringBuilder ^ Replace(System::String ^ oldValue, System::String ^ newValue, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * int * int -&gt; System.Text.StringBuilder" Usage="stringBuilder.Replace (oldValue, newValue, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">要替换的字符串。</param>
        <param name="newValue">替换 <paramref name="oldValue" /> 的字符串或 <see langword="null" />。</param>
        <param name="startIndex">此实例中子字符串开始的位置。</param>
        <param name="count">子字符串的长度。</param>
        <summary>将此实例的子字符串中出现的所有指定字符串替换为其他指定字符串。</summary>
        <returns>对此实例的引用，其中从 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的范围内 <paramref name="oldValue" /> 的所有实例被 <paramref name="newValue" /> 替换。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法执行序号、区分大小写的比较, 以标识指定`oldValue`子字符串中的匹配项。 如果`newValue`为`null` `oldValue`或,<xref:System.String.Empty?displayProperty=nameWithType>则删除的所有匹配项。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Text.StringBuilder.Replace%2A>方法。  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> 的长度为零。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 加 <paramref name="count" /> 指示一个不在此实例内的字符位置。  
  
或 
增大此实例的值将超过 <see cref="P:System.Text.StringBuilder.MaxCapacity" />。</exception>
        <altmember cref="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">要用序列化信息填充的对象。</param>
        <param name="context">存储和检索序列化数据的位置。 留待将来使用。</param>
        <summary>使用所需的数据填充 <see cref="T:System.Runtime.Serialization.SerializationInfo" /> 对象来反序列化当前 <see cref="T:System.Text.StringBuilder" /> 对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此`context`参数保留以供将来使用, 并且不参与此操作。  
  
 有关更多信息，请参见 <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType> 方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将 <see cref="T:System.Text.StringBuilder" /> 的值转换为 <see cref="T:System.String" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="stringBuilder.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将此实例的值转换为 <see cref="T:System.String" />。</summary>
        <returns>其值与此实例相同的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须先<xref:System.Text.StringBuilder.ToString%2A>调用方法将<xref:System.String> <xref:System.Text.StringBuilder>对象转换为对象, 然后才能将<xref:System.Text.StringBuilder>对象表示的字符串传递给具有<xref:System.String>参数或在用户界面中显示它的方法。  
  
   
  
## Examples  
 下面的示例演示如何调用 <xref:System.Text.StringBuilder.ToString%2A> 方法。 此示例是为<xref:System.Text.StringBuilder>类提供的更大示例的一部分。  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="override this.ToString : int * int -&gt; string" Usage="stringBuilder.ToString (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">此实例内子字符串的起始位置。</param>
        <param name="length">子字符串的长度。</param>
        <summary>将此实例中子字符串的值转换为 <see cref="T:System.String" />。</summary>
        <returns>一个字符串，其值与此实例的指定子字符串相同。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须先<xref:System.Text.StringBuilder.ToString%2A>调用方法将<xref:System.String> <xref:System.Text.StringBuilder>对象转换为对象, 然后才能将<xref:System.Text.StringBuilder>对象表示的字符串传递给具有<xref:System.String>参数或在用户界面中显示它的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 或 <paramref name="length" /> 小于零。  
  
- 或 - 
<paramref name="startIndex" /> 和 <paramref name="length" /> 之和大于当前实例的长度。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
