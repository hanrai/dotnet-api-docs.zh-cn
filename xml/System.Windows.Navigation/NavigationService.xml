<Type Name="NavigationService" FullName="System.Windows.Navigation.NavigationService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a8bd4b2bef7ec8cee36b45fcfd12498fd1d6d43e" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69446089" /></Metadata><TypeSignature Language="C#" Value="public sealed class NavigationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NavigationService extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Navigation.NavigationService" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NavigationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class NavigationService sealed" />
  <TypeSignature Language="F#" Value="type NavigationService = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>包含支持导航的各种方法、属性和事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService>封装在浏览器样式的导航上下文内下载内容的功能。  
  
 内容可以是任何类型的 .NET Framework 对象和 HTML 文件。 但一般情况下, 页是为进行导航<xref:System.Windows.Controls.Page>而打包内容的首选方式。  
  
 可以通过提供对象的实例并调用接受对象的<xref:System.Windows.Navigation.NavigationService.Navigate%2A>方法的重载, 来导航到内容:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Object%2CSystem.Object%29?displayProperty=nameWithType>  
  
 或者, 通过将相对或绝对 URI 传递到接受 URI 的<xref:System.Windows.Navigation.NavigationService.Navigate%2A>方法重载之一, 可以导航到内容:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%29?displayProperty=nameWithType>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigate%28System.Uri%2CSystem.Object%2CSystem.Boolean%29?displayProperty=nameWithType>  
  
 当内容通过 URI 导航到时, <xref:System.Windows.Navigation.NavigationService>将返回包含内容的对象。  
  
 导航的生存期可通过以下事件进行跟踪:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigated>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
-   <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
-   <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>。  
  
 并非每次发生导航时都会引发所有事件;引发的事件集由发生的导航类型 (内容或内容片段) 以及导航完成方式 (取消、停止或失败) 决定。  
  
 下图说明了引发这些事件的顺序:  
  
 ![页面导航流程图](~/add/media/navigationoverviewfigure11.png "页面导航流程图")  
  
 在导航过程中或导航<xref:System.Windows.Navigation.NavigationService>后, 提供有关要导航到的内容的信息, 包括要导航到的内容的 uri (<xref:System.Windows.Navigation.NavigationService.Source%2A>)、当前内容的 uri (<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>), 以及包含导航到的内容 (<xref:System.Windows.Navigation.NavigationService.Content%2A>)。  
  
 导航到内容时, <xref:System.Windows.Navigation.NavigationService>会将导航记录为导航历史记录中的条目。 当出现新的导航时, 通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>方法或通过在前进导航历史记录中通过调用<xref:System.Windows.Navigation.NavigationService.GoForward%2A>导航到某个条目来向后导航历史记录中添加一个条目。 通过在后退导航历史记录中通过调用<xref:System.Windows.Navigation.NavigationService.GoBack%2A>来向后导航历史记录中添加一个条目。 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A>和<xref:System.Windows.Navigation.NavigationService.CanGoForward%2A>报告后退和前进导航历史记录中是否存在条目。 此外, 可以通过调用<xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>删除后退导航历史记录中的最新条目。  
  
 默认情况下<xref:System.Windows.Navigation.NavigationService> , 不会在导航历史记录中存储内容对象的实例。 相反, <xref:System.Windows.Navigation.NavigationService>每次使用导航历史记录导航到内容对象时, 都将创建该对象的新实例。 此行为旨在避免在将大量内容导航到时消耗过多的内存。 因此, 不会从一个导航到下一个导航来记住内容的状态。 不过, WPF 提供了多种方法, 通过这些方法, 你可以在导航历史记录中存储一段内容的状态。  
  
 使用<xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>, 还可以记住单个页面实例的多个状态集。  
  
 <xref:System.Windows.Navigation.NavigationService>是一个`sealed`类, 因此不能被实例化, <xref:System.Windows.Navigation.NavigationService>而是由导航器用于启用导航。 在 WPF 中, 有两个导航<xref:System.Windows.Navigation.NavigationWindow>器<xref:System.Windows.Controls.Frame>: 和。  
  
 直观地[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]使用作为导航器来提供集成的用户体验。 [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)]但[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]实际上, 实际使用<xref:System.Windows.Application.MainWindow%2A> <xref:System.Windows.Navigation.NavigationWindow>作为导航器[!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)] ; 在中运行的的属性将返回对的<xref:System.Windows.Navigation.NavigationWindow>引用和由管理的导航历史记录。<xref:System.Windows.Navigation.NavigationWindow>与通过[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]以下方式管理的导航历史记录集成:  
  
-   在导航到内容时, 通过<xref:System.Windows.Navigation.NavigationService.Navigate%2A>从<xref:System.Windows.Navigation.NavigationService.GoBack%2A>中调用<xref:System.Windows.Navigation.NavigationService.GoForward%2A> 、和, [!INCLUDE[TLA2#tla_xbap](~/includes/tla2sharptla-xbap-md.md)]还会将相关导航历史记录项中[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]的添加到导航历史记录中。  
  
-   如果选择了[!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]导航[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]中的条目, [!INCLUDE[TLA2#tla_ie7](~/includes/tla2sharptla-ie7-md.md)]则<xref:System.Windows.Navigation.NavigationService>会导致向后导航到与这些条目关联的内容。  
  
> [!NOTE]
>  <xref:System.Windows.Controls.Frame>可以提供自己的导航历史记录, 也可以使用托管它的导航器的导航历史记录。 如果<xref:System.Windows.Controls.Frame>提供了其自己的导航历史记录, 则可以显示[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]其自己的导航以导航到导航历史记录中的条目; 这些条目不会添加到主机导航器<xref:System.Windows.Navigation.NavigationWindow>的导航历史记录中 ( <xref:System.Windows.Controls.Frame> [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] 、 [!INCLUDE[TLA2#tla_iegeneric](~/includes/tla2sharptla-iegeneric-md.md)]) 和, 因此不能从每个导航导航到 (请参见<xref:System.Windows.Controls.Frame.JournalOwnership%2A>)。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddBackEntry">
      <MemberSignature Language="C#" Value="public void AddBackEntry (System.Windows.Navigation.CustomContentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddBackEntry(class System.Windows.Navigation.CustomContentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddBackEntry (state As CustomContentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddBackEntry(System::Windows::Navigation::CustomContentState ^ state);" />
      <MemberSignature Language="F#" Value="member this.AddBackEntry : System.Windows.Navigation.CustomContentState -&gt; unit" Usage="navigationService.AddBackEntry state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Navigation.CustomContentState" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象，该对象表示与特定内容片段关联的应用程序定义的状态。</param>
        <summary>向包含 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象的后退导航历史记录中添加一个条目。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.AddBackEntry%2A>、 <xref:System.Windows.Navigation.CustomContentState>和<xref:System.Windows.Navigation.IProvideCustomContentState>可用于帮助记住当前内容的多个状态集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="state" /> 为 <see langword="null" />，并且 <see cref="T:System.Windows.Navigation.CustomContentState" /> 对象不是从 <see cref="M:System.Windows.Navigation.IProvideCustomContentState.GetContentState" /> 返回的对象。</exception>
        <altmember cref="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      </Docs>
    </Member>
    <Member MemberName="CanGoBack">
      <MemberSignature Language="C#" Value="public bool CanGoBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoBack" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoBack As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoBack { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoBack : bool" Usage="System.Windows.Navigation.NavigationService.CanGoBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示后退导航历史记录中是否至少有一个条目。</summary>
        <value>如果后退导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoBack%2A>若要确定后退导航历史记录中是否至少有一个条目。 此属性应在调用<xref:System.Windows.Navigation.NavigationService.GoBack%2A>之前进行检查; 如果<xref:System.Windows.Navigation.NavigationService.GoBack%2A>调用了并且<xref:System.InvalidOperationException>后退导航历史记录中没有任何项, 则会引发。  
  
> [!NOTE]
>  如果导航历史记录由多个导航器共享<xref:System.Windows.Navigation.NavigationWindow>( <xref:System.Windows.Controls.Frame>、), 则当前导航器的中可能尚未添加<xref:System.Windows.Navigation.NavigationService>后退导航历史记录中的最新条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="CanGoForward">
      <MemberSignature Language="C#" Value="public bool CanGoForward { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGoForward" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanGoForward As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanGoForward { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanGoForward : bool" Usage="System.Windows.Navigation.NavigationService.CanGoForward" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示前进导航历史记录中是否至少有一个条目。</summary>
        <value>如果前进导航历史记录中至少具有一个条目，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.CanGoForward%2A>确定前进导航历史记录中是否至少有一个条目。 此属性应在调用<xref:System.Windows.Navigation.NavigationService.GoForward%2A>之前进行检查; 如果<xref:System.Windows.Navigation.NavigationService.GoForward%2A>调用了并且<xref:System.InvalidOperationException>前进导航历史记录中没有任何项, 则会引发。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="Content">
      <MemberSignature Language="C#" Value="public object Content { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Content" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Content" />
      <MemberSignature Language="VB.NET" Value="Public Property Content As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Content { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Content : obj with get, set" Usage="System.Windows.Navigation.NavigationService.Content" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置对包含当前内容的对象的引用。</summary>
        <value>一个对象，它是对包含当前内容的对象的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过以下两种方式之一设置内容:  
  
-   直接将它设置为对对象的引用。  
  
-   间接调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>、 <xref:System.Windows.Navigation.NavigationService.GoBack%2A>或。 <xref:System.Windows.Navigation.NavigationService.GoForward%2A>  
  
 设置<xref:System.Windows.Navigation.NavigationService>将启动新导航; 因为导航是异步的<xref:System.Windows.Navigation.NavigationService.Content%2A> , 因此, 如果在设置后立即检查, 则不会返回值。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
    <Member MemberName="CurrentSource">
      <MemberSignature Language="C#" Value="public Uri CurrentSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri CurrentSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentSource As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ CurrentSource { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentSource : Uri" Usage="System.Windows.Navigation.NavigationService.CurrentSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取上次导航到的内容的 URI。</summary>
        <value>如果<see cref="T:System.Uri" />是通过使用 URI 导航到, 则为上次导航到的内容的; <see langword="null" />否则为。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在成功完成导航<xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>到不同的 URI 之前, 不会更改属性的值。  
  
 <xref:System.Windows.Navigation.NavigationService.CurrentSource%2A>可以使用仅分段 URI 进行设置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FragmentNavigation">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.FragmentNavigationEventHandler FragmentNavigation" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FragmentNavigation As FragmentNavigationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::FragmentNavigationEventHandler ^ FragmentNavigation;" />
      <MemberSignature Language="F#" Value="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " Usage="member this.FragmentNavigation : System.Windows.Navigation.FragmentNavigationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.FragmentNavigationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当开始导航到某个内容片段时发生，如果所需片段位于当前内容中，它会立即发生；或者，如果所需片段位于不同内容中，它会在加载了源 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 内容之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, 内容片段是一个名<xref:System.Windows.UIElement>为的内容, <xref:System.Windows.UIElement> <xref:System.Windows.FrameworkElement.Name%2A>其属性已设置为, 例如:  
  
```  
<TextBlock Name="FragmentName">...</TextBlock>  
```  
  
 可以通过提供具有[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]以下格式的后缀的 URI 导航到片段:  
  
 \#*FragmentName*  
  
 下面显示了引用内容片段的 URI 示例:  
  
 `http://www.microsoft.com/targetpage.xaml#FragmentName`  
  
 加载源页面后 (引发事件<xref:System.Windows.Navigation.NavigationService.LoadCompleted>后), 片段导航开始, <xref:System.Windows.Navigation.NavigationService>并尝试查找[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]片段。 如果找到<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Navigation.NavigationWindow>片段, 则指示内容导航器 (、 <xref:System.Windows.Controls.Frame>) 显示片段。 [!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)] 如果需要更改此行为, 您可以处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>以提供您自己的片段导航行为。 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>向传递了<xref:System.Windows.Navigation.FragmentNavigationEventArgs>一个参数, 该参数公开用于此目的的属性, 包括:  
  
-   拥有此导航服务的导航器 (<xref:System.Windows.Navigation.NavigationWindow>、 <xref:System.Windows.Controls.Frame>)。  
  
-   片段名称。  
  
 您可以通过<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>处理来用您自己的自定义实现来重写默认的 WPF 片段实现。 如果这样做, 则需要将设置<xref:System.Windows.Navigation.FragmentNavigationEventArgs.Handled%2A>为`true`; 否则, 将应用默认的 WPF 片断处理行为。  
  
 应避免直接在<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>事件处理程序中启动导航。 由于<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>是在现有导航过程中引发的, 因此<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>从事件处理程序启动新导航会创建一个嵌套的<xref:System.ExecutionEngineException>导航, 从而导致引发。 相反, 你可以通过使用<xref:System.Windows.Threading.Dispatcher>创建异步工作项来间接启动导航。  
  
> [!NOTE]
>  引发<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Application.FragmentNavigation?displayProperty=nameWithType> <xref:System.Windows.Application>时, 它还会引发对象上的事件。 <xref:System.Windows.Navigation.NavigationService.FragmentNavigation>  
  
> [!IMPORTANT]
>  在以下情况下, 不支持[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]片段导航 ( `Page`作为根[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]元素的仅标记文件)。  
>   
>  •导航到松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页面中的片段时。  
>   
>  •从松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页面导航到其他松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页面中的片段时。  
>   
>  但松散[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]页可以导航到其自己的片段。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.FragmentNavigation>以提供自定义片段导航行为。 在这种情况下, 如果找不[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]到源[!INCLUDE[TLA2#tla_titlexaml](~/includes/tla2sharptla-titlexaml-md.md)]页中的片段, 该示例将打开错误页。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowfragmentnavigationcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowFragmentNavigationCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowfragmentnavigationcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="GetNavigationService">
      <MemberSignature Language="C#" Value="public static System.Windows.Navigation.NavigationService GetNavigationService (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Navigation.NavigationService GetNavigationService(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GetNavigationService(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Navigation::NavigationService ^ GetNavigationService(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="static member GetNavigationService : System.Windows.DependencyObject -&gt; System.Windows.Navigation.NavigationService" Usage="System.Windows.Navigation.NavigationService.GetNavigationService dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationService</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">由导航器承载的内容中的 <see cref="T:System.Windows.DependencyObject" />。</param>
        <summary>获取对导航器的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用，该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />。</summary>
        <returns>对导航器（该导航器的内容中包含指定的 <see cref="T:System.Windows.DependencyObject" />）的 <see cref="T:System.Windows.Navigation.NavigationService" /> 的引用在某些情况下可以为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 导航器具有<xref:System.Windows.Navigation.NavigationService>处理内容导航的。 WPF 有两个导航<xref:System.Windows.Navigation.NavigationWindow>器<xref:System.Windows.Controls.Frame>: 和。 为了处理导航请求和管理导航生存期, 导航器使用 WPF 导航服务, 该服务以<xref:System.Windows.Navigation.NavigationService>类的形式实现。 导航器承载的内容可以通过<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>调用方法获取对导航器的引用。  
  
 <xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>当以下情况时返回`null`: `dependencyObject`  
  
-   <xref:System.Windows.Navigation.NavigationWindow>是。  
  
-   <xref:System.Windows.Controls.Frame>是:  
  
    1.  由另一导航器承载。  
  
    2.  将其<xref:System.Windows.Controls.Frame.JournalOwnership%2A>属性设置为<xref:System.Windows.Navigation.JournalOwnership.UsesParentJournal>。  
  
-   不是由导航器承载的内容的一部分。  
  
 WPF 提供了两个快捷方式用于获取对<xref:System.Windows.Navigation.NavigationService>的引用:  
  
-   处理到的导航<xref:System.Windows.Controls.Page.NavigationService%2A?displayProperty=nameWithType>的<xref:System.Windows.Controls.Page>可以通过获取其属性的值来访问。 <xref:System.Windows.Controls.Page> <xref:System.Windows.Navigation.NavigationService>  
  
-   可以通过获取属性的值<xref:System.Windows.Controls.Frame>来访问用于处理导航的。 <xref:System.Windows.Controls.Frame.NavigationService%2A> <xref:System.Windows.Navigation.NavigationService>  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.Windows.Controls.UserControl>通过调用<xref:System.Windows.Navigation.NavigationService.GetNavigationService%2A>来检索导航服务。  
  
 [!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode1)]
 [!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode1)]  
[!code-csharp[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/csharp/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/CSharp/ContentUserControl.xaml.cs#getnavigationservicecode2)]
[!code-vb[NSGetNavigationServiceSnippets#GetNavigationServiceCODE2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NSGetNavigationServiceSnippets/visualbasic/contentusercontrol.xaml.vb#getnavigationservicecode2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dependencyObject" /> 参数为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GoBack">
      <MemberSignature Language="C#" Value="public void GoBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoBack();" />
      <MemberSignature Language="F#" Value="member this.GoBack : unit -&gt; unit" Usage="navigationService.GoBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到后退导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用<xref:System.Windows.Navigation.NavigationService.GoBack%2A>之前<xref:System.Windows.Navigation.NavigationService.CanGoBack%2A> , 可以检查属性以确定后退导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到后退导航历史记录中的最新条目 (如果有)。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowbackcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowBackCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowbackcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在调用 <see cref="M:System.Windows.Navigation.NavigationService.GoBack" /> 时后退导航历史记录中没有条目。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoForward" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoForward" />
      </Docs>
    </Member>
    <Member MemberName="GoForward">
      <MemberSignature Language="C#" Value="public void GoForward ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GoForward() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.GoForward" />
      <MemberSignature Language="VB.NET" Value="Public Sub GoForward ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GoForward();" />
      <MemberSignature Language="F#" Value="member this.GoForward : unit -&gt; unit" Usage="navigationService.GoForward " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>导航到前进导航历史记录中的最新条目（如果有）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用<xref:System.Windows.Navigation.NavigationService.GoForward%2A>之前<xref:System.Windows.Navigation.NavigationService.CanGoForward%2A> , 可以检查属性以确定前进导航历史记录中是否存在条目。  
  
   
  
## Examples  
 下面的示例导航到前进导航历史记录中的最新条目 (如果有)。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowforwardcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowForwardCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowforwardcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">如果前进导航历史记录中没有任何条目，则调用 <see cref="M:System.Windows.Navigation.NavigationService.GoForward" />。</exception>
        <altmember cref="P:System.Windows.Navigation.NavigationService.CanGoBack" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.GoBack" />
      </Docs>
    </Member>
    <Member MemberName="LoadCompleted">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.LoadCompletedEventHandler LoadCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LoadCompleted As LoadCompletedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::LoadCompletedEventHandler ^ LoadCompleted;" />
      <MemberSignature Language="F#" Value="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " Usage="member this.LoadCompleted : System.Windows.Navigation.LoadCompletedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.LoadCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当已加载、分析并开始呈现目标导航内容时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要<xref:System.Windows.Navigation.NavigationService.LoadCompleted>在加载完成时发现有关导航请求的相关信息, 请处理。 此信息可从传递<xref:System.Windows.Navigation.NavigationEventArgs> <xref:System.Windows.Navigation.NavigationService.LoadCompleted>给事件处理程序的对象中获得, 其中包括:  
  
-   内容及其 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>、 <xref:System.Windows.Controls.Frame>)。  
  
-   如果导航是通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A>启动的, 则为附加数据。  
  
-   响应详细信息 (使用<xref:System.Net.WebResponse>对象)。  
  
 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>当找不到或无法加载源页面时, 不会引发, 在这<xref:System.Windows.Navigation.NavigationService.NavigationFailed>种情况下会引发。  
  
> [!NOTE]
>  引发<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Application.LoadCompleted?displayProperty=nameWithType> <xref:System.Windows.Application>时, 它还会引发对象上的事件。 <xref:System.Windows.Navigation.NavigationService.LoadCompleted>  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.LoadCompleted>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowloadcompletedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowLoadCompletedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowloadcompletedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Navigate">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>异步导航到指定的源内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj -&gt; bool" Usage="navigationService.Navigate root" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <summary>异步导航到某个对象中包含的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>如果满足以下条件<xref:System.Object> , 则将导航到指定的: `root`  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件未被取消。  
  
-   可以创建 web 请求 ( <xref:System.Windows.Navigation.NavigationService.Navigating>请参阅)。  
  
 如果`root` <xref:System.Windows.Navigation.NavigationService.Content%2A>为`null`, 则清除现有内容 ()。  
  
> [!NOTE]
>  下载 Web 内容时, 可能会收到 Web 异常 (例如, 404:找不到文件)。 你可以从<xref:System.Windows.Navigation.NavigationService.NavigationFailed>处理此类异常。  
  
   
  
## Examples  
 下面的示例演示如何导航到<xref:System.Windows.Controls.Page>包含源内容树的对象。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigateobjectcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateObjectCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigateobjectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri -&gt; bool" Usage="navigationService.Navigate source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <summary>异步导航到由 URI 指定的内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的`source`值可以是 Web [!INCLUDE[TLA#tla_url](~/includes/tlasharptla-url-md.md)]或有效的 pack URI (请参阅[WPF 中的 pack uri](~/docs/framework/wpf/app-development/pack-uris-in-wpf.md))。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>`source`如果满足以下条件, 则将导航到指定的 URI:  
  
-   <xref:System.Windows.Navigation.NavigationService.Navigating>事件未被取消。  
  
-   可以创建 web 请求 ( <xref:System.Windows.Navigation.NavigationService.Navigating>请参阅)。  
  
 如果`source` <xref:System.Windows.Navigation.NavigationService.Content%2A>为`null`, 则清除现有内容 ()。  
  
> [!NOTE]
>  下载 Web 内容时, 可能会收到 Web 异常 (例如, 404:找不到文件)。 你可以从<xref:System.Windows.Navigation.NavigationService.NavigationFailed>处理此类异常。  
  
 可以使用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>导航到内容片段。 如果由 URI 标识的内容是当前内容, 则不会再次下载。  
  
   
  
## Examples  
 下面的示例演示如何导航到 URI。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatecode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigateCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatecode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (object root, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(object root, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (root As Object, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(System::Object ^ root, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : obj * obj -&gt; bool" Usage="navigationService.Navigate (root, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="root" Type="System.Object" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="root">一个包含目标导航内容的对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航某个对象包含的内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管传递对象而不是 URI <xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>, 但此方法的行为与相同。  
  
   
  
## Examples  
 下面的示例演示如何导航到<xref:System.Windows.Controls.Page>包含源内容的对象和传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateObjectStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateObjectStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj -&gt; bool" Usage="navigationService.Navigate (source, navigationState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <summary>异步导航到位于某个 URI 中的源内容，并传递一个对象，其中包含要在导航过程中进行处理的数据。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于导航是异步的, 因此可以同时在多个导航中进行。 例如, 如果一个页面上有两个子框架, 则可以导航两个框架。 在这种情况下, 可能会多次引发由<xref:System.Windows.Navigation.NavigationService>引发的各种导航事件, 其中一个是正在导航到的每个内容片段, 而不必按顺序请求。 因此, 如果特定导航请求需要处理特定于单个请求的数据, 则它不能使用可用于所有导航请求的数据。 相反, 你可以使用`navigationState`来传递数据, 以进行特定于一个导航请求的导航处理。  
  
 以下事件参数提供对导航状态的访问权限:  
  
-   <xref:System.Windows.Navigation.NavigatingCancelEventArgs.ExtraData%2A>(传递给<xref:System.Windows.Navigation.NavigationService.Navigating>事件)。  
  
-   <xref:System.Windows.Navigation.NavigationEventArgs.ExtraData%2A>(传递到<xref:System.Windows.Navigation.NavigationService.Navigated>, <xref:System.Windows.Navigation.NavigationService.NavigationStopped>, <xref:System.Windows.Navigation.NavigationService.LoadCompleted>事件处理程序)。  
  
   
  
## Examples  
 下面的示例演示了导航到 URI 和传递导航状态。  
  
 [!code-csharp[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/CSharp/MainWindow.xaml.cs#mainwindowcode)]
 [!code-vb[NavigationServiceNavigateUriStateSnippets#MainWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceNavigateUriStateSnippets/visualbasic/mainwindow.xaml.vb#mainwindowcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigate">
      <MemberSignature Language="C#" Value="public bool Navigate (Uri source, object navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Navigate(class System.Uri source, object navigationState, bool sandboxExternalContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Navigate (source As Uri, navigationState As Object, sandboxExternalContent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Navigate(Uri ^ source, System::Object ^ navigationState, bool sandboxExternalContent);" />
      <MemberSignature Language="F#" Value="member this.Navigate : Uri * obj * bool -&gt; bool" Usage="navigationService.Navigate (source, navigationState, sandboxExternalContent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Uri" />
        <Parameter Name="navigationState" Type="System.Object" />
        <Parameter Name="sandboxExternalContent" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">使用所需内容的 URI 初始化的 <see cref="T:System.Uri" /> 对象。</param>
        <param name="navigationState">一个包含要在导航过程中进行处理的数据的对象。</param>
        <param name="sandboxExternalContent">将内容下载到部分信任的安全沙盒中（如果为 <see langword="true" />，则具有默认的 Internet 区域权限集）。 默认值为 <see langword="false" />。</param>
        <summary>异步导航到位于某个 URI 中的源内容，传递一个对象（其中包含在导航过程中进行处理的导航状态），并沙盒处理内容。</summary>
        <returns>如果未取消导航，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法仅适用于独立应用程序[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]和内容。  
  
 此方法的行为<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>与相同, 并通过确保正在下载的内容放入部分信任的安全沙盒 (具有默认的 Internet 区域权限集) 来扩展此方法, 请参阅[WPF 部分信任安全](~/docs/framework/wpf/wpf-partial-trust-security.md)).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Uri,System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object)" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Navigate(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Navigated">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatedEventHandler Navigated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatedEventHandler Navigated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigated As NavigatedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatedEventHandler ^ Navigated;" />
      <MemberSignature Language="F#" Value="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " Usage="member this.Navigated : System.Windows.Navigation.NavigatedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>找到导航的目标内容且可通过 <see cref="P:System.Windows.Navigation.NavigationService.Content" /> 属性得到这些内容时发生，即使尚未加载完毕也是如此。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要<xref:System.Windows.Navigation.NavigationService.Navigated>在下载时发现有关导航请求的相关信息, 可以处理。 此信息可从传递<xref:System.Windows.Navigation.NavigationEventArgs> <xref:System.Windows.Navigation.NavigationService.Navigated>给事件处理程序的对象中获得, 其中包括:  
  
-   源页。 当<xref:System.Windows.Navigation.NavigationService.Navigated>引发时, 至少已经分析了源[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]页树的一部分, 并将其附加到目标内容控件。  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>、 <xref:System.Windows.Controls.Frame>)。  
  
-   如果导航是通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A>启动的, 则为附加数据。  
  
-   响应详细信息 (使用<xref:System.Net.WebResponse>对象)。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigated>当找不到或无法加载源页面时, 不会引发, 在这<xref:System.Windows.Navigation.NavigationService.NavigationFailed>种情况下会引发。  
  
> [!NOTE]
>  引发<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType> <xref:System.Windows.Application>时, 它还会引发对象上的事件。 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.Navigated>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Navigating">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigatingCancelEventHandler Navigating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigatingCancelEventHandler Navigating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.Navigating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Navigating As NavigatingCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigatingCancelEventHandler ^ Navigating;" />
      <MemberSignature Language="F#" Value="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " Usage="member this.Navigating : System.Windows.Navigation.NavigatingCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigatingCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>请求新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.Navigating>请求新导航时, 但在请求源内容之前引发, 包括:  
  
-   调用 <xref:System.Windows.Navigation.NavigationService.Navigate%2A>。  
  
-   <xref:System.Windows.Navigation.NavigationService.GoBack%2A>或<xref:System.Windows.Navigation.NavigationService.GoForward%2A>调用 (或从导航[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]中选择条目)。  
  
-   导航到内容片段。  
  
 如果需要<xref:System.Windows.Navigation.NavigationService.Navigating>在导航开始之前发现有关导航请求的相关信息, 可以处理。 此信息可从传递<xref:System.Windows.Navigation.NavigatingCancelEventArgs> <xref:System.Windows.Navigation.NavigationService.Navigating>给事件处理程序的对象获取。  
  
 将从参数创建和提供用于导航的<xref:System.Net.WebRequest> 对象;因为此时尚未发出实际请求,所以,如有必要,你可以重新配置该对象。<xref:System.Net.WebRequest> <xref:System.Windows.Navigation.NavigatingCancelEventArgs>  
  
 如果需要, <xref:System.Windows.Navigation.NavigatingCancelEventArgs>还可以通过将设置<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>为 true 来处理取消导航。 如果取消导航, 则不会引发任何其他导航事件。  
  
> [!NOTE]
>  如果你的应用程序承载于浏览器中, 则无法通过取消该<xref:System.Windows.Navigation.NavigationService.Navigating>事件阻止用户离开你的应用程序。  
  
 导航器导航到第一段内容后 (<xref:System.Windows.Navigation.NavigationWindow>、 <xref:System.Windows.Controls.Frame>), 将在导航历史记录中添加离开的每个内容片段。 如果需要保存有关要离开的内容的状态信息, 可以通过设置<xref:System.Windows.Navigation.NavigatingCancelEventArgs.ContentStateToSave%2A> <xref:System.Windows.Navigation.CustomContentState>对象将状态添加到该内容的日记条目。  
  
> [!NOTE]
>  引发<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Application.Navigating?displayProperty=nameWithType> <xref:System.Windows.Application>时, 它还会引发对象上的事件。 <xref:System.Windows.Navigation.NavigationService.Navigating>  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.Navigating>以检测是否发出了用于刷新静态内容的请求, 如果是, 则取消该请求。  
  
 <xref:System.Windows.Navigation.NavigationService.Navigating>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigatingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigatingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigatingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationFailed">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationFailedEventHandler NavigationFailed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      <MemberSignature Language="VB.NET" Value="Public Event NavigationFailed As NavigationFailedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationFailedEventHandler ^ NavigationFailed;" />
      <MemberSignature Language="F#" Value="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " Usage="member this.NavigationFailed : System.Windows.Navigation.NavigationFailedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationFailedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在导航到所请求内容出错时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在<xref:System.IO.IOException>导航<xref:System.Net.WebException> 过程中引发了或,则<xref:System.Windows.Navigation.NavigationService.NavigationFailed>会引发事件。 <xref:System.Windows.Navigation.NavigationService.NavigationFailed>传递了一个<xref:System.Windows.Navigation.NavigationFailedEventArgs> , 它封装了有关异常的信息以及导致异常的导航的详细信息。  
  
 如果导航失败导致异常, 且未处理, 则会按列出的顺序引发以下事件:  
  
-   <xref:System.Windows.Navigation.NavigationService.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Controls.Frame.NavigationFailed?displayProperty=nameWithType> 或 <xref:System.Windows.Navigation.NavigationWindow.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.NavigationFailed?displayProperty=nameWithType>。  
  
-   <xref:System.Windows.Application.DispatcherUnhandledException>。  
  
 如果导航器 (<xref:System.Windows.Navigation.NavigationWindow>、 <xref:System.Windows.Controls.Frame>) 由一个或多个导航器承载`NavigationFailed` , 则不会对任何导航器引发。  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationFailed>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationfailedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationFailedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationfailedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="M:System.Windows.Navigation.NavigationService.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="NavigationProgress">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationProgressEventHandler NavigationProgress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationProgress As NavigationProgressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationProgressEventHandler ^ NavigationProgress;" />
      <MemberSignature Language="F#" Value="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " Usage="member this.NavigationProgress : System.Windows.Navigation.NavigationProgressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationProgressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在下载过程中定期发生，用于提供定位进度信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>传递了一个<xref:System.Windows.Navigation.NavigationProgressEventArgs> , 它公开了以下进度信息:  
  
-   到目前为止下载的字节数<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>()。  
  
-   要下载的总字节数 (<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>)。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>对于下载的每个1024字节, 将引发一次, 如果剩余字节数不到1024字节, 则会引发一次。 出于此原因, 处理<xref:System.Windows.Navigation.NavigationService.NavigationProgress>提供了一种有效的方法来跟踪和显示当前下载的进度。  
  
 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>在某些情况下 (例如, 导航到相同的内容片段), 或在导航到当前加载的内容 (即<xref:System.Windows.Navigation.NavigationService.Content%2A>属性的值) 的内容时, 不会引发。  
  
 导航到已编译的 XAML 资源时, 可能<xref:System.Windows.Navigation.NavigationService.NavigationProgress>不会引发最终事件。 这意味着, 在下载结束时, 最后报告<xref:System.Windows.Navigation.NavigationProgressEventArgs.BytesRead%2A>的值可能不<xref:System.Windows.Navigation.NavigationProgressEventArgs.MaxBytes%2A>等于值。 处理导航<xref:System.Windows.Navigation.NavigationService.LoadCompleted>完成后要通知的事件。  
  
> [!NOTE]
>  引发<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Application.NavigationProgress?displayProperty=nameWithType> <xref:System.Windows.Application>时, 它还会引发对象上的事件。 <xref:System.Windows.Navigation.NavigationService.NavigationProgress>  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationProgress>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationprogresscode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationProgressCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationprogresscode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="NavigationStopped">
      <MemberSignature Language="C#" Value="public event System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Navigation.NavigationStoppedEventHandler NavigationStopped" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Navigation.NavigationService.NavigationStopped" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event NavigationStopped As NavigationStoppedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Navigation::NavigationStoppedEventHandler ^ NavigationStopped;" />
      <MemberSignature Language="F#" Value="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " Usage="member this.NavigationStopped : System.Windows.Navigation.NavigationStoppedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.NavigationStoppedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在调用 <see cref="M:System.Windows.Navigation.NavigationService.StopLoading" /> 方法时发生，或者在当前导航正处于进行过程中时又请求一个新导航时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要<xref:System.Windows.Navigation.NavigationService.NavigationStopped>在下载停止时发现有关导航请求的相关信息, 可以处理。 此信息可从传递<xref:System.Windows.Navigation.NavigationEventArgs> <xref:System.Windows.Navigation.NavigationService.NavigationStopped>给事件处理程序的对象中获得, 其中包括:  
  
-   请求的 URI。  
  
-   导航器 (<xref:System.Windows.Navigation.NavigationWindow>、 <xref:System.Windows.Controls.Frame>)。  
  
-   如果导航是通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>或<xref:System.Windows.Navigation.NavigationService.Navigate%2A?displayProperty=nameWithType>启动的, 则为附加数据。  
  
> [!NOTE]
>  引发<xref:System.Windows.Navigation.NavigationService> <xref:System.Windows.Application.NavigationStopped?displayProperty=nameWithType> <xref:System.Windows.Application>时, 它还会引发对象上的事件。 <xref:System.Windows.Navigation.NavigationService.NavigationStopped>  
  
   
  
## Examples  
 下面的示例演示如何处理<xref:System.Windows.Navigation.NavigationService.NavigationStopped>。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindownavigationstoppedcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowNavigationStoppedCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindownavigationstoppedcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.FragmentNavigation" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigated" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.LoadCompleted" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationProgress" />
        <altmember cref="E:System.Windows.Navigation.NavigationService.NavigationFailed" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="navigationService.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>重新加载当前内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果再次导航到当前内容 (由<xref:System.Windows.Navigation.NavigationService.Source%2A>属性的值指定), <xref:System.Windows.Navigation.NavigationService>则不会再次下载内容。 若要<xref:System.Windows.Navigation.NavigationService>强制重新导航到内容, 请调用。 <xref:System.Windows.Navigation.NavigationService.Refresh%2A>  
  
 请注意, 如果再次导航到当前内容, 无论是通过调用<xref:System.Windows.Navigation.NavigationService.Navigate%2A>还是<xref:System.Windows.Navigation.NavigationService.Refresh%2A>, 都不会在导航历史记录中添加新条目。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Navigation.NavigationService.Navigating" />
      </Docs>
    </Member>
    <Member MemberName="RemoveBackEntry">
      <MemberSignature Language="C#" Value="public System.Windows.Navigation.JournalEntry RemoveBackEntry ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Navigation.JournalEntry RemoveBackEntry() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.RemoveBackEntry" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveBackEntry () As JournalEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Navigation::JournalEntry ^ RemoveBackEntry();" />
      <MemberSignature Language="F#" Value="member this.RemoveBackEntry : unit -&gt; System.Windows.Navigation.JournalEntry" Usage="navigationService.RemoveBackEntry " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Navigation.JournalEntry</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>移除后退历史记录中的最新日记条目。</summary>
        <returns>后退导航历史记录中的最新 <see cref="T:System.Windows.Navigation.JournalEntry" />（如果有）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果两个或更多<xref:System.Windows.Navigation.NavigationWindow>导航<xref:System.Windows.Controls.Frame>器 (、) 共享相同的导航历史记录, <xref:System.Windows.Navigation.NavigationService.RemoveBackEntry%2A>则一个导航器可以使用来检索在另一个导航器中发生的导航的后退导航历史记录项。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Navigation.NavigationService.AddBackEntry(System.Windows.Navigation.CustomContentState)" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public Uri Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Navigation.NavigationService.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Source { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : Uri with get, set" Usage="System.Windows.Navigation.NavigationService.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前内容的 URI，或当前正在导航到的新内容的 URI。</summary>
        <value>一个<see cref="T:System.Uri" /> , 其中包含当前内容的 URI 或当前正在导航到的内容。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为与当前所显示的 uri 不同的 uri, 导航器 (<xref:System.Windows.Navigation.NavigationWindow>、 <xref:System.Windows.Controls.Frame>) 将导航到指定的 uri。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A>设置为从导航到的 URI 加载的内容, 除非取消导航。  
  
 <xref:System.Windows.Navigation.NavigationService.Source%2A>可以使用仅分段 URI 进行设置, 并且可以设置为`null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopLoading">
      <MemberSignature Language="C#" Value="public void StopLoading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopLoading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Navigation.NavigationService.StopLoading" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopLoading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopLoading();" />
      <MemberSignature Language="F#" Value="member this.StopLoading : unit -&gt; unit" Usage="navigationService.StopLoading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止为当前导航请求下载更多内容。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A>可在<xref:System.Windows.Navigation.NavigationService.Navigate%2A>返回后立即调用, 并停止正在子框架中进行的导航。  
  
 (<xref:System.Windows.Controls.Frame>).  
  
 调用方法会引发<xref:System.Windows.Navigation.NavigationService.NavigationStopped>事件。 <xref:System.Windows.Navigation.NavigationService.StopLoading%2A>  
  
> [!NOTE]
>  <xref:System.Windows.Navigation.NavigationService.StopLoading%2A>必须在启动导航的同一线程上调用。  
  
   
  
## Examples  
 下面的示例演示如何停止加载。  
  
 [!code-csharp[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/NavigationServiceSnippets/CSharp/MainWindow.xaml.cs#mainwindowstoploadingcode)]
 [!code-vb[NavigationServiceSnippets#MainWindowStopLoadingCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/NavigationServiceSnippets/visualbasic/mainwindow.xaml.vb#mainwindowstoploadingcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Navigation.NavigationService.Navigate" />
      </Docs>
    </Member>
  </Members>
</Type>
