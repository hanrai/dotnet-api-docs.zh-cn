<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3db2ebd669db6d0e1f12be28a90e1a8e5a863ed0" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68437536" /></Metadata><TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="Interaction" /> 模块包含用于与对象、应用程序和系统交互的过程。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此模块支持运行其他程序、调用方法或属性、从计算机发出嘟嘟声的 Visual Basic 语言关键字和运行时库成员、提供命令行字符串、操作 COM 对象和控制对话框。  
  
## Examples  
 下面的示例使用`Shell`函数来运行用户指定的应用程序。 指定<xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType>为第二个参数将以正常大小打开应用程序, 并为其提供焦点。  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/information-and-interaction-summary.md">信息和交互摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">关键字 (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>激活已经正在运行的应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="ProcessId"><see langword="Integer" />，指定分配给该进程的 Win32 进程 ID 号。 可以使用 <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" /> 返回的 ID，前提是该 ID 不为零。</param>
        <summary>激活已经正在运行的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`AppActivate`将应用程序的活动窗口集中在一起。 您可能没有活动窗口的句柄或引用, 甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下, 不能使用<xref:System.Windows.Forms.Control.Focus%2A>方法。  
  
 `AppActivate`函数会将焦点更改为命名应用程序或窗口, 但不会影响它是最大化还是最小化。 当用户执行某个操作来更改焦点或关闭窗口时, 焦点将离开激活的应用程序窗口。 您可以使用`Shell`函数启动应用程序并设置窗口样式。  
  
 如果使用`Title`参数, 则使用`AppActivate`不区分大小写的比较, 否则需要与标题栏的内容完全匹配。 它首先查找顶级窗口, 然后遍历子窗口。 如果找不到匹配项, 它将引发<xref:System.ArgumentException>。  
  
 只能将用于`AppActivate`拥有 windows 的进程使用。 大多数控制台应用程序不拥有窗口, 这意味着它们不会出现在`AppActivate`搜索的进程列表中。 在控制台应用程序中运行时, 系统会创建一个单独的进程来运行应用程序, 并将输出返回到控制台进程。 因此, 当你请求当前进程 ID 时, 将获取此单独进程的进程 ID, 而不是控制台应用程序的进程 ID。  
  
 在运行时, 该`AppActivate`函数会激活标题`Title`与匹配或与进程 ID 匹配`ProcessId`的任何正在运行的应用程序。 如果没有完全匹配项, 则会激活其标题字符串以结尾的`Title`任何应用程序。 如果有多个名为`Title`的应用程序, 该`AppActivate`函数将随意选择一个应用程序来激活。  
  
> [!NOTE]
>  `AppActivate`函数要求`UIPermission` 在级别,这可能会影响在部分信任情况<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>下的执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例演示了用于激活应用`AppActivate`程序窗口的函数的各种用法。 如果记事本进程未运行, 则该示例引发<xref:System.ArgumentException>。 此`Shell`过程假定应用程序位于指定的路径中。  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Title"><see langword="String" /> 表达式，用于指定要激活的应用程序的标题栏中的标题。 可以使用启动应用程序后分配给该应用程序的标题。</param>
        <summary>激活已经正在运行的应用程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`AppActivate`将应用程序的活动窗口集中在一起。 您可能没有活动窗口的句柄或引用, 甚至知道哪个窗口在给定时刻处于活动状态。 在这种情况下, 不能使用<xref:System.Windows.Forms.Control.Focus%2A>方法。  
  
 `AppActivate`函数会将焦点更改为命名应用程序或窗口, 但不会影响它是最大化还是最小化。 当用户执行某个操作来更改焦点或关闭窗口时, 焦点将离开激活的应用程序窗口。 您可以使用`Shell`函数启动应用程序并设置窗口样式。  
  
 如果使用`Title`参数, 则使用`AppActivate`不区分大小写的比较, 否则需要与标题栏的内容完全匹配。 它首先查找顶级窗口, 然后遍历子窗口。 如果找不到匹配项, 它将引发<xref:System.ArgumentException>。  
  
 只能将用于`AppActivate`拥有 windows 的进程使用。 大多数控制台应用程序不拥有窗口, 这意味着它们不会出现在`AppActivate`搜索的进程列表中。 在控制台应用程序中运行时, 系统会创建一个单独的进程来运行应用程序, 并将输出返回到控制台进程。 因此, 当你请求当前进程 ID 时, 将获取此单独进程的进程 ID, 而不是控制台应用程序的进程 ID。  
  
 在运行时, 该`AppActivate`函数会激活标题`Title`与匹配或与进程 ID 匹配`ProcessId`的任何正在运行的应用程序。 如果没有完全匹配项, 则会激活其标题字符串以结尾的`Title`任何应用程序。 如果有多个名为`Title`的应用程序, 该`AppActivate`函数将随意选择一个应用程序来激活。  
  
> [!NOTE]
>  `AppActivate`函数要求`UIPermission` 在级别,这可能会影响在部分信任情况<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>下的执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例演示了用于激活应用`AppActivate`程序窗口的函数的各种用法。 如果记事本进程未运行, 则该示例引发<xref:System.ArgumentException>。 此`Shell`过程假定应用程序位于指定的路径中。  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过计算机扬声器提示音。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嘟嘟声的音调和持续时间取决于您的硬件和系统软件, 因此在不同的计算机之间有所不同。  
  
> [!NOTE]
>  `Beep`函数要求`UIPermission` 在级别,这可能会影响在部分信任情况<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>下的执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
   
  
## Examples  
 此示例使用 `Beep` 函数通过计算机的扬声器发出音调。  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/playing-sounds.md">播放声音</related>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">必需。 <see langword="Object" />。 一个指向公开属性或方法的对象的指针。</param>
        <param name="ProcName">必需。 <see langword="String" />。 一个字符串表达式，包含对象的属性或方法的名称。</param>
        <param name="UseCallType">必需。 类型 <see cref="T:Microsoft.VisualBasic.CallType" /> 的一个枚举成员，它表示正在被调用的过程的类型。 <see langword="CallType" /> 的值可以是 <see langword="Method" />、<see langword="Get" /> 或 <see langword="Set" />。</param>
        <param name="Args">可选。 <see langword="ParamArray" />。 一个形参数组，包含要传递给正在调用的属性或方法的实参。</param>
        <summary>执行对象的方法，或者设置或返回对象的属性。</summary>
        <returns>执行对象的方法，或者设置或返回对象的属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `CallByName`函数在运行时用于获取属性、设置属性或调用方法。  
  
   
  
## Examples  
 在下面的示例中, 第一行使用`CallByName`设置文本框的`Text`属性, 第二行`Text`检索`Move`属性的值, 第三行调用方法来移动文本框。  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 下一个示例使用`CallByName`函数调用集合对象的`Add`和`Item`方法。  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">无效 <paramref name="UseCallType" /> 值；必须为 <see langword="Method" />、<see langword="Get" /> 或 <see langword="Set" />。</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">参数数组</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/early-late-binding/calling-a-property-or-method-using-a-string-name.md">使用字符串名调用属性或方法</related>
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Choice" Type="System.Object[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">必需。 <see langword="Double" />。 数值表达式，它得出的值在 1 和 <paramref name="Choice" /> 参数中传递的元素数量之间。</param>
        <param name="Choice">必需。 <see langword="Object" /> 参数数组。 可以为以逗号分隔的 <see langword="Object" /> 变量或表达式列表或一维 <see langword="Object" /> 元素数组提供计算为 <see langword="Object" /> 数据类型的单个变量或表达式。</param>
        <summary>从参数列表中选择和返回一个值。</summary>
        <returns>从参数列表中选择和返回一个值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 函数根据的值返回`Choice()`传入的列表的成员。 `Index` `Choose` 当为1时`Index` , 将选择列表的第一个成员。 当为`Index` `UBound`()时,将选择列表的最后一个成员。`Choice()` 如果`Index`超出这些限制, `Choose`则返回`Nothing`。  
  
 如果`Index`不是整数, 则在计算之前舍入为最接近的整数。  
  
 您可以使用`Choose`在可能的列表中查找值。  
  
> [!NOTE]
>  自变量列表中的表达式可以包含函数调用。 作为对的调用`Choose`的准备参数列表的一部分, Visual Basic 编译器将调用每个表达式中的每个函数。 这意味着, 如果选择`Index`不同的表达式, 则不能依赖于未调用的特定函数。  
  
   
  
## Examples  
 此示例使用`Choose`函数来显示名称, 以响应传入`Ind`参数中的过程的索引。  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回命令行的参数部分，该命令行用于启动 Visual Basic 或启动使用 Visual Basic 开发的可执行程序。 <see langword="My" /> 功能可以提供比 <see langword="Command" /> 函数更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />。</summary>
        <returns>命令行的参数部分，该命令行用于启动 Visual Basic 或启动使用 Visual Basic 开发的可执行程序。  
  
<see langword="My" /> 功能可以提供比 <see langword="Command" /> 函数更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回参数后, 可以搜索常用分隔符 (如空格、向后或正斜杠、连字符或引号), 以拆分或搜索单独参数的字符串。  
  
 对于使用 Visual Basic 开发并编译为 .exe 文件的应用程序, 该`Command`函数返回在命令行上出现在应用程序名称之后的任何参数, 格式如下:。 `MyApp(cmdlineargs)`  
  
   
  
## Examples  
 此示例使用`Command`函数返回包含数组的对象中的命令行参数。  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
        <related type="Article" href="~/docs/visual-basic/reference/command-line-compiler/index.md">Visual Basic 命令行编译器</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/program-structure/structure-of-a-visual-basic-program.md">Visual Basic 程序的结构</related>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">必需。 <see langword="String" />。 要创建的对象的程序 ID。</param>
        <param name="ServerName">可选。 <see langword="String" />。 要在其上创建对象的网络服务器的名称。 如果 <paramref name="ServerName" /> 是空字符串 ("")，则使用本地计算机。</param>
        <summary>创建并返回对 COM 对象的引用。 不能在 Visual Basic 中使用 <see langword="CreateObject" /> 创建这些类的实例，除非将类显式公开为 COM 组件。</summary>
        <returns>创建并返回对 COM 对象的引用。 不能在 Visual Basic 中使用 <see langword="CreateObject" /> 创建这些类的实例，除非将类显式公开为 COM 组件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建 COM 组件的实例, 请将返回`CreateObject`的对象分配给对象变量:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 用于存储返回对象的对象变量的类型可能会影响应用程序的性能。 使用`As Object`子句声明对象变量将创建一个变量, 该变量可包含对任何类型的对象的引用。 但是, 通过该变量对对象的访问是*后期绑定*的, 也就是说, 在程序运行时将进行绑定。 应避免后期绑定的原因有很多, 包括应用程序性能下降。  
  
 你可以创建一个生成早期绑定的对象变量, 即在编译程序时进行绑定。 为此, 请从 "**项目**" 菜单上的 "**添加引用**" 对话框的 " **COM** " 选项卡中为你的对象添加对类型库的引用。 然后声明对象的特定类型的对象变量。 在大多数情况下, 使用`Dim`语句和主互操作程序集来创建对象比`CreateObject`使用函数更有效。  
  
## <a name="interacting-with-unmanaged-code"></a>与非托管代码交互  
 另一个问题是, COM 对象使用非托管代码, 而不是公共语言运行时的优点。 将 Visual Basic 的托管代码与 COM 中的非托管代码混合使用会产生相当大的复杂性。 添加对 COM 对象的引用时, Visual Basic 会搜索该库的主互操作程序集 (PIA);如果找到一个, 则使用它。 如果未找到 PIA, 则会创建一个互操作性程序集, 该程序集包含 COM 库中每个类的本地互操作性类。 有关详细信息, 请参阅[.NET Framework 应用程序中的 COM 互操作性](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md)。  
  
 通常应尽可能使用强绑定对象和主互操作程序集。 下面的示例将`CreateObject`函数与 Microsoft Office 对象结合使用来仅用于演示目的。 但是, 在与相应的主互操作程序集一起使用时, 这些对象更易于使用且更可靠。  
  
## <a name="creating-an-object-on-a-remote-computer"></a>在远程计算机上创建对象  
 可以通过将计算机名称传递给`ServerName` `CreateObject`函数的参数, 在远程网络计算机上创建对象。 该名称与共享名称的计算机名称部分相同: 对于名为 "\\\MyServer\Public" 的共享`ServerName` , 为 "MyServer"。  
  
> [!NOTE]
>  有关使应用程序在远程联网计算机上可访问的其他信息, 请参阅 COM 文档 (请参阅 Microsoft 开发人员网络)。 可能需要为应用程序添加注册表项。  
  
 下面的代码返回在名为`MyServer`的远程计算机上运行的 Excel 实例的版本号:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 如果远程服务器名称不正确或不可用, 则会发生运行时错误。  
  
> [!NOTE]
>  当`CreateObject`没有对象的当前实例时使用。 如果对象实例已在运行, 则将启动一个新实例, 并创建一个指定类型的对象。 若要使用当前实例, 或要启动应用程序并将文件加载, 请使用`GetObject`函数。 如果对象已将自身注册为单实例对象, 则无论执行多少次`CreateObject` , 都只会创建一个对象实例。  
  
## <a name="creating-framework-objects"></a>创建框架对象  
 仅可使用`CreateObject`函数创建 COM 对象。 虽然没有用于创建 .NET Framework 对象的完全等效机制, 但<xref:System.Activator> <xref:System>命名空间中的包含创建本地或远程对象的方法。 特别是, <xref:System.Activator.CreateInstance%2A>方法<xref:System.Activator.CreateInstanceFrom%2A>或方法可能会很有用。  
  
> [!IMPORTANT]
>  `CreateObject`函数需要非托管代码权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用`CreateObject`函数创建 Microsoft Excel 工作表, 并将该工作表保存到文件中。 若要使用此示例, 必须将 Excel 安装在运行此程序的计算机上。 此外, 你必须从 "**项目**" 菜单上的 "**添加引用**" 对话框的 " **COM** " 选项卡中添加对类型库的引用。 类型库的名称因计算机上安装的 Excel 的版本而异。 例如, Microsoft Excel 2002 的类型库命名为 " **Microsoft excel 10.0 对象库**"。  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">服务器不可用。</exception>
        <exception cref="T:System.IO.FileNotFoundException">不存在指定类型的对象。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/dim-statement.md">Dim 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">.NET Framework 应用程序中的 COM 互操作性</related>
        <related type="Article" href="~/docs/framework/interop/index.md">与非托管代码交互操作</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含应用节或项设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 <see langword="String" /> 表达式，包含要从中删除项设置的节的名称。 如果仅提供了 <paramref name="AppName" /> 和 <paramref name="Section" />，则将删除指定的节以及所有相关的项设置。</param>
        <param name="Key">可选。 <see langword="String" /> 表达式，包含要删除的项设置的名称。</param>
        <summary>从 Windows 注册表中某个应用程序的项中删除一个节或一个项设置。 与 <see langword="DeleteSetting" /> 函数相比，<see langword="My" /> 功能在注册表操作方面可为你提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果提供所有参数, 则将删除指定的设置。 如果尝试对不存在的节或键设置使用`DeleteSetting` , 则会发生运行时错误。  
  
 `DeleteSetting`要求用户登录, 因为它在用户以交互方式登录`HKEY_LOCAL_USER`之前处于不活动状态的注册表项下运行。  
  
 要从非交互式进程 (如 mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\` `HKEY_USER\DEFAULT\Software`或注册表项下。  
  
   
  
## Examples  
 下面的示例首先使用`SaveSetting`过程在 Windows 注册表中`MyApp`为应用程序生成条目`DeleteSetting` , 然后使用函数将其删除。 由于未`Key`指定任何参数, 因此将`Startup`删除整个节, 其中包括节名称及其所有键。  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Expression">必需。 此表达式用于计算包含环境变量名称的字符串，或对应于环境字符串表中环境字符串的数字顺序的整数。</param>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
        <returns>与操作系统环境变量关联的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Expression`包含一个字符串, 则<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数将返回分配给指定的环境字符串的文本, 即该环境变量的环境字符串表中等号 (=) 后面的文本。 如果在环境字符串`Expression`表中找不到中的字符串, 则返回长度为零的字符串 ("")。  
  
 如果`Expression`包含一个整数, 则返回占据环境字符串表中该数值位置的字符串。 在这种情况<xref:Microsoft.VisualBasic.Interaction.Environ%2A>下, 将返回所有文本, 包括环境变量的名称。 如果指定位置没有环境字符串, <xref:Microsoft.VisualBasic.Interaction.Environ%2A>则返回一个长度为零的字符串。  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数需要环境权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数提供环境字符串表中`PATH`语句的输入编号和长度。  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缺少 <paramref name="Expression" />。</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Expression">必需。 此表达式用于计算包含环境变量名称的字符串，或对应于环境字符串表中环境字符串的数字顺序的整数。</param>
        <summary>返回与操作系统环境变量关联的字符串。</summary>
        <returns>与操作系统环境变量关联的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Expression`包含一个字符串, 则<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数将返回分配给指定的环境字符串的文本, 即该环境变量的环境字符串表中等号 (=) 后面的文本。 如果在环境字符串`Expression`表中找不到中的字符串, 则返回长度为零的字符串 ("")。  
  
 如果`Expression`包含一个整数, 则返回占据环境字符串表中该数值位置的字符串。 在这种情况<xref:Microsoft.VisualBasic.Interaction.Environ%2A>下, 将返回所有文本, 包括环境变量的名称。 如果指定位置没有环境字符串, <xref:Microsoft.VisualBasic.Interaction.Environ%2A>则返回一个长度为零的字符串。  
  
> [!IMPORTANT]
>  <xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数需要环境权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用<xref:Microsoft.VisualBasic.Interaction.Environ%2A>函数提供环境字符串表中`PATH`语句的输入编号和长度。  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">缺少 <paramref name="Expression" />。</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含请求其项设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 一个 <see langword="String" /> 表达式，其中包含请求其关键设置的节的名称。 <see langword="GetAllSettings" /> 返回一个包含二维字符串数组的对象。 这些字符串包含指定节中的所有项设置及其相应的值。</param>
        <summary>从 Windows 注册表中某个应用程序的项返回项设置及其各自的值（最初通过 <see langword="SaveSetting" /> 创建）的列表。 与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <returns>Windows 注册表中某个应用程序的项中的项设置及其各自的值（最初通过 <see langword="SaveSetting" /> 创建）的列表。  
  
与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings``Object`如果或不`Section`存在, 则返回未初始化的。 `AppName`  
  
 由于它在用户`HKEY_LOCAL_USER` `GetAllSettings`以交互方式登录之前处于不活动状态的注册表项下运行, 因此要求用户登录。  
  
 要从非交互式进程 (如 mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\` `HKEY_USER\DEFAULT\Software`或注册表项下。  
  
   
  
## Examples  
 此示例首先使用`SaveSetting`函数为指定为`AppName`的应用程序在 Windows 注册表中生成条目, 然后使用`GetAllSettings`函数来显示设置。 请注意, 应用程序`Section`名称和名称不能`GetAllSettings`用来检索。 最后, 函数`DeleteSetting`将删除应用程序的条目。  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Class" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="PathName">可选。 <see langword="String" />。 包含要检索的对象的文件的完整路径和名称。 如果省略了 <paramref name="PathName" />，则 <paramref name="Class" /> 为必选。</param>
        <param name="Class">如果未提供 <paramref name="PathName" />，则为必选。 <see langword="String" />。 表示对象的类的字符串。 <paramref name="Class" /> 参数具有以下语法和部分： 
 <c>appname</c><c>.</c><c>objecttype</c>  
  
[1|1] 参数 
[1|2]“描述” 
[2|1] <c>appname</c>  
  
[2|2]“所需的”。 <see langword="String" />。 提供对象的应用程序的名称。  
  
[3|1] <c>objecttype</c>  
  
[3|2]“所需的”。 <see langword="String" />。 要创建的对象的类型或类。</param>
        <summary>返回对 COM 组件提供的对象的引用。</summary>
        <returns>对 COM 组件提供的对象的引用。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObject`使用函数从文件中加载 COM 组件的实例。 下面的示例阐释了这一点。  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 此代码运行时, 将启动与指定`PathName`的关联的应用程序, 并激活指定文件中的对象。  
  
## <a name="default-cases"></a>默认情况  
 如果`PathName`是长度为零的字符串 (`""`), `GetObject`则返回指定类类型的新对象实例。 如果省略`PathName`该参数, `GetObject`则返回在中`Class`指定的类类型的当前活动对象。 如果不存在指定类型的对象, 则会发生错误。  
  
## <a name="accessing-a-subobject"></a>访问子对象  
 某些应用程序允许你激活与文件关联的子对象。 为此, 请将感叹号 (`!`) 添加到文件名的末尾, 并在其后面添加一个字符串, 该字符串标识要激活的文件部分。 有关如何创建此字符串的信息, 请参阅创建对象的应用程序的文档。  
  
 例如, 在绘图应用程序中, 可能有多个层用于存储在文件中的绘图。 你可以使用以下代码在名`schema.cad`为的绘图中激活层。  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>指定类  
 如果未指定对象的`Class`, 则自动化会根据你提供的文件名确定要启动的应用程序和要激活的对象。 但是, 某些文件可以支持多个对象类。 例如, 绘制可能支持三种不同类型的对象: `Application`对象`Drawing` 、对象和`Toolbar`对象, 这些对象都属于同一文件。 若要指定要激活的文件中的哪个对象, 请使用可选`Class`的参数。 下面的示例阐释了这一点。  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 在前面的示例中`Figment` , 是一个绘图应用程序的名称`Drawing` , 并且是它支持的对象类型之一。  
  
## <a name="using-the-object"></a>使用对象  
 激活某个对象后, 可以使用声明的对象变量在代码中引用该对象。 在前面的示例中, 使用对象变量`drawObj`访问新对象的属性和方法。 下面的示例阐释了这一点。  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  如果存在对象的当前实例, 或者如果要使用加载的文件创建对象, 请使用函数。`GetObject` 如果没有当前实例, 并且你不希望在加载文件的情况下启动对象, 请使用<xref:Microsoft.VisualBasic.Interaction.CreateObject%2A>函数。  
>   
>  如果对象已将自身注册为 ActiveX 单实例对象, 则无论调用多少次`CreateObject` , 都只会创建一个对象实例。 对于单实例对象, `GetObject`在使用零长度字符串 (`""`) 语法调用时始终返回相同的实例, 如果省略该`PathName`参数, 则会导致错误。 不能使用`GetObject`来获取对使用 Visual Basic 创建的类的引用。  
  
> [!IMPORTANT]
>  `GetObject`函数需要非托管代码权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用`GetObject`函数获取对特定 Microsoft Excel 工作表的引用 (`excelObj`)。 它使用工作表的`Application`属性使 Excel 可见, 将其关闭, 然后执行其他操作。 使用两个 API 调用, `detectExcel`该过程将查找 Excel, 如果正在运行, 则将其输入到正在运行的对象表中。 如果 Excel 尚未运行`GetObject` , 则第一次调用会导致错误, 在此示例`excelWasNotRunning`中, 该标志将设置为`True`。 第二次调用`GetObject`指定要打开的文件。 如果 Excel 尚未运行, 则第二次调用将启动它并返回对指定文件`test.xls`表示的工作表的引用。 文件必须存在于指定的位置;否则, Visual Basic 引发<xref:System.IO.FileNotFoundException>。 接下来, 示例代码使 Excel 和包含指定工作表的窗口可见。  
  
 此示例需要`Option Strict Off` , 因为它使用后期绑定, 其中对象被分配给类型`Object`的变量。 如果从 Visual `Option Strict On` Studio 的 "**项目**" 菜单的 "**添加引用**" 对话框的 " **COM** " 选项卡中添加对 Excel 类型库的引用, 则可以指定和声明特定对象类型的对象。  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 调用`getExcel`函数时, 将进行检查以查看 Excel 是否已在运行。 如果不是, 则创建实例。  
  
> [!IMPORTANT]
>  为简单起见, 前面的示例假定名`XLMAIN`为的任何窗口都属于 Microsoft Excel 的实例。 如果另一个对象 (可能由非法篡改来启动) 使用该名称创建了一个窗口, 则它将接收你打算用于 Excel 的所有消息。 在要用于生产的应用程序中, 应包括一些更严格的`XLMAIN`测试, 以验证是否确实属于 Excel。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">不存在指定类类型的对象。</exception>
        <exception cref="T:System.IO.FileNotFoundException">不存在具有指定路径和文件名的对象。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Declare Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Default" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含请求其项设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 <see langword="String" /> 表达式，包含在其中找到项设置的节的名称。</param>
        <param name="Key">必需。 <see langword="String" /> 表达式，包含要返回的项设置的名称。</param>
        <param name="Default">可选。 包含要返回的值的表达式（如果没有在 <paramref name="Key" /> 设置中设置值）。 如果省略，则假定 <paramref name="Default" /> 为零长度字符串 ("")。</param>
        <summary>从 Windows 注册表中应用程序的项返回项设置值。 与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <returns>Windows 注册表中某个应用程序的项中的项设置值。  
  
与 <see langword="My" /> 相比，<see langword="GetAllSettings" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在`GetSetting`参数中指定的任何项不存在, `GetSetting`则返回值`Default`。  
  
 由于它在用户`HKEY_LOCAL_USER` `GetSetting`以交互方式登录之前处于不活动状态的注册表项下运行, 因此要求用户登录。  
  
 要从非交互式进程 (如 mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\` `HKEY_USER\DEFAULT\Software`或注册表项下。  
  
 `GetSetting`需要`Read` 。<xref:System.Security.Permissions.RegistryPermission>  
  
   
  
## Examples  
 此示例首先使用`SaveSetting`函数为指定为`AppName`的应用程序在 Windows 注册表中生成项`GetSetting` , 然后使用函数显示其中一个设置。 由于指定`Default`了参数, 因此保证返回某些值。 请注意`Section` , 不能用`GetSetting`检索到名称。 最后, 函数`DeleteSetting`将删除应用程序的所有条目。  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">一个或多个参数不是 <see langword="String" /> 表达式，或用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">必需。 <see langword="Boolean" />。 要计算的表达式。</param>
        <param name="TruePart">必需。 <see langword="Object" />。 当 <paramref name="Expression" /> 计算结果为 <see langword="True" /> 时返回。</param>
        <param name="FalsePart">必需。 <see langword="Object" />。 当 <paramref name="Expression" /> 计算结果为 <see langword="False" /> 时返回。</param>
        <summary>根据表达式的计算，返回两个对象中的一个。</summary>
        <returns>根据表达式的计算，返回两个对象中的一个。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 函数提供 Visual C++中三元[条件运算符:？:](https://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271)的对应项。 `IIf`  
  
   
  
## Examples  
 此示例使用`IIf`函数来计算`checkIt`过程的`testMe`参数, 如果数量大于 1000, 则返回单词 "大"; 否则返回 "Small" 一词。  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 请注意, `Option Strict`如果`On`为`CStr` , 则必须使用关键字将从`Object`的返回显式转换为`String`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Option Strict Statement</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">Type Conversion Functions</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/if-then-else-statement.md">If...Then...Else 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Title" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="DefaultResponse" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="XPos" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="YPos" Type="System.Int32" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Prompt">必选的 <see langword="String" /> 表达式，作为消息显示在对话框中。 <paramref name="Prompt" /> 的最大长度大约为 1024 个字符，具体取决于所用字符的宽度。 如果 <paramref name="Prompt" /> 包含多行，可以使用回车符 (<see langword="Chr(" />13<see langword=")" />) 或换行符 (<see langword="Chr(" />10<see langword=")" />)，或组合使用回车符/换行符 (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) 来分隔每行。</param>
        <param name="Title">可选。 显示在对话框标题栏中的 <see langword="String" /> 表达式。 如果省略 <paramref name="Title" />，则标题栏中显示应用程序名称。</param>
        <param name="DefaultResponse">可选。 <see langword="String" /> 表达式。如果未提供其他输入，则作为默认响应显示在文本框中。 如果省略 <paramref name="DefaultResponse" />，则显示的文本框为空。</param>
        <param name="XPos">可选。 数值表达式，指定屏幕左边缘与对话框左边缘之间的距离（以缇为单位）。 如果省略 <paramref name="XPos" />，则对话框水平居中。</param>
        <param name="YPos">可选。 数值表达式，指定屏幕顶部与对话框上边缘之间的距离（以缇为单位）。 如果省略 <paramref name="YPos" />，则对话框垂直定位在屏幕向下大约三分之一处。</param>
        <summary>在对话框中显示提示，等待用户输入文本或单击按钮，然后返回包含文本框内容的字符串。</summary>
        <returns>在对话框中显示提示，等待用户输入文本或单击按钮，然后返回包含文本框内容的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果用户单击 "**取消**", 则返回一个长度为零的字符串。  
  
 若要指定除第一个参数以外的其他参数, `InputBox`必须在表达式中使用函数。 如果省略任何位置参数, 则必须保留相应的逗号分隔符。  
  
> [!NOTE]
>  `InputBox`函数要求`UIPermission` 在级别,这可能会影响在部分信任情况<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>下的执行。 有关详细信息, 请参阅[请求权限](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/yd267cce(v%3dvs.100))和<xref:System.Security.Permissions.UIPermission> 。  
  
   
  
## Examples  
 此示例演示使用函数提示用户输入`InputBox`值的各种方式。 如果省略 x 和 y 位置, 则对话框将自动居中放置在各自的轴上。 如果用户`MyValue`单击 "确定" 或按 ENTER 键, 则该变量包含用户输入的值。  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Title" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Prompt">必需。 作为消息显示在对话框中的 <see langword="String" /> 表达式。 <paramref name="Prompt" /> 的最大长度大约为 1024 个字符，具体取决于所用字符的宽度。 如果 <paramref name="Prompt" /> 包含多行，可以使用回车符 (<see langword="Chr(" />13<see langword=")" />) 或换行符 (<see langword="Chr(" />10<see langword=")" />)，或组合使用回车符/换行符 (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) 来分隔每行。</param>
        <param name="Buttons">可选。 数值表达式，它是值的总和，指定显示的按钮数目及按钮类型，使用的图标样式，默认按钮的标识以及消息框的样式等。 如果省略 <paramref name="Buttons" />，则默认值为 0。</param>
        <param name="Title">可选。 显示在对话框标题栏中的 <see langword="String" /> 表达式。 如果省略 <paramref name="Title" />，则标题栏中显示应用程序名称。</param>
        <summary>在对话框中显示消息，等待用户单击按钮，然后返回一个整数，该整数指示用户单击的按钮。</summary>
        <returns><list type="table">
            <item>
              <term> 返回的常量 
 </term>
              <description> 值 
 </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 
 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 
 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 
 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 
 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 
 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 
 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 
 </description>
            </item>
          </list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果省略任何位置参数, 则必须保留相应的逗号分隔符。  
  
 如果对话框显示 "**取消**" 按钮, 则按 ESC 键具有与单击 "**取消**" 相同的效果  
  
 如果对话框包含 "**帮助**" 按钮, 则会为该对话框提供上下文相关帮助。 但是，在关闭其他任一按钮前，不会返回任何值。 在 Windows 窗体应用程序中 , 选择 "帮助<xref:System.Windows.Forms.Control.HelpRequested> " 按钮将执行窗体的事件。  
  
> [!NOTE]
>  `MsgBox`函数要求`UIPermission` 在级别,这可能会影响在部分信任情况<xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows>下的执行。 有关更多信息，请参见<xref:System.Security.Permissions.UIPermission>。  
  
 下表列出了枚举值。`MsgBoxStyle`  
  
|成员|值|说明|  
|-|-|-|  
|成员|值|说明|  
|`OKOnly`|0|仅显示 "确定" 按钮。|  
|`OKCancel`|1|显示 "确定" 和 "取消" 按钮。|  
|`AbortRetryIgnore`|2|显示 "中止"、"重试" 和 "忽略" 按钮。|  
|`YesNoCancel`|3|显示 "是"、"否" 和 "取消" 按钮。|  
|`YesNo`|4|显示 "是" 和 "否" 按钮。|  
|`RetryCancel`|5|显示 "重试" 和 "取消" 按钮。|  
|`Critical`|16|显示关键消息图标。|  
|`Question`|32|显示警告查询图标。|  
|`Exclamation`|48|显示警告消息图标。|  
|`Information`|64|显示信息消息图标。|  
|`DefaultButton1`|0|第一个按钮是默认值。|  
|`DefaultButton2`|256|第二个按钮是默认值。|  
|`DefaultButton3`|512|第三个按钮是默认值。|  
|`ApplicationModal`|0|应用程序是模式的。 在当前应用程序中继续工作之前, 用户必须响应该消息框。|  
|`SystemModal`|4096|系统是模式的。 所有应用程序都将挂起, 直到用户响应消息框。|  
|`MsgBoxSetForeground`|65536|指定消息框窗口作为前台窗口。|  
|`MsgBoxRight`|524288|文本右对齐。|  
|`MsgBoxRtlReading`|1048576|指定文本在希伯来语和阿拉伯语系统中应显示为从右到左阅读。|  
  
 第一组值 (0-5) 描述对话框中显示的按钮的数量和类型。 第二组 (16, 32, 48, 64) 描述了图标样式。 第三组 (0, 256, 512) 确定默认的按钮。 第四组 (0, 4096) 确定消息框的模态, 第五组指定消息框窗口是否为前景窗口, 以及文本的对齐方式和方向。 在添加数字以创建`Buttons`自变量的最终值时, 请使用每个组中的一个数字。  
  
   
  
## Examples  
 此示例使用`MsgBox`函数在包含 "是" 和 "否" 按钮的对话框中显示严重错误消息。 "否" 按钮指定为默认响应。 这是通过将`MsgBox`常量值组合成一个数值表达式来完成的。 在这种情况下, 将添加 4 (是/否按钮组合) 和 16 ("**关键消息**" 窗口) 和 "256" (第二个按钮作为默认按钮), 总共为276。 `MsgBox`函数返回的值取决于用户选择的按钮:Yes 返回值 6;No 返回值7。  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Prompt" /> 不是一个 <see langword="String" /> 表达式，或者 <paramref name="Title" /> 无效。</exception>
        <exception cref="T:System.InvalidOperationException">进程不是以 User Interactive 模式运行。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">一个或多个参数，而不是 <see langword="MsgBoxResult" /> 或 <see langword="MsgBoxStyle" /> 枚举的成员。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Start" Type="System.Int64" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Stop" Type="System.Int64" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Interval" Type="System.Int64" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Number">必需。 <see langword="Long" />。 要在一个计算范围中找到的整数。</param>
        <param name="Start">必需。 <see langword="Long" />。 一个整数，指示计算出的范围集的开始值。 <paramref name="Start" /> 不能小于 0。</param>
        <param name="Stop">必需。 <see langword="Long" />。 一个整数，指示计算出的范围集的结束值。 <paramref name="Stop" /> 不能小于或等于 <paramref name="Start" />。</param>
        <param name="Interval">必需。 <see langword="Long" />。 一个整数，指示在 <paramref name="Start" /> 和 <paramref name="Stop" /> 之间计算的每个范围大小。 <paramref name="Interval" /> 不能小于 1。</param>
        <summary>返回一个字符串，该字符串表示包含某个数字的计算范围。</summary>
        <returns>一个字符串，该字符串表示包含某个数字的计算范围。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 函数计算一组数值范围, 每个数值范围包含`Interval`指定的值的数目。 `Partition` 第一个范围从开始`Start`, 最后一个范围结束于。 `Stop` 然后`Partition` , 该函数标识包含`Number`的范围并返回描述该范围的字符串。 范围在字符串中表示为 "*lowervalue*:*uppervalue*", 其中范围的低端 (*lowervalue*) 通过冒号 (:) 与高端 (*uppervalue*) 隔开。  
  
 如有必要, `Partition`该函数将在*lowervalue*和*uppervalue*之前插入前导空格, 以便它们与值 (`Stop` + 1) 的字符串表示形式具有相同的字符数。 这可以确保如果使用具有多个值的`Partition` `Number`函数的输出, 则在执行任何后续排序操作的过程中, 将会正确处理生成的文本。  
  
 下表显示了使用三组`Start`、 `Stop`和`Interval`计算的范围的示例字符串。 如果`Start`和的值为, `Stop`则 "第一个范围" 和 "最后一个范围" 列将显示可能的最小和最大范围。 "第一个范围之前" 和 "最后一范围之后" 列显示为`Number` `Start`小于和大于`Stop`的值返回的字符串。  
  
|`Start`|`Stop`|`Interval`|在第一个范围之前|第一个范围|最后一个范围|最后一个范围之后|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|04|"95:99 "|"100:"|  
|20|199|10|"   :19|0.25|"190:199"|"200:"|  
|100|1010|20|"    :99 "|"100:119 "|"1000:1010"|"1011:"|  
  
 在上表中, 当和`Start` `Stop`定义一组`Interval`不能平均除以的数字时, 第三行显示结果。 最后一个范围结束于`Stop`, 它的长度仅`Interval`为11个数字, 即使为20。  
  
 如果`Interval`为 1, 则范围为 "`Number`:`Number`", 而不考虑`Start`和`Stop`参数。 例如, 如果`Number`为 267, `Stop`为 1000, 并且`Interval`为 1, `Partition`则返回 "267:267 "。  
  
 `Partition`构造数据库查询时, 会很有用。 您可以创建一个选择查询, 用于显示在各种值范围内发生的订单数, 例如, 发票值介于1到1000、1001到2000等。  
  
   
  
## Examples  
 下面的示例设置从1950到2049的数十系列范围。 它在相应的范围`year`内查找值, 并`String`返回显示范围的值。 例如`year` ,`Partition`如果的值为 1984, 则返回 "1980:1989"。  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Start" /> &lt; 0、<paramref name="Stop" /> &lt;= <paramref name="Start" /> 或 <paramref name="Interval" /> &lt; 1。</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Section" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Key" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Setting" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="AppName">必需。 <see langword="String" /> 表达式，包含应用该设置的应用程序或项目的名称。</param>
        <param name="Section">必需。 <see langword="String" /> 表达式，包含在其中保存项设置的节的名称。</param>
        <param name="Key">必需。 <see langword="String" /> 表达式，包含将保存的项设置的名称。</param>
        <param name="Setting">必需。 包含值的表达式，<paramref name="Key" /> 将被设置为该值。</param>
        <summary>在 Windows 注册表中保存或创建应用程序项。 与 <see langword="My" /> 相比，<see langword="SaveSetting" /> 功能在注册表操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 函数将项添加到`HKEY_CURRENT_USER\Software\VB and VBA Program Settings`中。 `SaveSetting`  
  
 如果由于任何原因而无法保存密钥设置, 则会发生错误。  
  
 `SaveSetting`要求用户登录, 因为它在用户以交互方式登录`HKEY_LOCAL_USER`之前处于不活动状态的注册表项下运行。  
  
 要从非交互式进程 (如 mtx.exe) 访问的注册表设置应存储在`HKEY_LOCAL_MACHINE\Software\` `HKEY_USER\DEFAULT\Software`或注册表项下。  
  
 `SaveSetting`需要`Write`和`Create` 。 <xref:System.Security.Permissions.RegistryPermission>  
  
   
  
## Examples  
 下面的示例首先使用`SaveSetting`函数为`MyApp`应用程序的 Windows 注册表中的条目`DeleteSetting` , 然后使用函数将其删除。  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未能创建注册表项，或用户没有登录。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">读取和写入注册表 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="Pathname">必需。 <see langword="String" />。 要执行的程序的名称，以及所有必需的参数和命令行开关。 <paramref name="PathName" /> 也可以包含驱动器和目录路径或文件夹。
如果不知道程序的路径，则可以使用 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> 进行定位。 例如，你可以调用 <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>，这将返回驱动器 C:\\ 上任意位置每个名为 <c>testFile.txt</c> 的文件的完整路径。</param>
        <param name="PathName">必需。 <see langword="String" />。 要执行的程序的名称，以及所有必需的参数和命令行开关。 <paramref name="PathName" /> 也可以包含驱动器和目录路径或文件夹。  
 如果不知道程序的路径，则可以使用 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> 进行定位。 例如，你可以调用 <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>，这将返回驱动器 C:\\ 上任意位置每个名为 <c>testFile.txt</c> 的文件的完整路径。</param>
        <param name="Style">可选。 <see langword="AppWinStyle" />。 从 <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> 中选择的一个值，该值指定将要在其中运行程序的窗口的样式。 如果省略 <paramref name="Style" />，<see langword="Shell" /> 将使用 <see langword="AppWinStyle.MinimizedFocus" /> 以最小化方式启动该程序并获得焦点。</param>
        <param name="Wait">可选。 <see langword="Boolean" />。 一个指示 <see langword="Shell" /> 函数是否应等待程序完成的值。 如果省略 <paramref name="Wait" />，则 <see langword="Shell" /> 将使用 <see langword="False" />。</param>
        <param name="Timeout">可选。 <see langword="Integer" />。 如果 <paramref name="Wait" /> 为 <see langword="True" />，则为等待完成的毫秒数。 如果省略 <paramref name="Timeout" />，则 <see langword="Shell" /> 使用 -1，表示没有超时设置并且 <see langword="Shell" /> 到程序结束时才返回。 因此，如果省略 <paramref name="Timeout" /> 或将其设置为 -1，则 <see langword="Shell" /> 可能永远不会将控制返回给您的程序。</param>
        <summary>运行一个可执行程序，并且如果该程序仍在运行则返回一个包含该程序的进程 ID 的整数。</summary>
        <returns>一个整数，包含该程序仍在运行时的进程 ID。 如果该程序已完成执行，则为 0。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Shell`函数的返回值取决于在返回时`Shell`中`PathName`名为的程序是否仍在执行。 如果将设置`Wait`为`True` , 并且在超时过期之前程序完成, `Shell`则返回零。 如果超时时间已到, 或者省略`Wait`或将其设置为`False`, `Shell`则返回程序的进程 ID。 进程 ID 是一个唯一的编号, 用于标识正在运行的程序。  
  
## <a name="failure-to-start"></a>未能启动  
 如果函数无法启动命名程序<xref:System.IO.FileNotFoundException> , 则会发生错误。 `Shell` 例如, 当你尝试使用`command.com` <xref:System.Windows.Forms?displayProperty=nameWithType>从应用程序运行16位程序 (例如) 时, 就会发生这种情况。 为解决此问题, 你可以运行一个调用所需的16位程序的32位程序。 对于`command.com`, 你可以作为替代项运行`cmd.exe` 。  
  
## <a name="waiting-for-completion"></a>等待完成  
 默认情况下, `Shell`函数以异步方式运行程序。 这意味着在执行`Shell` `Shell`函数后面的语句之前, 使用函数启动的程序可能无法完成执行。 如果希望在继续操作之前等待程序完成, 请将设置`Wait`为。 `True`  
  
## <a name="determining-the-exit-code"></a>确定退出代码  
 进程在终止时可以返回*退出代码*。 但是, 你不能`Shell`使用来检索此退出代码, `Shell`因为如果它等待终止, 则返回零, 同时还会因为进程`Shell`在中的不同对象中运行。  
  
 若要从进程中检索退出代码, 你必须编写自己的代码来启动进程并等待终止。 下面的示例演示如何启动进程, 等待它终止, 并检索其退出代码。  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>保护文件规范  
 应始终将整个路径和文件规范括在引号中, 如下面的示例所示。  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 字符串文本中的每对相邻双引号`" "`() 被解释为字符串中的一个双引号字符。 因此, 前面的示例向`Shell`函数提供以下字符串:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 如果没有用引号引起来的路径, Windows 将在 C:\ 中查找名`Program.exe`为的文件目录中, 而`display.exe`不是在 C:\Program Files 目录中。  
  
> [!IMPORTANT]
>  如果未将路径和文件规范括在引号中, 则如果文件名或路径节点包含空格, 则会产生安全风险。 在前面的示例中, 路径节点`\Program Files`包括空格。 如果规范不在引号内并且已在 C: `Program.exe` \\中安装了名为的程序 (例如, 违法篡改), 则 Windows `display.exe`将执行它, 而不是。  
  
> [!IMPORTANT]
>  `Shell`函数需要非托管代码权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 下面的示例使用`Shell`函数来运行用户指定的应用程序。 指定<xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType>为第二个参数将以正常大小打开应用程序, 并为其提供焦点。  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Style" /> 不在 0 到 9（包含 0 和 9）范围内。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><see langword="Shell" /> 找不到 <paramref name="PathName" /> 文件。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="PathName" /> 为 <see langword="Nothing" />。</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">必需。 <see langword="Object" /> 参数数组。 必须具有偶数个元素。 可以提供以逗号分隔的 <see langword="Object" /> 变量或表达式的列表，或一维 <see langword="Object" /> 元素数组。</param>
        <summary>计算表达式列表，并返回与列表中第一个为 <see langword="Object" /> 的表达式对应的 <see langword="True" /> 值。</summary>
        <returns>计算表达式列表，并返回与列表中第一个为 <see langword="Object" /> 的表达式对应的 <see langword="True" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供给`VarExpr`的参数由成对的表达式和值组成。 函数从中`VarExpr`的最低索引到最高索引计算奇数表达式, 并返回与计算结果为`True`的第一个表达式关联的偶数值。 `Switch` 例如, `VarExpr(0)`如果为`True`,则返回`VarExpr(3)`; 如果`Switch`为`VarExpr(0)` `False` `VarExpr(1)` ,`VarExpr(2)`则返回; 如果为, 则返回, 依此类推。 `True` `Switch`  
  
 如果未提供`VarExpr`参数, `Switch`则返回`Nothing`。  
  
> [!NOTE]
>  自变量列表中的表达式可以包含函数调用。 作为对的调用`Switch`的准备参数列表的一部分, Visual Basic 编译器将调用每个表达式中的每个函数。 这意味着, 如果参数列表中前面的表达式为`True`, 则不能依赖于未调用的特定函数。  
  
   
  
## Examples  
 下面的示例使用`Switch`函数返回与 city 名称匹配的语言名称。 它需要`Option Strict`。 `Off`  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 由于命名空间还包含名<xref:System.Diagnostics.Switch>为的类`Switch` , 因此必须使用<xref:Microsoft.VisualBasic>命名空间限定对函数的调用。 <xref:System.Diagnostics>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">参数数目为奇数。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Select...Case 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">参数数组</related>
      </Docs>
    </Member>
  </Members>
</Type>