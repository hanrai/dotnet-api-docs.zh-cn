<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b8affba69c9ea52a1bf3e93c3b9d5d4a2d6fd1f8" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69317705" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
    <AssemblyVersion>10.0.4.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see langword="FileSystem" /> 模块包含用于执行文件、目录或文件夹以及系统操作的过程。 与使用 <see langword="My" /> 模块相比，<see langword="FileSystem" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此模块支持访问文件和文件夹的 Visual Basic 语言关键字和运行库成员。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">目录和文件摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">输入和输出摘要</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">关键字 (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Visual Basic 运行时库成员</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必需。 一个字符串表达式，用于标识哪个目录或文件夹将成为新的默认目录或文件夹。 <paramref name="Path" /> 可以包含驱动器。 如果未指定驱动器，则 <see langword="ChDir" /> 更改当前驱动器上的默认目录或文件夹。</param>
        <summary>更改当前目录或文件夹。 与 <see langword="My" /> 函数相比，<see langword="ChDir" /> 功能在文件 I/O 操作方面可提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDir`函数会更改默认目录, 但不会更改默认的驱动器。 例如, 如果默认驱动器是 C, 则以下语句将更改驱动器 D 上的默认目录, 但 C 仍是默认驱动器:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 可以通过键入两个句点来进行相对目录更改, 如下所示:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  `ChDir`函数需要非托管代码权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和。  
  
   
  
## Examples  
 此示例使用`ChDir`函数更改当前目录或文件夹。  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> 为空。</exception>
        <exception cref="T:System.IO.FileNotFoundException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">如何：在 Visual Basic 中分析文件路径</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">创建、删除和移动文件和目录 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>更改当前驱动器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">必需。 指定现有驱动器的字符串表达式。 如果提供一个零长度字符串 ("")，则当前驱动器不会更改。 如果 <paramref name="Drive" /> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</param>
        <summary>更改当前驱动器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数更改当前驱动器。 如果驱动器不存在, 该函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">必需。 指定现有驱动器的字符串表达式。 如果提供一个零长度字符串 ("")，则当前驱动器不会更改。 如果 <paramref name="Drive" /> 参数为多字符字符串，<see langword="ChDrive" /> 将仅使用第一个字母。</param>
        <summary>更改当前驱动器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ChDrive`函数需要非托管代码权限, 这可能会影响在部分信任情况下的执行。 有关详细信息, 请<xref:System.Security.Permissions.SecurityPermission>参阅和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
   
  
## Examples  
 此示例使用`ChDrive`函数更改当前驱动器。 如果驱动器不存在, 该函数将引发异常。  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">指定的驱动器无效，或驱动器不可用。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示当前路径的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">可选。 指定现有驱动器的 <see langword="Char" /> 表达式。 如果未指定驱动器或 <paramref name="Drive" /> 是长度为零的字符串 ("")，则 <see langword="CurDir" /> 返回当前驱动器的路径。</param>
        <summary>返回表示当前路径的字符串。 与 <see langword="CurDir" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />。</summary>
        <returns>表示当前路径的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`CurDir`函数返回当前路径。  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 函数支持使用多字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。 `Dir`  
  
 `VbVolume`返回驱动器的卷标, 而不是特定的文件名。  
  
 第一次`Dir`调用`PathName`函数时, 必须提供。 若要检索下一项, 可以对不带参数的`Dir`函数进行后续调用。  
  
> [!IMPORTANT]
>  若要正确运行, `Dir`该函数<xref:System.Security.Permissions.FileIOPermissionAccess.Read>要求将<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>和标志<xref:System.Security.Permissions.FileIOPermission>授予执行代码。 有关详细信息, 请<xref:System.Security.Permissions.FileIOPermission>参阅<xref:System.Security.SecurityException>、和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
  
 `Attributes`参数枚举值如下所示:  
  
|值|返回的常量|说明|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定没有属性的文件。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件以及没有属性的文件。|  
|`Hidden`|`vbHidden`|指定隐藏的文件, 还指定没有属性的文件。|  
|`System`|`vbSystem`|指定系统文件以及没有属性的文件。|  
|`Volume`|`vbVolume`|指定卷标;如果指定任何其他属性, `vbVolume`则将忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹以及没有属性的文件。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举由 Visual Basic 语言指定, 可用于代码中的任何位置, 而不是实际值。  
  
   
  
## Examples  
 此示例使用`Dir`函数检查是否存在特定的文件和目录。  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="PathName">可选。 一个字符串表达式，用于指定文件名、目录或文件夹名或者驱动器卷标。 如果未找到 <paramref name="PathName" />，则返回一个零长度字符串 (<see langword="&quot;&quot;" />)。</param>
        <param name="Pathname">可选。 一个字符串表达式，用于指定文件名、目录或文件夹名或者驱动器卷标。 如果未找到 <paramref name="Pathname" />，则返回一个零长度字符串 (<see langword="&quot;&quot;" />)。</param>
        <param name="Attributes">可选。 其值指定文件特性的枚举或数值表达式。 如果省略，则 <see langword="Dir" /> 将返回与 <paramref name="Pathname" /> 匹配但不具有任何特性的文件。</param>
        <summary>返回表示文件、目录或文件夹名称的字符串，该文件、目录或文件夹具有指定的模式或文件特性，或者具有指定的驱动器卷标。 与 <see langword="Dir" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" />。</summary>
        <returns>一个字符串，表示与指定模式或文件特性匹配的文件、目录或文件夹的名称，或者表示驱动器卷标。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 函数支持使用多字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。 `Dir`  
 `VbVolume`返回驱动器的卷标, 而不是特定的文件名。  
 第一次`Dir`调用`PathName`函数时, 必须提供。 若要检索下一项, 可以对不带参数的`Dir`函数进行后续调用。  
> [!IMPORTANT]
>  若要正确运行, `Dir`该函数<xref:System.Security.Permissions.FileIOPermissionAccess.Read>要求将<xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery>和标志<xref:System.Security.Permissions.FileIOPermission>授予执行代码。 有关详细信息, 请<xref:System.Security.Permissions.FileIOPermission>参阅<xref:System.Security.SecurityException>、和[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)。  
 `Attributes`参数枚举值如下所示:  
|值|返回的常量|说明|  
|-|-|-|  
|`Normal`|`vbnormal`|默认。 指定没有属性的文件。|  
|`ReadOnly`|`vbReadOnly`|指定只读文件以及没有属性的文件。|  
|`Hidden`|`vbHidden`|除了指定没有属性的文件, 还指定隐藏文件。|  
|`System`|`vbSystem`|除了指定没有属性的文件, 还指定系统文件。|  
|`Volume`|`vbVolume`|指定卷标;如果指定任何其他属性, `vbVolume`则将忽略。|  
|`Directory`|`vbDirectory`|指定目录或文件夹, 以及没有属性的文件。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
> [!NOTE]
>  这些枚举由 Visual Basic 语言指定, 并且可以在代码中的任何位置使用来代替实际值。  
## Examples  
 此示例使用`Dir`函数检查是否存在特定的文件和目录。  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 一个包含任何有效文件号的 <see langword="Integer" />。</param>
        <summary>当达到为进行 <see langword="True" /> 或顺序 <see langword="Random" /> 而打开的文件的结尾时，此方法返回布尔值 <see langword="Input" />。</summary>
        <returns>当达到为进行 <see langword="Random" /> 或顺序 <see langword="Input" /> 而打开的文件的结尾时，为布尔值 <see langword="True" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`EOF`可避免由于尝试获取超过文件结尾的输入而生成的错误。  
  
 函数将返回`False` , 直到到达文件末尾。 `EOF` 对于`Random`打开或`Binary`访问的文件, `EOF`返回`False`直到最后执行`FileGet`的函数无法读取整个记录。  
  
 使用打开的文件`Binary`进行访问时, 在返回`True`之前`EOF` , 尝试`Input`使用函数读取文件将生成错误。 `EOF` `Get` `Input`使用和函数(`EOF`而不是读取二进制文件时使用), 或使用函数时使用。 `Loc` `LOF` 对于为打开的`Output`文件`EOF` , 始终`True`返回。  
  
   
  
## Examples  
 此示例使用`EOF`函数来检测文件的结尾。 此示例假设`Testfile`是包含多行文本的文本文件。  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 <see langword="Integer" />。 任何有效文件数。</param>
        <summary>返回一个枚举，该枚举表示使用 <see langword="FileOpen" /> 函数打开的文件的文件模式。 与 <see langword="FileAttr" /> 函数相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>下列枚举值指示文件访问模式： 
 <list type="table"><item><term> 值 
 </term><description> 模式 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数返回一个枚举, 该枚举表示使用`FileOpen`函数打开的文件的文件模式。  
  
   
  
## Examples  
 此示例使用`FileAttr`函数返回打开的文件的文件模式。  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">可选。 要关闭的 0 个或多个信道的参数数组。</param>
        <summary>关闭对用 <see langword="FileOpen" /> 函数打开的文件的输入/输出 (I/O)。 <see langword="My" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`FileClose`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息，请参阅[如何：使用 StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md)从文件读取文本, [如何:使用 StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md)和[演练将文本写入文件:操作 Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md)中的文件和目录。  
  
 如果省略`FileNumbers`, 则`FileOpen`函数打开的所有活动文件都将关闭。  
  
 关闭已为`Output`或`Append`打开的文件时, 最终的输出缓冲区会写入该文件的操作系统缓冲区。 与关闭的文件关联的所有缓冲区空间都将释放。  
  
 `FileClose`执行函数时, 文件与文件编号的关联将结束。  
  
   
  
## Examples  
 此示例使用`FileClose`函数关闭为打开的`Input`文件。  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End 语句</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Stop 语句 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">必需。 指定要复制的文件的名称的字符串表达式。 <paramref name="Source" /> 可以包含源文件的驱动器和目录或文件夹。</param>
        <param name="Destination">必需。 指定目标文件名的字符串表达式。 <paramref name="Destination" /> 可包含目标文件的驱动器和目录或文件夹。</param>
        <summary>复制文件。 与 <see langword="FileCopy" /> 相比，<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> 在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关更多信息，请参见<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果尝试对当前打开的`FileCopy`文件使用函数, 则会发生错误。  
  
 `FileCopy`需要完全信任才能在本地驱动器上工作。  
  
   
  
## Examples  
 此示例使用`FileCopy`函数将一个文件复制到另一个文件。 出于本示例的目的, 假定`SrcFile`是包含数据的文件。  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Source" /> 或 <paramref name="Destination" /> 无效或未指定。</exception>
        <exception cref="T:System.IO.IOException">文件已打开。</exception>
        <exception cref="T:System.IO.FileNotFoundException">文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">如何：在 Visual Basic 中在不同的目录中创建文件的副本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">如何：在同一目录中创建文件副本 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">如何：在 Visual Basic 中将一个目录复制到另一个目录</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必需。 指定一个文件名的字符串表达式。 <paramref name="PathName" /> 可能包括目录或文件夹以及驱动器。</param>
        <summary>返回一个 <see langword="Date" /> 值，该值指示写入文件的日期和时间。 相比 <see langword="FileDateTime" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅<see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns><see langword="Date" /> 值，该值指示文件的创建日期和时间或上次修改日期和时间。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileDateTime`函数来确定文件的创建日期和时间或上次修改日期和时间。 显示的日期和时间的格式基于系统的区域设置。  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="PathName" /> 无效或包含通配符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用`FileGet`读取的数据通常写入到`FilePut`文件中。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用`FileGet`读取的数据通常写入到`FilePut`文件中。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用描述符, 则为。 然后, 传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用`FileGet`读取的数据通常写入到`FilePut`文件中。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用`FileGet`读取的数据通常写入到`FilePut`文件中。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度,`FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否为描述长度的字符串写入一个双字节说明符。 默认值为 <see langword="False" />。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <param name="ArrayIsDynamic">可选。 仅当写入数组时使用。 指定是否将数组视为动态数组，以及是否需要描述数组大小和边界的数组说明符。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否为描述长度的字符串写入一个双字节说明符。 默认值为 <see langword="False" />。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。 相比 <see langword="FileGet" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet`仅在`Random`和`Binary`模式下有效。  
  
 使用读取的`FileGet`数据通常通过使用`FilePut`写入到文件。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则读取最后`FileGet`一个 or `FilePut`函数之后的下一个记录或字节 (或最后一个`Seek`函数指向的)。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGet`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与读取的数据的长度匹配。  
  
-   默认情况下, 如果要读入的变量是字符串, `FileGet`则读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串;放到文件中时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量是数组, 则可以选择是否读取数组的大小和维度的说明符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 读取数组时, 必须匹配数组的写入方式。 如果使用描述符编写, 则必须读取描述符。 如果未使用该说明符, 则传递到`FileGet`的数组的大小和界限确定要读取的内容。  
  
     描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中参数`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218字节分布如下:  
  
    -   描述符的18个字节:(2 + 8 * 2)  
  
    -   数据为200字节:(5 * 10 * 4)。  
  
-   如果要读入的变量是任何其他类型的变量 (不是变长字符串或对象), `FileGet`只会读取变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要读取的数据的长度。 `FileOpen`  
  
-   `FileGet`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePut`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中的`RecordLength`子句指定的记录长度必须大于或等于读取单个元素所需的所有字节之和。 `FileOpen` 这包括任何数组及其说明符。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGet`连续读取磁盘中的所有变量;也就是说, 记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FileGet`只读取数据。 未读取任何说明符。  
  
-   `FileGet`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
    > [!IMPORTANT]
    >  使用`FileGet`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 数据读入到其中的有效变量名称。</param>
        <param name="RecordNumber">可选。 读取的开始位置处的记录号（<see langword="Random" /> 模式文件）或字节数（<see langword="Binary" /> 模式文件）。</param>
        <summary>将数据从打开的磁盘文件读入到一个变量中。  相比 <see langword="FileGetObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` `Long`如果返回类型`Short` `FileGetObject` 而`Object`不是另一种类型 (如、、等),则使用函数而不`Integer`是以避免编译时的歧义。  
  
 如果打算写出`Variant`类型, `FileGetObject`则是必需的。 当不确定时, 如果使用第二个参数的对象, 则始终建议使用`FilePutObject`和。 `FileGetObject`  
  
 `FileGetObject`仅在`Random`和`Binary`模式下有效。  
  
 用读取的`FileGetObject`数据通常用`FilePutObject`来编写。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 `RecordNumber`如果省略`Seek` , `FileGetObject`则读取最后一个`FileGetObject` or `FilePutObject`函数之后 (或由最后一个函数指向) 的记录或字节。  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果读取的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FileGetObject`则读取记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于无法精确确定填充数据量, 因此最好让记录长度与所读取的数据的长度匹配。  
  
-   如果读入的变量是一个字符串, 则默认情况下`FileGetObject`会读取包含字符串长度的双字节说明符, 然后读取进入该变量的数据。 因此, `RecordLength` `FileOpen`函数的子句指定的记录长度必须至少为大于字符串实际长度的两个字节。 Visual Basic 6.0 及更早版本支持固定长度字符串, 读取文件时, 不写入长度说明符。 如果要读取没有说明符的字符串, 应传递`True` `StringIsFixedLength`到参数, 并且读入的字符串应为正确的长度。  
  
-   如果读入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 参数指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:2 + 8 * NumberOfDimensions。  
  
     例如, 当数组写入磁盘时, 以下数组声明需要218字节:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     分发了 218 个字节，如下所示：为描述符分发了 18 个字节 (2 + 8 * 2)，为数据分发了 100 个字节 (5 * 10 * 4)。  
  
-   `FileGetObject`读取结构的元素, 就好像每个元素都是单独读取的, 只不过元素之间没有空白。 在磁盘上, 用户定义类型 (使用`FilePutObject`编写) 中的动态数组以一个描述符为前缀, 其长度等于2再加上维度数的8倍:2 + 8 * NumberOfDimensions。 函数中子句`RecordLength`指定的记录长度必须大于或等于读取单个元素所需的所有字节的总和, 包括任何数组及其说明符。 `FileOpen` <xref:Microsoft.VisualBasic.VBFixedStringAttribute>类可应用于结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 所有`Random`规则均适用, 但有以下例外:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FileGetObject`连续读取磁盘中的所有变量, 即没有记录之间的空白。  
  
-   对于结构中除数组以外的任何数组, `FileGetObject`只读取数据。 未读取任何说明符。  
  
 `FileGetObject`读取长度可变的字符串, 该字符串不是结构的元素, 不需要双字节长度说明符。 读取的字节数等于字符串中的字符数。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
   
  
## Examples  
 下面的示例将记录读入测试文件中, 然后检索该记录。  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必需。 指定一个文件的字符串表达式。 <paramref name="PathName" /> 可能包括目录或文件夹以及驱动器。</param>
        <summary>返回一个值，该值以字节为单位指定文件长度。 相比 <see langword="FileLen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />。</summary>
        <returns>文件的长度（以字节为单位）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用`FileLen`函数时指定的文件处于打开状态, 则返回的值表示文件在打开时的大小。  
  
> [!NOTE]
>  若要获取打开文件的当前长度, 请使用`LOF`函数。  
  
   
  
## Examples  
 此示例使用`FileLen`函数返回文件的长度 (以字节为单位)。 出于本示例的目的, 假定`TestFile`是包含一些数据的文件。  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。 可使用 <see langword="FreeFile" /> 函数获取下一个可用的文件号。</param>
        <param name="FileName">必需。 一个指定文件名的字符串表达式，其中可包含目录或文件夹以及驱动器。</param>
        <param name="Mode">必需。 指定文件模式的枚举：<see langword="Append" />、<see langword="Binary" />、<see langword="Input" />、<see langword="Output" /> 或 <see langword="Random" />。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.OpenMode" />。</param>
        <param name="Access">可选。 一个枚举，它指定对打开的文件所允许进行的操作：<see langword="Read" />、<see langword="Write" /> 或 <see langword="ReadWrite" />。 默认为 <see langword="ReadWrite" />。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.OpenAccess" />。</param>
        <param name="Share">可选。 一个枚举，它指定不允许其他进程对打开的文件所进行的操作：<see langword="Shared" />、<see langword="Lock Read" />、<see langword="Lock Write" /> 和 <see langword="Lock Read Write" />。 默认为 <see langword="Lock Read Write" />。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.OpenShare" />。</param>
        <param name="RecordLength">可选。 小于或等于 32,767（字节）的数字。 对于为进行随机访问而打开的文件，此值是记录的长度。 对于顺序文件，此值是缓冲的字符数。</param>
        <summary>打开一个文件以进行输入或输出。 相比 <see langword="FileOpen" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`FileOpen`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 必须先打开文件, 然后才能对其执行任何 i/o 操作。 `FileOpen`为文件的 i/o 分配一个缓冲区, 并确定与该缓冲区一起使用的访问模式。  
  
> [!IMPORTANT]
>  写入文件时, 如果尝试写入文件的文件不存在, 则应用程序可能需要创建一个文件。 为此, 需要对要在其中创建文件的目录具有权限。 但是, 如果由`FileName`指定的文件存在, 则应用程序只需要`Write`文件本身的权限。 如果可能, 在部署过程中创建文件并仅授予`Write`对该文件的权限 (而不是整个目录), 以帮助提高安全性。 为了帮助提高安全性, 请将数据写入用户目录, 而不是写入到根目录或 Program Files 目录。  
  
 可以通过使用`FreeFile()`函数找到要打开的通道。  
  
> [!IMPORTANT]
>  函数需要`Read` 从`FileIOPermissionAccess`枚举访问, 这可能会影响在部分信任情况下的执行。 `FileOpen` 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例演示了如何使用`FileOpen`函数来启用文件的输入和输出。  
  
 下面的代码在`TestFile` `Input`模式下打开文件。  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 此示例将在模式中`Binary`打开文件, 仅用于写入操作。  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 下面的示例在`Random`模式下打开文件。 文件包含结构`Person`的记录。  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 此代码示例在`Output`模式下打开文件; 任何进程都可以读取或写入文件。  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 此代码示例在`Binary`读取模式下打开文件; 其他进程无法读取文件。  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">记录长度是负数（并且不等于 -1）。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileName" /> 已经打开，或 <paramref name="FileName" /> 无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关更多信息，请参见 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FilePut(System::Object ^ FileNumber, System::Object ^ Value, System::Object ^ RecordNumber);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否将字符串的双字节字符串长度说明符写入文件中。 默认值为 <see langword="False" />。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <param name="ArrayIsDynamic">可选。 仅当写入数组时使用。 指定是否将数组视为动态数组，以及是否写入用于描述字符串长度的数组说明符。</param>
        <param name="StringIsFixedLength">可选。 仅在写入字符串时适用。 指定是否将字符串的双字节字符串长度说明符写入文件中。 默认值为 <see langword="False" />。</param>
        <summary>将变量中得数据写入磁盘文件中。 相比 <see langword="FilePut" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGet` 从文件中读取使用 `FilePut` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 如果省略`RecordNumber`, 则写入最后一个`FileGet`或`FilePut`函数后面或最后`Seek`一个函数指向的下一个记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePut`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGet`使用, 则必须使用来执行相同操作, 并且必须确保将字符串初始化为预期的长度。 `FilePut`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePut`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能确定填充数据量, 因此通常最好让记录长度与要写入的数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则将引发异常。  
  
-   如果写入的变量是字符串, `FilePut`则写入包含字符串长度的双字节说明符, 然后写入该变量中的数据。 因此, `RecordLength` `FileOpen`函数中子句指定的记录长度必须至少为两个字节, 大于字符串的实际长度。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePut`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePut`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果要写入的变量是包含字符串`FilePut`的对象, 则写入一个两个字节说明符, 该说明符`VarType(8)`标识对象的, 一个双字节说明符, 指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果要写入的变量是数组, 则可以选择是否为数组的大小和维度编写说明符。 Visual Basic 6.0 及更早版本写入动态数组的文件描述符, 但不写入固定大小的数组。 Visual Basic 2005 默认为不写入描述符。 若要编写描述符, 请将`ArrayIsDynamic`参数设置`True`为。 写入数组时, 必须匹配读取数组的方式;如果它将使用描述符读取, 则必须编写描述符。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。 函数中子句`RecordLength`指定的记录长度必须大于或等于写入数组数据和数组描述符所需的所有字节之和。 `FileOpen` 例如, 当数组写入磁盘时, 以下数组声明需要218字节。  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   如果写入的变量是任何其他类型的变量 (不是变长字符串或对象), `FilePut`则只写入变量数据。 函数中子句`RecordLength`指定的记录长度必须大于或等于要写入的数据的长度。 `FileOpen`  
  
-   `FilePut`编写结构的元素, 就好像每个元素都是单独编写的, 只不过元素之间没有空白。 `VBFixedString`特性可应用到结构中的字符串字段, 以指示写入磁盘时字符串的大小。  
  
    > [!NOTE]
    >  写入磁盘时, 具有超过`VBFixedString`特性指定的字节数的字符串字段将被截断。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, 大部分`Random`模式规则均适用, 但有一些例外情况。 在`Binary`模式下打开的文件的以下规则不同于`Random`模式的规则:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePut`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
-   对于结构中除数组以外的任何数组, `FilePut`只写入数据。 不写入任何说明符。  
  
-   `FilePut`写入不包含双字节长度说明符的结构元素的可变长度字符串。 写入的字节数等于字符串中的字符数。 例如, 下面的语句将11个字节写入第1个文件:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   使用`FilePut`函数写入文件需要`Write`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`FilePut`函数将数据写入文件。 将结构`Person`的五个记录写入文件。  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="RecordNumber" /> &lt; 1 且不等于 -1。</exception>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 有效变量名，它包含写入磁盘的数据。</param>
        <param name="RecordNumber">可选。 开始写入处的记录号（<see langword="Random" /> 模式文件）或字节号（<see langword="Binary" /> 模式文件）。</param>
        <summary>将变量中得数据写入磁盘文件中。  相比 <see langword="FilePutObject" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` `Long`如果传递类型`Short` `FilePutObject` 而`Object`不是另一种类型 (如、、等),则使用函数而不`Integer`是来避免编译时出现歧义。  
  
 `FilePutObject`写入和读取描述对象的描述符。 如果打算写出`Variant`类型, `FilePutObject`则是必需的。 当不确定时, 如果使用第二个参数的对象, 我们建议始终使用`FilePutObject`和。 `FileGetObject`  
  
 `FilePutObject`仅在`Random`和`Binary`模式下有效。  
  
 通常使用 `FileGetObject` 从文件中读取使用 `FilePutObject` 编写的数据。  
  
 文件中的第一个记录或字节位于位置 1, 第二个记录或字节在位置 2, 依此类推。 `RecordNumber`如果省略`Seek` , `FilePutObject`则在最后`FileGetObject`一个或`FilePutObject`函数 (或最后一个函数指向的记录或字节) 后写入下一条记录或字节。  
  
 `StringIsFixedLength`参数控制函数是将字符串解释为变量还是固定长度。 `FilePutObject`当参数为`True`时, 不写入长度说明符。 如果将与`StringIsFixedLength`结合`True`  =  `FileGetObject`使用, 则必须使用来执行相同操作, 并且还必须确保将字符串初始化为预期的长度。 `FilePutObject`  
  
## <a name="random-mode"></a>随机模式  
 对于以`Random`模式打开的文件, 以下规则适用:  
  
-   如果写入的数据的长度小于`RecordLength` `FileOpen`函数的子句中指定的长度, `FilePutObject`则写入记录长度边界的后续记录。 一条记录的末尾和下一条记录的开头之间的空格将填充到文件缓冲区的现有内容中。 由于不能准确确定填充数据量, 因此最好将记录长度与所写入数据的长度匹配。 如果写入的数据的长度大于`RecordLength` `FileOpen`函数的子句中指定的长度, 则会引发异常。  
  
-   如果写入的变量是包含数值类型的对象, 则会写入`FilePutObject`两个字节, `VarType`用于标识对象的, 然后写入变量。 例如, 在编写包含整数的对象时, `FilePutObject`将写入六个字节: 两个字节, 用于标识作为`VarType(3)` (`Integer`) 的对象和包含数据的四个字节。 函数中参数`RecordLength`指定的记录长度必须至少为两个字节, 大于存储变量所需的实际字节数。 `FileOpen`  
  
-   如果写入的变量是包含字符串`FilePutObject`的对象, 则写入一个双字节说明符, 该说明符`VarType(8)`标识对象的, 两个字节的说明符指示字符串的长度, 然后写入字符串数据。 函数中参数`RecordLength`指定的记录长度必须至少为4个字节, 大于字符串的实际长度。 `FileOpen` 如果要在不包含说明符的情况下放置字符串, 则应`True`将传递`StringIsFixedLength`给参数, 并且读入的字符串应为正确的长度。  
  
-   如果写入的变量为数组，则 `RecordLength` 函数中 `FileOpen` 子句指定的记录长度必须大于或等于写入数组数据和数组描述符需要的所有字节之和。 描述符指定数组的秩、大小和每个排名的下限。 其长度等于2再加上维度数的8倍:(2 + 8 * NumberOfDimensions)。  
  
## <a name="binary-mode"></a>二进制模式  
 对于以`Binary`模式打开的文件, `Random`所有模式规则均适用, 但以下情况除外:  
  
-   函数中的`RecordLength`子句无效。 `FileOpen` `FilePutObject`连续将所有变量写入磁盘, 也就是说, 在记录之间不进行填充。  
  
   
  
## Examples  
 此示例使用`FilePutObject`函数将字符串写入文件。  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="RecordWidth">必需。 0 到 255（包括 0 和 255）范围内的数值表达式，它表示在开始新一行前每一行中所显示的字符数。 如果 <paramref name="RecordWidth" /> 等于 0，则行的长度没有限制。 <paramref name="RecordWidth" /> 的默认值为 0。</param>
        <summary>为用 <see langword="FileOpen" /> 函数打开的文件分配输出行宽。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 此示例使用`FileWidth`函数设置文件的输出行宽度。  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个 <see langword="Integer" /> 值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</summary>
        <returns>一个整数值，该值表示 <see langword="FileOpen" /> 函数可用的下一个文件号。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用`FreeFile`可提供尚未使用的文件号。  
  
   
  
## Examples  
 此示例使用`FreeFile`函数返回下一个可用的文件号。 为循环内的输出打开5个文件, 并将一些示例数据写入每个文件。  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">正在使用的文件数超过 255。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必需。 指定一个文件名、目录名或文件夹名的字符串表达式。 <paramref name="PathName" /> 可以包含驱动器和目录或文件夹。</param>
        <summary>返回一个表示文件、目录或文件夹的特性的 <see langword="FileAttribute" /> 值。 相比 <see langword="FileAttribute" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>枚举值的按位组合。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定设置了哪些特性, 请`And`使用运算符来执行`GetAttr`函数返回的值的按位比较以及所需的单个文件特性的值。 如果结果不为零, 则为命名文件设置该属性。 例如, 如果未设置该`And` `Archive`属性, 则以下表达式的返回值为零:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 如果设置了`Archive`属性, 则返回一个非零值。  
  
   
  
## Examples  
 此示例使用`GetAttr`函数来确定文件和目录或文件夹的属性。  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="Pathname" /> 无效或包含通配符。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">And 运算符 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其写入了一些数据行, 每行包含一个引号中的字符串和一个逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其写入了一些数据行, 每行包含一个引号中的字符串和一个逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入 14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Value">必需。 被赋以从文件中读取的值的变量不能是数组或对象变量。</param>
        <summary>读取打开的顺序文件中的数据，并将这些数据赋值给变量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Input`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`Input`数据通常通过使用`Write`写入到文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
> [!IMPORTANT]
>  在从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 2005 的源文件。  
  
 在读取时, 不修改标准字符串或数值数据, 而是将其分配给变量。 下表说明了如何处理其他输入数据。  
  
|数据|赋给变量的值|  
|-|-|  
|分隔逗号或空白行|空|  
|#NULL#|`DBNull`|  
|#TRUE # 或 #FALSE#|`True` 或 `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|表达式所表示的日期和/或时间|  
|#ERROR`errornumber`#|`errornumber`(变量是标记为错误的对象)|  
  
 如果在您输入数据项时到达该文件的末尾, 则输入将停止并发生错误。  
  
> [!NOTE]
>  `Input`函数未本地化。 例如, 在德语版本中, 如果输入3、14159, 则它仅返回 3, 因为逗号被视为变量分隔符, 而不是小数点。  
  
> [!IMPORTANT]
>  使用`Input`函数从文件读取需要`Read`从`FileIOPermissionAccess`枚举访问。 有关详细信息，请参阅 <xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Input`函数将文件中的数据读入两个变量中。 此示例假定`TestFile`是一个文件, 它`Write`使用函数向其中写入多行数据, 每行包含一个用引号表示的字符串和一个用逗号分隔的数字, 例如: ("Hello", 234)。  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="CharCount">必需。 用于指定要读取的字符数的任何有效数值表达式。</param>
        <summary>返回 <see langword="String" /> 值，该值包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。 相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>一个字符串，该字符串包含以 <see langword="Input" /> 或 <see langword="Binary" /> 模式打开的文件中的字符。 相比 <see langword="InputString" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`InputString`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用`InputString`函数读取的数据通常使用`Print`或`FilePut`写入文件。 仅将此函数用于以`Input`或`Binary`模式打开的文件。  
  
 与函数不同`InputString` , 函数返回它读取的所有字符。 `Input` 这包括逗号、回车符、换行符、引号和前导空格。  
  
 使用打开的文件`Binary`进行访问时, 在返回`True`之前`EOF` , 尝试`InputString`使用函数读取文件将生成错误。 `EOF` `InputString` `FileGet` `EOF`使用和函数`Loc` (而不是) 通过使用读取二进制文件时使用, 或使用函数时使用。 `LOF`  
  
> [!NOTE]
>  在从文件中读取时, 不要根据文件扩展名对文件内容做出安全决策。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
   
  
## Examples  
 此示例使用`InputString`函数从文件中一次读取一个字符, 然后将其打印`Output`到窗口中。 此示例假设`MyFile`是包含多行示例数据的文本文件。  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> 不存在。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="CharCount" />&lt; 0 或 &gt; 214。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">必需。 指定要删除的一个或多个文件名的字符串表达式。 <paramref name="PathName" /> 可以包含驱动器和目录或文件夹。</param>
        <summary>从磁盘中删除文件。 相比 <see langword="Kill" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关更多信息，请参见<see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill`支持使用多字符 (`*`) 和单字符 (`?`) 通配符来指定多个文件。  
  
 **安全说明**若要`Kill`执行, 该函数需要`Read`和`PathDiscovery`的<xref:System.Security.Permissions.FileIOPermission>标志才能向执行代码授予。 有关详细信息, 请<xref:System.Security.SecurityException>参阅[代码访问权限](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 此示例使用`Kill`函数从磁盘中删除文件。  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">目标文件打开。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目标文件未找到。</exception>
        <exception cref="T:System.Security.SecurityException">权限被拒绝。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <summary>从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</summary>
        <returns>从打开的顺序文件中读取一行并将其赋值给一个 <see langword="String" /> 变量。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`LineInput`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 使用读取的`LineInput`数据通常通过使用`Print`写入到文件。  
  
> [!IMPORTANT]
>  从文件中读取时, 请不要根据文件扩展名来决定文件的内容。 例如, 名为 "Form1" 的文件可能不是 Visual Basic 的源文件。  
  
 函数每次从一个文件读取一个字符, 直到它遇到回车符 (`Chr(13)`) 或回车符/换行符 (`Chr(13) + Chr(10)`) 序列。 `LineInput` 将跳过回车符/换行符, 而不是追加到字符串。  
  
> [!IMPORTANT]
>  使用`LineInput`函数从文件读取需要`Read`从<xref:System.Security.Permissions.FileIOPermissionAccess>枚举访问。  
  
   
  
## Examples  
 此示例使用`LineInput`函数从顺序文件中读取一行, 并将其分配给变量。 此示例假设`TestFile`是包含多行示例数据的文本文件。  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">到达文件末尾。</exception>
        <exception cref="T:System.IO.IOException"><paramref name="FileNumber" /> 不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效的 <see langword="Integer" /> 文件号。</param>
        <summary>返回指定打开文件中当前读/写位置的值。</summary>
        <returns>打开文件中当前读/写位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Loc`函数从零开始; 使用它检索文件中的第一个字节时, 将返回0。  
  
 提供`Loc`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 下面说明了每个文件访问模式的返回值:  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入文件的最后一条记录的编号。|  
|`Sequential`|文件中的当前字节位置除以128。 但是, 不使用也`Loc`不需要为顺序文件返回的信息。|  
|`Binary`|上次读取或写入字节的位置。|  
  
   
  
## Examples  
 此示例使用`Loc`函数返回打开的文件中的当前读/写位置。 此示例假设`MyFile`是包含多行示例数据的文本文件。  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 和`Unlock`函数在多个进程可能需要访问同一文件的环境中使用。  
  
 `Lock`和`Unlock`函数始终成对使用。 `Lock` 和`Unlock`的参数必须完全相同。  
  
 如果`Record`未提供`FromRecord` 、 `ToRecord`或且未提供, 则将为整个文件锁定。 如果`Record`单独指定, 则将锁定/解锁单个记录。  
  
 如果文件已打开以进行顺序`Lock`输入或输出, `Unlock`则会影响整个文件, 而不考虑`FromRecord`和`ToRecord`指定的范围。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含结构`Person`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Record">可选。 唯一要锁定或取消锁定的记录号或字节数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 和`Unlock`函数在多个进程可能需要访问同一文件的环境中使用。  
  
 `Lock`和`Unlock`函数始终成对使用。 `Lock` 和`Unlock`的参数必须完全相同。  
  
 如果`Record`未提供`FromRecord` 、 `ToRecord`或且未提供, 则将为整个文件锁定。 如果`Record`单独指定, 则将锁定/解锁单个记录。  
  
 如果文件已打开以进行顺序`Lock`输入或输出, `Unlock`则会影响整个文件, 而不考虑`FromRecord`和`ToRecord`指定的范围。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含结构`Person`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="FromRecord">可选。 第一个要锁定或取消锁定的记录号或字节数。</param>
        <param name="ToRecord">可选。 最后一个要锁定或取消锁定的记录号或字节数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 和`Unlock`函数在多个进程可能需要访问同一文件的环境中使用。  
  
 `Lock`和`Unlock`函数始终成对使用。 `Lock` 和`Unlock`的参数必须完全相同。  
  
 如果`Record`未提供`FromRecord` 、 `ToRecord`或且未提供, 则将为整个文件锁定。 如果`Record`单独指定, 则将锁定/解锁单个记录。  
  
 如果文件已打开以进行顺序`Lock`输入或输出, `Unlock`则会影响整个文件, 而不考虑`FromRecord`和`ToRecord`指定的范围。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含结构`Person`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 一个包含有效文件号的整数。</param>
        <summary>返回使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。 相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>使用 <see langword="FileOpen" /> 函数打开的文件的大小（以字节为单位）。 相比 <see langword="LOF" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileLen`使用函数可获取未打开的文件的长度。  
  
   
  
## Examples  
 此示例使用`LOF`函数来确定打开的文件的大小。 此示例假设`TestFile`是包含示例数据的文本文件。  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必需。 标识要创建的目录的字符串表达式。 <paramref name="Path" /> 可以包含驱动器。 如果未指定驱动器，则 <see langword="MkDir" /> 在当前驱动器上创建新目录。</param>
        <summary>新建目录。 相比 <see langword="MkDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此函数创建一个新目录。  
  
   
  
## Examples  
 此示例使用`MkDir`函数来创建目录。 如果未指定驱动器, 则将在当前驱动器上创建新目录。  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> 未指定或为空。</exception>
        <exception cref="T:System.Security.SecurityException">权限被拒绝。</exception>
        <exception cref="T:System.IO.IOException">目录已存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">如何：在 Visual Basic 中创建目录</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Output">可选。 要写入文件的零个或多个由逗号分隔的表达式。  
  
<paramref name="Output" /> 参数的设置是： 
 <see langword="T:System.IO.IOException" />：文件模式无效。  
  
 <see langword="T:System.IO.IOException" />：<paramref name="FileNumber" /> 不存在。</param>
        <summary>将已设置显示格式的数据写入顺序文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Print` 和`PrintLine`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print`不在行尾包含换行符;不过, `PrintLine`确实包含换行。  
  
 通常使用`Print` `LineInput`或从文件中读取使用编写的数据。`Input`  
  
 如果省略`Output`了`PrintLine`, 则会在文件中打印空白行; 对于`Print`, 不会输出任何内容。 用逗号分隔的多个表达式将在制表符边界上对齐, 但混合使用`TAB`逗号, 可能导致不一致的结果。  
  
 对于`Boolean`数据, 可以`True`是`False`或。 不会`False`转换和关键字,无论区域设置如何。`True`  
  
 使用系统识别的标准短日期格式将日期数据写入文件。 当日期或时间部分缺失或为零时, 只将提供的部分写入文件中。  
  
 如果`Output`数据为空, 则不向文件写入任何内容。 但是, 如果`Output`列表数据为`DBNull`, `Null`将写入文件。  
  
 对于`Error`数据, 输出显示为`Error errorcode`。 无论区域设置如何, 都不会转换关键字。`Error`  
  
 使用`Print`写入到文件中的所有数据都是可以识别的, 也就是说, 使用适当的小数点分隔符正确设置数据的格式。 如果用户希望输出由多个区域设置使用的数据, `Write`则应使用。  
  
 使用`Print`或`PrintLine` 函数写入`Write`文件需要枚举中`FileIOPermissionAccess`的访问权限。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数将数据写入文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Output">可选。 要写入文件的零个或多个由逗号分隔的表达式。  
  
<paramref name="Output" /> 参数的设置是： 
 <see langword="T:System.IO.IOException" />：文件模式无效。  
  
 <see langword="T:System.IO.IOException" />：<paramref name="FileNumber" /> 不存在。</param>
        <summary>将已设置显示格式的数据写入顺序文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Print` 和`PrintLine`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 `Print`不在行尾包含换行符;不过,`PrintLine`确实包含换行。  
  
 通常使用`Print` `LineInput`或从文件中读取使用编写的数据。`Input`  
  
 如果省略`Output`了`PrintLine`, 则会在文件中打印空白行; 对于`Print`, 不会输出任何内容。 用逗号分隔的多个表达式将在制表符边界上对齐, 但混合使用`TAB`逗号, 可能导致不一致的结果。  
  
 对于`Boolean`数据, 可以`True`是`False`或。 不会`False`转换和关键字,无论区域设置如何。`True`  
  
 使用系统识别的标准短日期格式将日期数据写入文件。 当日期或时间部分缺失或为零时, 只将提供的部分写入文件中。  
  
 如果`Output`数据为空, 则不向文件写入任何内容。 但是, 如果`Output`列表数据为`DBNull`, `Null`将写入文件。  
  
 对于`Error`数据, 输出显示为`Error errorcode`。 无论区域设置如何, 都不会转换关键字。`Error`  
  
 使用`Print`写入到文件中的所有数据都是可以识别的, 也就是说, 使用适当的小数点分隔符正确设置数据的格式。 如果用户希望输出由多个区域设置使用的数据, `Write`则应使用。  
  
 使用`Print`或`PrintLine` 函数写入`Write`文件需要枚举中`FileIOPermissionAccess`的访问权限。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Print`和`PrintLine`函数将数据写入文件。  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">必需。 指定现有文件名和位置的字符串表达式。 <paramref name="OldPath" /> 可包含文件的目录和驱动器。</param>
        <param name="NewPath">必需。 指定新文件名和位置的字符串表达式。 <paramref name="NewPath" /> 可包含目标位置的目录和驱动器。 <paramref name="NewPath" /> 指定的文件名不能是已存在的文件名。</param>
        <summary>重命名磁盘文件或目录。 相比 <see langword="Rename" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要, 函数将重命名文件并将其移动到不同的目录。`Rename` 函数可以跨驱动器移动文件, 但它只能在`NewPath`和`OldPath`位于同一驱动器上时重命名现有的目录。 `Rename` `Rename`无法创建新的文件或目录。  
  
 对打开的文件使用函数会产生错误。`Rename` 在重命名之前, 必须先关闭打开的文件。 `Rename`参数不能包含多字符 (*) 和单字符 (？) 通配符。  
  
> [!IMPORTANT]
>  当使用`Rename`将不受保护的位置中的文件复制到受保护的位置时, 该文件将保留有限的权限。 请检查以确保未引入可能的安全风险。  
  
   
  
## Examples  
 此示例使用`Rename`函数重命名文件。 出于本示例的目的, 假定指定的目录已存在。  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">路径无效。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="OldPath" /> 文件不存在。</exception>
        <exception cref="T:System.IO.IOException">无法重命名为不同的设备。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">如何：在 Visual Basic 中重命名文件</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭所有使用 <see langword="FileOpen" /> 函数打开的磁盘文件。 相比 <see langword="Reset" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 函数`Reset`将关闭该`FileOpen`函数打开的所有活动文件, 并且该函数与`FileClose()`不带任何参数的函数相同。  
  
   
  
## Examples  
 此示例使用`Reset`函数关闭所有打开的文件, 并将所有文件缓冲区的内容写入磁盘。 请注意, 使用`Object`变量`FileNumber`作为字符串和数字。  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">End 语句</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">必需。 标识要移除的目录或文件夹的字符串表达式。 <paramref name="Path" /> 可以包含驱动器。 如果未指定驱动器，则 <see langword="RmDir" /> 移除当前驱动器上的目录。</param>
        <summary>移除现有目录。 相比 <see langword="RmDir" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果尝试对包含文件的目录使用`RmDir` , 则会出现错误。 在尝试删除目录之前, 请使用函数删除所有文件。`Kill`  
  
   
  
## Examples  
 此示例使用`RmDir`函数来删除现有目录。  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Path" /> 未指定或为空。</exception>
        <exception cref="T:System.IO.IOException">目标目录包含文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">目录不存在。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <returns>一个 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`返回一个介于1和 2147483647 (相当于 2 ^ 31-1) (含) 之间的值。  
  
 下面说明了每个文件访问模式的返回值:  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一个记录的编号|  
|`Binary`, `Input`, `Output`, `Append`|发生下一操作的字节位置。 文件中的第一个字节的位置为 1, 第二个字节在位置 2, 依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数返回当前文件位置。 该示例假设`TestFile`是包含结构`Record`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 对于以`Random`模式打开的文件`Seek` , 返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 对于以`Random`模式之外的模式打开的文件`Seek` , 返回发生下一操作的字节位置。 假设`TestFile`是包含多行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数来设置文件中下一次读取或写入的位置。  
  
 对于以`Random`模式之外的模式打开的文件`Seek` , 将设置下一操作发生的字节位置。 假设`TestFile`是包含多行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 一个包含有效文件号的 <see langword="Integer" />。</param>
        <param name="Position">必需。 一个 1 到 2,147,483,647 范围内（包括 1 和 2,147,483,647）的数字，用于指示下一个读取/写入操作应该发生的位置。</param>
        <summary>返回 <see langword="Long" />，它指定使用 <see langword="FileOpen" /> 函数打开的文件中的当前读/写位置；或设置使用 <see langword="FileOpen" /> 函数打开的文件中的下一个读/写操作的位置。 相比 <see langword="Seek" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek`返回一个介于1和 2147483647 (相当于 2 ^ 31-1) (含) 之间的值。  
  
 下面说明了每个文件访问模式的返回值:  
  
|模式|返回值|  
|-|-|  
|`Random`|读取或写入的下一个记录的编号|  
|`Binary`, `Input`, `Output`, `Append`|发生下一操作的字节位置。 文件中的第一个字节的位置为 1, 第二个字节在位置 2, 依此类推。|  
  
   
  
## Examples  
 此示例使用`Seek`函数返回当前文件位置。 该示例假设`TestFile`是包含结构`Record`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 对于以`Random`模式打开的文件`Seek` , 返回下一条记录的数目。  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 对于以`Random`模式之外的模式打开的文件`Seek` , 返回发生下一操作的字节位置。 假设`TestFile`是包含多行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 此示例使用`Seek`函数来设置文件中下一次读取或写入的位置。  
  
 对于以`Random`模式之外的模式打开的文件`Seek` , 将设置下一操作发生的字节位置。 假设`TestFile`是包含多行文本的文件。  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">从文件读取 (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">写入文件 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">必需。 指定一个文件名的字符串表达式。 <paramref name="PathName" /> 可以包含驱动器和目录或文件夹。</param>
        <param name="Attributes">必需。 常量或数值表达式，所有这些值一起指定文件特性。</param>
        <summary>设置文件的特性信息。 相比 <see langword="SetAttr" />，<see langword="My" /> 功能可使文件 I/O 操作的效率更高、性能更好。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果尝试设置打开的文件的属性, 则会发生运行时错误。  
  
 `Attributes`参数枚举值如下所示:  
  
|值|返回的常量|说明|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (默认值)。|  
|`ReadOnly`|`vbReadOnly`|只读。|  
|`Hidden`|`vbHidden`|隐藏。|  
|`System`|`vbSystem`|系统文件。|  
|`Volume`|`vbVolume`|卷标|  
|`Directory`|`vbDirectory`|目录或文件夹。|  
|`Archive`|`vbArchive`|文件自上次备份后已更改。|  
|`Alias`|`vbAlias`|文件具有不同的名称。|  
  
> [!NOTE]
>  这些枚举是由 Visual Basic 语言指定的。 可以在代码中的任何位置使用这些名称, 而不是实际值。  
  
   
  
## Examples  
 此示例使用`SetAttr`函数为文件设置属性。  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Attribute" /> 类型无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">必需。 在显示或输出列表中下一个表达式之前要插入的空格数。</param>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`Count`小于输出行宽度, 则下一个打印位置紧跟打印的空格数。 如果`Count`大于输出行宽度, `SPC`则使用公式计算下一个打印位置:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 例如, 如果当前打印位置为 24, 则输出行宽度为 80, 并且您指定`SPC(90)`, 下一次打印将从位置 34 (当前打印位置 + 90/80 的余数) 开始。 如果当前打印位置与输出行宽度`Count`之间的差异小于 (或 `SPC` `Count` `Mod`宽度), 则函数将跳到下一行的开头, 并生成等于`Count`的空格-(*width* - *currentprintposition*)。  
  
> [!NOTE]
>  请确保表格列宽度足以允许宽信。  
  
   
  
## Examples  
 此示例使用`SPC`函数将输出定位于文件和**输出**窗口中。  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 运算符 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前行`Column`上的当前打印位置大于, `TAB`则跳到下一个输出行`Column`的列值等于。 如果`Column`小于 1, `TAB`则将打印位置移动到第1列。 如果`Column`大于输出行宽度, `TAB`则使用公式计算下一个打印位置:  
  
 列 Mod 宽度  
  
 例如, 如果*width*为 80, 并且您指定`TAB(90)`了, 则下一次打印将从第10列 (90/80 的余数) 开始。 如果`Column`小于当前打印位置, 则打印将从计算的打印位置的下一行开始。 如果计算出的打印位置大于当前打印位置, 则打印在同一行的计算打印位置处开始打印。  
  
 输出行上最左侧的打印位置始终为1。 使用`Print` `FileWidth`或`PrintLine`函数打印到文件时, 最右侧的打印位置是输出文件的当前宽度, 可以使用函数进行设置。  
  
 函数还可用于`WriteLine`函数。 `TAB` 它不能与<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>一起使用。  
  
> [!NOTE]
>  请确保表格列的宽度足以容纳宽信。  
  
   
  
## Examples  
 此示例使用`TAB`函数将输出定位于文件和**输出**窗口中。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 运算符 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">可选。 在显示或输出列表中下一个表达式之前要移动到的列号。 如果省略它，则 <see langword="TAB" /> 将插入点移动到下一个打印区域的开始位置。</param>
        <summary>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</summary>
        <returns>与 <see langword="Print" /> 或 <see langword="PrintLine" /> 函数一起使用以定位输出。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前行上的当前打印位置大于`Column`, `TAB`则跳到下一个输出行`Column`的列值等于。 如果`Column`小于 1, `TAB`则将打印位置移动到第1列。 如果`Column`大于输出行宽度, `TAB`则使用公式计算下一个打印位置:  
  
 列 Mod 宽度  
  
 例如, 如果*width*为 80, 并且您指定`TAB(90)`了, 则下一次打印将从第10列 (90/80 的余数) 开始。 如果`Column`小于当前打印位置, 则打印将从计算的打印位置的下一行开始。 如果计算出的打印位置大于当前打印位置, 则打印在同一行的计算打印位置处开始打印。  
  
 输出行上最左侧的打印位置始终为1。 使用`Print` `FileWidth`或`PrintLine`函数打印到文件时, 最右侧的打印位置是输出文件的当前宽度, 可以使用函数进行设置。  
  
 函数还可用于`WriteLine`函数。 `TAB` 它不能与<xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType>或<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>一起使用。  
  
> [!NOTE]
>  请确保表格列的宽度足以容纳宽信。  
  
   
  
## Examples  
 此示例使用`TAB`函数将输出定位于文件和**输出**窗口中。  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Mod 运算符 (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 和`Unlock`函数在多个进程可能需要访问同一文件的环境中使用。  
  
 `Lock`和`Unlock`函数始终成对使用。 `Lock` 和`Unlock`的参数必须完全相同。  
  
 如果`Record`未提供`FromRecord` 、 `ToRecord`或且未提供, 则将为整个文件锁定。 如果`Record`单独指定, 则将锁定/解锁单个记录。  
  
 如果文件已打开以进行顺序`Lock`输入或输出, `Unlock`则会影响整个文件, 而不考虑`FromRecord`和`ToRecord`指定的范围。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含结构`Person`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="Record">可选。 唯一要锁定或取消锁定的记录号或字节数</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 和`Unlock`函数在多个进程可能需要访问同一文件的环境中使用。  
  
 `Lock`和`Unlock`函数始终成对使用。 `Lock` 和`Unlock`的参数必须完全相同。  
  
 如果`Record`未提供`FromRecord` 、 `ToRecord`或且未提供, 则将为整个文件锁定。 如果`Record`单独指定, 则将锁定/解锁单个记录。  
  
 如果文件已打开以进行顺序`Lock`输入或输出, `Unlock`则会影响整个文件, 而不考虑`FromRecord`和`ToRecord`指定的范围。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含结构`Person`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 任何有效文件数。</param>
        <param name="FromRecord">可选。 第一个要锁定或取消锁定的记录号或字节数。</param>
        <param name="ToRecord">可选。 最后一个要锁定或取消锁定的记录号或字节数。</param>
        <summary>控制其他进程对使用 <see langword="Open" /> 函数打开的文件的全部或部分的访问。 与 <see langword="My" /> 和 <see langword="Lock" /> 相比，<see langword="Unlock" /> 功能在文件 I/O 操作方面可为您提供更高的效率和更好的性能。 有关详细信息，请参阅 <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Lock` 和`Unlock`函数在多个进程可能需要访问同一文件的环境中使用。  
  
 `Lock`和`Unlock`函数始终成对使用。 `Lock` 和`Unlock`的参数必须完全相同。  
  
 如果`Record`未提供`FromRecord` 、 `ToRecord`或且未提供, 则将为整个文件锁定。 如果`Record`单独指定, 则将锁定/解锁单个记录。  
  
 如果文件已打开以进行顺序`Lock`输入或输出, `Unlock`则会影响整个文件, 而不考虑`FromRecord`和`ToRecord`指定的范围。  
  
   
  
## Examples  
 此示例演示如何使用`Lock`和`Unlock`函数。 此示例假定`People.txt`是包含结构`Person`的记录的文件。  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 包含任何有效文件数的 <see langword="Integer" /> 表达式。</param>
        <param name="Output">可选。 要写入文件的一个或多个由逗号分隔的表达式。</param>
        <summary>将数据写入一个顺序文件。 通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Write` 和`WriteLine`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`, 则会在文件中打印一个空行。 多个表达式可以用逗号分隔。  
  
 与函数不同, 函数`Write`在写入到文件中时, 在字符串中的项和引号之间插入逗号。 `Print` 不需要在列表中放置显式分隔符。 使用`Write`将数据写入文件时, 仅支持数字、 `Boolean`、日期、null 和`Error`数据格式。 遵循以下通用假设, 这样无论区域设置如何, 都可以使用`Input`读取和正确地解释数据:  
  
-   始终使用句点作为小数点分隔符来编写数值数据。  
  
-   对于`Boolean`数据, 可以`#TRUE#`是`#FALSE#`或。 不会`False`转换和关键字,无论区域设置如何。`True`  
  
-   使用通用日期格式将数据写入文件。 当日期或时间部分缺失或为零时, 只将提供的部分写入文件中。  
  
-   如果`Output`数据为空, 则不向文件写入任何内容。 但对于空数据, `#NULL#`将写入。  
  
-   对于`Error`数据, 输出显示为`#ERROR errorcode#`。 不`Error`转换关键字, 无论区域设置如何。  
  
 `WriteLine``Chr(13) + Chr(10)`在`Output`将最后一个字符写入文件后, 插入一个换行符 (即回车符/换行符, 或)。  
  
 您可以通过使用双引号或 "" 在字符串中嵌入引号。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回值为的`Double quotation marks aren't "difficult" to handle`字符串。  
  
 使用`Write`或`WriteLine` 函数写入`Append`文件需要枚举中`FileIOPermissionAccess`的访问权限。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数将原始数据写入顺序文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">文件模式无效。</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic.Core</AssemblyName>
        <AssemblyVersion>10.0.4.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">必需。 包含任何有效文件数的 <see langword="Integer" /> 表达式。</param>
        <param name="Output">可选。 要写入文件的一个或多个由逗号分隔的表达式。</param>
        <summary>将数据写入一个顺序文件。 通常使用 <see langword="Input" /> 从文件中读取使用 <see langword="Write" /> 编写的数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供`Write` 和`WriteLine`函数是为了向后兼容, 可能会影响性能。 对于非旧版应用程序, 对象`My.Computer.FileSystem`提供更好的性能。 有关详细信息, 请参阅[使用 Visual Basic 进行文件访问](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md)。  
  
 如果省略`Output`, 则会在文件中打印一个空行。 多个表达式可以用逗号分隔。  
  
 与函数不同, 函数`Write`在写入到文件中时, 在字符串中的项和引号之间插入逗号。 `Print` 不需要在列表中放置显式分隔符。 使用`Write`将数据写入文件时, 仅支持数字、 `Boolean`、日期、null 和`Error`数据格式。 遵循以下通用假设, 这样无论区域设置如何, 都可以使用`Input`读取和正确地解释数据:  
  
-   始终使用句点作为小数点分隔符来编写数值数据。  
  
-   对于`Boolean`数据, 可以`#TRUE#`是`#FALSE#`或。 不会`False`转换和关键字,无论区域设置如何。`True`  
  
-   使用通用日期格式将数据写入文件。 当日期或时间部分缺失或为零时, 只将提供的部分写入文件中。  
  
-   如果`Output`数据为空, 则不向文件写入任何内容。 但对于空数据, `#NULL#`将写入。  
  
-   对于`Error`数据, 输出显示为`#ERROR errorcode#`。 不`Error`转换关键字, 无论区域设置如何。  
  
 `WriteLine``Chr(13) + Chr(10)`在`Output`将最后一个字符写入文件后, 插入一个换行符 (即回车符/换行符, 或)。  
  
 您可以通过使用双引号或 "" 在字符串中嵌入引号。 例如，应用于对象的  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 返回值为的`Double quotation marks aren't "difficult" to handle`字符串。  
  
 使用`Write`或`WriteLine` 函数写入`Append`文件需要枚举中`FileIOPermissionAccess`的访问权限。 有关更多信息，请参见<xref:System.Security.Permissions.FileIOPermissionAccess>。  
  
   
  
## Examples  
 此示例使用`Write`函数将原始数据写入顺序文件。  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">使用 Visual Basic 访问文件</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">如何：在 Visual Basic 中向文件内写入文本</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">如何：使用 Streamwriter (Visual Basic) 将文本写入文件</related>
      </Docs>
    </Member>
  </Members>
</Type>
