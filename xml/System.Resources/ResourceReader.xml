<Type Name="ResourceReader" FullName="System.Resources.ResourceReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="cc2329cf6988186b9da27d48b6c8d95189893181" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69275950" /></Metadata><TypeSignature Language="C#" Value="public sealed class ResourceReader : System.Resources.IResourceReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ResourceReader extends System.Object implements class System.Collections.IEnumerable, class System.IDisposable, class System.Resources.IResourceReader" />
  <TypeSignature Language="DocId" Value="T:System.Resources.ResourceReader" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ResourceReader&#xA;Implements IResourceReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResourceReader sealed : System::Resources::IResourceReader" />
  <TypeSignature Language="F#" Value="type ResourceReader = class&#xA;    interface IResourceReader&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Resources.Reader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Resources.ResourceManager</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Resources.IResourceReader</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>通过读取顺序资源名称/值对枚举二进制资源 (.resources) 文件的资源。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-class-note](~/includes/untrusted-data-class-note.md)]

 类提供<xref:System.Resources.IResourceReader>接口的标准实现。 <xref:System.Resources.ResourceReader> <xref:System.Resources.ResourceReader>实例表示嵌入到程序集中的独立 .resources 文件或 .resources 文件。 它用于枚举 .resources 文件中的资源, 并检索其名称/值对。 它与<xref:System.Resources.ResourceManager>类不同, 后者用于从嵌入在程序集中的 .resources 文件中检索指定的已命名资源。 类用于检索事先知道其名称的资源, <xref:System.Resources.ResourceReader>而类可用于检索在编译时不知道其数字或精确名称的资源。 <xref:System.Resources.ResourceManager> 例如, 应用程序可以使用资源文件来存储组织中的部分和项的配置信息, 其中节或节中的项的数目事先是未知的。 `Section1` `Section1Item1`然后,可以<xref:System.Resources.ResourceReader>使用对象大致命名资源 (例如、 、等)并检索资源。`Section1Item2`  
  
> [!IMPORTANT]
>  此类型实现 <xref:System.IDisposable> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。  
  
 有关使用类的<xref:System.Resources.ResourceReader>详细信息, 请参阅以下部分:  
  
-   [实例化 ResourceReader 对象](#instantiate)  
  
-   [枚举 ResourceReader 对象的资源](#enumerate)  
  
    -   [使用 IDictionaryEnumerator 属性检索资源](#idictionaryenumerator)  
  
    -   [使用 GetResourceData 按名称检索资源](#getresourcedata)  
  
<a name="instantiate"></a>   
## <a name="instantiating-a-resourcereader-object"></a>实例化 ResourceReader 对象  
 .Resources 文件是一个二进制文件, 该文件已通过[resgen.exe (资源文件生成器)](~/docs/framework/tools/resgen-exe-resource-file-generator.md)通过文本文件或 XML .resx 文件进行编译。 <xref:System.Resources.ResourceReader>对象可以表示独立 .resources 文件或已嵌入到程序集中的 .resources 文件。  
  
 若要实例<xref:System.Resources.ResourceReader>化从独立 .resources 文件中读取的对象, 请<xref:System.Resources.ResourceReader>将类构造函数用于输入流或包含 .resources 文件名称的字符串。 下面的示例演示了这两种方法。 第一个实例化<xref:System.Resources.ResourceReader>一个对象, 该对象表示一个名`Resources1.resources`为的 .resources 文件, 使用其文件名。 第二个实例<xref:System.Resources.ResourceReader>化一个对象, 该对象表示使用`Resources2.resources`从文件创建的流命名的 .resources 文件。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#2)]  
  
 若要创建<xref:System.Resources.ResourceReader>表示嵌入 .resources 文件的对象, 请从嵌入 .resources <xref:System.Reflection.Assembly>文件的程序集中实例化对象。 其<xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType>方法<xref:System.IO.Stream>返回可传递给构造<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>函数的对象。 下面的示例实例化<xref:System.Resources.ResourceReader>一个表示嵌入 .resources 文件的对象。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/ctor1.cs#3)]
 [!code-vb[System.Resources.ResourceReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/ctor1.vb#3)]  
  
<a name="enumerate"></a>   
## <a name="enumerating-a-resourcereader-objects-resources"></a>枚举 ResourceReader 对象的资源  
 若要枚举 .resources 文件中的资源, 请调用<xref:System.Resources.ResourceReader.GetEnumerator%2A> <xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>返回对象的方法。 调用`IDictionaryEnumerator.MoveNext`方法以从一个资源移到下一个资源。 如果已枚举`false` .resources 文件中的所有资源, 则方法将返回。  
  
> [!NOTE]
>  <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>尽管类实现接口和方法, 但方法并不提供实现。<xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType> <xref:System.Collections.IEnumerable> <xref:System.Resources.ResourceReader> 相反, 该<xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法<xref:System.Collections.IDictionaryEnumerator>返回提供对每个资源的名称/值对的访问的接口对象。  
  
 可以通过两种方式检索集合中的单个资源:  
  
-   可以循环访问集合中的<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>每个资源, 并使用<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>属性来检索资源名称和值。 如果所有资源的类型相同, 或者知道每个资源的数据类型, 则我们建议采用此方法。  
  
-   在循环访问<xref:System.Collections.IDictionaryEnumerator?displayProperty=nameWithType>集合并<xref:System.Resources.ResourceReader.GetResourceData%2A>调用方法以检索资源的数据时, 可以检索每个资源的名称。 如果你不知道每个资源的数据类型, 或者以前的方法引发异常, 则建议采用此方法。  
  
<a name="idictionaryenumerator"></a>   
### <a name="retrieving-resources-by-using-idictionaryenumerator-properties"></a>使用 IDictionaryEnumerator 属性检索资源  
 枚举 .resources 文件中的资源的第一种方法涉及直接检索每个资源的名称/值对。 调用`IDictionaryEnumerator.MoveNext`方法移动到集合中的每个资源后, 可以<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>从属性和<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性的资源数据中检索资源名称。  
  
 下面的示例演示如何使用<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>和<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性检索 .resources 文件中每个资源的名称和值。 若要运行该示例, 请创建名为 ApplicationResources 的以下文本文件来定义字符串资源。  
  
```  
Title="Contact Information"  
Label1="First Name:"  
Label2="Middle Name:"  
Label3="Last Name:"  
Label4="SSN:"  
Label5="Street Address:"  
Label6="City:"  
Label7="State:"  
Label8="Zip Code:"  
Label9="Home Phone:"  
Label10="Business Phone:"  
Label11="Mobile Phone:"  
Label12="Other Phone:"  
Label13="Fax:"  
Label14="Email Address:"  
Label15="Alternate Email Address:"  
```  
  
 然后, 可以使用以下命令将文本资源文件转换为名为 ApplicationResources 的二进制文件:  
  
 **resgen ApplicationResources**  
  
 下面的示例使用<xref:System.Resources.ResourceReader>类来枚举独立的二进制 .resources 文件中的每个资源, 并显示其密钥名称和相应的值。  
  
 [!code-csharp[System.Resources.ResourceReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/class1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/class1.vb#1)]  
  
 尝试从<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性中检索资源数据会引发以下异常:  
  
-   如果<xref:System.FormatException>数据不是预期的格式, 则为。  
  
-   如果<xref:System.IO.FileNotFoundException>找不到包含数据所属类型的程序集, 则为。  
  
-   如果<xref:System.TypeLoadException>找不到数据所属的类型, 则为。  
  
 通常, 如果在手动修改了某个类型的程序集时已手动修改了该类型的程序集, 或该程序集已被无意中删除, 或者如果该程序集是较旧的版本, 则会引发这些异常。类型。 如果引发其中一个异常, 可以通过枚举每个资源并调用<xref:System.Resources.ResourceReader.GetResourceData%2A>方法来检索资源, 如以下部分所示。 此方法提供了有关<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性尝试返回的数据类型的一些信息。  
  
<a name="getresourcedata"></a>   
### <a name="retrieving-resources-by-name-with-getresourcedata"></a>使用 GetResourceData 按名称检索资源  
 在 .resources 文件中枚举资源的第二种方法还涉及通过调用`IDictionaryEnumerator.MoveNext`方法来浏览文件中的资源。 对于每个资源, 从<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>属性中检索资源的名称, 然后将其传递<xref:System.Resources.ResourceReader.GetResourceData%28System.String%2CSystem.String%40%2CSystem.Byte%5B%5D%40%29>给方法以检索资源的数据。 这在`resourceData`参数中作为字节数组返回。  
  
 与从<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>和<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性检索资源名称和值相比, 此方法更难, 因为它返回构成资源值的实际字节。 但是, 如果尝试检索资源时引发异常, 则<xref:System.Resources.ResourceReader.GetResourceData%2A>方法可以通过提供有关资源的数据类型的信息来帮助确定异常的源。 有关指示资源的数据类型的字符串的详细信息, 请参阅<xref:System.Resources.ResourceReader.GetResourceData%2A>。  
  
 下面的示例演示如何使用此方法检索资源并处理引发的任何异常。 它以编程方式创建一个二进制 .resources 文件, 其中包含四个字符串、一个布尔值、一个整数、一个位图`DateTimeTZI`和一个自定义对象。 若要运行该示例, 请执行以下操作:  
  
1.  创建一个包含该`DateTimeTZI`结构的名为 Library 的程序集。 下面是该程序集的源代码。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/library.cs#4)]
     [!code-vb[System.Resources.ResourceReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/library.vb#4)]  
  
     使用以下命令编译中C#的源代码:  
  
    ```  
    csc /t:library library.cs  
    ```  
  
     或者, 可以使用以下命令在 Visual Basic 中对其进行编译:  
  
    ```  
    vbc library.vb /t:library  
    ```  
  
2.  编译并执行以下源代码, 这会创建一个名为 ContactResources 的 .resources 文件。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/createresourceex1.cs#5)]
     [!code-vb[System.Resources.ResourceReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/createresourceex1.vb#5)]  
  
     源代码文件被命名为 CreateResources.cs。 可以使用以下命令在C#中对其进行编译:  
  
    ```  
    csc CreateResources.cs /r:library.dll  
    ```  
  
     或者, 可以使用以下命令在 Visual Basic 中对其进行编译:  
  
    ```  
    vbc CreateResources.vb /r:library.dll  
    ```  
  
3.  编译并运行以下代码以枚举 ContactResources 文件中的资源。  
  
     [!code-csharp[System.Resources.ResourceReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.class/cs/readresourceex1.cs#6)]
     [!code-vb[System.Resources.ResourceReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.class/vb/readresourceex1.vb#6)]  
  
     修改源代码 (例如, 通过<xref:System.FormatException>在`try`块末尾特意引发, 或重命名库 .dll 程序集, 使其在运行时不可用), 可以运行该示例, <xref:System.Resources.ResourceReader.GetResourceData%2A>以了解如何调用使您能够检索或重新创建某些资源信息。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Resources.ResourceReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]。
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : System.IO.Stream -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">用于读取资源的输入流。</param>
        <summary>为指定的流初始化 <see cref="T:System.Resources.ResourceReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数实例化<xref:System.Resources.ResourceReader>一个对象, 该对象从独立 .resources 文件或嵌入在程序集中的 .resources 文件检索资源。 <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29> 若要从独立 .resources 文件中读取, 请实例<xref:System.IO.Stream>化对象并将其传递<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>给构造函数。 若要读取嵌入的 .resources 文件, 请使用 .resources <xref:System.Reflection.Assembly.GetManifestResourceStream%2A?displayProperty=nameWithType>文件的区分大小写的名称调用方法, 并将返回<xref:System.IO.Stream>的对象传递到<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>构造函数。  
  
[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]
  
## Examples  
 本部分中的示例使用名`PatientForm.txt`为的以下 .txt 文件来定义应用程序使用的资源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 可以通过发出以下命令, 将 .txt 文件编译为 .resources 文件:  
  
 **resgen PatientForm**  
  
 下面的示例假定资源文件嵌入到包含应用程序的可执行代码的程序集中。 它从当前正在执行的`PatientForm.resources`程序集检索名为的资源文件, 并显示其每个资源的名称和值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream1.cs#1)]
 [!code-vb[System.Resources.ResourceReader.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream1.vb#1)]  
  
 如果该C#示例名为`Example.cs`, 则可以使用以下命令对其进行编译:  
  
 **csc Example.cs/res: PatientForm**  
  
 如果 Visual Basic 示例命名为`Example.vb`, 则可以使用以下命令对其进行编译:  
  
 **vbc 示例 .vb/res: PatientForm**  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="stream" /> 参数不可读。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.IOException">在访问 <paramref name="stream" /> 时发生 I/O 错误。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于提供序列化服务。 安全操作: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResourceReader (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResourceReader(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="new System.Resources.ResourceReader : string -&gt; System.Resources.ResourceReader" Usage="new System.Resources.ResourceReader fileName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="fileName">要读取的源文件的路径及名称。 文件名<c></c>不区分大小写。</param>
        <summary>为指定的资源文件初始化 <see cref="T:System.Resources.ResourceReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数实例化<xref:System.Resources.ResourceReader>一个对象, 该对象从独立 .resources 文件中检索资源。 <xref:System.Resources.ResourceReader.%23ctor%28System.String%29> 若要从嵌入的 .resources 文件中检索资源, 请<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29>使用构造函数。  

[!INCLUDE [untrusted-data-instance-note](~/includes/untrusted-data-instance-note.md)]

## Examples  
 本部分中的示例使用名`PatientForm.txt`为的以下 .txt 文件来定义应用程序使用的资源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 可以通过发出以下命令, 将此 .txt 文件编译为 .resources 文件:  
  
 **resgen PatientForm**  
  
 下面的示例枚举中`PatientForm.resources`的资源, 并显示每个资源的名称和值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="fileName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法找到该文件。</exception>
        <exception cref="T:System.IO.IOException">发生了 I/O 错误。</exception>
        <exception cref="T:System.BadImageFormatException">资源文件的格式无效。 例如，文件的长度可能为零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="resourceReader.Close " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.Close</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放与此 <see cref="T:System.Resources.ResourceReader" /> 对象相关联的所有操作系统资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.Close%2A>可以安全地调用多次。  
  
   
  
## Examples  
 下面的示例在文件的资源中移动, 并显示它找到的所有键/值对。 然后, 该代码使用<xref:System.Resources.ResourceReader.Close%2A>方法关闭并释放它<xref:System.Resources.ResourceReader>所使用的所有资源。  
  
 [!code-cpp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CPP/getenumerator.cpp#1)]
 [!code-csharp[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/CS/getenumerator.cs#1)]
 [!code-vb[System.Resources.ResourceReader.GetEnumerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Resources.ResourceReader.GetEnumerator Example/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="resourceReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Resources.ResourceReader" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用的<xref:System.Resources.ResourceReader>此实例完成后, 调用<xref:System.Resources.ResourceReader.Dispose%2A>以释放此实例使用的所有资源。 你应消除对此<xref:System.Resources.ResourceReader>实例的进一步引用, 以便垃圾回收器可以回收实例的内存, 而不是使其处于活动状态以完成。  
  
 <xref:System.Resources.ResourceReader.Dispose%2A>调用专用 Dispose (Boolean) 方法, 该方法包含用于释放托管资源和非托管资源的代码。 有关详细信息, 请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionaryEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionaryEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IDictionaryEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionaryEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IDictionaryEnumerator" Usage="resourceReader.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Resources.IResourceReader.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionaryEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</summary>
        <returns>此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, 可以<xref:System.Resources.ResourceReader.GetEnumerator%2A>通过调用方法来枚举资源, 然后在返回<xref:System.Collections.IDictionaryEnumerator>的<xref:System.Collections.IEnumerator.MoveNext%2A>对象上重复调用方法, 直到该方法`false`返回。 资源名称可从<xref:System.Collections.IDictionaryEnumerator.Key%2A?displayProperty=nameWithType>属性获取, 其值<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>来自属性。 该示例演示如何以这种方式枚举资源。  
  
 <xref:System.Resources.ResourceReader>类的<xref:System.Collections.IDictionaryEnumerator.Value%2A?displayProperty=nameWithType>属性实现可能引发以下异常:  
  
-   <xref:System.IO.FileNotFoundException>  
  
     找不到包含数据所属的类型的程序集。  
  
-   <xref:System.FormatException>  
  
     数据的格式不正确。  
  
-   <xref:System.TypeLoadException>  
  
     找不到数据所属的类型。  
  
 您可以通过调用<xref:System.Resources.ResourceReader.GetResourceData%2A>方法来检索有关数据类型的信息以及分配给该命名资源的字节数组的信息, 从而处理此异常。 有关详细信息, 请参阅<xref:System.Resources.ResourceReader>类主题中的 "按名称使用 GetResourceData 检索资源" 部分。  
  
> [!IMPORTANT]
>  <xref:System.Resources.ResourceReader>类包含两个返回枚举器的方法。 <xref:System.Resources.ResourceReader.GetEnumerator%2A> 方法<xref:System.Collections.IDictionaryEnumerator>返回接口对象, 是枚举资源时建议调用的方法。  
  
   
  
## Examples  
 本部分中的示例使用名`PatientForm.txt`为的以下 .txt 文件来定义应用程序使用的资源。  
  
```  
  
Title="Top Pet Animal Clinic"  
Label1="Patient Number:"  
Label2="Pet Name:"  
Label3="Species:"  
Label4="Breed:"  
Label5="Date of Birth:"  
Label6="Age:"  
Label7="Owner:"  
Label8="Address:"  
Label9="Home Phone:"  
Label10="Work Phone:"  
Label11="Mobile Phone:"  
  
```  
  
 可以通过发出以下命令, 将 .txt 文件编译为 .resources 文件:  
  
 **resgen PatientForm**  
  
 下面的示例枚举中`PatientForm.resources`的资源, 并显示每个资源的名称和值。  
  
 [!code-csharp[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/cs/stream2.cs#2)]
 [!code-vb[System.Resources.ResourceReader.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.resources.resourcereader.ctor/vb/stream2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">读取器已关闭或释放，因此无法访问。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="GetResourceData">
      <MemberSignature Language="C#" Value="public void GetResourceData (string resourceName, out string resourceType, out byte[] resourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetResourceData(string resourceName, [out] string&amp; resourceType, [out] unsigned int8[]&amp; resourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.GetResourceData(System.String,System.String@,System.Byte[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetResourceData (resourceName As String, ByRef resourceType As String, ByRef resourceData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetResourceData(System::String ^ resourceName, [Runtime::InteropServices::Out] System::String ^ % resourceType, [Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % resourceData);" />
      <MemberSignature Language="F#" Value="member this.GetResourceData : string *  *  -&gt; unit" Usage="resourceReader.GetResourceData (resourceName, resourceType, resourceData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceType" Type="System.String" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="resourceData" Type="System.Byte[]" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="resourceName">资源的名称。</param>
        <param name="resourceType">当此方法返回时，包含表示检索资源的类型名称的字符串。 此参数未经初始化即被传递。</param>
        <param name="resourceData">此方法返回时，包含一个字节数组，该字节数组为所检索类型的二进制表示形式。 此参数未经初始化即被传递。</param>
        <summary>从打开的资源文件或流检索指定资源的类型名称和数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.GetResourceData%2A>方法检索指定资源的值作为字节数组。 当<xref:System.Collections.IDictionaryEnumerator.Value%2A>属性尝试检索资源的值时, 通常会使用该属性引发异常。  
  
 `resourceType`表示资源的数据类型的字符串。 可以是下列值之一:  
  
-   指示资源的数据类型`ResourceTypeCode`的枚举成员的字符串表示形式。 `ResourceTypeCode`是使用的私有枚举。指示使用特殊的二进制格式存储19个常见数据类型之一。 其中包括<xref:System.Boolean>.NET Framework 基元数据类型 (、 <xref:System.Double> <xref:System.Decimal> 、、、<xref:System.Int64>、 <xref:System.Int16>、、、 、<xref:System.SByte>、 <xref:System.Int32> <xref:System.Char> <xref:System.Byte> <xref:System.Single> <xref:System.UInt16>、 <xref:System.UInt32>、 )<xref:System.UInt64>以及<xref:System.DateTime>、和, 此外,`ResourceTypeCode`枚举还包括下表中显示的值。 <xref:System.TimeSpan> <xref:System.String>  
  
    |ResourceTypeCode 值|说明|  
    |----------------------------|-----------------|  
    |`ResourceTypeCode.ByteArray`|数据是字节数组。 此数据类型通常是通过调用<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Byte%5B%5D%29?displayProperty=nameWithType>方法导致的。|  
    |`ResourceTypeCode.Null`|数据为空引用。 此数据类型通常是使用值为<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.Object%29?displayProperty=nameWithType> `null`的对象调用方法导致的。|  
    |`ResourceTypeCode.Stream`|数据存储在流中。 此数据类型通常是通过调用<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%29?displayProperty=nameWithType>或<xref:System.Resources.ResourceWriter.AddResource%28System.String%2CSystem.IO.Stream%2CSystem.Boolean%29?displayProperty=nameWithType>方法生成的。|  
  
     假定未损坏, 则通常可以通过<xref:System.BitConverter>调用或<xref:System.IO.BinaryReader>方法将其从字节数组转换回其原始值。 `resourceData`  
  
-   一个字符串, 其中包含类型的完全限定名称, 该类型的序列化数据将`resourceData`分配给自变量 ( `System.String`例如,)。 此外, 对于不属于 .NET Framework 类库的类型, 该字符串包含包含该类型的程序集的名称、版本、区域性和公钥。 例如, 下面的字符串表示序列化数据表示`Person` `Extensions`命名空间中类型的一个实例, 该类型在名为 Utility 的程序集的版本1.0 中, 该程序集没有公共密钥, 也没有指定的区域性。  
  
     `Extensions.Person, Utility, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null`  
  
     假设未损坏并且源类型可用, `resourceData`则可以通过将字节数组转换为<xref:System.IO.Stream>对象并将流传递到, 将字节数组转换回其原始值。 `resourceData` <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter.Deserialize%2A?displayProperty=nameWithType>方法。  
  
-   用于描述<xref:System.Resources.ResourceWriter.AddResourceData%2A?displayProperty=nameWithType>方法调用中的数据类型的字符串。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" /> 不存在。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="resourceName" /> 具有无效的类型。</exception>
        <exception cref="T:System.FormatException">检索的资源数据已损坏。</exception>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Resources.ResourceReader" /> 对象未初始化，可能因其已被关闭。</exception>
        <altmember cref="M:System.Resources.ResourceWriter.AddResourceData(System.String,System.String,System.Byte[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</summary>
        <returns>此 <see cref="T:System.Resources.ResourceReader" /> 对象的枚举器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Resources.ResourceReader.System%23Collections%23IEnumerable%23GetEnumerator%2A?displayProperty=nameWithType>是显式接口实现。 它只能在 <xref:System.Resources.ResourceReader> 实例被强制转换为 <xref:System.Collections.IEnumerable> 接口时使用。 在 .resources 文件中枚举资源的建议方法是调用<xref:System.Collections.IEnumerator.MoveNext%2A> <xref:System.Resources.ResourceReader.GetEnumerator%2A?displayProperty=nameWithType>方法返回的<xref:System.Collections.IDictionaryEnumerator>对象的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">读取器已关闭，并且无法访问。</exception>
        <altmember cref="T:System.Collections.IDictionary" />
        <altmember cref="T:System.Collections.IDictionaryEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Resources.ResourceReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.ResourceManager</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Resources.Reader</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放由 <see cref="T:System.Resources.ResourceReader" /> 占用的资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
调用 Dispose 允许出于其他目的重新分配<xref:System.Resources.ResourceReader>使用的资源。 有关 Dispose 的详细信息, 请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。

## Examples  
下面的代码示例在文件的资源中移动, 并输出找到的所有键/值对。 然后, 该代码使用 theIDisposable 方法关闭并释放它所<xref:System.Resources.ResourceReader>使用的所有资源。

```vb
Imports System
Imports System.Resources
Imports System.Collections

Public Class ReadResources

    Public Shared Sub Main(args() As String)
        ' Create a resource reader for items.resources 
        ' and get an enumerator to iterate through the file. 
        Dim reader As IResourceReader = New ResourceReader("items.resources")
        Dim en As IDictionaryEnumerator = reader.GetEnumerator()

        ' Iterate through the file, printing the key and value pairs. 
        While en.MoveNext()
            Console.WriteLine()
            Console.WriteLine("Name: {0}", en.Key)
            Console.WriteLine("Value: {0}", en.Value)
        End While 

        ' Clean up all resources associated with the reader. 
        ' Calling Dispose is equivalent to calling Close.
        reader.Dispose()
    End Sub 

End Class
```

```csharp
using System;
using System.Resources;
using System.Collections;

public class ReadResources 
{
    public static void Main(string[] args) 
    {
        // Create a resource reader for items.resources 
        // and get an enumerator to iterate through the file.
        IResourceReader reader = new ResourceReader("items.resources");
        IDictionaryEnumerator en = reader.GetEnumerator();

        // Iterate through the file, printing the key/value pairs. 
        while (en.MoveNext()) 
        {
            Console.WriteLine();
            Console.WriteLine("Name: {0}", en.Key);
            Console.WriteLine("Value: {0}", en.Value);
        }

        // Clean up all resources associated with the reader. 
        // Calling Dispose is equivalent to calling Close.
        reader.Dispose();
    }
}
```

```cpp
using namespace System;
using namespace System::Resources;
using namespace System::Collections;
int main()
{
   array<String^>^args = Environment::GetCommandLineArgs();

   // Create a resource reader for items.resources 
   // and get an enumerator to iterate through the file.
   IResourceReader^ reader = gcnew ResourceReader( "items.resources" );
   IDictionaryEnumerator^ en = reader->GetEnumerator();

   // Iterate through the file, printing the key/value pairs. 
   while ( en->MoveNext() )
   {
      Console::WriteLine();
      Console::WriteLine( "Name: {0}", en->Key );
      Console::WriteLine( "Value: {0}", en->Value );
   }

   // Clean up all resources associated with the reader. 
   // Calling the destructor is equivalent to calling Close.
   reader->~IResourceReader();
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
