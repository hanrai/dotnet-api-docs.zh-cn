<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8193f1d65725a40b2301463ace7d4d95fbe76d8c" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69439296" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="6567e-101">表示应用程序域，它是一个应用程序在其中执行的独立环境。</span><span class="sxs-lookup"><span data-stu-id="6567e-101">Represents an application domain, which is an isolated environment where applications execute.</span></span> <span data-ttu-id="6567e-102">此类不能被继承。</span><span class="sxs-lookup"><span data-stu-id="6567e-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-103">应用程序域由<xref:System.AppDomain>对象表示, 有助于提供隔离、卸载和安全边界来执行托管代码。</span><span class="sxs-lookup"><span data-stu-id="6567e-103">Application domains, which are represented by <xref:System.AppDomain> objects, help provide isolation, unloading, and security boundaries for executing managed code.</span></span>  
  
-   <span data-ttu-id="6567e-104">使用应用程序域来隔离可能会关闭进程的任务。</span><span class="sxs-lookup"><span data-stu-id="6567e-104">Use application domains to isolate tasks that might bring down a process.</span></span> <span data-ttu-id="6567e-105">如果正在执行的任务<xref:System.AppDomain>的状态变为不稳定, 则可以在<xref:System.AppDomain>不影响进程的情况下卸载。</span><span class="sxs-lookup"><span data-stu-id="6567e-105">If the state of the <xref:System.AppDomain> that's executing a task becomes unstable, the <xref:System.AppDomain> can be unloaded without affecting the process.</span></span> <span data-ttu-id="6567e-106">当进程必须长时间运行而不重新启动时, 这非常重要。</span><span class="sxs-lookup"><span data-stu-id="6567e-106">This is important when a process must run for long periods without restarting.</span></span> <span data-ttu-id="6567e-107">你还可以使用应用程序域来隔离不应共享数据的任务。</span><span class="sxs-lookup"><span data-stu-id="6567e-107">You can also use application domains to isolate tasks that should not share data.</span></span>  
  
-   <span data-ttu-id="6567e-108">如果将程序集加载到默认应用程序域中, 则在进程运行时, 不能从内存中卸载该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-108">If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</span></span> <span data-ttu-id="6567e-109">但是, 如果打开第二个应用程序域来加载和执行程序集, 则在卸载该应用程序域时将卸载该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-109">However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</span></span> <span data-ttu-id="6567e-110">使用此方法可以最大程度地减少偶尔使用大型 Dll 的长时间运行的进程的工作集。</span><span class="sxs-lookup"><span data-stu-id="6567e-110">Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</span></span>  
  
 > [!NOTE]
 >  <span data-ttu-id="6567e-111">在 .net Core 上, <xref:System.AppDomain>实现受设计限制, 不提供隔离、卸载或安全边界。</span><span class="sxs-lookup"><span data-stu-id="6567e-111">On .NET Core, the <xref:System.AppDomain> implementation is limited by design and does not provide isolation, unloading, or security boundaries.</span></span> <span data-ttu-id="6567e-112">对于 .NET Core, 只有一个<xref:System.AppDomain>。</span><span class="sxs-lookup"><span data-stu-id="6567e-112">For .NET Core, there is exactly one <xref:System.AppDomain>.</span></span> <span data-ttu-id="6567e-113">通过<xref:System.Runtime.Loader.AssemblyLoadContext>提供隔离和卸载。</span><span class="sxs-lookup"><span data-stu-id="6567e-113">Isolation and unloading are provided through <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="6567e-114">安全边界应由进程边界和适当的远程处理技术提供。</span><span class="sxs-lookup"><span data-stu-id="6567e-114">Security boundaries should be provided by process boundaries and appropriate remoting techniques.</span></span>
 
 <span data-ttu-id="6567e-115">可在单个进程中运行多个应用程序域;但是, 应用程序域和线程之间不会有一对一的相关性。</span><span class="sxs-lookup"><span data-stu-id="6567e-115">Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="6567e-116">多个线程可以属于单个应用程序域, 而给定线程并不局限于单个应用程序域, 在任何给定时间, 线程都在一个应用程序域中执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-116">Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</span></span>  
  
 <span data-ttu-id="6567e-117">使用<xref:System.AppDomain.CreateDomain%2A>方法创建应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-117">Application domains are created using the <xref:System.AppDomain.CreateDomain%2A> method.</span></span> <span data-ttu-id="6567e-118"><xref:System.AppDomain>实例用于加载和执行程序集 (<xref:System.Reflection.Assembly>)。</span><span class="sxs-lookup"><span data-stu-id="6567e-118"><xref:System.AppDomain> instances are used to load and execute assemblies (<xref:System.Reflection.Assembly>).</span></span> <span data-ttu-id="6567e-119"><xref:System.AppDomain>当不再使用时, 可以将其卸载。</span><span class="sxs-lookup"><span data-stu-id="6567e-119">When an <xref:System.AppDomain> is no longer in use, it can be unloaded.</span></span>  
  
 <span data-ttu-id="6567e-120"><xref:System.AppDomain>类实现了一组事件, 使应用程序能够在加载程序集、卸载应用程序域或引发未经处理的异常时做出响应。</span><span class="sxs-lookup"><span data-stu-id="6567e-120">The <xref:System.AppDomain> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</span></span>  
  
 <span data-ttu-id="6567e-121">有关使用应用程序域的详细信息, 请参阅[应用程序域](~/docs/framework/app-domains/application-domains.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-121">For more information on using application domains, see [Application Domains](~/docs/framework/app-domains/application-domains.md).</span></span>  
  
 <span data-ttu-id="6567e-122">此类实现<xref:System.MarshalByRefObject>、 <xref:System._AppDomain>和<xref:System.Security.IEvidenceFactory>接口。</span><span class="sxs-lookup"><span data-stu-id="6567e-122">This class implements the <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, and <xref:System.Security.IEvidenceFactory> interfaces.</span></span>  
  
 <span data-ttu-id="6567e-123">永远不应为<xref:System.AppDomain>对象创建可远程包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-123">You should never create a remotable wrapper for an <xref:System.AppDomain> object.</span></span> <span data-ttu-id="6567e-124">这样做可能会发布对此的<xref:System.AppDomain>远程引用, 公开诸如远程访问等方法<xref:System.AppDomain.CreateInstance%2A> , 并有效地销毁该<xref:System.AppDomain>的代码访问安全性。</span><span class="sxs-lookup"><span data-stu-id="6567e-124">Doing so could publish a remote reference to that <xref:System.AppDomain>, exposing methods such as <xref:System.AppDomain.CreateInstance%2A> to remote access and effectively destroying code access security for that <xref:System.AppDomain>.</span></span> <span data-ttu-id="6567e-125">连接到远程<xref:System.AppDomain>客户端的恶意客户端可以获取对自身<xref:System.AppDomain>有权访问的任何资源的访问权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-125">Malicious clients connecting to the remoted <xref:System.AppDomain> could obtain access to any resource the <xref:System.AppDomain> itself has access to.</span></span> <span data-ttu-id="6567e-126">不要为扩展<xref:System.MarshalByRefObject>和实现可由恶意客户端用来绕过安全系统的方法的任何类型创建可远程包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-126">Do not create remotable wrappers for any type that extends <xref:System.MarshalByRefObject> and that implements methods that could be used by malicious clients to bypass the security system.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6567e-127"><xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>属性的默认值为`false`。</span><span class="sxs-lookup"><span data-stu-id="6567e-127">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> property is `false`.</span></span> <span data-ttu-id="6567e-128">对于服务, 此设置是不安全的。</span><span class="sxs-lookup"><span data-stu-id="6567e-128">This setting is unsafe for services.</span></span> <span data-ttu-id="6567e-129">若要防止服务下载部分受信任的代码, 请将`true`此属性设置为。</span><span class="sxs-lookup"><span data-stu-id="6567e-129">To prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-130">此示例演示如何创建新<xref:System.AppDomain>的, 在该新<xref:System.AppDomain>中实例化类型, 并与该类型的对象进行通信。</span><span class="sxs-lookup"><span data-stu-id="6567e-130">This example shows how to create a new <xref:System.AppDomain>, instantiate a type in that new <xref:System.AppDomain>, and communicate with that type's object.</span></span> <span data-ttu-id="6567e-131">此外, 此示例还演示如何卸载导致对象<xref:System.AppDomain>被垃圾回收的。</span><span class="sxs-lookup"><span data-stu-id="6567e-131">In addition, this example shows how to unload the <xref:System.AppDomain> causing the object to be garbage collected.</span></span>  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482"><span data-ttu-id="6567e-132">如何：配置应用程序域</span><span class="sxs-lookup"><span data-stu-id="6567e-132">How To: Configure an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba"><span data-ttu-id="6567e-133">如何：创建应用程序域</span><span class="sxs-lookup"><span data-stu-id="6567e-133">How To: Create an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9"><span data-ttu-id="6567e-134">如何：将程序集加载到应用程序域中</span><span class="sxs-lookup"><span data-stu-id="6567e-134">How to: Load Assemblies into an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192"><span data-ttu-id="6567e-135">如何：卸载应用程序域</span><span class="sxs-lookup"><span data-stu-id="6567e-135">How to: Unload an Application Domain</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-136">获取当前应用程序域的激活上下文。</span><span class="sxs-lookup"><span data-stu-id="6567e-136">Gets the activation context for the current application domain.</span></span></summary>
        <value><span data-ttu-id="6567e-137">一个对象，表示当前应用程序域的激活上下文；或者如果域没有激活上下文，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-137">An object that represents the activation context for the current application domain, or <see langword="null" /> if the domain has no activation context.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-138">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-138">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-139">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-139">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6567e-140">要追加到专用路径的目录名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-140">The name of the directory to be appended to the private path.</span></span></param>
        <summary><span data-ttu-id="6567e-141">将指定的目录名追加到专用路径列表。</span><span class="sxs-lookup"><span data-stu-id="6567e-141">Appends the specified directory name to the private path list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-142">不建议使用此属性, 因为它可能会在已加载程序集之后更改其探测路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-142">The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</span></span> <span data-ttu-id="6567e-143">改用 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-143">Use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="6567e-144">专用路径 (或相对搜索路径) 是相对于基目录的路径, 在该路径中, 程序集冲突解决程序对专用程序集进行探测。</span><span class="sxs-lookup"><span data-stu-id="6567e-144">The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-145">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-145">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-146">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-147">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-148">获得应用程序域中的应用程序标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-148">Gets the identity of the application in the application domain.</span></span></summary>
        <value><span data-ttu-id="6567e-149">标识应用程序域中应用程序的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-149">An object that identifies the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-150">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-150">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-151">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-151">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-152">获取说明授予应用程序的权限以及应用程序是否拥有允许其运行的信任级别的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-152">Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</span></span></summary>
        <value><span data-ttu-id="6567e-153">封装应用程序域中应用程序的权限及信任信息的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-153">An object that encapsulates permission and trust information for the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-154">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-154">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-155">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-155">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-156">程序集显示名称，采用 <see cref="P:System.Reflection.Assembly.FullName" /> 属性提供的格式。</span><span class="sxs-lookup"><span data-stu-id="6567e-156">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="6567e-157">返回应用策略后的程序集显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-157">Returns the assembly display name after policy has been applied.</span></span></summary>
        <returns><span data-ttu-id="6567e-158">包含应用策略后的程序集显示名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="6567e-158">A string containing the assembly display name after policy has been applied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-159"><xref:System.AppDomain.ApplyPolicy%2A>方法采用程序集显示名称, 并返回策略后的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-159">The <xref:System.AppDomain.ApplyPolicy%2A> method takes an assembly display name and returns the post-policy display name.</span></span> <span data-ttu-id="6567e-160">如果需要使用策略加载程序集, 这会很有用, 因为仅反射上下文不应用策略。</span><span class="sxs-lookup"><span data-stu-id="6567e-160">This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-161">在加载程序集时发生。</span><span class="sxs-lookup"><span data-stu-id="6567e-161">Occurs when an assembly is loaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-162">此<xref:System.AssemblyLoadEventHandler>事件的委托指示加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-162">The <xref:System.AssemblyLoadEventHandler> delegate for this event indicates what assembly was loaded.</span></span>  
  
 <span data-ttu-id="6567e-163">若要为此事件注册事件处理程序, 你必须具有所需的权限, <xref:System.Security.SecurityException>否则将引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-163">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="6567e-164">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-164">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-165">下面的示例演示<xref:System.AppDomain.AssemblyLoad>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-165">The following sample demonstrates the <xref:System.AppDomain.AssemblyLoad> event.</span></span>  
  
 <span data-ttu-id="6567e-166">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-166">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-167">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-167">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-168">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-168">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-169">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-170">在对程序集的解析失败时发生。</span><span class="sxs-lookup"><span data-stu-id="6567e-170">Occurs when the resolution of an assembly fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-171">此事件的责任<xref:System.ResolveEventHandler>是返回<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>由属性指定的程序集; 如果程序集未被识别, 则为。</span><span class="sxs-lookup"><span data-stu-id="6567e-171">It is the responsibility of the <xref:System.ResolveEventHandler> for this event to return the assembly that is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property, or to return null if the assembly is not recognized.</span></span> <span data-ttu-id="6567e-172">必须将程序集加载到执行上下文中;如果将其加载到仅反射上下文中, 导致引发此事件的负载会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-172">The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</span></span>  
  
 <span data-ttu-id="6567e-173">有关使用此事件的指导, 请参阅[解决程序集加载](~/docs/framework/app-domains/resolve-assembly-loads.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-173">For guidance on the use of this event, see [Resolving Assembly Loads](~/docs/framework/app-domains/resolve-assembly-loads.md).</span></span>  
  
 <span data-ttu-id="6567e-174">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]从开始<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , 属性返回请求未能解析程序集加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-174">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="6567e-175">例如, 加载程序可能无法加载请求程序集的依赖项, 因为请求的程序集及其依赖项不在探测路径中。</span><span class="sxs-lookup"><span data-stu-id="6567e-175">For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</span></span> <span data-ttu-id="6567e-176">如果提供了多个版本的依赖项, 则知道请求程序集的标识可能对查找依赖项或标识正确的版本很有用。</span><span class="sxs-lookup"><span data-stu-id="6567e-176">Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</span></span> <span data-ttu-id="6567e-177">有关详细信息，请参阅 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6567e-177">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-178">从开始[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] <xref:System.ResolveEventHandler> , 为所有程序集 (包括资源程序集) 引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-178">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the <xref:System.ResolveEventHandler> event is raised for all assemblies, including resource assemblies.</span></span> <span data-ttu-id="6567e-179">在早期版本中, 资源程序集不引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-179">In earlier versions, the event was not raised for resource assemblies.</span></span> <span data-ttu-id="6567e-180">如果对操作系统进行了本地化, 则可以多次调用处理程序: 对回退链中的每个区域性调用一次。</span><span class="sxs-lookup"><span data-stu-id="6567e-180">If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</span></span>  
  
 <span data-ttu-id="6567e-181">对于此事件, <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>属性将在应用策略之前返回程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-181">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-182">如果为此事件注册了多个事件处理程序, 则将按顺序调用事件处理程序, 直到事件处理程序返回一个不`null`为的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-182">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="6567e-183">后续事件处理程序将被忽略。</span><span class="sxs-lookup"><span data-stu-id="6567e-183">Subsequent event handlers are ignored.</span></span>
  
 <span data-ttu-id="6567e-184">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-184">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-185">下面的示例演示<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-185">The following sample demonstrates the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-186">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-186">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-187">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-187">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-188">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-188">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-189">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-189">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a"><span data-ttu-id="6567e-190">解决程序集加载</span><span class="sxs-lookup"><span data-stu-id="6567e-190">Resolving Assembly Loads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-191">获取基目录，它由程序集冲突解决程序用来探测程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-191">Gets the base directory that the assembly resolver uses to probe for assemblies.</span></span></summary>
        <value><span data-ttu-id="6567e-192">基目录，由程序集冲突解决程序用来探测程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-192">The base directory that the assembly resolver uses to probe for assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-193">此属性与<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>属性相对应。</span><span class="sxs-lookup"><span data-stu-id="6567e-193">This property corresponds to the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="6567e-194">也可以使用字符串 "APPBASE" <xref:System.AppDomain.GetData%2A>的方法来检索它。</span><span class="sxs-lookup"><span data-stu-id="6567e-194">It can also be retrieved using the <xref:System.AppDomain.GetData%2A> method with the string "APPBASE".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-195">下面的代码示例创建一个新的应用程序域, 指定在搜索要加载到域中的程序集时要使用的基目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-195">The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</span></span> <span data-ttu-id="6567e-196">然后, 该示例使用<xref:System.AppDomain.BaseDirectory%2A>属性获取基目录路径, 以便向控制台显示。</span><span class="sxs-lookup"><span data-stu-id="6567e-196">The example then uses the <xref:System.AppDomain.BaseDirectory%2A> property to obtain the base directory path, for display to the console.</span></span>  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-197">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-197">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-198">用于访问路径本身中的信息, 包括路径的格式为 "file://" 或\\"\UNC\dir" 或 "c:\\"。</span><span class="sxs-lookup"><span data-stu-id="6567e-198">for access to the information in the path itself, including if the path is in the form "file://" or \\\UNC\dir or "c:\\".</span></span> <span data-ttu-id="6567e-199">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-199">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-200">将指定专用程序集位置的路径重置为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6567e-200">Resets the path that specifies the location of private assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-201">私有路径是公共语言运行时搜索以查找私有程序集的基目录的相对路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-201">The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</span></span>  
  
 <span data-ttu-id="6567e-202">有关详细信息，请参阅 <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6567e-202">For more information, see <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-203">下面的代码示例演示了如何使用<xref:System.AppDomain.ClearPrivatePath%2A>方法从专用路径列表中移除所有项, 以便在加载程序集时搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-203">The following code example demonstrates how to use the <xref:System.AppDomain.ClearPrivatePath%2A> method to remove all entries from the list of private paths to search when assemblies are loaded.</span></span>  
  
 <span data-ttu-id="6567e-204">此方法现已过时, 不应用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-204">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-205">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-205">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-206">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-206">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-207">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-207">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-208">将包含影像复制的程序集的目录列表重置为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6567e-208">Resets the list of directories containing shadow copied assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-209">卷影副本路径是存储卷影复制的程序集的目录的列表。</span><span class="sxs-lookup"><span data-stu-id="6567e-209">The shadow copy path is a list of directories where shadow copied assemblies are stored.</span></span>  
  
 <span data-ttu-id="6567e-210">有关详细信息, 请<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>参阅和[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-210">For more information, see <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-211">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-211">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-212">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-212">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-213">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-213">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="6567e-214">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="6567e-214">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-215">创建指定 COM 类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-215">Creates a new instance of a specified COM type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-216">文件的名称，该文件包含定义所请求的类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-216">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-217">所请求类型的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-217">The name of the requested type.</span></span></param>
        <summary><span data-ttu-id="6567e-218">创建指定 COM 类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-218">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="6567e-219">形参指定文件的名称，该文件包含含有类型和类型名称的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-219">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="6567e-220">一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-220">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="6567e-221">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-221">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-222">使用此方法可以远程创建对象, 而无需在本地加载类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-222">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="6567e-223">必须将返回值解包, 才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-223">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="6567e-224">必须显式或默认情况下`true`将值为的<xref:System.TypeLoadException>属性应用于 COM 类型, 此方法才能创建该类型的实例; 否则, 将引发。 <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="6567e-224">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-225">下面的示例演示</span><span class="sxs-lookup"><span data-stu-id="6567e-225">The following sample demonstrates</span></span>  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-226"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-226"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-227">无法加载此类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-227">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-228">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-228">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-229">未找到公共无形参构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-229">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-230"><paramref name="assemblyName" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-230"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="6567e-231"><paramref name="typeName" /> 是一个抽象类。</span><span class="sxs-lookup"><span data-stu-id="6567e-231"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="6567e-232">或</span><span class="sxs-lookup"><span data-stu-id="6567e-232">-or-</span></span> 
<span data-ttu-id="6567e-233">使用晚期绑定机制调用了此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-233">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-234">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-234">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-235"><paramref name="assemblyName" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6567e-235"><paramref name="assemblyName" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-236"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-236"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-237">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-237">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-238">所引用的 COM 对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-238">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-239">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-239">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-240">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-240">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-241">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-241">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-242">文件的名称，该文件包含定义所请求的类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-242">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-243">所请求类型的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-243">The name of the requested type.</span></span></param>
        <param name="hashValue"><span data-ttu-id="6567e-244">表示计算所得的哈希代码的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-244">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="6567e-245">表示程序集清单使用的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="6567e-245">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="6567e-246">创建指定 COM 类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-246">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="6567e-247">形参指定文件的名称，该文件包含含有类型和类型名称的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-247">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="6567e-248">一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-248">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="6567e-249">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-249">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-250">使用此方法可以远程创建对象, 而无需在本地加载类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-250">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="6567e-251">必须将返回值解包, 才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-251">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="6567e-252">必须显式或默认情况下`true`将值为的<xref:System.TypeLoadException>属性应用于 COM 类型, 此方法才能创建该类型的实例; 否则, 将引发。 <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="6567e-252">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-253"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-253"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-254">无法加载此类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-254">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-255">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-255">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-256">未找到公共无形参构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-256">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-257"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-257"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="6567e-258"><paramref name="typeName" /> 是一个抽象类。</span><span class="sxs-lookup"><span data-stu-id="6567e-258"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="6567e-259">或</span><span class="sxs-lookup"><span data-stu-id="6567e-259">-or-</span></span> 
<span data-ttu-id="6567e-260">使用晚期绑定机制调用了此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-260">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-261">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-261">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-262"><paramref name="assemblyFile" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6567e-262"><paramref name="assemblyFile" /> is the empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-263"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-263"><paramref name="assemblyFile" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-264">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-264">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-265">所引用的 COM 对象为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-265">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-266">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-266">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-267">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-267">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-268">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-268">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-269">创建新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-269">Creates a new application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="6567e-270">域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-270">The friendly name of the domain.</span></span></param>
        <summary><span data-ttu-id="6567e-271">使用指定的名称新建应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-271">Creates a new application domain with the specified name.</span></span></summary>
        <returns><span data-ttu-id="6567e-272">新创建的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-272">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-273">`friendlyName`参数用于标识域, 这种方式对于人来说是有意义的。</span><span class="sxs-lookup"><span data-stu-id="6567e-273">The `friendlyName` parameter is intended to identify the domain in a manner that is meaningful to humans.</span></span> <span data-ttu-id="6567e-274">此字符串应适合在用户界面中显示。</span><span class="sxs-lookup"><span data-stu-id="6567e-274">This string should be suitable for display in user interfaces.</span></span>  
  
 <span data-ttu-id="6567e-275">此方法重载使用来自<xref:System.AppDomainSetup>默认应用程序域的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-275">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-276">下面的示例演示了如何使用其中一个<xref:System.AppDomain.CreateDomain%2A>重载创建域。</span><span class="sxs-lookup"><span data-stu-id="6567e-276">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-277"><paramref name="friendlyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-277"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="6567e-278">方法在 .NET Core 上不受支持。</span><span class="sxs-lookup"><span data-stu-id="6567e-278">Method not supported on .NET Core.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-279">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-279">to provide evidence.</span></span> <span data-ttu-id="6567e-280">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-280">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="6567e-281">域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-281">The friendly name of the domain.</span></span> <span data-ttu-id="6567e-282">此友好名称可在用户界面中显示以标识域。</span><span class="sxs-lookup"><span data-stu-id="6567e-282">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="6567e-283">有关详细信息，请参阅 <see cref="P:System.AppDomain.FriendlyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-283">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="6567e-284">确定代码标识的证据，该代码在应用程序域中运行。</span><span class="sxs-lookup"><span data-stu-id="6567e-284">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="6567e-285">传递 <see langword="null" /> 以使用当前应用程序域的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-285">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <summary><span data-ttu-id="6567e-286">使用所提供的证据创建具有给定名称的新应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-286">Creates a new application domain with the given name using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="6567e-287">新创建的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-287">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-288">此方法重载使用来自<xref:System.AppDomainSetup>默认应用程序域的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-288">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="6567e-289">如果`securityInfo`未提供, 则使用当前应用程序域中的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-289">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-290">不要使用此方法重载来创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-290">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="6567e-291">从开始`securityInfo` , 提供的证据不再影响应用程序域的授予集。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-291">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="6567e-292"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>使用方法重载创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-292">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-293">下面的示例演示了如何使用其中一个<xref:System.AppDomain.CreateDomain%2A>重载创建域。</span><span class="sxs-lookup"><span data-stu-id="6567e-293">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-294"><paramref name="friendlyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-294"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-295">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-295">to provide evidence.</span></span> <span data-ttu-id="6567e-296">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-296">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="6567e-297">域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-297">The friendly name of the domain.</span></span> <span data-ttu-id="6567e-298">此友好名称可在用户界面中显示以标识域。</span><span class="sxs-lookup"><span data-stu-id="6567e-298">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="6567e-299">有关详细信息，请参阅 <see cref="P:System.AppDomain.FriendlyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-299">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="6567e-300">确定代码标识的证据，该代码在应用程序域中运行。</span><span class="sxs-lookup"><span data-stu-id="6567e-300">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="6567e-301">传递 <see langword="null" /> 以使用当前应用程序域的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-301">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="6567e-302">包含应用程序域初始化信息的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-302">An object that contains application domain initialization information.</span></span></param>
        <summary><span data-ttu-id="6567e-303">使用指定的名称、证据和应用程序域设置信息创建新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-303">Creates a new application domain using the specified name, evidence, and application domain setup information.</span></span></summary>
        <returns><span data-ttu-id="6567e-304">新创建的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-304">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-305">如果`info`未提供, 此方法重载将使用来自<xref:System.AppDomainSetup>默认应用程序域的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-305">If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="6567e-306">如果`securityInfo`未提供, 则使用当前应用程序域中的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-306">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-307">不要使用此方法重载来创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-307">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="6567e-308">从开始`securityInfo` , 提供的证据不再影响应用程序域的授予集。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-308">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="6567e-309"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>使用方法重载创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-309">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-310">下面的示例演示了如何使用其中一个<xref:System.AppDomain.CreateDomain%2A>重载创建域。</span><span class="sxs-lookup"><span data-stu-id="6567e-310">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-311"><paramref name="friendlyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-311"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-312">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-312">to provide evidence.</span></span> <span data-ttu-id="6567e-313">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-313">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="info" Type="System.AppDomainSetup" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="6567e-314">域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-314">The friendly name of the domain.</span></span> <span data-ttu-id="6567e-315">此友好名称可在用户界面中显示以标识域。</span><span class="sxs-lookup"><span data-stu-id="6567e-315">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="6567e-316">有关更多信息，请参见 <see cref="P:System.AppDomain.FriendlyName" /> 的说明。</span><span class="sxs-lookup"><span data-stu-id="6567e-316">For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="6567e-317">确定代码标识的证据，该代码在应用程序域中运行。</span><span class="sxs-lookup"><span data-stu-id="6567e-317">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="6567e-318">传递 <see langword="null" /> 以使用当前应用程序域的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-318">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="6567e-319">包含应用程序域初始化信息的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-319">An object that contains application domain initialization information.</span></span></param>
        <param name="grantSet"><span data-ttu-id="6567e-320">一个默认权限集，被授予加载到新应用程序域的所有无特定权限的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-320">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</span></span></param>
        <param name="fullTrustAssemblies"><span data-ttu-id="6567e-321">一组强名称，表示在新应用程序域中被认为完全受信任的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-321">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</span></span></param>
        <summary><span data-ttu-id="6567e-322">使用指定的名称、证据、应用程序域设置信息、默认权限集和一组完全受信任的程序集创建新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-322">Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</span></span></summary>
        <returns><span data-ttu-id="6567e-323">新创建的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-323">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-324">必须设置<xref:System.AppDomainSetup.ApplicationBase%2A>为<xref:System.AppDomainSetup> 提供的`info`对象的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-324">You must set the <xref:System.AppDomainSetup.ApplicationBase%2A> property of the <xref:System.AppDomainSetup> object that you supply for `info`.</span></span> <span data-ttu-id="6567e-325">否则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-325">Otherwise, an exception is thrown.</span></span>  
  
 <span data-ttu-id="6567e-326">如果`securityInfo`未提供, 则使用当前应用程序域中的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-326">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="6567e-327">为`grantSet` <xref:System.Security.Policy.ApplicationTrust>和`fullTrustAssemblies`提供的信息用于为新的应用程序域创建对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-327">The information provided for `grantSet` and `fullTrustAssemblies` is used to create an <xref:System.Security.Policy.ApplicationTrust> object for the new application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-328"><paramref name="friendlyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-328"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6567e-329">应用程序域为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-329">The application domain is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-330">或</span><span class="sxs-lookup"><span data-stu-id="6567e-330">-or-</span></span> 
<span data-ttu-id="6567e-331"><see cref="P:System.AppDomainSetup.ApplicationBase" /> 属性在为 <paramref name="info" /> 提供的 <see cref="T:System.AppDomainSetup" /> 对象上没有设置。</span><span class="sxs-lookup"><span data-stu-id="6567e-331">The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-332">用于创建和操作应用程序域的功能。</span><span class="sxs-lookup"><span data-stu-id="6567e-332">for the ability to create and manipulate an application domain.</span></span> <span data-ttu-id="6567e-333">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-333">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="6567e-334">安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-334">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="6567e-335">域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-335">The friendly name of the domain.</span></span> <span data-ttu-id="6567e-336">此友好名称可在用户界面中显示以标识域。</span><span class="sxs-lookup"><span data-stu-id="6567e-336">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="6567e-337">有关详细信息，请参阅 <see cref="P:System.AppDomain.FriendlyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-337">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="6567e-338">确定代码标识的证据，该代码在应用程序域中运行。</span><span class="sxs-lookup"><span data-stu-id="6567e-338">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="6567e-339">传递 <see langword="null" /> 以使用当前应用程序域的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-339">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="6567e-340">基目录，由程序集冲突解决程序用来探测程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-340">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="6567e-341">有关详细信息，请参阅 <see cref="P:System.AppDomain.BaseDirectory" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-341">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="6567e-342">相对于基目录的路径，在此程序集冲突解决程序应探测专用程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-342">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="6567e-343">有关详细信息，请参阅 <see cref="P:System.AppDomain.RelativeSearchPath" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-343">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="6567e-344">如果为 <see langword="true" />，则向此应用程序域中加载程序集的卷影副本。</span><span class="sxs-lookup"><span data-stu-id="6567e-344">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</span></span></param>
        <summary><span data-ttu-id="6567e-345">使用证据、应用程序基路径、相对搜索路径和指定是否向应用程序域中加载程序集的影像副本的形参创建具有给定名称的新应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-345">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span></summary>
        <returns><span data-ttu-id="6567e-346">新创建的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-346">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-347">如果`securityInfo`未提供, 则使用当前应用程序域中的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-347">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="6567e-348">有关卷影复制的详细信息, <xref:System.AppDomain.ShadowCopyFiles%2A>请参阅和[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-348">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-349">不要使用此方法重载来创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-349">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="6567e-350">从开始`securityInfo` , 提供的证据不再影响应用程序域的授予集。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-350">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="6567e-351"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>使用方法重载创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-351">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-352">下面的示例演示了如何使用其中一个<xref:System.AppDomain.CreateDomain%2A>重载创建域。</span><span class="sxs-lookup"><span data-stu-id="6567e-352">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-353"><paramref name="friendlyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-353"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-354">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-354">to provide evidence.</span></span> <span data-ttu-id="6567e-355">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-355">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appBasePath" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="adInitArgs" Type="System.String[]" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="6567e-356">域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-356">The friendly name of the domain.</span></span> <span data-ttu-id="6567e-357">此友好名称可在用户界面中显示以标识域。</span><span class="sxs-lookup"><span data-stu-id="6567e-357">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="6567e-358">有关详细信息，请参阅 <see cref="P:System.AppDomain.FriendlyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-358">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="6567e-359">确定代码标识的证据，该代码在应用程序域中运行。</span><span class="sxs-lookup"><span data-stu-id="6567e-359">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="6567e-360">传递 <see langword="null" /> 以使用当前应用程序域的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-360">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="6567e-361">基目录，由程序集冲突解决程序用来探测程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-361">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="6567e-362">有关详细信息，请参阅 <see cref="P:System.AppDomain.BaseDirectory" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-362">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="6567e-363">相对于基目录的路径，在此程序集冲突解决程序应探测专用程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-363">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="6567e-364">有关详细信息，请参阅 <see cref="P:System.AppDomain.RelativeSearchPath" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-364">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="6567e-365">如果为 <see langword="true" />，则将程序集的卷影副本加载到应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-365"><see langword="true" /> to load a shadow copy of an assembly into the application domain.</span></span></param>
        <param name="adInit"><span data-ttu-id="6567e-366"><see cref="T:System.AppDomainInitializer" /> 委托，表示初始化新的 <see cref="T:System.AppDomain" /> 对象时调用的回调方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-366">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <param name="adInitArgs"><span data-ttu-id="6567e-367">字符串实参数组，在初始化新的 <see cref="T:System.AppDomain" /> 对象时传递给由 <paramref name="adInit" /> 表示的回调。</span><span class="sxs-lookup"><span data-stu-id="6567e-367">An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <summary><span data-ttu-id="6567e-368">使用证据、应用程序基路径、相对搜索路径和指定是否向应用程序域中加载程序集的影像副本的形参创建具有给定名称的新应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-368">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span> <span data-ttu-id="6567e-369">指定在初始化应用程序域时调用的回调方法，以及传递回调方法的字符串实参数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-369">Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</span></span></summary>
        <returns><span data-ttu-id="6567e-370">新创建的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-370">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-371">所表示`adInit`的方法在新创建的应用程序域的上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-371">The method represented by `adInit` is executed in the context of the newly created application domain.</span></span>  
  
 <span data-ttu-id="6567e-372">如果`securityInfo`未提供, 则使用当前应用程序域中的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-372">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="6567e-373">有关卷影复制的详细信息, <xref:System.AppDomain.ShadowCopyFiles%2A>请参阅和[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-373">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-374">不要使用此方法重载来创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-374">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="6567e-375">从开始`securityInfo` , 提供的证据不再影响应用程序域的授予集。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-375">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="6567e-376"><xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29>使用方法重载创建沙盒应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-376">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-377"><paramref name="friendlyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-377"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-378">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-378">to provide evidence.</span></span> <span data-ttu-id="6567e-379">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-379">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-380">创建在指定程序集中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-380">Creates a new instance of a specified type defined in a specified assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-381">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-381">The display name of the assembly.</span></span> <span data-ttu-id="6567e-382">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-382">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-383"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-383">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="6567e-384">创建在指定程序集中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-384">Creates a new instance of the specified type defined in the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="6567e-385">一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-385">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="6567e-386">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-386">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-387">此方法调用的无参数构造`typeName`函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-387">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="6567e-388">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-388">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="6567e-389">尝试对不是<xref:System.AppDomain.CreateInstance%2A>当前应用程序域的目标应用程序域调用将导致成功地在目标应用程序域中加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-389">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="6567e-390">由于不<xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>是, 因此当此方法尝试将加载的程序集的加载到当前应用程序域时, 公共语言运行时将尝试将程序集加载到当前应用程序域和<xref:System.MarshalByRefObject>加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-390">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="6567e-391">如果两个应用程序域的路径设置不同, 则加载到当前应用程序域中的程序集可能不同于首先加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-391">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-392">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-392">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-393"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-393"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-394"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-394"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-395">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-395">-or-</span></span> 
<span data-ttu-id="6567e-396">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-396">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-397">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-397">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-398">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-398"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-399">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-399">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-400">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-400">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-401">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-401"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-402">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-402">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-403">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-404">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-405">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-405">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-406">用于在创建委托的实例时调用非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-406">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="6567e-407">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="6567e-407">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-408">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-408">The display name of the assembly.</span></span> <span data-ttu-id="6567e-409">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-409">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-410"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-410">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-411">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-411">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-412">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-412">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-413">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-413">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-414">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-414">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-415">创建在指定程序集中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-415">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="6567e-416">形参指定激活特性数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-416">A parameter specifies an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="6567e-417">一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-417">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="6567e-418">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-418">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-419">此方法调用的无参数构造`typeName`函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-419">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="6567e-420">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-420">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="6567e-421">尝试对不是<xref:System.AppDomain.CreateInstance%2A>当前应用程序域的目标应用程序域调用将导致成功地在目标应用程序域中加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-421">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="6567e-422">由于不<xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>是, 因此当此方法尝试将加载的程序集的加载到当前应用程序域时, 公共语言运行时将尝试将程序集加载到当前应用程序域和<xref:System.MarshalByRefObject>加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-422">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="6567e-423">如果两个应用程序域的路径设置不同, 则加载到当前应用程序域中的程序集可能不同于首先加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-423">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-424">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-424">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-425"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-425"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-426"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-426"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-427">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-427">-or-</span></span> 
<span data-ttu-id="6567e-428">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-428">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-429">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-429">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-430">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-430"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-431">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-431">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-432">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-432">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-433">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-433">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-434">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-434"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-435">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-435">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-436">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-436">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-437">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-437">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-438">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-438">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-439">用于在创建委托的实例时调用非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-439">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="6567e-440">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="6567e-440">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="6567e-441">用于在所有类型成员上调用操作的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-441">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="6567e-442">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="6567e-442">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-443">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-443">The display name of the assembly.</span></span> <span data-ttu-id="6567e-444">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-444">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-445"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-445">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-446">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-446">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-447">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-447">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-448">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-448">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-449">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-449">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="6567e-450">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-450">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-451">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-451">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-452">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-452">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-453">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-453">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-454">区域性特定的信息，这些信息控制将 <paramref name="args" /> 强制转换为 <paramref name="typeName" /> 构造函数所声明的正式类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-454">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-455">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-455">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-456">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-456">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-457">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-457">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-458">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="6567e-458">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="6567e-459">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-459">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-460">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-460">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-461">创建在指定程序集中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-461">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="6567e-462">形参指定联编程序、绑定标志、构造函数实参、用于解释实参的特定于区域性的信息，以及可选激活特性。</span><span class="sxs-lookup"><span data-stu-id="6567e-462">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</span></span></summary>
        <returns><span data-ttu-id="6567e-463">一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-463">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="6567e-464">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-464">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-465">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-465">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="6567e-466">尝试对不是<xref:System.AppDomain.CreateInstance%2A>当前应用程序域的目标应用程序域调用将导致成功地在目标应用程序域中加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-466">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="6567e-467">由于不<xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>是, 因此当此方法尝试将加载的程序集的加载到当前应用程序域时, 公共语言运行时将尝试将程序集加载到当前应用程序域和<xref:System.MarshalByRefObject>加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-467">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="6567e-468">如果两个应用程序域的路径设置不同, 则加载到当前应用程序域中的程序集可能不同于首先加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-468">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-469">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-470"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-470"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-471"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-471"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-472">或</span><span class="sxs-lookup"><span data-stu-id="6567e-472">-or-</span></span> 
 <span data-ttu-id="6567e-473"><paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-473"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-474">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-474">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-475">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-475"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-476">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-476">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-477">未找到匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-477">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-478">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-478">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-479">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-479"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-480">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-480">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-481">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-481">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-482">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-482">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-483">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-483">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-484">用于在创建委托的实例时调用非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-484">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="6567e-485">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="6567e-485">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="6567e-486">用于在所有类型成员上调用操作的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-486">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="6567e-487">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="6567e-487">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-488">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-488">The display name of the assembly.</span></span> <span data-ttu-id="6567e-489">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-489">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-490"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-490">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-491">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-491">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-492">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-492">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-493">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-493">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-494">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-494">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="6567e-495">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-495">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-496">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-496">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-497">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-497">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-498">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-498">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-499">区域性特定的信息，这些信息控制将 <paramref name="args" /> 强制转换为 <paramref name="typeName" /> 构造函数所声明的正式类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-499">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-500">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-500">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-501">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-501">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-502">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-502">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-503">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-503">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-504">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-504">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="6567e-505">用于授权创建 <paramref name="typeName" /> 的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-505">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="6567e-506">创建在指定程序集中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-506">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="6567e-507">形参指定联编程序、绑定标志、构造函数实参、特定于区域性的信息，这些信息用于解释实参、激活特性和授权，以创建类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-507">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</span></span></summary>
        <returns><span data-ttu-id="6567e-508">一个对象，该对象是 <paramref name="typeName" /> 指定的新实例的包装。</span><span class="sxs-lookup"><span data-stu-id="6567e-508">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="6567e-509">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-509">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-510">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-510">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="6567e-511">尝试对不是<xref:System.AppDomain.CreateInstance%2A>当前应用程序域的目标应用程序域调用将导致成功地在目标应用程序域中加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-511">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="6567e-512">由于不<xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>是, 因此当此方法尝试将加载的程序集的加载到当前应用程序域时, 公共语言运行时将尝试将程序集加载到当前应用程序域和<xref:System.MarshalByRefObject>加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-512">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="6567e-513">如果两个应用程序域的路径设置不同, 则加载到当前应用程序域中的程序集可能不同于首先加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-513">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-514">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-514">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-515"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-515"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-516"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-516"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-517">或</span><span class="sxs-lookup"><span data-stu-id="6567e-517">-or-</span></span> 
<span data-ttu-id="6567e-518">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-518">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-519">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-519">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-520">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-520"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-521">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-521">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-522">未找到匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-522">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-523">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-523">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="6567e-524">或</span><span class="sxs-lookup"><span data-stu-id="6567e-524">-or-</span></span> 
 <span data-ttu-id="6567e-525"><paramref name="securityAttributes" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-525"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="6567e-526">未启用旧版 CAS 策略时，<paramref name="securityAttributes" /> 应该为 <see langword="null." /></span><span class="sxs-lookup"><span data-stu-id="6567e-526">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-527">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-527"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-528">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-528">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-529">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-529">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-530">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-530">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-531">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-531">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-532">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-532">to provide evidence.</span></span> <span data-ttu-id="6567e-533">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-533">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="6567e-534">用于在所有类型成员上调用操作的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-534">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="6567e-535">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="6567e-535">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-536">创建指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-536">Creates a new instance of a specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-537">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-537">The display name of the assembly.</span></span> <span data-ttu-id="6567e-538">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-538">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-539"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-539">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="6567e-540">创建指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-540">Creates a new instance of the specified type.</span></span> <span data-ttu-id="6567e-541">形参指定定义类型的程序集以及类型的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-541">Parameters specify the assembly where the type is defined, and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="6567e-542"><paramref name="typeName" /> 所指定对象的实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-542">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-543">这是组合<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-543">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6567e-544">此方法调用的无参数构造`typeName`函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-544">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="6567e-545">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-545">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="6567e-546">请参阅的`typeName`格式的属性。<xref:System.Type.FullName%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="6567e-546">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-547">`M`如果对返回`C` `T2`的类型 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> `T1`为的对象的方法进行早期绑定调用, 并且该方法对程序集中的类型为的对象的方法进行早期绑定调用, 则该方法除外当前程序集或包含`T1` `C`的程序集将加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-547">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="6567e-548">即使对的早期绑定调用`T1.M()`是在的主体<xref:System.Reflection.Emit.DynamicMethod>或其他动态生成的代码中进行的, 也会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-548">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="6567e-549">如果当前域为默认域, 则在进程`C`结束之前, 不能卸载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-549">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="6567e-550">如果当前域稍后尝试加载程序集`C`, 则加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-550">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-551">下面的代码示例演示了在其他应用程序域中执行代码的最简单方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-551">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="6567e-552">该示例定义了一个从`Worker` <xref:System.MarshalByRefObject>继承的名为的类。</span><span class="sxs-lookup"><span data-stu-id="6567e-552">The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="6567e-553">`Worker`类定义一个方法, 该方法显示执行它的应用程序域的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-553">The `Worker` class defines a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="6567e-554">该示例在默认应用`Worker`程序域和新的应用程序域中创建的实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-554">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-555">必须将包含`Worker`的程序集加载到这两个应用程序域中, 但它可以加载仅存在于新应用程序域中的其他程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-555">The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-556"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-556"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-557">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-557">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-558">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-558"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-559">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-559"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-560">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-560">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-561">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-561">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-562"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-562"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-563">或</span><span class="sxs-lookup"><span data-stu-id="6567e-563">-or-</span></span> 
<span data-ttu-id="6567e-564">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-564">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-565">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-565">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-566">对于读取包含程序集清单的文件的功能, 或者如果从清单文件之外的模块创建类型, 则为。</span><span class="sxs-lookup"><span data-stu-id="6567e-566">for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</span></span> <span data-ttu-id="6567e-567">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-567">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-568">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-568">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-569">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-569">The display name of the assembly.</span></span> <span data-ttu-id="6567e-570">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-570">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-571"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-571">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-572">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-572">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-573">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-573">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-574">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-574">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-575">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-575">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-576">创建指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-576">Creates a new instance of the specified type.</span></span> <span data-ttu-id="6567e-577">形参指定定义类型的程序集、类型的名称和激活特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-577">Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="6567e-578"><paramref name="typeName" /> 所指定对象的实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-578">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-579">这是组合<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-579">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6567e-580">此方法调用的无参数构造`typeName`函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-580">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="6567e-581">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-581">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="6567e-582">请参阅的`typeName`格式的属性。<xref:System.Type.FullName%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="6567e-582">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-583">`M`如果对返回`C` `T2`的类型 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> `T1`为的对象的方法进行早期绑定调用, 并且该方法对程序集中的类型为的对象的方法进行早期绑定调用, 则该方法除外当前程序集或包含`T1` `C`的程序集将加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-583">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="6567e-584">即使对的早期绑定调用`T1.M()`是在的主体<xref:System.Reflection.Emit.DynamicMethod>或其他动态生成的代码中进行的, 也会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-584">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="6567e-585">如果当前域为默认域, 则在进程`C`结束之前, 不能卸载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-585">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="6567e-586">如果当前域稍后尝试加载程序集`C`, 则加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-586">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-587"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-587"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-588">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-588">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-589">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-589"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-590">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-590"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-591">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-591">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-592">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-592">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-593">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-593">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-594"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-594"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-595">或</span><span class="sxs-lookup"><span data-stu-id="6567e-595">-or-</span></span> 
<span data-ttu-id="6567e-596">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-596">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-597">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-597">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-598">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-598">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-599">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-599">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-600">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-600">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-601">用于在创建委托的实例时调用非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-601">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="6567e-602">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="6567e-602">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="6567e-603">用于在所有类型成员上调用操作的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-603">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="6567e-604">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="6567e-604">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-605">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-605">The display name of the assembly.</span></span> <span data-ttu-id="6567e-606">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-606">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-607"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-607">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-608">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-608">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-609">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-609">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-610">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-610">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-611">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-611">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="6567e-612">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-612">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-613">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-613">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-614">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-614">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-615">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-615">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-616">用于控制类型强制的特定于区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-616">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="6567e-617">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-617">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-618">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-618">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-619">通常是包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-619">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object.</span></span> <span data-ttu-id="6567e-620">指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-620">that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-621">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="6567e-621">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="6567e-622">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-622">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-623">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-623">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-624">创建在指定的程序集中定义的指定类型的新实例，指定是否忽略类型名称的大小写，并指定绑定特性和用于选择要创建的类型的联编程序、构造函数的自变量、区域性以及激活特性。</span><span class="sxs-lookup"><span data-stu-id="6567e-624">Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="6567e-625"><paramref name="typeName" /> 所指定对象的实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-625">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-626">这是组合<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-626">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6567e-627">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-627">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="6567e-628">请参阅的`typeName`格式的属性。<xref:System.Type.FullName%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="6567e-628">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-629">`M`如果对返回`C` `T2`的类型 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> `T1`为的对象的方法进行早期绑定调用, 并且该方法对程序集中的类型为的对象的方法进行早期绑定调用, 则该方法除外当前程序集或包含`T1` `C`的程序集将加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-629">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="6567e-630">即使对的早期绑定调用`T1.M()`是在的主体<xref:System.Reflection.Emit.DynamicMethod>或其他动态生成的代码中进行的, 也会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-630">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="6567e-631">如果当前域为默认域, 则在进程`C`结束之前, 不能卸载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-631">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="6567e-632">如果当前域稍后尝试加载程序集`C`, 则加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-632">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-633">下面的示例演示如何使用`ignoreCase`参数。</span><span class="sxs-lookup"><span data-stu-id="6567e-633">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-634"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-634"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-635">未找到匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-635">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-636">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-636"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-637">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-637"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-638">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-638">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-639">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-639">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-640">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-640">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-641"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-641"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-642">或</span><span class="sxs-lookup"><span data-stu-id="6567e-642">-or-</span></span> 
 <span data-ttu-id="6567e-643"><paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-643"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-644">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-644">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-645">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-645">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-646">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-646">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-647">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-647">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-648">用于在创建委托的实例时调用非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-648">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="6567e-649">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="6567e-649">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="6567e-650">用于在所有类型成员上调用操作的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-650">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="6567e-651">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="6567e-651">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-652">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-652">The display name of the assembly.</span></span> <span data-ttu-id="6567e-653">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-654"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-654">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-655">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-655">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-656">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-656">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-657">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-657">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-658">一个对象，它使用反射启用绑定、参数类型的强制、成员的调用和 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-658">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="6567e-659">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-659">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-660">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-660">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-661">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-661">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-662">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-662">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-663">用于控制类型强制的特定于区域性的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-663">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="6567e-664">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-664">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-665">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-665">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-666">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-666">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-667">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="6567e-667">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="6567e-668">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-668">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-669">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-669">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="6567e-670">用于授权创建 <paramref name="typeName" /> 的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-670">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="6567e-671">创建指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-671">Creates a new instance of the specified type.</span></span> <span data-ttu-id="6567e-672">形参指定类型的名称以及查找和创建该类型的方式。</span><span class="sxs-lookup"><span data-stu-id="6567e-672">Parameters specify the name of the type, and how it is found and created.</span></span></summary>
        <returns><span data-ttu-id="6567e-673"><paramref name="typeName" /> 所指定对象的实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-673">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-674">这是组合<xref:System.AppDomain.CreateInstance%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-674">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6567e-675">有关<xref:System.Reflection.AssemblyName> 的`assemblyName`格式, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6567e-675">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="6567e-676">请参阅的`typeName`格式的属性。<xref:System.Type.FullName%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="6567e-676">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-677">`M`如果对返回`C` `T2`的类型 <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> `T1`为的对象的方法进行早期绑定调用, 并且该方法对程序集中的类型为的对象的方法进行早期绑定调用, 则该方法除外当前程序集或包含`T1` `C`的程序集将加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-677">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="6567e-678">即使对的早期绑定调用`T1.M()`是在的主体<xref:System.Reflection.Emit.DynamicMethod>或其他动态生成的代码中进行的, 也会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-678">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="6567e-679">如果当前域为默认域, 则在进程`C`结束之前, 不能卸载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-679">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="6567e-680">如果当前域稍后尝试加载程序集`C`, 则加载可能会失败。</span><span class="sxs-lookup"><span data-stu-id="6567e-680">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-681">下面的示例演示如何使用`ignoreCase`参数。</span><span class="sxs-lookup"><span data-stu-id="6567e-681">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-682"><paramref name="assemblyName" /> 或 <paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-682"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-683">未找到匹配的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-683">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-684">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typename" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-684"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-685">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-685"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-686">调用方没有权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-686">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-687">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-687">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-688">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-688">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-689"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-689"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-690">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-690">-or-</span></span> 
<span data-ttu-id="6567e-691">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-691">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-692">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-692">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-693">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-693">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-694">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-694">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-695">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-695">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-696">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-696">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-697">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-697">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="6567e-698">用于在所有类型成员上调用操作的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-698">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="6567e-699">关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="6567e-699">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-700">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-700">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-701">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-701">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="6567e-702">该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</span><span class="sxs-lookup"><span data-stu-id="6567e-702">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-703"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-703">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="6567e-704">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-704">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="6567e-705">一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-705">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="6567e-706">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-706">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-707">调用的无参数`typeName`构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-707">The parameterless constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="6567e-708">有关更多信息，请参见 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-708">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6567e-709"><xref:System.AppDomain.CreateInstanceFrom%2A>当方法用于创建目标应用程序域中的实例 (而不是调用的应用程序域) 时, 将在目标应用程序域中加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-709">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="6567e-710">但是, 如果实例在调用应用程序域中解包, 则以特定方式使用已解包的实例可能会导致程序集加载到调用应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-710">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="6567e-711">例如, 在实例解包后, 可能会请求其类型信息, 以便以后调用其方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-711">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="6567e-712">将程序集加载到调用应用程序域时, 可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-712">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="6567e-713">如果以前将同一程序集的另一个版本加载到调用应用程序域中, 或调用应用程序域的加载路径不同于目标应用程序域的加载路径, 则<xref:System.MissingMethodException>可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-713">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="6567e-714">如果调用应用程序域对实例类型进行早期绑定调用, <xref:System.InvalidCastException>则可以在尝试强制转换实例时引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-714">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-715">下面的示例演示如何使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法重载在目标应用程序域中创建对象的实例并调用其方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-715">The following example shows how to use the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to create an instance of an object in a target application domain and call its methods.</span></span>  
  
 <span data-ttu-id="6567e-716">该示例定义了`MarshalableExample`类, 该类可跨应用程序域边界进行封送处理。</span><span class="sxs-lookup"><span data-stu-id="6567e-716">The example defines the `MarshalableExample` class, which can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="6567e-717">该示例生成当前正在执行的程序集的路径, 创建目标应用程序域, 并使用<xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29>方法重载将示例程序集加载到目标应用程序域中并创建的`MarshalableExample`实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-717">The example builds a path to the currently executing assembly, creates a target application domain, and uses the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to load the example assembly into the target application domain and create an instance of `MarshalableExample`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-718">在此示例中, 路径是绝对路径, 但相对路径也会起作用<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> , 因为方法用于加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-718">The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used to load the assembly.</span></span>  
  
 <span data-ttu-id="6567e-719">解包对象句柄之后, 该示例演示了在目标应用程序域中使用对象的三种方法:</span><span class="sxs-lookup"><span data-stu-id="6567e-719">After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</span></span>  
  
-   <span data-ttu-id="6567e-720">使用反射通过后期绑定调用方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-720">Invoking a method with late binding, using reflection.</span></span> <span data-ttu-id="6567e-721">这需要类型信息, 这会导致程序集加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-721">This requires type information, which causes the assembly to be loaded into the application domain of the caller.</span></span> <span data-ttu-id="6567e-722">(在此示例中, 它已加载。)</span><span class="sxs-lookup"><span data-stu-id="6567e-722">(In this example, it is already loaded.)</span></span>  
  
-   <span data-ttu-id="6567e-723">将对象强制转换为调用方和被调用方都已知的接口。</span><span class="sxs-lookup"><span data-stu-id="6567e-723">Casting the object to an interface known to both the caller and the callee.</span></span> <span data-ttu-id="6567e-724">如果接口是在调用程序集或调用方和被调用方引用的第三个程序集中定义的, 则调用的程序集不会加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-724">If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</span></span>  
  
-   <span data-ttu-id="6567e-725">当调用方知道对象的类型时, 直接使用对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-725">Using the object directly when its type is known to the caller.</span></span> <span data-ttu-id="6567e-726">必须将程序集加载到调用方的应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-726">The assembly must be loaded into the application domain of the caller.</span></span>  
  
 <span data-ttu-id="6567e-727">避免将调用的程序集加载到调用方的应用程序域中的另一种方法是, 调用<xref:System.MarshalByRefObject>方从类派生, 并定义可在目标应用程序域中运行的方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-727">Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain.</span></span> <span data-ttu-id="6567e-728">该方法可以使用反射来检查目标程序集, 因为目标程序集已加载到目标应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-728">That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</span></span> <span data-ttu-id="6567e-729">请参阅<xref:System.AppDomain.DynamicDirectory%2A>属性的示例。</span><span class="sxs-lookup"><span data-stu-id="6567e-729">See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-730"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-730"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-731">或</span><span class="sxs-lookup"><span data-stu-id="6567e-731">-or-</span></span> 
 <span data-ttu-id="6567e-732"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-732"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-733">未找到 <paramref name="assemblyFile" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-733"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-734">在 <paramref name="assemblyFile" /> 中未找到 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-734"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-735">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-735">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-736">未找到无形参的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-736">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-737">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-737">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-738"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-738"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-739">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-739">-or-</span></span> 
<span data-ttu-id="6567e-740">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-740">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-741">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-741">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-742">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-742">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-743">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-743">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-744">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-744">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-745">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-745">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-746">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-746">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="6567e-747">该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</span><span class="sxs-lookup"><span data-stu-id="6567e-747">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-748"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-748">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-749">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-749">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-750">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-750">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-751">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-751">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-752">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-752">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-753">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-753">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="6567e-754">一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-754">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="6567e-755">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-755">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-756">调用的无参数`typeName`构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-756">The parameterless constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="6567e-757">有关此方法的详细信息, 请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-757">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6567e-758"><xref:System.AppDomain.CreateInstanceFrom%2A>当方法用于创建目标应用程序域中的实例 (而不是调用的应用程序域) 时, 将在目标应用程序域中加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-758">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="6567e-759">但是, 如果实例在调用应用程序域中解包, 则以特定方式使用已解包的实例可能会导致程序集加载到调用应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-759">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="6567e-760">例如, 在实例解包后, 可能会请求其类型信息, 以便以后调用其方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-760">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="6567e-761">将程序集加载到调用应用程序域时, 可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-761">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="6567e-762">如果以前将同一程序集的另一个版本加载到调用应用程序域中, 或调用应用程序域的加载路径不同于目标应用程序域的加载路径, 则<xref:System.MissingMethodException>可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-762">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="6567e-763">如果调用应用程序域对实例类型进行早期绑定调用, <xref:System.InvalidCastException>则可以在尝试强制转换实例时引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-763">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-764"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-764"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-765">未找到 <paramref name="assemblyFile" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-765"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-766">在 <paramref name="assemblyFile" /> 中未找到 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-766"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-767">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-767">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-768">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-768">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-769">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-769">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-770">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-770">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-771"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-771"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-772">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-772">-or-</span></span> 
<span data-ttu-id="6567e-773">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-773">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-774">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-774">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-775">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-775">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-776">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-776">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-777">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-777">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-778">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-778">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-779">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-779">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="6567e-780">该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</span><span class="sxs-lookup"><span data-stu-id="6567e-780">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-781"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-781">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-782">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-782">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-783">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-783">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-784">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-784">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-785">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-785">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="6567e-786">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-786">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-787">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-787">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-788">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-788">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-789">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-789">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-790">区域性特定的信息，这些信息控制将 <paramref name="args" /> 强制转换为 <paramref name="typeName" /> 构造函数所声明的正式类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-790">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-791">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-791">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-792">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-792">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-793">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-793">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-794">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="6567e-794">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="6567e-795">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-795">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-796">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-796">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-797">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-797">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="6567e-798">一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-798">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="6567e-799">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-799">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-800">有关更多信息，请参见 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-800">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6567e-801"><xref:System.AppDomain.CreateInstanceFrom%2A>当方法用于创建目标应用程序域中的实例 (而不是调用的应用程序域) 时, 将在目标应用程序域中加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-801">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="6567e-802">但是, 如果实例在调用应用程序域中解包, 则以特定方式使用已解包的实例可能会导致程序集加载到调用应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-802">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="6567e-803">例如, 在实例解包后, 可能会请求其类型信息, 以便以后调用其方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-803">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="6567e-804">将程序集加载到调用应用程序域时, 可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-804">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="6567e-805">如果以前将同一程序集的另一个版本加载到调用应用程序域中, 或调用应用程序域的加载路径不同于目标应用程序域的加载路径, 则<xref:System.MissingMethodException>可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-805">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="6567e-806">如果调用应用程序域对实例类型进行早期绑定调用, <xref:System.InvalidCastException>则可以在尝试强制转换实例时引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-806">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-807"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-807"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-808">或</span><span class="sxs-lookup"><span data-stu-id="6567e-808">-or-</span></span> 
 <span data-ttu-id="6567e-809"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-809"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-810">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-810">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-811">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-811">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-812">未找到 <paramref name="assemblyFile" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-812"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-813">在<paramref name="typeName" /> 中未找到 <paramref name="assemblyFile" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-813"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-814">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-814">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-815">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-815">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-816"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-816"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-817">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-817">-or-</span></span> 
 <span data-ttu-id="6567e-818"><paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-818"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-819">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-819">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-820">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-820">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-821">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-821">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-822">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-822">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-823">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-823">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-824">文件的名称（包括路径），该文件包含定义所请求类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-824">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="6567e-825">该程序集是使用 <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> 方法加载的。</span><span class="sxs-lookup"><span data-stu-id="6567e-825">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-826"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-826">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-827">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-827">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-828">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-828">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-829">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-829">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-830">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-830">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="6567e-831">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-831">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-832">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-832">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-833">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-833">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-834">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-834">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-835">区域性特定的信息，这些信息控制将 <paramref name="args" /> 强制转换为 <paramref name="typeName" /> 构造函数所声明的正式类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-835">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-836">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-836">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-837">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-837">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-838">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-838">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-839">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="6567e-839">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="6567e-840">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-840">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-841">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-841">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="6567e-842">用于授权创建 <paramref name="typeName" /> 的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-842">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="6567e-843">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-843">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="6567e-844">一个对象，它是新实例的包装，或者如果找不到 <see langword="null" />，则为 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-844">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="6567e-845">返回值需要打开包装才能访问真实对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-845">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-846">有关此方法的详细信息, 请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-846">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="6567e-847"><xref:System.AppDomain.CreateInstanceFrom%2A>当方法用于创建目标应用程序域中的实例 (而不是调用的应用程序域) 时, 将在目标应用程序域中加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-847">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="6567e-848">但是, 如果实例在调用应用程序域中解包, 则以特定方式使用已解包的实例可能会导致程序集加载到调用应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-848">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="6567e-849">例如, 在实例解包后, 可能会请求其类型信息, 以便以后调用其方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-849">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="6567e-850">将程序集加载到调用应用程序域时, 可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-850">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="6567e-851">如果以前将同一程序集的另一个版本加载到调用应用程序域中, 或调用应用程序域的加载路径不同于目标应用程序域的加载路径, 则<xref:System.MissingMethodException>可能会出现异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-851">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="6567e-852">如果调用应用程序域对实例类型进行早期绑定调用, <xref:System.InvalidCastException>则可以在尝试强制转换实例时引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-852">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-853"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-853"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-854">或</span><span class="sxs-lookup"><span data-stu-id="6567e-854">-or-</span></span> 
 <span data-ttu-id="6567e-855"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-855"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-856">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-856">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="6567e-857">或</span><span class="sxs-lookup"><span data-stu-id="6567e-857">-or-</span></span> 
 <span data-ttu-id="6567e-858"><paramref name="securityAttributes" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-858"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="6567e-859">未启用旧版 CAS 策略时，<paramref name="securityAttributes" /> 应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-859">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-860">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-860">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-861">未找到 <paramref name="assemblyFile" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-861"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-862">在<paramref name="typeName" /> 中未找到 <paramref name="assemblyFile" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-862"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-863">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-863">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-864">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-864">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-865"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-865"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-866">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-866">-or-</span></span> 
<span data-ttu-id="6567e-867">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-867">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-868">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-868">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="6567e-869">此示例为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-869">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-870">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-870">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-871">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-871">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-872">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-872">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-873">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-873">to provide evidence.</span></span> <span data-ttu-id="6567e-874">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-874">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-875">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-875">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-876">定义所请求类型的程序集的文件名和路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-876">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName"><span data-ttu-id="6567e-877"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-877">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="6567e-878">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-878">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="6567e-879">请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-879">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-880">这是组合<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-880">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6567e-881">此方法调用的无参数构造`typeName`函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-881">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="6567e-882">有关更多信息，请参见 <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-882">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-883"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-883"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-884">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-884">-or-</span></span> 
 <span data-ttu-id="6567e-885"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-885"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-886">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-886">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-887">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-887"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-888">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-888"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-889">未找到无形参的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-889">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-890">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-890">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-891"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-891"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-892">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-892">-or-</span></span> 
<span data-ttu-id="6567e-893">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-894">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-894">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-895">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-895">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-896">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-896">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-897">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-897">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, object[] activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, object[] activationAttributes) cil managed" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyFile As String, typeName As String, activationAttributes As Object()) As Object" FrameworkAlternate="netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" FrameworkAlternate="netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="2" FrameworkAlternate="netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-898">定义所请求类型的程序集的文件名和路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-898">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="assemblyFile">To be added.</param>
        <param name="typeName"><span data-ttu-id="6567e-899">所请求类型的完全限定名，包括命名空间而不是程序集（请参见 <see cref="P:System.Type.FullName" /> 属性）。</span><span class="sxs-lookup"><span data-stu-id="6567e-899">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-900">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-900">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-901">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-901">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-902">此参数与客户端激活的对象相关。客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-902">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-903">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-903">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-904">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-904">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="6567e-905">请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-905">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-906">这是组合<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-906">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="6567e-907">此方法调用的无参数构造`typeName`函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-907">This method calls the parameterless constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="6567e-908">有关此方法的详细信息, 请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-908">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-909"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-909"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-910">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-910">-or-</span></span> 
 <span data-ttu-id="6567e-911"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-911"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-912">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-912">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-913">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-913">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-914">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-914"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-915">在 <paramref name="assemblyName" /> 中未找到 <paramref name="typeName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-915"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-916">未找到无形参的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-916">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-917">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-917">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-918"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-918"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-919">或</span><span class="sxs-lookup"><span data-stu-id="6567e-919">-or-</span></span> 
<span data-ttu-id="6567e-920">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-920">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-921">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-921">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-922">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-922">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-923">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-923">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-924">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-924">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-925">定义所请求类型的程序集的文件名和路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-925">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-926"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-926">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-927">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-927">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-928">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-928">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-929">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-929">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-930">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-930">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="6567e-931">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-931">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-932">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-932">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-933">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-933">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-934">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-934">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-935">区域性特定的信息，这些信息控制将 <paramref name="args" /> 强制转换为 <paramref name="typeName" /> 构造函数所声明的正式类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-935">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-936">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-936">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-937">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-937">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-938">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-938">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-939">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="6567e-939">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="6567e-940">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-940">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-941">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-941">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="6567e-942">创建在指定的程序集文件中定义的指定类型的新实例，指定是否忽略类型名称的大小写，并指定绑定特性和用于选择要创建的类型的联编程序、构造函数的自变量、区域性以及激活特性。</span><span class="sxs-lookup"><span data-stu-id="6567e-942">Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="6567e-943">请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-943">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-944">这是组合<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-944">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6567e-945">有关此方法的详细信息, 请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-945">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-946"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-946"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-947">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-947">-or-</span></span> 
 <span data-ttu-id="6567e-948"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-948"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-949">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-949">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-950">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-950">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-951">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-951"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-952">在<paramref name="typeName" /> 中未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-952"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-953">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-953">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-954">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-954">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-955"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-955"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-956">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-956">-or-</span></span> 
 <span data-ttu-id="6567e-957"><paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-957"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-958">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-958">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-959">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-959">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-960">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-960">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-961">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-961">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.Object[]" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" Index="8" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-962">定义所请求类型的程序集的文件名和路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-962">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="6567e-963"><see cref="P:System.Type.FullName" /> 属性返回的所请求类型的完全限定名称，包含命名空间而不是程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-963">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="6567e-964">一个布尔值，指示是否执行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-964">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="6567e-965">影响 <paramref name="typeName" /> 构造函数搜索的零个或多个位标志的组合。</span><span class="sxs-lookup"><span data-stu-id="6567e-965">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-966">如果 <paramref name="bindingAttr" /> 为零，则对公共构造函数进行区分大小写的搜索。</span><span class="sxs-lookup"><span data-stu-id="6567e-966">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="6567e-967">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。</span><span class="sxs-lookup"><span data-stu-id="6567e-967">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="6567e-968">如果 <paramref name="binder" /> 为 null，则使用默认联编程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-968">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-969">要传递给构造函数的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-969">The arguments to pass to the constructor.</span></span> <span data-ttu-id="6567e-970">此实参数组必须在数量、顺序和类型方面与要调用的构造函数的形参匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-970">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="6567e-971">如果无参数构造函数是首选，则 <paramref name="args" /> 必须为空数组或 NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-971">If the parameterless constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="6567e-972">区域性特定的信息，这些信息控制将 <paramref name="args" /> 强制转换为 <paramref name="typeName" /> 构造函数所声明的正式类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-972">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="6567e-973">如果 <paramref name="culture" /> 为 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-973">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="6567e-974">包含一个或多个可以参与激活的特性的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-974">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="6567e-975">通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-975">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="6567e-976">此参数与客户端激活的对象相关。</span><span class="sxs-lookup"><span data-stu-id="6567e-976">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="6567e-977">客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-977">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="6567e-978">应改用 Windows Communication Foundation 来开发分布式应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-978">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="6567e-979">用于授权创建 <paramref name="typeName" /> 的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-979">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="6567e-980">创建在指定程序集文件中定义的指定类型的新实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-980">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="6567e-981">请求的对象，或者如果找不到 <paramref name="typeName" /> 则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-981">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-982">这是组合<xref:System.AppDomain.CreateInstanceFrom%2A>和<xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>的便利方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-982">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6567e-983">有关此方法的详细信息, 请参阅<xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-983">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-984"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-984"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-985">或</span><span class="sxs-lookup"><span data-stu-id="6567e-985">-or-</span></span> 
 <span data-ttu-id="6567e-986"><paramref name="typeName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-986"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-987">调用方不能为非继承自 <see cref="T:System.MarshalByRefObject" /> 的对象提供激活属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-987">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-988">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-988">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-989">未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-989"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="6567e-990">在<paramref name="typeName" /> 中未找到 <paramref name="assemblyName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-990"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-991">未找到匹配的公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-991">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="6567e-992">调用方没有足够的权限调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-992">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-993"><paramref name="assemblyName" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-993"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-994">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-994">-or-</span></span> 
<span data-ttu-id="6567e-995">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高的版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-995">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-996">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-996">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="6567e-997">用于读取包含程序集清单的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-997">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="6567e-998">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="6567e-998">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-999">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-999">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1000">获取当前 <see cref="T:System.Threading.Thread" /> 的当前应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1000">Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</span></span></summary>
        <value><span data-ttu-id="6567e-1001">当前应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1001">The current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6567e-1002">下面的代码示例创建一个新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1002">The following code example creates a new application domain.</span></span> <span data-ttu-id="6567e-1003">属性用于获取表示当前应用程序域的对象。<xref:System.AppDomain> <xref:System.AppDomain.CurrentDomain%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-1003">The <xref:System.AppDomain.CurrentDomain%2A> property is used to obtain an <xref:System.AppDomain> object that represents the current application domain.</span></span> <span data-ttu-id="6567e-1004"><xref:System.AppDomain.FriendlyName%2A>属性提供当前应用程序域的名称, 该名称随后将显示在命令行中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1004">The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-1005">在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1005">Defines a dynamic assembly in the current application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1006">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1006">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1007">动态程序集的访问模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1007">The access mode for the dynamic assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1008">以指定名称和访问模式定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1008">Defines a dynamic assembly with the specified name and access mode.</span></span></summary>
        <returns><span data-ttu-id="6567e-1009">含指定名称和访问模式的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1009">A dynamic assembly with the specified name and access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1010">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1010">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1011">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1011">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1012">在开发用于发出动态程序集的代码的过程中, 建议使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载来指定证据和权限, 提供希望动态程序集具有的证据, 并将其包括在<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="6567e-1012">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1013">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1013">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1014">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1014">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1015">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1015">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1016">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1016">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1017">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1017">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1018"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1018"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1019"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1019">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1020">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1020">-or-</span></span> 
<span data-ttu-id="6567e-1021"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1021">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1022">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1022">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1023">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1023">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1024">动态程序集的访问模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1024">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="6567e-1025">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1025">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="6567e-1026">使用指定的名称、访问模式和自定义特性定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1026">Defines a dynamic assembly with the specified name, access mode, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="6567e-1027">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1027">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1028">使用此方法重载指定在创建动态程序集时不能正常运行的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1028">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="6567e-1029">例如, 如果在创建动态程序<xref:System.Security.SecurityTransparentAttribute>集<xref:System.Security.SecurityCriticalAttribute>之后添加了安全属性 (例如和), 则这些属性不能正常工作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1029">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="6567e-1030">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1030">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1031">有关此限制的详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1031">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 <span data-ttu-id="6567e-1032">此方法重载在中[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]引入。</span><span class="sxs-lookup"><span data-stu-id="6567e-1032">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1033">下面的代码示例演示如何创建具有的<xref:System.Security.SecurityTransparentAttribute>动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1033">The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>.</span></span> <span data-ttu-id="6567e-1034">特性必须指定为<xref:System.Reflection.Emit.CustomAttributeBuilder>对象数组的元素。</span><span class="sxs-lookup"><span data-stu-id="6567e-1034">The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.</span></span>  
  
 <span data-ttu-id="6567e-1035">创建的<xref:System.Reflection.Emit.CustomAttributeBuilder>第一步是获取该属性的构造函数。</span><span class="sxs-lookup"><span data-stu-id="6567e-1035">The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute.</span></span> <span data-ttu-id="6567e-1036">构造函数没有任何参数, 因此<xref:System.Type.GetConstructor%2A> , 将使用空的<xref:System.Type>对象数组来调用方法, 以表示参数的类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-1036">The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters.</span></span> <span data-ttu-id="6567e-1037">第二步是将生成<xref:System.Reflection.ConstructorInfo>的对象传递给<xref:System.Reflection.Emit.CustomAttributeBuilder>类的构造函数, 同时传递到类型<xref:System.Object>为的空数组来表示参数。</span><span class="sxs-lookup"><span data-stu-id="6567e-1037">The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.</span></span>  
  
 <span data-ttu-id="6567e-1038">然后, <xref:System.Reflection.Emit.CustomAttributeBuilder>将生成的传递<xref:System.AppDomain.DefineDynamicAssembly%2A>给方法, 作为数组的唯一元素。</span><span class="sxs-lookup"><span data-stu-id="6567e-1038">The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the <xref:System.AppDomain.DefineDynamicAssembly%2A> method as the only element of an array.</span></span>  
  
 <span data-ttu-id="6567e-1039">示例代码在新的动态程序集中定义一个模块和一个类型, 然后显示该程序集的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1039">The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</span></span>  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1040"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1040"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1041"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1041">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1042">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1042">-or-</span></span> 
<span data-ttu-id="6567e-1043"><paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1043">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1044">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1044">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1045">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1045">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1046">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1046">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="6567e-1047">为动态程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1047">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="6567e-1048">该证据始终作为最后一组用于策略解析的证据来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1048">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="6567e-1049">使用指定名称、访问模式和证据定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1049">Defines a dynamic assembly using the specified name, access mode, and evidence.</span></span></summary>
        <returns><span data-ttu-id="6567e-1050">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1050">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1051">定义动态`evidence` <xref:System.Reflection.Assembly>时, 仅完全受信任的调用方可以提供它们。</span><span class="sxs-lookup"><span data-stu-id="6567e-1051">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="6567e-1052">运行时将<xref:System.Security.Policy.Evidence>通过安全策略映射来确定授予的权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-1052">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="6567e-1053">部分受信任的调用方必须`evidence`提供空值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1053">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="6567e-1054">如果`evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>为`null`, 则运行时将权限集 (即当前 grant 和 deny 集) 从调用方复制到正在定义的动态, 并将策略标记为已解决。</span><span class="sxs-lookup"><span data-stu-id="6567e-1054">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="6567e-1055">如果动态<xref:System.Reflection.Assembly>保存在磁盘上, 则后续的加载将根据与保存位置<xref:System.Reflection.Assembly>相关的策略获得授权。</span><span class="sxs-lookup"><span data-stu-id="6567e-1055">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="6567e-1056">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1056">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1057">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1057">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1058">在开发用于发出动态程序集的代码的过程中, 建议使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载来指定证据和权限, 提供希望动态程序集具有的证据, 并将其包括在<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="6567e-1058">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1059">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1059">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1060">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1060">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1061">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法<xref:System.AppDomain.AssemblyResolve>和事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1061">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1062">首先, 该代码示例尝试使用无效的程序集`MyDynamicType`名称<xref:System.AppDomain.CreateInstance%2A>调用方法来创建的实例, 并捕获产生的异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-1062">First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.</span></span>  
  
 <span data-ttu-id="6567e-1063">然后, 该代码示例为<xref:System.AppDomain.AssemblyResolve>事件添加事件处理程序, 并再次尝试创建的`MyDynamicType`实例。</span><span class="sxs-lookup"><span data-stu-id="6567e-1063">The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`.</span></span> <span data-ttu-id="6567e-1064">在对的调用<xref:System.AppDomain.CreateInstance%2A>过程中<xref:System.AppDomain.AssemblyResolve> , 对无效的程序集引发了事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1064">During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly.</span></span> <span data-ttu-id="6567e-1065">事件处理程序创建一个包含名为`MyDynamicType`的类型的动态程序集, 为该类型提供一个无参数的构造函数, 并返回新的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1065">The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly.</span></span> <span data-ttu-id="6567e-1066"><xref:System.AppDomain.CreateInstance%2A>然后, 对的调用成功完成, 的`MyDynamicType`构造函数在控制台显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="6567e-1066">The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1067"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1067"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1068"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1068">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1069">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1069">-or-</span></span> 
<span data-ttu-id="6567e-1070"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1070">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1071">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1071">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1072">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1072">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1073">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1073">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1074">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1074">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1075">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1075">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="6567e-1076">保存程序集的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1076">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="6567e-1077">如果 <paramref name="dir" /> 是 <see langword="null" />，目录将默认为当前目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1077">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <summary><span data-ttu-id="6567e-1078">使用指定名称、访问模式和存储目录定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1078">Defines a dynamic assembly using the specified name, access mode, and storage directory.</span></span></summary>
        <returns><span data-ttu-id="6567e-1079">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1079">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1080">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1080">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1081">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1081">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1082">在开发用于发出动态程序集的代码的过程中, 建议使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载来指定证据和权限, 提供希望动态程序集具有的证据, 并将其包括在<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="6567e-1082">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1083">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1083">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1084">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1084">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1085">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1085">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1086">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1086">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1087">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1087">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1088"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1088"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1089"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1089">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1090">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1090">-or-</span></span> 
<span data-ttu-id="6567e-1091"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1091">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1092">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1092">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1093">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1093">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1094">动态程序集的访问模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1094">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="6567e-1095">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1095">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="6567e-1096">安全上下文的源。</span><span class="sxs-lookup"><span data-stu-id="6567e-1096">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="6567e-1097">定义具有指定名称、访问模式和自定义特性的动态程序集，并将指定源用于动态程序集的安全上下文。</span><span class="sxs-lookup"><span data-stu-id="6567e-1097">Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</span></span></summary>
        <returns><span data-ttu-id="6567e-1098">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1098">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1099">使用此方法重载指定在创建动态程序集时不能正常运行的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1099">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="6567e-1100">例如, 如果在创建动态程序<xref:System.Security.SecurityTransparentAttribute>集<xref:System.Security.SecurityCriticalAttribute>之后添加了安全属性 (例如和), 则这些属性不能正常工作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1100">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="6567e-1101">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1101">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1102">有关此限制的详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1102">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1103"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1103"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1104"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1104">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1105">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1105">-or-</span></span> 
<span data-ttu-id="6567e-1106"><paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1106">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1107">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1107">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6567e-1108"><paramref name="securityContextSource" /> 的值不是枚举值之一。</span><span class="sxs-lookup"><span data-stu-id="6567e-1108">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1109">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1109">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1110">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1110">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="6567e-1111">保存程序集的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1111">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="6567e-1112">如果 <paramref name="dir" /> 是 <see langword="null" />，目录将默认为当前目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1112">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="6567e-1113">为动态程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1113">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="6567e-1114">该证据始终作为最后一组用于策略解析的证据来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1114">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="6567e-1115">使用指定名称、访问模式、存储目录和证据定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1115">Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</span></span></summary>
        <returns><span data-ttu-id="6567e-1116">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1116">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1117">定义动态`evidence` <xref:System.Reflection.Assembly>时, 仅完全受信任的调用方可以提供它们。</span><span class="sxs-lookup"><span data-stu-id="6567e-1117">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="6567e-1118">运行时将<xref:System.Security.Policy.Evidence>通过安全策略映射来确定授予的权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-1118">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="6567e-1119">部分受信任的调用方必须`evidence`提供空值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1119">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="6567e-1120">如果`evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>为`null`, 则运行时将权限集 (即当前 grant 和 deny 集) 从调用方复制到正在定义的动态, 并将策略标记为已解决。</span><span class="sxs-lookup"><span data-stu-id="6567e-1120">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="6567e-1121">如果动态<xref:System.Reflection.Assembly>保存在磁盘上, 则后续的加载将根据与保存位置<xref:System.Reflection.Assembly>相关的策略获得授权。</span><span class="sxs-lookup"><span data-stu-id="6567e-1121">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="6567e-1122">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1122">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1123">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1123">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1124">在开发用于发出动态程序集的代码的过程中, 建议使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载来指定证据和权限, 提供希望动态程序集具有的证据, 并将其包括在<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="6567e-1124">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1125">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1125">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1126">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1126">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1127">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1127">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1128">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1128">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1129">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1129">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1130"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1130"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1131"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1131">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1132">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1132">-or-</span></span> 
<span data-ttu-id="6567e-1133"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1133">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1134">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1134">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1135">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1135">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1136">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1137">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1137">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1138">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1138">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="6567e-1139">必需的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1139">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="6567e-1140">可选的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1140">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="6567e-1141">被拒绝的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1141">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="6567e-1142">使用指定名称、访问模式和权限请求定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1142">Defines a dynamic assembly using the specified name, access mode, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="6567e-1143">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1143">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1144">除非动态程序集已`requiredPermissions`保存`optionalPermissions`并重新加载到内存中, 否则不会使用为、和`refusedPermissions`指定的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1144">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="6567e-1145">若要为从不保存到磁盘的临时程序集指定权限请求, 请使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载, 该重载指定证据和请求的权限, 并提供一个<xref:System.Security.Policy.Evidence>对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1145">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1146">在开发用于发出动态程序集的代码的过程中, 建议使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载来指定证据和权限, 提供希望动态程序集具有的证据, 并将其包括在<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="6567e-1146">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1147">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1147">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1148">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1148">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="6567e-1149">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1149">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1150">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1150">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1151">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1151">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1152">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1152">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1153">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1153">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1154"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1154"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1155"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1155">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1156">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1156">-or-</span></span> 
<span data-ttu-id="6567e-1157"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1157">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1158">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1158">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="3" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="4" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1159">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1159">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1160">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1160">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="6567e-1161">保存动态程序集的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1161">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="6567e-1162">如果 <paramref name="dir" /> 为 <see langword="null" />，则使用当前目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1162">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="6567e-1163">若要在动态程序集中同步模块、类型和成员的创建，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1163"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="6567e-1164">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1164">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="6567e-1165">使用指定名称、访问模式、存储目录和同步选项定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1165">Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="6567e-1166">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1166">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1167">使用此方法重载指定在创建动态程序集时不能正常运行的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1167">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="6567e-1168">例如, 如果在创建动态程序<xref:System.Security.SecurityTransparentAttribute>集<xref:System.Security.SecurityCriticalAttribute>之后添加了安全属性 (例如和), 则这些属性不能正常工作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1168">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="6567e-1169">如果`isSynchronized`为<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> ,则<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>将同步生成的的以下方法:、、、、和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 `true`</span><span class="sxs-lookup"><span data-stu-id="6567e-1169">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="6567e-1170">如果在不同的线程上调用了这两个方法, 则将阻止一个方法, 直到另一个线程完成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1170">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1171"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1171"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1172"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1172">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1173">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1173">-or-</span></span> 
<span data-ttu-id="6567e-1174"><paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1174">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1175">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1175">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1176">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1176">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1177">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1177">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="6567e-1178">为动态程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1178">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="6567e-1179">该证据始终作为最后一组用于策略解析的证据来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1179">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="6567e-1180">必需的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1180">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="6567e-1181">可选的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1181">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="6567e-1182">被拒绝的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1182">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="6567e-1183">使用指定名称、访问模式、证据和权限请求定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1183">Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="6567e-1184">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1184">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1185">`requiredPermissions`仅当`optionalPermissions` `refusedPermissions`同时提供了或动态程序集已保存并重新加载到内存中时,才使用为、和指定的权限请求。`evidence`</span><span class="sxs-lookup"><span data-stu-id="6567e-1185">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1186">在开发发出动态程序集的代码的过程中, 建议你将包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1186">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1187">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1187">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1188">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1188">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="6567e-1189">定义动态`evidence` <xref:System.Reflection.Assembly>时, 仅完全受信任的调用方可以提供它们。</span><span class="sxs-lookup"><span data-stu-id="6567e-1189">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="6567e-1190">运行时将<xref:System.Security.Policy.Evidence>通过安全策略映射来确定授予的权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-1190">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="6567e-1191">部分受信任的调用方必须`evidence`提供空值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1191">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="6567e-1192">如果`evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>为`null`, 则运行时将权限集 (即当前 grant 和 deny 集) 从调用方复制到正在定义的动态, 并将策略标记为已解决。</span><span class="sxs-lookup"><span data-stu-id="6567e-1192">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="6567e-1193">如果动态<xref:System.Reflection.Assembly>保存在磁盘上, 则后续的加载将根据与保存位置<xref:System.Reflection.Assembly>相关的策略获得授权。</span><span class="sxs-lookup"><span data-stu-id="6567e-1193">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="6567e-1194">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1194">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1195">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1195">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1196">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1196">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1197">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1197">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1198">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1198">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1199"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1199"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1200"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1200">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1201">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1201">-or-</span></span> 
<span data-ttu-id="6567e-1202"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1202">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1203">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1203">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1204">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1204">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1205">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1205">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1206">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1206">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1207">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1207">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="6567e-1208">保存程序集的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1208">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="6567e-1209">如果 <paramref name="dir" /> 是 <see langword="null" />，目录将默认为当前目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1209">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="6567e-1210">必需的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1210">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="6567e-1211">可选的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1211">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="6567e-1212">被拒绝的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1212">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="6567e-1213">使用指定名称、访问模式、存储目录和权限请求定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1213">Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="6567e-1214">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1214">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1215">除非动态程序集已`requiredPermissions`保存`optionalPermissions`并重新加载到内存中, 否则不会使用为、和`refusedPermissions`指定的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1215">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="6567e-1216">若要为从不保存到磁盘的临时程序集指定权限请求, 请使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载, 该重载指定证据和请求的权限, 并提供一个<xref:System.Security.Policy.Evidence>对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1216">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1217">在开发用于发出动态程序集的代码的过程中, 建议使用<xref:System.AppDomain.DefineDynamicAssembly%2A>方法的重载来指定证据和权限, 提供希望动态程序集具有的证据, 并将其包括在<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>`refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="6567e-1217">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1218">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1218">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1219">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1219">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="6567e-1220">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1220">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1221">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1221">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1222">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1222">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1223">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1223">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1224">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1224">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1225"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1225"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1226"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1226">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1227">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1227">-or-</span></span> 
<span data-ttu-id="6567e-1228"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1228">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1229">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1229">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1230">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1230">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1231">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1231">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="6567e-1232">保存程序集的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1232">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="6567e-1233">如果 <paramref name="dir" /> 是 <see langword="null" />，目录将默认为当前目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1233">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="6567e-1234">为动态程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1234">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="6567e-1235">该证据始终作为最后一组用于策略解析的证据来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1235">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="6567e-1236">必需的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1236">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="6567e-1237">可选的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1237">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="6567e-1238">被拒绝的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1238">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="6567e-1239">使用指定名称、访问模式、存储目录、证据和权限请求定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1239">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="6567e-1240">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1240">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1241">`requiredPermissions`仅当`optionalPermissions` `refusedPermissions`同时提供了或动态程序集已保存并重新加载到内存中时,才使用为、和指定的权限请求。`evidence`</span><span class="sxs-lookup"><span data-stu-id="6567e-1241">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1242">在开发发出动态程序集的代码的过程中, 建议你将包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1242">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1243">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1243">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1244">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1244">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="6567e-1245">定义动态`evidence` <xref:System.Reflection.Assembly>时, 仅完全受信任的调用方可以提供它们。</span><span class="sxs-lookup"><span data-stu-id="6567e-1245">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="6567e-1246">运行时将<xref:System.Security.Policy.Evidence>通过安全策略映射来确定授予的权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-1246">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="6567e-1247">部分受信任的调用方必须`evidence`提供空值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1247">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="6567e-1248">如果`evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>为`null`, 则运行时将权限集 (即当前 grant 和 deny 集) 从调用方复制到正在定义的动态, 并将策略标记为已解决。</span><span class="sxs-lookup"><span data-stu-id="6567e-1248">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="6567e-1249">如果动态<xref:System.Reflection.Assembly>保存在磁盘上, 则后续的加载将根据与保存位置<xref:System.Reflection.Assembly>相关的策略获得授权。</span><span class="sxs-lookup"><span data-stu-id="6567e-1249">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="6567e-1250">此方法应仅用于在当前应用程序域中定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1250">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="6567e-1251">有关详细信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1251">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1252">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1252">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1253">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1253">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1254">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1254">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1255"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1255"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1256"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1256">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1257">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1257">-or-</span></span> 
<span data-ttu-id="6567e-1258"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1258">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1259">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1259">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1260">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1260">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1261">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1261">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1262">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1262">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1263">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1263">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="6567e-1264">保存动态程序集的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1264">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="6567e-1265">如果 <paramref name="dir" /> 是 <see langword="null" />，目录将默认为当前目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1265">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="6567e-1266">为动态程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1266">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="6567e-1267">该证据始终作为最后一组用于策略解析的证据来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1267">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="6567e-1268">必需的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1268">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="6567e-1269">可选的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1269">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="6567e-1270">被拒绝的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1270">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="6567e-1271">若要在动态程序集中同步模块、类型和成员的创建，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1271"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="6567e-1272">使用指定名称、访问模式、存储目录、证据、权限请求和同步选项定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1272">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="6567e-1273">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1273">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1274">`requiredPermissions`仅当`optionalPermissions` `refusedPermissions`同时提供了或动态程序集已保存并重新加载到内存中时,才使用为、和指定的权限请求。`evidence`</span><span class="sxs-lookup"><span data-stu-id="6567e-1274">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1275">在开发发出动态程序集的代码的过程中, 建议你将包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType>在`refusedPermissions`中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1275">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="6567e-1276">在参数中包含<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification>可确保对MSIL进行验证。`refusedPermissions`</span><span class="sxs-lookup"><span data-stu-id="6567e-1276">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="6567e-1277">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1277">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="6567e-1278">定义动态<xref:System.Reflection.Assembly>时, 仅完全受信任的调用方可以提供其证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1278">Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="6567e-1279">运行时将<xref:System.Security.Policy.Evidence>通过安全策略映射来确定授予的权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-1279">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="6567e-1280">部分受信任的`null` `evidence`调用方必须为参数提供。</span><span class="sxs-lookup"><span data-stu-id="6567e-1280">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="6567e-1281">如果`evidence` <xref:System.Reflection.Assembly> <xref:System.Reflection.Assembly>为`null`, 则运行时将权限集 (即当前 grant 和 deny 集) 从调用方复制到正在定义的动态, 并将策略标记为已解决。</span><span class="sxs-lookup"><span data-stu-id="6567e-1281">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="6567e-1282">如果动态<xref:System.Reflection.Assembly>保存在磁盘上, 则后续的加载将根据与保存位置<xref:System.Reflection.Assembly>相关的策略获得授权。</span><span class="sxs-lookup"><span data-stu-id="6567e-1282">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="6567e-1283">如果`isSynchronized`为<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> ,则<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>将同步生成的的以下方法:、、、、和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 `true`</span><span class="sxs-lookup"><span data-stu-id="6567e-1283">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="6567e-1284">如果在不同的线程上调用了这两种方法, 则会阻止一个方法, 直到另一个线程完成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1284">If two of these methods are called on different threads, one will block until the other completes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1285">下面的示例演示<xref:System.AppDomain.DefineDynamicAssembly%2A>方法和<xref:System.AppDomain.AssemblyResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1285">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-1286">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1286">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1287">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1287">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1288"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1288"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1289"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1289">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1290">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1290">-or-</span></span> 
<span data-ttu-id="6567e-1291"><paramref name="name" /> 的 <see langword="Name" /> 属性以空格开头，或包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1291">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1292">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1292">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1293">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1293">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1294">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1294">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="dir" Type="System.String" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" Index="3" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" Index="4" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" Index="5" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" Index="6" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="isSynchronized" Type="System.Boolean" Index="7" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" Index="8" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1295">动态程序集的唯一标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1295">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="6567e-1296">访问动态程序集所采用的模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-1296">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="6567e-1297">保存动态程序集的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1297">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="6567e-1298">如果 <paramref name="dir" /> 为 <see langword="null" />，则使用当前目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1298">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="evidence"><span data-ttu-id="6567e-1299">为动态程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1299">The evidence that is supplied for the dynamic assembly.</span></span> <span data-ttu-id="6567e-1300">该证据始终作为最后一组用于策略解析的证据来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1300">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="6567e-1301">必需的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1301">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="6567e-1302">可选的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1302">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="6567e-1303">被拒绝的权限请求。</span><span class="sxs-lookup"><span data-stu-id="6567e-1303">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="6567e-1304">若要在动态程序集中同步模块、类型和成员的创建，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1304"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="6567e-1305">要应用于程序集的可枚举特性列表；如果无特性，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1305">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="6567e-1306">使用指定的名称、访问模式、存储目录、证据、权限请求、同步选项和自定义特性定义动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1306">Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="6567e-1307">具有指定名称和功能的动态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1307">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1308">使用此方法重载指定在创建动态程序集时不能正常运行的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1308">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="6567e-1309">例如, 如果在创建动态程序<xref:System.Security.SecurityTransparentAttribute>集<xref:System.Security.SecurityCriticalAttribute>之后添加了安全属性 (例如和), 则这些属性不能正常工作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1309">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="6567e-1310">`requiredPermissions`仅当`optionalPermissions`同时提供`refusedPermissions`了参数时,或者如果动态程序集已保存并重新加载到内存中时,才使用为、和参数指定的权限请求。`evidence`</span><span class="sxs-lookup"><span data-stu-id="6567e-1310">The permission requests specified for the `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` parameters are used only if the `evidence` parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1311">开发用于发出动态程序集的代码时, 我们建议您在<xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> `refusedPermissions`参数中包含该标志。</span><span class="sxs-lookup"><span data-stu-id="6567e-1311">When you develop code that emits dynamic assemblies, we recommend that you include the <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag in the `refusedPermissions` parameter.</span></span> <span data-ttu-id="6567e-1312">此标志的包含确保将验证 Microsoft 中间语言 (MSIL)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1312">The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</span></span> <span data-ttu-id="6567e-1313">此方法将检测意外生成的不可验证代码, 否则很难检测到这种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-1313">This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</span></span> <span data-ttu-id="6567e-1314">此方法的限制是, 它在与要求<xref:System.Security.SecurityException>完全信任的代码一起使用时也会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1314">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when it is used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="6567e-1315">定义动态<xref:System.Reflection.Assembly>时, 仅完全受信任的调用方可以提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1315">Only fully trusted callers can supply evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="6567e-1316">运行时将<xref:System.Security.Policy.Evidence>通过安全策略进行映射, 以确定授予的权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-1316">The runtime maps the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="6567e-1317">部分受信任的`null` `evidence`调用方必须为参数提供。</span><span class="sxs-lookup"><span data-stu-id="6567e-1317">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="6567e-1318">如果`evidence` 为`null`, 则运行时将权限集 (即, 当前 grant 和 deny 集) 从调用方的程序集复制到正在定义的动态程序集, 并将策略标记为已解决。</span><span class="sxs-lookup"><span data-stu-id="6567e-1318">If `evidence` is `null`, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</span></span>  
  
 <span data-ttu-id="6567e-1319">如果动态程序集保存到磁盘, 则后续的加载将根据与动态程序集保存位置相关联的策略获得授予。</span><span class="sxs-lookup"><span data-stu-id="6567e-1319">If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</span></span>  
  
 <span data-ttu-id="6567e-1320">如果`isSynchronized`为<xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A> <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A> <xref:System.Reflection.Emit.AssemblyBuilder> <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A> ,则<xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>将同步生成的的以下方法:、、、、和<xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>。 `true`</span><span class="sxs-lookup"><span data-stu-id="6567e-1320">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="6567e-1321">如果在不同的线程上调用了这两个方法, 则将阻止一个方法, 直到另一个线程完成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1321">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 <span data-ttu-id="6567e-1322">此方法重载在中[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]引入。</span><span class="sxs-lookup"><span data-stu-id="6567e-1322">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1323"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1323"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-1324"><paramref name="name" /> 的 <see langword="Name" /> 属性为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1324">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="6567e-1325">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1325">-or-</span></span> 
<span data-ttu-id="6567e-1326"><paramref name="name" /> 的 <see langword="Name" /> 属性以空白开始，或者包含正斜杠或反斜杠。</span><span class="sxs-lookup"><span data-stu-id="6567e-1326">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1327">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1327">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1328">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1328">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1329">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1329">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate"><span data-ttu-id="6567e-1330">指定要调用的方法的委托。</span><span class="sxs-lookup"><span data-stu-id="6567e-1330">A delegate that specifies a method to call.</span></span></param>
        <summary><span data-ttu-id="6567e-1331">在另一个应用程序域中执行代码，该应用程序域由指定的委托标识。</span><span class="sxs-lookup"><span data-stu-id="6567e-1331">Executes the code in another application domain that is identified by the specified delegate.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1332">`callBackDelegate`可以指定按值封送、 <xref:System.MarshalByRefObject>或。 <xref:System.ContextBoundObject></span><span class="sxs-lookup"><span data-stu-id="6567e-1332">`callBackDelegate` can specify a marshal-by-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1333">下面的示例演示如何使用静态<xref:System.AppDomain.DoCallBack%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1333">The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 <span data-ttu-id="6567e-1334">下面的示例演示如何使用<xref:System.AppDomain.DoCallBack%2A>方法 (通过值)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1334">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 <span data-ttu-id="6567e-1335">下面的示例演示如何按<xref:System.AppDomain.DoCallBack%2A>引用使用方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1335">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1336"><paramref name="callBackDelegate" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1336"><paramref name="callBackDelegate" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1337">获得初始化应用程序域时主机提供的域管理器。</span><span class="sxs-lookup"><span data-stu-id="6567e-1337">Gets the domain manager that was provided by the host when the application domain was initialized.</span></span></summary>
        <value><span data-ttu-id="6567e-1338">一个对象，表示初始化应用程序域时主机提供的域管理器；或者如果没有提供域管理器，则返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1338">An object that represents the domain manager provided by the host when the application domain was initialized, or <see langword="null" /> if no domain manager was provided.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1339">公共语言运行时 (CLR) 的非托管主机可以提供域管理器。</span><span class="sxs-lookup"><span data-stu-id="6567e-1339">An unmanaged host of the common language runtime (CLR) can provide a domain manager.</span></span> <span data-ttu-id="6567e-1340">域管理器可以参与初始化新应用程序域并提供参与应用程序域操作的其他<xref:System.Security.HostSecurityManager>管理器, 例如。</span><span class="sxs-lookup"><span data-stu-id="6567e-1340">The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-1341">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-1341">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-1342">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-1342">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1343">在即将卸载 <see cref="T:System.AppDomain" /> 时发生。</span><span class="sxs-lookup"><span data-stu-id="6567e-1343">Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1344">此<xref:System.EventHandler>事件的委托可以在卸载应用程序域之前执行任何终止活动。</span><span class="sxs-lookup"><span data-stu-id="6567e-1344">The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.</span></span>  
  
 <span data-ttu-id="6567e-1345">需要在卸载时执行处理的每个应用程序域都应为此事件注册事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1345">Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</span></span> <span data-ttu-id="6567e-1346">不应使用共享的事件处理程序, 因为<xref:System.EventHandler>委托不标识正在卸载的域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1346">A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1347">此事件永远不会在默认应用程序域中引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1347">This event is never raised in the default application domain.</span></span>  
  
 <span data-ttu-id="6567e-1348">不要对引发事件的线程做出假设。</span><span class="sxs-lookup"><span data-stu-id="6567e-1348">Do not make assumptions about the thread the event is raised on.</span></span> <span data-ttu-id="6567e-1349">事件可以在不同于调用<xref:System.AppDomain.Unload%2A>方法的线程上引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1349">The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1350">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1350">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1351">获取目录，它由程序集冲突解决程序用来探测动态创建的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1351">Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></summary>
        <value><span data-ttu-id="6567e-1352">目录，它由程序集冲突解决程序用来探测动态创建的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1352">The directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1353">若要设置动态目录, 请为将用于创建新应用<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>程序域的<xref:System.AppDomainSetup>对象的属性分配基目录路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1353">To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain.</span></span> <span data-ttu-id="6567e-1354">通过添加一个子目录 (其简单名称是分配给<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>属性的字符串的哈希代码), 可以修改分配给该属性的基目录路径, 因此基目录的格式为*原路径*\\*哈希代码*。</span><span class="sxs-lookup"><span data-stu-id="6567e-1354">The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so the format of the base directory is *original path*\\*hash code*.</span></span> <span data-ttu-id="6567e-1355">动态目录是此基目录的子目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1355">The dynamic directory is a subdirectory of this base directory.</span></span> <span data-ttu-id="6567e-1356">它<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>的简单名称是属性的值, 因此其格式是*原始路径*\\*哈希代码*\\*应用程序名称*。</span><span class="sxs-lookup"><span data-stu-id="6567e-1356">Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1357">下面的示例创建一个应用程序域, 其中包含动态程序集的目录、发出动态程序集并将其存储在动态目录中, 然后将程序集加载到新应用程序域中并使用该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1357">The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</span></span>  
  
 <span data-ttu-id="6567e-1358">该示例创建一个<xref:System.AppDomainSetup>对象, 并将<xref:System.AppDomainSetup.ApplicationName%2A>其属性设置为 "example" <xref:System.AppDomainSetup.DynamicBase%2A> , 并将其属性设置为 "C:\DynamicAssemblyDir"。</span><span class="sxs-lookup"><span data-stu-id="6567e-1358">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="6567e-1359">然后, 该示例显示<xref:System.AppDomainSetup.DynamicBase%2A>属性, 显示已将应用程序名称的哈希代码附加为最初分配的路径的子目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1359">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1360">本示例中的基目录应位于示例应用程序的探测路径之外。</span><span class="sxs-lookup"><span data-stu-id="6567e-1360">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="6567e-1361">请确保在其他位置编译该示例。</span><span class="sxs-lookup"><span data-stu-id="6567e-1361">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="6567e-1362">每次运行该示例时, 删除基目录及其所有子目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1362">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="6567e-1363">该示例使用<xref:System.AppDomainSetup>对象创建一个新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1363">The example creates a new application domain, using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="6567e-1364">该示例使用<xref:System.AppDomain.DynamicDirectory%2A>属性检索目录的名称, 因此它可以创建目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1364">The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory.</span></span> <span data-ttu-id="6567e-1365">(该示例通过连接原始路径、应用程序名称的哈希代码和应用程序名称, 可以轻松地轻松创建目录。)</span><span class="sxs-lookup"><span data-stu-id="6567e-1365">(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</span></span>  
  
 <span data-ttu-id="6567e-1366">该示例包含一个`GenerateDynamicAssembly`方法, 该方法发出名`DynamicHelloWorld.dll`为的程序集, 并将其存储在新应用程序域的动态目录中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1366">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="6567e-1367">动态程序集包含一个类型, `HelloWorld`该类型具有一个名为`HelloFromAD`的`Shared`静态方法 (Visual Basic 中的方法)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1367">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="6567e-1368">调用此方法将显示应用程序域的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1368">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="6567e-1369">类派生自<xref:System.MarshalByRefObject>, 因此该示例可以在新的应用程序域中创建类的实例并调用其`Test`方法。 `Example`</span><span class="sxs-lookup"><span data-stu-id="6567e-1369">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="6567e-1370">方法按其显示名称加载动态程序集, 并调用静态`HelloFromAD`方法。 `Test`</span><span class="sxs-lookup"><span data-stu-id="6567e-1370">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="6567e-1371">可以通过编写名为`DynamicHelloWorld.dll`的程序集的代码, 并在与此示例相同的目录中进行编译, 来显示在正常探测路径之后搜索动态目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-1371">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="6567e-1372">程序集必须具有名为`HelloWorld`的静态`HelloFromAD`方法的类。</span><span class="sxs-lookup"><span data-stu-id="6567e-1372">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="6567e-1373">此方法不必与示例中的相同。它可以直接在控制台上显示字符串。</span><span class="sxs-lookup"><span data-stu-id="6567e-1373">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="6567e-1374">该程序集还必须有<xref:System.Reflection.AssemblyVersionAttribute>一个将其版本设置为1.0.0.0 的特性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1374">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="6567e-1375">运行此示例时, 将在搜索动态目录之前找到当前目录中编译的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1375">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1376">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1376">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1377">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-1377">for access to the path information.</span></span> <span data-ttu-id="6567e-1378">关联枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1378">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1379">获取与该应用程序域关联的 <see cref="T:System.Security.Policy.Evidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1379">Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</span></span></summary>
        <value><span data-ttu-id="6567e-1380">与该应用程序域关联的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1380">The evidence associated with this application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1381">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1381">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1382">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1382">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1383">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1383">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="6567e-1384">安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1384">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-1385">执行指定文件中包含的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1385">Executes the assembly contained in the specified file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-1386">包含要执行程序集的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1386">The name of the file that contains the assembly to execute.</span></span></param>
        <summary><span data-ttu-id="6567e-1387">执行指定文件中包含的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1387">Executes the assembly contained in the specified file.</span></span></summary>
        <returns><span data-ttu-id="6567e-1388">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1388">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1389">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1389">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1390">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1390">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="6567e-1391">此方法使用<xref:System.Reflection.Assembly.LoadFile%2A>方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1391">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="6567e-1392">你还可以使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法执行程序集, 该方法<xref:System.Reflection.Assembly.Load%2A>使用方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1392">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1393">若要创建<xref:System.AppDomain>要加载和执行的, 请<xref:System.AppDomain.CreateDomain%2A>使用方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1393">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1394">下面的示例演示如何在两个不同的<xref:System.AppDomain.ExecuteAssembly%2A>域上使用重载之一。</span><span class="sxs-lookup"><span data-stu-id="6567e-1394">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1395"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1395"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1396"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-1396"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1397"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1397"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1398">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1398">-or-</span></span> 
<span data-ttu-id="6567e-1399">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1399">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1400">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1400">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1401">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1401">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1402">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1402">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1403">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1403">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1404">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1404">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1405">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="6567e-1405">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1406">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1406">to execute a console application.</span></span> <span data-ttu-id="6567e-1407">关联的枚举<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1407">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-1408">包含要执行程序集的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1408">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1409">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1409">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1410">使用指定的证据执行指定文件中包含的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1410">Executes the assembly contained in the specified file, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="6567e-1411">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1411">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1412">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1412">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1413"><xref:System.AppDomain.ExecuteAssembly%2A>方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1413">The <xref:System.AppDomain.ExecuteAssembly%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="6567e-1414">此方法使用<xref:System.Reflection.Assembly.LoadFile%2A>方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1414">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="6567e-1415">你还可以使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法执行程序集, 该方法<xref:System.Reflection.Assembly.Load%2A>使用方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1415">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1416">下面的示例演示如何在两个不同的<xref:System.AppDomain.ExecuteAssembly%2A>域上使用重载之一。</span><span class="sxs-lookup"><span data-stu-id="6567e-1416">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1417"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1417"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1418"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-1418"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1419"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1419"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1420">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1420">-or-</span></span> 
<span data-ttu-id="6567e-1421">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1421">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1422">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1422">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1423">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1423">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1424">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1424">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1425">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1425">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1426">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1426">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1427">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1427">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1428">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1428">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1429">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="6567e-1429">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1430">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1430">to execute a console application.</span></span> <span data-ttu-id="6567e-1431">关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1431">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-1432">包含要执行程序集的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1432">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1433">程序集的入口点的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-1433">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1434">使用指定的参数执行指定文件中包含的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1434">Executes the assembly contained in the specified file, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="6567e-1435">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1435">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1436">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1436">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1437">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1437">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="6567e-1438">此方法使用<xref:System.Reflection.Assembly.LoadFile%2A>方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1438">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="6567e-1439">你还可以使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法执行程序集, 该方法<xref:System.Reflection.Assembly.Load%2A>使用方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1439">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1440">下面的示例演示如何在两个不同的<xref:System.AppDomain.ExecuteAssembly%2A>域上使用重载之一。</span><span class="sxs-lookup"><span data-stu-id="6567e-1440">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1441"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1441"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1442"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-1442"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1443"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1443"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1444">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1444">-or-</span></span> 
 <span data-ttu-id="6567e-1445"><paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1445"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1446">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1446">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1447">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1447">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1448">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1448">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1449">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1449">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1450">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1450">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1451">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="6567e-1451">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1452">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1452">to execute a console application.</span></span> <span data-ttu-id="6567e-1453">关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1453">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-1454">包含要执行程序集的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1454">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1455">为程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1455">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1456">程序集的入口点的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-1456">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1457">使用指定的证据和自变量执行指定文件中包含的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1457">Executes the assembly contained in the specified file, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="6567e-1458">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1458">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1459">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1459">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1460">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1460">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="6567e-1461">此方法使用<xref:System.Reflection.Assembly.LoadFile%2A>方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1461">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="6567e-1462">你还可以使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法执行程序集, 该方法<xref:System.Reflection.Assembly.Load%2A>使用方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1462">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1463">下面的示例演示如何在两个不同的<xref:System.AppDomain.ExecuteAssembly%2A>域上使用重载之一。</span><span class="sxs-lookup"><span data-stu-id="6567e-1463">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1464"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1464"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1465"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-1465"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1466"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1466"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1467">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1467">-or-</span></span> 
<span data-ttu-id="6567e-1468">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1468">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1469">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1469">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1470">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1470">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-1471"><paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1471"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="6567e-1472">未启用旧版 CAS 策略时， <paramref name="assemblySecurity" /> 应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1472">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1473">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1473">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1474">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1474">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1475">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1475">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1476">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1476">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1477">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1477">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1478">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="6567e-1478">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1479">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1479">to execute a console application.</span></span> <span data-ttu-id="6567e-1480">关联的枚举<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1480">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-1481">包含要执行程序集的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1481">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1482">程序集的入口点的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-1482">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="6567e-1483">表示计算所得的哈希代码的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1483">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="6567e-1484">表示程序集清单使用的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1484">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="6567e-1485">使用指定的参数、哈希值和哈希算法执行指定文件中包含的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1485">Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="6567e-1486">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1486">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1487">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1487">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1488">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1488">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="6567e-1489">此方法使用<xref:System.Reflection.Assembly.LoadFile%2A>方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1489">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="6567e-1490">你还可以使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法执行程序集, 该方法<xref:System.Reflection.Assembly.Load%2A>使用方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1490">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1491">下面的示例演示如何在两个不同的<xref:System.AppDomain.ExecuteAssembly%2A>域上使用重载之一。</span><span class="sxs-lookup"><span data-stu-id="6567e-1491">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1492"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1492"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1493"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-1493"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1494"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1494"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1495">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1495">-or-</span></span> 
 <span data-ttu-id="6567e-1496"><paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1496"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1497">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1497">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1498">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1498">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1499">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1499">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1500">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1500">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1501">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1501">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1502">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="6567e-1502">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1503">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1503">to execute a console application.</span></span> <span data-ttu-id="6567e-1504">关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1504">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="6567e-1505">包含要执行程序集的文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1505">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1506">为程序集提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1506">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1507">程序集的入口点的实参。</span><span class="sxs-lookup"><span data-stu-id="6567e-1507">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="6567e-1508">表示计算所得的哈希代码的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1508">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="6567e-1509">表示程序集清单使用的哈希算法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1509">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="6567e-1510">使用指定的证据、参数、哈希值和哈希算法执行指定文件中包含的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1510">Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="6567e-1511">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1511">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1512">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1512">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1513">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1513">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="6567e-1514">此方法使用<xref:System.Reflection.Assembly.LoadFile%2A>方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1514">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="6567e-1515">你还可以使用<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法执行程序集, 该方法<xref:System.Reflection.Assembly.Load%2A>使用方法加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1515">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1516">下面的示例演示如何在两个不同的<xref:System.AppDomain.ExecuteAssembly%2A>域上使用重载之一。</span><span class="sxs-lookup"><span data-stu-id="6567e-1516">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1517"><paramref name="assemblyFile" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1517"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1518"><paramref name="assemblyFile" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-1518"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1519"><paramref name="assemblyFile" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1519"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1520">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1520">-or-</span></span> 
<span data-ttu-id="6567e-1521">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1521">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1522">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1522">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1523">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1523">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-1524"><paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1524"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="6567e-1525">未启用旧版 CAS 策略时， <paramref name="assemblySecurity" /> 应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1525">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1526">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1526">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1527">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1527">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1528">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1528">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1529">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1529">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1530">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1530">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1531">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="6567e-1531">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1532">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1532">to execute a console application.</span></span> <span data-ttu-id="6567e-1533">关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1533">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-1534">执行程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1534">Executes an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-1535">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1535">The display name of the assembly.</span></span> <span data-ttu-id="6567e-1536">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1536">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="6567e-1537">在给定其显示名称的情况下执行程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1537">Executes an assembly given its display name.</span></span></summary>
        <returns><span data-ttu-id="6567e-1538">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1538">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1539">方法为方法提供类似的功能, 但按显示名称指定<xref:System.Reflection.AssemblyName>程序集, 而不按文件位置指定。 <xref:System.AppDomain.ExecuteAssembly%2A> <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-1539">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="6567e-1540">因此, <xref:System.AppDomain.ExecuteAssemblyByName%2A>将<xref:System.Reflection.Assembly.Load%2A> 用<xref:System.Reflection.Assembly.LoadFile%2A>方法 (而不是方法) 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1540">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1541">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1541">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1542">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1542">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="6567e-1543">若要创建<xref:System.AppDomain>要加载和执行的, 请<xref:System.AppDomain.CreateDomain%2A>使用方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1543">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1544"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1544"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1545">找不到由 <paramref name="assemblyName" /> 指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1545">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1546">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1546">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1547">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1547">-or-</span></span> 
<span data-ttu-id="6567e-1548">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1548">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1549">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1549">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1550">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1550">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1551">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1551">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1552">用于从文件或目录进行读取的访问权限, 用于访问路径本身中的信息以及将显示名称重定向到路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1552">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="6567e-1553">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1553">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1554">对于访问网站, 将显示名称重定向到 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-1554">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1555">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1555">to execute a console application.</span></span> <span data-ttu-id="6567e-1556">关联的枚举<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1556">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-1557"><see cref="T:System.Reflection.AssemblyName" /> 对象，表示程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1557">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1558">启动该进程时传递的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="6567e-1558">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="6567e-1559">根据给定的 <see cref="T:System.Reflection.AssemblyName" /> 使用指定的自变量执行程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1559">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="6567e-1560">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1560">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1561">方法为方法提供类似的功能, 但按显示名称指定<xref:System.Reflection.AssemblyName>程序集, 而不按文件位置指定。 <xref:System.AppDomain.ExecuteAssembly%2A> <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-1561">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="6567e-1562">因此, <xref:System.AppDomain.ExecuteAssemblyByName%2A>将<xref:System.Reflection.Assembly.Load%2A> 用<xref:System.Reflection.Assembly.LoadFile%2A>方法 (而不是方法) 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1562">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1563">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1563">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1564">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1564">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1565">找不到由 <paramref name="assemblyName" /> 指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1565">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1566">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1566">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1567">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1567">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1568">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1568">-or-</span></span> 
 <span data-ttu-id="6567e-1569"><paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1569"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1570">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1570">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1571">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1571">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1572">用于从文件或目录进行读取的访问权限, 用于访问路径本身中的信息以及将显示名称重定向到路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1572">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="6567e-1573">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1573">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1574">对于访问网站, 将显示名称重定向到 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-1574">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1575">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1575">to execute a console application.</span></span> <span data-ttu-id="6567e-1576">关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1576">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-1577">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1577">The display name of the assembly.</span></span> <span data-ttu-id="6567e-1578">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1578">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1579">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1579">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1580">在给定显示名称的情况下，使用指定证据执行程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1580">Executes an assembly given its display name, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="6567e-1581">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1581">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1582">方法为方法提供类似的功能, 但按显示名称指定<xref:System.Reflection.AssemblyName>程序集, 而不按文件位置指定。 <xref:System.AppDomain.ExecuteAssembly%2A> <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-1582">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="6567e-1583">因此, <xref:System.AppDomain.ExecuteAssemblyByName%2A>将<xref:System.Reflection.Assembly.Load%2A> 用<xref:System.Reflection.Assembly.LoadFile%2A>方法 (而不是方法) 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1583">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1584">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1584">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1585"><xref:System.AppDomain.ExecuteAssemblyByName%2A>方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1585">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1586">将<xref:System.AppDomain.ExecuteAssemblyByName%2A> 方法<xref:System.Security.Policy.Evidence>与参数一起使用时, 会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="6567e-1586">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="6567e-1587">作为参数提供给<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1587">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1588"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1588"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1589">找不到由 <paramref name="assemblyName" /> 指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1589">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1590">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1590">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1591">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1591">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1592">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1592">-or-</span></span> 
<span data-ttu-id="6567e-1593">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1593">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1594">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1594">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1595">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1595">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1596">用于从文件或目录进行读取的访问权限, 用于访问路径本身中的信息以及将显示名称重定向到路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1596">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="6567e-1597">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1597">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1598">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1598">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1599">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1599">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1600">对于访问网站, 将显示名称重定向到 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-1600">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1601">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1601">to execute a console application.</span></span> <span data-ttu-id="6567e-1602">关联的枚举<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1602">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-2.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-1603">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1603">The display name of the assembly.</span></span> <span data-ttu-id="6567e-1604">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1604">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1605">启动该进程时传递的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="6567e-1605">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="6567e-1606">在给定显示名称的情况下，使用指定自变量执行程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1606">Executes the assembly given its display name, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="6567e-1607">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1607">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1608">方法为方法提供类似的功能, 但按显示名称指定<xref:System.Reflection.AssemblyName>程序集, 而不按文件位置指定。 <xref:System.AppDomain.ExecuteAssembly%2A> <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-1608">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="6567e-1609">因此, <xref:System.AppDomain.ExecuteAssemblyByName%2A>将<xref:System.Reflection.Assembly.Load%2A> 用<xref:System.Reflection.Assembly.LoadFile%2A>方法 (而不是方法) 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1609">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1610">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1610">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1611">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1611">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1612"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1612"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1613">找不到由 <paramref name="assemblyName" /> 指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1613">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1614">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1614">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1615">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1615">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1616">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1616">-or-</span></span> 
 <span data-ttu-id="6567e-1617"><paramref name="assemblyName" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1617"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1618">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1618">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1619">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1619">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1620">用于从文件或目录进行读取的访问权限, 用于访问路径本身中的信息以及将显示名称重定向到路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1620">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="6567e-1621">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1621">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1622">对于访问网站, 将显示名称重定向到 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-1622">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1623">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1623">to execute a console application.</span></span> <span data-ttu-id="6567e-1624">关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1624">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-1625"><see cref="T:System.Reflection.AssemblyName" /> 对象，表示程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1625">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1626">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1626">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1627">启动该进程时传递的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="6567e-1627">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="6567e-1628">根据给定的 <see cref="T:System.Reflection.AssemblyName" /> 使用指定的证据和实参执行程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1628">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="6567e-1629">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1629">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1630">方法为方法提供类似的功能, 但按显示名称指定<xref:System.Reflection.AssemblyName>程序集, 而不按文件位置指定。 <xref:System.AppDomain.ExecuteAssembly%2A> <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-1630">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="6567e-1631">因此, <xref:System.AppDomain.ExecuteAssemblyByName%2A>将<xref:System.Reflection.Assembly.Load%2A> 用<xref:System.Reflection.Assembly.LoadFile%2A>方法 (而不是方法) 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1631">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1632">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1632">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1633">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1633">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1634">将<xref:System.AppDomain.ExecuteAssemblyByName%2A> 方法<xref:System.Security.Policy.Evidence>与参数一起使用时, 会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="6567e-1634">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="6567e-1635">作为参数提供给<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1635">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1636">找不到由 <paramref name="assemblyName" /> 指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1636">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1637">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1637">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1638">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1638">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1639">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1639">-or-</span></span> 
<span data-ttu-id="6567e-1640">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1640">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1641">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1641">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-1642"><paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1642"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="6567e-1643">未启用旧版 CAS 策略时， <paramref name="assemblySecurity" /> 应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1643">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1644">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1644">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1645">用于从文件或目录进行读取的访问权限, 用于访问路径本身中的信息以及将显示名称重定向到路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1645">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="6567e-1646">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1646">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1647">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1647">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1648">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1648">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1649">对于访问网站, 将显示名称重定向到 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-1649">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1650">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1650">to execute a console application.</span></span> <span data-ttu-id="6567e-1651">关联枚举：<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1651">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="args" Type="System.String[]" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="6567e-1652">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1652">The display name of the assembly.</span></span> <span data-ttu-id="6567e-1653">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1653">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1654">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1654">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="6567e-1655">启动该进程时传递的命令行参数。</span><span class="sxs-lookup"><span data-stu-id="6567e-1655">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="6567e-1656">在给定其显示名称的情况下，使用指定证据和实参执行程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1656">Executes the assembly given its display name, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="6567e-1657">程序集的入口点返回的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1657">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1658">方法为方法提供类似的功能, 但按显示名称指定<xref:System.Reflection.AssemblyName>程序集, 而不按文件位置指定。 <xref:System.AppDomain.ExecuteAssembly%2A> <xref:System.AppDomain.ExecuteAssemblyByName%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-1658">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="6567e-1659">因此, <xref:System.AppDomain.ExecuteAssemblyByName%2A>将<xref:System.Reflection.Assembly.Load%2A> 用<xref:System.Reflection.Assembly.LoadFile%2A>方法 (而不是方法) 加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1659">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1660">程序集开始在 .NET Framework 标头中指定的入口点执行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1660">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="6567e-1661">此方法不会创建新的进程或应用程序域, 也不会在新线程上执行入口点方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1661">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1662">将<xref:System.AppDomain.ExecuteAssemblyByName%2A> 方法<xref:System.Security.Policy.Evidence>与参数一起使用时, 会合并证据部分。</span><span class="sxs-lookup"><span data-stu-id="6567e-1662">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="6567e-1663">作为参数提供给<xref:System.AppDomain.ExecuteAssemblyByName%2A>方法的证据将取代加载程序提供的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1663">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1664"><paramref name="assemblyName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1664"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1665">找不到由 <paramref name="assemblyName" /> 指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1665">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1666">找到了由 <paramref name="assemblyName" /> 指定的程序集，但无法加载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1666">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1667">由 <paramref name="assemblyName" /> 指定的程序集不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1667">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1668">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1668">-or-</span></span> 
<span data-ttu-id="6567e-1669">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyName" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1669">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1670">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1670">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-1671"><paramref name="assemblySecurity" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1671"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="6567e-1672">未启用旧版 CAS 策略时， <paramref name="assemblySecurity" /> 应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1672">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="6567e-1673">指定的程序集没有入口点。</span><span class="sxs-lookup"><span data-stu-id="6567e-1673">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1674">用于从文件或目录进行读取的访问权限, 用于访问路径本身中的信息以及将显示名称重定向到路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1674">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="6567e-1675">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1675">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1676">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1676">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1677">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1677">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1678">对于访问网站, 将显示名称重定向到 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-1678">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="6567e-1679">执行控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1679">to execute a console application.</span></span> <span data-ttu-id="6567e-1680">关联的枚举<see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1680">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1681">当托管代码抛出异常时发生，在运行时在调用堆栈中搜索应用程序域中的异常处理程序之前。</span><span class="sxs-lookup"><span data-stu-id="6567e-1681">Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1682">此事件只是一个通知。</span><span class="sxs-lookup"><span data-stu-id="6567e-1682">This event is only a notification.</span></span> <span data-ttu-id="6567e-1683">处理此事件不会处理异常, 也不会影响后续的异常处理。</span><span class="sxs-lookup"><span data-stu-id="6567e-1683">Handling this event does not handle the exception or affect subsequent exception handling in any way.</span></span> <span data-ttu-id="6567e-1684">引发事件并调用事件处理程序后, 公共语言运行时 (CLR) 开始搜索异常的处理程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1684">After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</span></span> <span data-ttu-id="6567e-1685"><xref:System.AppDomain.FirstChanceException>向应用程序域提供第一次可能检查任何托管异常的机会。</span><span class="sxs-lookup"><span data-stu-id="6567e-1685"><xref:System.AppDomain.FirstChanceException> provides the application domain with a first chance to examine any managed exception.</span></span>  
  
 <span data-ttu-id="6567e-1686">可以按应用程序域处理事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1686">The event can be handled per application domain.</span></span> <span data-ttu-id="6567e-1687">如果线程在执行调用时传递到多个应用程序域, 则会在已注册事件处理程序的每个应用程序域中引发事件, 然后 CLR 开始在该应用程序域中搜索匹配的异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1687">If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</span></span> <span data-ttu-id="6567e-1688">处理事件后, 会在该应用程序域中搜索匹配的异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1688">After the event has been handled, a search is made for a matching exception handler in that application domain.</span></span> <span data-ttu-id="6567e-1689">如果未找到任何内容, 则会在下一个应用程序域中引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1689">If none is found, the event is raised in the next application domain.</span></span>  
  
 <span data-ttu-id="6567e-1690">您必须处理<xref:System.AppDomain.FirstChanceException>事件的事件处理程序中发生的所有异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-1690">You must handle all exceptions that occur in the event handler for the <xref:System.AppDomain.FirstChanceException> event.</span></span> <span data-ttu-id="6567e-1691">否则, <xref:System.AppDomain.FirstChanceException>将以递归方式引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1691">Otherwise, <xref:System.AppDomain.FirstChanceException> is raised recursively.</span></span> <span data-ttu-id="6567e-1692">这可能导致堆栈溢出和终止应用程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-1692">This could result in a stack overflow and termination of the application.</span></span> <span data-ttu-id="6567e-1693">我们建议你将此事件的事件处理程序实现为受约束的执行区域 (Cer), 以将与基础结构相关的异常 (如内存不足或堆栈溢出) 与影响虚拟机有关, 同时引发异常通知正在处理。</span><span class="sxs-lookup"><span data-stu-id="6567e-1693">We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</span></span>  
  
 <span data-ttu-id="6567e-1694">如果异常指示进程状态损坏 (如访问冲突), 则不会引发此事件, 除非事件处理程序是安全关键的并且具有<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute>属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1694">This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="6567e-1695">当处理此通知事件时, 公共语言运行时挂起线程中止。</span><span class="sxs-lookup"><span data-stu-id="6567e-1695">The common language runtime suspends thread aborts while this notification event is being handled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1696">下面的示例创建一个名为`AD0` `AD3`的应用程序域系列, 其中`Worker`每个应用程序域中有一个对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1696">The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain.</span></span> <span data-ttu-id="6567e-1697">每`Worker`个对象都有一个对`Worker`下一个应用程序域中的对象的引用`Worker` , 最后一个应用程序域中的除外。</span><span class="sxs-lookup"><span data-stu-id="6567e-1697">Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain.</span></span> <span data-ttu-id="6567e-1698">此<xref:System.AppDomain.FirstChanceException>事件在除之外`AD1`的所有应用程序域中进行处理。</span><span class="sxs-lookup"><span data-stu-id="6567e-1698">The <xref:System.AppDomain.FirstChanceException> event is handled in all application domains except `AD1`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1699">除了在多个应用程序域中演示第一次异常通知的示例外, 你可以在[如何:接收首次异常通知](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1699">In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span></span>  
  
 <span data-ttu-id="6567e-1700">创建应用程序域后, 默认应用程序域将为第一个`TestException`应用程序域调用方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1700">When the application domains have been created, the default application domain calls the `TestException` method for the first application domain.</span></span> <span data-ttu-id="6567e-1701">每`Worker`个对象都`TestException`为下一个应用程序域调用方法, 直到`Worker`最后引发处理或未处理的异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-1701">Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled.</span></span> <span data-ttu-id="6567e-1702">因此, 当前线程通过所有应用程序域, 并`TestException`添加到每个应用程序域中的堆栈中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1702">Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.</span></span>  
  
 <span data-ttu-id="6567e-1703">当最后一个`Worker`对象处理异常时<xref:System.AppDomain.FirstChanceException> , 只会在最后一个应用程序域中引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1703">When the last `Worker` object handles the exception, the <xref:System.AppDomain.FirstChanceException> event is raised only in the last application domain.</span></span> <span data-ttu-id="6567e-1704">其他应用程序域绝不会有机会处理异常, 因此不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1704">The other application domains never get a chance to handle the exception, so the event is not raised.</span></span>  
  
 <span data-ttu-id="6567e-1705">如果最后一个`Worker`对象不处理异常<xref:System.AppDomain.FirstChanceException> , 则会在具有事件处理程序的每个应用程序域中引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-1705">When the last `Worker` object does not handle the exception, the <xref:System.AppDomain.FirstChanceException> event is raised in each application domain that has an event handler.</span></span> <span data-ttu-id="6567e-1706">每个事件处理程序完成后, 堆栈将继续展开, 直到默认应用程序域捕获到该异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-1706">After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1707">在事件处理程序中`e.Exception.Message` `FirstChanceHandler` , 若要查看随着事件更接近且更接近于默认应用程序域, 堆栈显示`e.Exception`方式如何增长。</span><span class="sxs-lookup"><span data-stu-id="6567e-1707">To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers.</span></span> <span data-ttu-id="6567e-1708">请注意, `TestException`当跨应用程序域边界调用时, 它会出现两次: 一次用于代理, 一次用于存根。</span><span class="sxs-lookup"><span data-stu-id="6567e-1708">Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</span></span>  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-1709">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-1709">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-1710">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-1710">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113"><span data-ttu-id="6567e-1711">如何：接收第一机会异常通知</span><span class="sxs-lookup"><span data-stu-id="6567e-1711">How to: Receive First-Chance Exception Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1712">获取此应用程序域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1712">Gets the friendly name of this application domain.</span></span></summary>
        <value><span data-ttu-id="6567e-1713">此应用程序域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1713">The friendly name of this application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1714">默认应用程序域的友好名称是进程可执行文件的文件名。</span><span class="sxs-lookup"><span data-stu-id="6567e-1714">The friendly name of the default application domain is the file name of the process executable.</span></span> <span data-ttu-id="6567e-1715">例如, 如果用于启动进程的可执行文件是`"c:\MyAppDirectory\MyAssembly.exe"`, 则默认应用程序域的友好名称是。 `"MyAssembly.exe"`</span><span class="sxs-lookup"><span data-stu-id="6567e-1715">For example, if the executable used to start the process is `"c:\MyAppDirectory\MyAssembly.exe"`, the friendly name of the default application domain is `"MyAssembly.exe"`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1716">下面的代码示例使用<xref:System.AppDomain.FriendlyName%2A>属性获取当前应用程序域的友好名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1716">The following code example uses the <xref:System.AppDomain.FriendlyName%2A> property to get the friendly name of the current application domain.</span></span> <span data-ttu-id="6567e-1717">对于默认应用程序域, 友好名称是应用程序的可执行文件的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1717">For the default application domain, the friendly name is the name of the application's executable file.</span></span> <span data-ttu-id="6567e-1718">此代码示例还显示了有关应用程序域的其他信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-1718">The code example also displays additional information about the application domain.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1719">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1719">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-1720">获取已加载到此应用程序域的执行上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1720">Gets the assemblies that have been loaded into the execution context of this application domain.</span></span></summary>
        <returns><span data-ttu-id="6567e-1721">此应用程序域中的程序集的数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-1721">An array of assemblies in this application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6567e-1722">下面的代码示例使用<xref:System.AppDomain.GetAssemblies%2A>方法来获取已加载到应用程序域中的所有程序集的列表。</span><span class="sxs-lookup"><span data-stu-id="6567e-1722">The following code example uses the <xref:System.AppDomain.GetAssemblies%2A> method to get a list of all assemblies that have been loaded into the application domain.</span></span> <span data-ttu-id="6567e-1723">然后, 将程序集显示到控制台。</span><span class="sxs-lookup"><span data-stu-id="6567e-1723">The assemblies are then displayed to the console.</span></span>  
  
 <span data-ttu-id="6567e-1724">若要运行此代码示例, 需要创建一个名为`CustomLibrary.dll`的程序集, 或更改传递给该<xref:System.AppDomain.GetAssemblies%2A>方法的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1724">To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1725">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1725">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  https://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-1726">获取当前线程标识符。</span><span class="sxs-lookup"><span data-stu-id="6567e-1726">Gets the current thread identifier.</span></span></summary>
        <returns><span data-ttu-id="6567e-1727">一个 32 位带符号整数，它是当前线程的标识符。</span><span class="sxs-lookup"><span data-stu-id="6567e-1727">A 32-bit signed integer that is the identifier of the current thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1728"><xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>使用属性 (即使 .NET Framework 由支持纤程的环境 (即轻型线程) 承载), 也是稳定的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1728">Use the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1729">调用此方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1729">to call this method.</span></span> <span data-ttu-id="6567e-1730">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-1730">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span> <span data-ttu-id="6567e-1731">安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1731">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-1732">预定义应用程序域属性的名称，或已定义的应用程序域属性的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1732">The name of a predefined application domain property, or the name of an application domain property you have defined.</span></span></param>
        <summary><span data-ttu-id="6567e-1733">为指定名称获取存储在当前应用程序域中的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1733">Gets the value stored in the current application domain for the specified name.</span></span></summary>
        <returns><span data-ttu-id="6567e-1734"><paramref name="name" /> 属性的值，或 <see langword="null" />（如果属性不存在）。</span><span class="sxs-lookup"><span data-stu-id="6567e-1734">The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1735">使用此方法检索名称数据对的内部缓存中的项的值, 这些名称数据对用于描述此实例的<xref:System.AppDomain>属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1735">Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span> <span data-ttu-id="6567e-1736">请注意, `name`与键值对的名称比较是区分大小写的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1736">Note that the comparison of `name` with the name of key-value pairs is case-sensitive.</span></span>  
  
 <span data-ttu-id="6567e-1737">缓存自动包含创建应用程序域时插入的预定义系统条目。</span><span class="sxs-lookup"><span data-stu-id="6567e-1737">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="6567e-1738">可以通过<xref:System.AppDomain.GetData%2A>方法或等效<xref:System.AppDomainSetup>属性检查其值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1738">You can inspect their values with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties.</span></span>  
  
 <span data-ttu-id="6567e-1739">可以通过<xref:System.AppDomain.SetData%2A>方法插入或修改自己的用户定义的名称数据对, 并<xref:System.AppDomain.GetData%2A>通过方法检查其值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1739">You can insert or modify your own user defined name-data pairs with the <xref:System.AppDomain.SetData%2A> method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 <span data-ttu-id="6567e-1740">下表描述`name`了每个预定义系统项及其对应<xref:System.AppDomainSetup>属性的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1740">The following table describes the `name` of each predefined system entry and its corresponding <xref:System.AppDomainSetup> property.</span></span>  
  
|<span data-ttu-id="6567e-1741">"Name" 的值</span><span class="sxs-lookup"><span data-stu-id="6567e-1741">Value of 'name'</span></span>|<span data-ttu-id="6567e-1742">Property</span><span class="sxs-lookup"><span data-stu-id="6567e-1742">Property</span></span>|  
|---------------------|--------------|  
|<span data-ttu-id="6567e-1743">APPBASE</span><span class="sxs-lookup"><span data-stu-id="6567e-1743">"APPBASE"</span></span>|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1744">"APP_CONFIG_FILE"</span><span class="sxs-lookup"><span data-stu-id="6567e-1744">"APP_CONFIG_FILE"</span></span>|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1745">"APP_LAUNCH_URL"</span><span class="sxs-lookup"><span data-stu-id="6567e-1745">"APP_LAUNCH_URL"</span></span>|<span data-ttu-id="6567e-1746">(无属性)</span><span class="sxs-lookup"><span data-stu-id="6567e-1746">(no property)</span></span><br /><br /> <span data-ttu-id="6567e-1747">"APP_LAUNCH_URL" 代表用户在任何重定向之前最初请求的 URL。</span><span class="sxs-lookup"><span data-stu-id="6567e-1747">"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</span></span> <span data-ttu-id="6567e-1748">仅当使用浏览器 (如 Internet Explorer) 启动应用程序时, 此功能才可用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1748">It is available only when the application has been launched with a browser such as Internet Explorer.</span></span> <span data-ttu-id="6567e-1749">并非所有浏览器都提供此值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1749">Not all browsers provide this value.</span></span>|  
|<span data-ttu-id="6567e-1750">"APP_NAME"</span><span class="sxs-lookup"><span data-stu-id="6567e-1750">"APP_NAME"</span></span>|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1751">"BINPATH_PROBE_ONLY"</span><span class="sxs-lookup"><span data-stu-id="6567e-1751">"BINPATH_PROBE_ONLY"</span></span>|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1752">"CACHE_BASE"</span><span class="sxs-lookup"><span data-stu-id="6567e-1752">"CACHE_BASE"</span></span>|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1753">"CODE_DOWNLOAD_DISABLED"</span><span class="sxs-lookup"><span data-stu-id="6567e-1753">"CODE_DOWNLOAD_DISABLED"</span></span>|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1754">"DEV_PATH"</span><span class="sxs-lookup"><span data-stu-id="6567e-1754">"DEV_PATH"</span></span>|<span data-ttu-id="6567e-1755">(无属性)</span><span class="sxs-lookup"><span data-stu-id="6567e-1755">(no property)</span></span>|  
|<span data-ttu-id="6567e-1756">"DISALLOW_APP"</span><span class="sxs-lookup"><span data-stu-id="6567e-1756">"DISALLOW_APP"</span></span>|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1757">"DISALLOW_APP_BASE_PROBING"</span><span class="sxs-lookup"><span data-stu-id="6567e-1757">"DISALLOW_APP_BASE_PROBING"</span></span>|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1758">"DISALLOW_APP_REDIRECTS"</span><span class="sxs-lookup"><span data-stu-id="6567e-1758">"DISALLOW_APP_REDIRECTS"</span></span>|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1759">"DYNAMIC_BASE"</span><span class="sxs-lookup"><span data-stu-id="6567e-1759">"DYNAMIC_BASE"</span></span>|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1760">"FORCE_CACHE_INSTALL"</span><span class="sxs-lookup"><span data-stu-id="6567e-1760">"FORCE_CACHE_INSTALL"</span></span>|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1761">"LICENSE_FILE" 或特定于应用程序的字符串</span><span class="sxs-lookup"><span data-stu-id="6567e-1761">"LICENSE_FILE", or an application-specific string</span></span>|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1762">"LOADER_OPTIMIZATION"</span><span class="sxs-lookup"><span data-stu-id="6567e-1762">"LOADER_OPTIMIZATION"</span></span>|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1763">"LOCATION_URI"</span><span class="sxs-lookup"><span data-stu-id="6567e-1763">"LOCATION_URI"</span></span>|<span data-ttu-id="6567e-1764">(无属性)</span><span class="sxs-lookup"><span data-stu-id="6567e-1764">(no property)</span></span>|  
|<span data-ttu-id="6567e-1765">"PRIVATE_BINPATH"</span><span class="sxs-lookup"><span data-stu-id="6567e-1765">"PRIVATE_BINPATH"</span></span>|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="6567e-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span><span class="sxs-lookup"><span data-stu-id="6567e-1766">"REGEX_DEFAULT_MATCH_TIMEOUT"</span></span>|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> <span data-ttu-id="6567e-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" 不是系统项, 可以通过调用<xref:System.AppDomain.SetData%2A>方法来设置其值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1767">"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <xref:System.AppDomain.SetData%2A> method.</span></span>|  
|<span data-ttu-id="6567e-1768">"SHADOW_COPY_DIRS"</span><span class="sxs-lookup"><span data-stu-id="6567e-1768">"SHADOW_COPY_DIRS"</span></span>|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1769">下面的示例创建一个新的应用程序域, 为域设置系统提供的值, 并为该域添加一个新的值对。</span><span class="sxs-lookup"><span data-stu-id="6567e-1769">The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</span></span> <span data-ttu-id="6567e-1770">然后, 该示例演示如何使用<xref:System.AppDomain.GetData%2A>方法来检索这些值对中的数据, 并将其显示在控制台中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1770">The example then demonstrates how to use the <xref:System.AppDomain.GetData%2A> method to retrieve the data from these value pairs and display them to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1771"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1771"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1772">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1772">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1773">如果属性适用于路径, 则用于访问路径本身中的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-1773">for access to the information in the path itself, if the property applies to a path.</span></span> <span data-ttu-id="6567e-1774">关联枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1774">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-1775">获取当前实例的类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-1775">Gets the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="6567e-1776">当前实例的类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-1776">The type of the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1777">获得一个整数，该整数唯一标识进程中的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1777">Gets an integer that uniquely identifies the application domain within the process.</span></span></summary>
        <value><span data-ttu-id="6567e-1778">标识应用程序域的整数。</span><span class="sxs-lookup"><span data-stu-id="6567e-1778">An integer that identifies the application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6567e-1779">下面的代码示例创建另一个应用程序域, 并显示有关默认域和新域的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-1779">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-1780">通过防止创建租约来给予 <see cref="T:System.AppDomain" /> 无限生存期。</span><span class="sxs-lookup"><span data-stu-id="6567e-1780">Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</span></span></summary>
        <returns><span data-ttu-id="6567e-1781">总是为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1781">Always <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1782">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1782">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-1783">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-1783">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-1784">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-1784">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="6567e-1785">要测试的兼容性开关。</span><span class="sxs-lookup"><span data-stu-id="6567e-1785">The compatibility switch to test.</span></span></param>
        <summary><span data-ttu-id="6567e-1786">获取可以为 null 的布尔值，该值指示是否设置了任何兼容性开关，如果已设置，则指定是否设置了指定的兼容性开关。</span><span class="sxs-lookup"><span data-stu-id="6567e-1786">Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</span></span></summary>
        <returns><span data-ttu-id="6567e-1787">如果未设置任何兼容性开关，则为 null 引用（Visual Basic 中的 <see langword="Nothing" />）；否则，为布尔值，指示是否设置了由 <paramref name="value" /> 指定的兼容性开关。</span><span class="sxs-lookup"><span data-stu-id="6567e-1787">A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1788">此方法测试是否已为当前应用程序域设置了指定的兼容性开关。</span><span class="sxs-lookup"><span data-stu-id="6567e-1788">This method tests whether the specified compatibility switch has been set for the current application domain.</span></span> <span data-ttu-id="6567e-1789">兼容性开关通常会还原在不同版本的 .NET Framework 之间发生更改的行为 (例如字符串排序方式)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1789">Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</span></span>  <span data-ttu-id="6567e-1790">它们是在创建应用程序<xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType>域之前通过调用方法设置的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1790">They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> method before creating an application domain.</span></span>  
  
 <span data-ttu-id="6567e-1791">下表提供了可设置为还原 .NET Framework 早期版本的行为的兼容性开关的示例。</span><span class="sxs-lookup"><span data-stu-id="6567e-1791">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="6567e-1792">开关</span><span class="sxs-lookup"><span data-stu-id="6567e-1792">Switch</span></span>|<span data-ttu-id="6567e-1793">含义</span><span class="sxs-lookup"><span data-stu-id="6567e-1793">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="6567e-1794">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="6567e-1794">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="6567e-1795">在此应用程序域中启用了[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]的代码访问安全性 (CAS)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1795">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="6567e-1796">请[ &lt;参阅y&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1796">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="6567e-1797">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="6567e-1797">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="6567e-1798">在此应用程序域[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]中启用了的字符串排序默认值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1798">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="6567e-1799">它的成功要求安装 sort00001000.dll。</span><span class="sxs-lookup"><span data-stu-id="6567e-1799">Its success requires sort00001000.dll to be installed.</span></span> <span data-ttu-id="6567e-1800">请[ &lt;参阅CompatSortNLSVersion&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1800">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="6567e-1801">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="6567e-1801">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="6567e-1802">在此应用程序域[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]中启用和 Unicode 5.0 的字符串排序默认值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1802">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="6567e-1803">它的成功要求安装 sort00060101。</span><span class="sxs-lookup"><span data-stu-id="6567e-1803">Its success requires sort00060101.dll to be installed.</span></span>|  
|<span data-ttu-id="6567e-1804">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="6567e-1804">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="6567e-1805"><xref:System.TimeSpan>此应用程序域[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]中启用了的格式设置行为。</span><span class="sxs-lookup"><span data-stu-id="6567e-1805"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span>  <span data-ttu-id="6567e-1806">请[ &lt;参阅&gt; ](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) <xref:System.TimeSpan>主题中的 TimeSpan_LegacyFormatMode 元素和 "还原旧的 TimeSpan 格式" 部分。</span><span class="sxs-lookup"><span data-stu-id="6567e-1806">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="6567e-1807">"UseRandomizedStringHashAlgorithm"</span><span class="sxs-lookup"><span data-stu-id="6567e-1807">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="6567e-1808">运行时基于每个应用程序域计算字符串的哈希代码, 而不是使用单个哈希算法跨应用程序域生成一致的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="6567e-1808">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="6567e-1809">请[ &lt;参阅UseRandomizedStringHashAlgorithm&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1809">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-1810">返回一个值，指示应用程序域是否是进程的默认应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1810">Returns a value that indicates whether the application domain is the default application domain for the process.</span></span></summary>
        <returns><span data-ttu-id="6567e-1811">如果当前 <see cref="T:System.AppDomain" /> 对象表示进程的默认应用程序域，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1811"><see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1812">每个托管进程都有一个默认的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1812">Every managed process has a default application domain.</span></span> <span data-ttu-id="6567e-1813">执行在默认域中开始。</span><span class="sxs-lookup"><span data-stu-id="6567e-1813">Execution begins in the default domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1814">下面的代码示例创建另一个应用程序域, 并显示有关默认域和新域的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-1814">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-1815">指示此应用程序域是否正在卸载以及公共语言运行时是否正在终止该域包含的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1815">Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</span></span></summary>
        <returns><span data-ttu-id="6567e-1816">如果此应用程序域正在卸载，并且公共语言运行时已开始调用终止程序，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1816"><see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1817">对象的终止方法使您能够在垃圾回收对象之前执行任何必要的清理操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1817">The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</span></span> <span data-ttu-id="6567e-1818">完成后, 对象可访问但处于无效状态, 因此无法使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-1818">After finalization, the object is accessible but in an invalid state and therefore unusable.</span></span> <span data-ttu-id="6567e-1819">最终, 垃圾回收完成并回收对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1819">Eventually, garbage collection completes and reclaims the object.</span></span>  
  
 <span data-ttu-id="6567e-1820">对象的终止方法是在以下情况之一中调用的: 在垃圾回收过程中, 当公共语言运行时关闭时, 或者当卸载包含对象的应用程序域时。</span><span class="sxs-lookup"><span data-stu-id="6567e-1820">An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</span></span> <span data-ttu-id="6567e-1821">此<xref:System.AppDomain.IsFinalizingForUnload%2A>方法仅`true`在最后一种情况下返回; 如果从`true`例程垃圾回收或 CLR 关闭结束结果, 则不会返回。</span><span class="sxs-lookup"><span data-stu-id="6567e-1821">The <xref:System.AppDomain.IsFinalizingForUnload%2A> method returns `true` only in the last case; it does not return `true` if finalization results from routine garbage collection or from CLR shutdown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1822">若要确定完成是否是由于 CLR 关闭引起的, <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType>请使用属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1822">To determine whether finalization is due to CLR shutdown, use the <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="6567e-1823">如果终止`true`是由于正在卸载的应用程序域或 CLR 正在关闭, 则返回。</span><span class="sxs-lookup"><span data-stu-id="6567e-1823">It returns `true` if finalization is due to an application domain being unloaded or to the CLR shutting down.</span></span>  
  
 <span data-ttu-id="6567e-1824">在域卸载过程中, 在你的完成方法中执行时, 你可能想要访问由静态字段引用的另一个对象并具有一个终止方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1824">While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</span></span> <span data-ttu-id="6567e-1825">但是, 您不能可靠地这样做, 因为访问的对象可能已经完成。</span><span class="sxs-lookup"><span data-stu-id="6567e-1825">However, you cannot reliably do so because the accessed object might already have been finalized.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1826">此规则的例外情况是<xref:System.Console>类, 该类包含引用流对象的静态字段, 但它是专门实现的, 因此即使在域卸载或系统关闭期间, 你始终可以写入系统控制台。</span><span class="sxs-lookup"><span data-stu-id="6567e-1826">An exception to this rule is the <xref:System.Console> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</span></span>  
  
 <span data-ttu-id="6567e-1827">在对象的终止方法中使用此方法可确定包含该对象的应用程序域是否正在卸载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1827">Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</span></span> <span data-ttu-id="6567e-1828">如果是这种情况, 则无法可靠地访问任何具有终止方法并且由静态字段引用的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1828">If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1829">获取一个值，该值指示加载到当前应用程序域的程序集是否是以完全信任方式执行的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1829">Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</span></span></summary>
        <value><span data-ttu-id="6567e-1830">如果加载到当前应用程序域的程序集是以完全信任方式执行的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1830"><see langword="true" /> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1831">此方法始终返回`true`在桌面上运行的应用程序的默认应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1831">This method always returns `true` for the default application domain of an application that runs on the desktop.</span></span> <span data-ttu-id="6567e-1832">它为`false` <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>使用方法重载创建的沙盒应用程序域返回, 除非授予该应用程序域的权限等效于完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-1832">It returns `false` for a sandboxed application domain that was created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1833">下面的示例演示<xref:System.AppDomain.IsFullyTrusted%2A>具有完全信任和部分信任的应用程序域的属性<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-1833">The following example demonstrates the <xref:System.AppDomain.IsFullyTrusted%2A> property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> property with fully trusted and partially trusted application domains.</span></span> <span data-ttu-id="6567e-1834">完全受信任的应用程序域是应用程序的默认应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1834">The fully trusted application domain is the default application domain for the application.</span></span> <span data-ttu-id="6567e-1835">使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法重载创建部分受信任的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-1835">The partially trusted application domain is created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="6567e-1836">该示例使用`Worker`派生自<xref:System.MarshalByRefObject>的类, 因此它可以跨应用程序域边界进行封送处理。</span><span class="sxs-lookup"><span data-stu-id="6567e-1836">The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="6567e-1837">该示例在默认`Worker`应用程序域中创建对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1837">The example creates a `Worker` object in the default application domain.</span></span> <span data-ttu-id="6567e-1838">然后, 它调用`TestIsFullyTrusted`方法以显示应用程序域的属性值, 以及加载到应用程序域中的两个程序集的属性值: mscorlib, 这是 .NET Framework 的一部分, 以及示例程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1838">It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</span></span> <span data-ttu-id="6567e-1839">应用程序域是完全受信任的, 因此这两个程序集都是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1839">The application domain is fully trusted, so both assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="6567e-1840">该示例在沙盒`Worker`应用程序域中创建另一个对象, 并`TestIsFullyTrusted`再次调用方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-1840">The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method.</span></span> <span data-ttu-id="6567e-1841">即使在部分受信任的应用程序域中, Mscorlib 也始终是受信任的, 但该示例程序集是部分受信任的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1841">Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</span></span>  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-1842">获取一个值，该值指示当前应用程序域是否拥有一个为加载到该应用程序域的所有程序集授予的权限集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1842">Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</span></span></summary>
        <value><span data-ttu-id="6567e-1843">如果当前应用程序域具有一组同构权限，则为 <see langword="true" />；否则，为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1843"><see langword="true" /> if the current application domain has a homogenous set of permissions; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1844">此属性返回`true`通过<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>使用方法重载创建的沙盒应用程序域的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1844">This property returns `true` for sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="6567e-1845">沙盒应用程序域具有一组相同的权限;也就是说, 对加载到应用程序域中的所有部分受信任的程序集授予相同的权限集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1845">Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="6567e-1846">沙盒应用程序域 (可选) 有一个从该权限集中免除的具有强名称的程序集的列表, 而是使用完全信任级别运行。</span><span class="sxs-lookup"><span data-stu-id="6567e-1846">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 <span data-ttu-id="6567e-1847">完全受信任的<xref:System.AppDomain.PermissionSet%2A>代码可以使用属性来确定沙盒应用程序域的同源授权集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1847">Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.</span></span>  
  
 <span data-ttu-id="6567e-1848">此属性还将`true`为桌面应用程序的默认应用程序域返回, 因为该应用程序域授予所有程序集的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-1848">This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-1849">将 <see cref="T:System.Reflection.Assembly" /> 加载到此应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1849">Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="6567e-1850"><see langword="byte" /> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</span><span class="sxs-lookup"><span data-stu-id="6567e-1850">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1851">加载带有基于通用对象文件格式 (COFF) 的图像的 <see cref="T:System.Reflection.Assembly" />，该图像包含已发出的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1851">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="6567e-1852">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1852">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1853">从开始, 使用此方法加载的程序集的信任级别与应用程序域的信任级别相同。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-1853">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="6567e-1854">此方法只应用于将程序集加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1854">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="6567e-1855">提供此方法是为了为无法调用静态<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法的互操作性调用方提供便利。</span><span class="sxs-lookup"><span data-stu-id="6567e-1855">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6567e-1856">若要将程序集加载到其他应用程序域中, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>请使用方法 (如)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1856">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="6567e-1857">有关此方法的所有重载所共有的信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1857">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1858">下面的示例演示如何加载原始程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1858">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="6567e-1859">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1859">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1860">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1860">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1861"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1861"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1862"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1862"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1863">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1863">-or-</span></span> 
<span data-ttu-id="6567e-1864">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1864">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1865">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1865">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1866">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1866">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1867">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1867">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1868">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1868">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="6567e-1869">描述要加载的程序集的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1869">An object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="6567e-1870">在给定 <see cref="T:System.Reflection.AssemblyName" /> 的情况下加载 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1870">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="6567e-1871">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1871">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1872">此方法只应用于将程序集加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1872">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="6567e-1873">提供此方法是为了为无法调用静态<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法的互操作性调用方提供便利。</span><span class="sxs-lookup"><span data-stu-id="6567e-1873">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6567e-1874">若要将程序集加载到其他应用程序域中, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>请使用方法 (如)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1874">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="6567e-1875">如果已加载请求的程序集的版本, 则即使请求了不同的版本, 此方法也会返回已加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1875">If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</span></span>  
  
 <span data-ttu-id="6567e-1876">不建议为提供部分程序`assemblyRef`集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1876">Supplying a partial assembly name for `assemblyRef` is not recommended.</span></span> <span data-ttu-id="6567e-1877">(部分名称省略了一个或多个区域性、版本或公钥标记。</span><span class="sxs-lookup"><span data-stu-id="6567e-1877">(A partial name omits one or more of culture, version, or public key token.</span></span> <span data-ttu-id="6567e-1878">对于采用字符串而不是<xref:System.Reflection.AssemblyName>对象的重载, "MyAssembly, version = 1.0.0.0" 是部分名称的示例, "MyAssembly, version = 1.0.0.0, Culture = 中立, PublicKeyToken = 18ab3442da84b47" 是全名的示例。)使用部分名称会对性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="6567e-1878">For overloads that take a string instead of an <xref:System.Reflection.AssemblyName> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</span></span> <span data-ttu-id="6567e-1879">此外, 仅当应用程序基目录 (<xref:System.AppDomain.BaseDirectory%2A>或<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>) 中存在程序集的精确副本时, 部分程序集名称才可以从全局程序集缓存加载程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1879">In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<xref:System.AppDomain.BaseDirectory%2A> or <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="6567e-1880">如果当前<xref:System.AppDomain>对象表示应用程序域`A`, 并且<xref:System.AppDomain.Load%2A>从应用程序域`B`中调用方法, 则会将程序集加载到这两个应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1880">If the current <xref:System.AppDomain> object represents application domain `A`, and the <xref:System.AppDomain.Load%2A> method is called from application domain `B`, the assembly is loaded into both application domains.</span></span> <span data-ttu-id="6567e-1881">例如, 以下代码将加载到`MyAssembly`新应用程序域`ChildDomain`中, 同时加载到代码执行的应用程序域中:</span><span class="sxs-lookup"><span data-stu-id="6567e-1881">For example, the following code loads `MyAssembly` into the new application domain `ChildDomain` and also into the application domain where the code executes:</span></span>  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 <span data-ttu-id="6567e-1882">由于<xref:System.Reflection.Assembly>不是从<xref:System.MarshalByRefObject>派生的, 因此程序集将加载到这两个域中, 因此<xref:System.AppDomain.Load%2A>无法封送方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="6567e-1882">The assembly is loaded into both domains because <xref:System.Reflection.Assembly> does not derive from <xref:System.MarshalByRefObject>, and therefore the return value of the <xref:System.AppDomain.Load%2A> method cannot be marshaled.</span></span> <span data-ttu-id="6567e-1883">相反, 公共语言运行时尝试将程序集加载到调用应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1883">Instead, the common language runtime tries to load the assembly into the calling application domain.</span></span> <span data-ttu-id="6567e-1884">如果两个应用程序域的路径设置不同, 则加载到这两个应用程序域中的程序集可能会有所不同。</span><span class="sxs-lookup"><span data-stu-id="6567e-1884">The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-1885">如果同时设置<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>了属性<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>和属性, 则第一次尝试加载程序集时将使用显示名称 (包括版本、区域性等<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> , 由属性返回)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1885">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="6567e-1886">如果找不到该文件, 则<xref:System.Reflection.AssemblyName.CodeBase%2A>使用属性来搜索该程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1886">If the file is not found, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to search for the assembly.</span></span> <span data-ttu-id="6567e-1887">如果使用<xref:System.Reflection.AssemblyName.CodeBase%2A>找到程序集, 则会将显示名称与程序集匹配。</span><span class="sxs-lookup"><span data-stu-id="6567e-1887">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="6567e-1888">如果匹配失败, <xref:System.IO.FileLoadException>则会引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-1888">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1889"><paramref name="assemblyRef" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1889"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1890"><paramref name="assemblyRef" /> 未找到。</span><span class="sxs-lookup"><span data-stu-id="6567e-1890"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1891"><paramref name="assemblyRef" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1891"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1892">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1892">-or-</span></span> 
<span data-ttu-id="6567e-1893">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1893">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1894">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1894">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1895">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1895">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1896">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1896">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1897">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1897">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="6567e-1898">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1898">The display name of the assembly.</span></span> <span data-ttu-id="6567e-1899">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1899">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="6567e-1900">在给定其显示名称的情况下加载 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1900">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="6567e-1901">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1901">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1902">此方法只应用于将程序集加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1902">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="6567e-1903">提供此方法是为了为无法调用静态<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法的互操作性调用方提供便利。</span><span class="sxs-lookup"><span data-stu-id="6567e-1903">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6567e-1904">若要将程序集加载到其他应用程序域中, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>请使用方法 (如)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1904">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="6567e-1905">有关此方法的所有重载所共有的信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1905">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1906"><paramref name="assemblyString" /> 为 <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="6567e-1906"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1907"><paramref name="assemblyString" /> 。</span><span class="sxs-lookup"><span data-stu-id="6567e-1907"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1908"><paramref name="assemblyString" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1908"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1909">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1909">-or-</span></span> 
<span data-ttu-id="6567e-1910">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1910">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1911">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1911">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1912">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1912">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1913">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1913">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1914">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1914">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1915">如果程序集不是本地的, 则能够访问程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-1915">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="6567e-1916"><see langword="byte" /> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</span><span class="sxs-lookup"><span data-stu-id="6567e-1916">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="6567e-1917"><see langword="byte" /> 类型的数组，它包含表示程序集符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="6567e-1917">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1918">加载带有基于通用对象文件格式 (COFF) 的图像的 <see cref="T:System.Reflection.Assembly" />，该图像包含已发出的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1918">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="6567e-1919">还加载表示 <see cref="T:System.Reflection.Assembly" /> 的符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="6567e-1919">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="6567e-1920">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1920">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1921">从开始, 使用此方法加载的程序集的信任级别与应用程序域的信任级别相同。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-1921">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="6567e-1922">此方法只应用于将程序集加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1922">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="6567e-1923">提供此方法是为了为无法调用静态<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法的互操作性调用方提供便利。</span><span class="sxs-lookup"><span data-stu-id="6567e-1923">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6567e-1924">若要将程序集加载到其他应用程序域中, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>请使用方法 (如)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1924">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="6567e-1925">有关此方法的所有重载所共有的信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1925">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1926">下面的示例演示如何加载原始程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1926">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="6567e-1927">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1927">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1928">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1928">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1929"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1929"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1930"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1930"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1931">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1931">-or-</span></span> 
<span data-ttu-id="6567e-1932">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1932">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1933">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1933">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1934">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1934">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1935">用于读取不以 "file://" 开头的 URI。</span><span class="sxs-lookup"><span data-stu-id="6567e-1935">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1936">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1936">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1937">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1937">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="6567e-1938">描述要加载的程序集的对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-1938">An object that describes the assembly to load.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1939">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1939">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1940">在给定 <see cref="T:System.Reflection.AssemblyName" /> 的情况下加载 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1940">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="6567e-1941">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1941">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1942">此方法只应用于将程序集加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1942">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="6567e-1943">提供此方法是为了为无法调用静态<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法的互操作性调用方提供便利。</span><span class="sxs-lookup"><span data-stu-id="6567e-1943">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6567e-1944">若要将程序集加载到其他应用程序域中, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>请使用方法 (如)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1944">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="6567e-1945">有关此方法的所有重载所共有的信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1945">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1946"><paramref name="assemblyRef" /> 为 <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="6567e-1946"><paramref name="assemblyRef" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1947"><paramref name="assemblyRef" /> 。</span><span class="sxs-lookup"><span data-stu-id="6567e-1947"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1948"><paramref name="assemblyRef" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1948"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1949">或</span><span class="sxs-lookup"><span data-stu-id="6567e-1949">-or-</span></span> 
<span data-ttu-id="6567e-1950">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1950">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1951">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1951">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1952">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1952">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1953">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1953">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1954">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1954">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1955">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1955">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1956">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1956">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1957">用于读取格式不是 "file://" 或 "\\\UNC\dir\\" 或 "c:\\" 的路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1957">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="6567e-1958">程序集的显示名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1958">The display name of the assembly.</span></span> <span data-ttu-id="6567e-1959">请参阅 <see cref="P:System.Reflection.Assembly.FullName" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1959">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="6567e-1960">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1960">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1961">在给定其显示名称的情况下加载 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1961">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="6567e-1962">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1962">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1963">此方法只应用于将程序集加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1963">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="6567e-1964">提供此方法是为了为无法调用静态<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法的互操作性调用方提供便利。</span><span class="sxs-lookup"><span data-stu-id="6567e-1964">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6567e-1965">若要将程序集加载到其他应用程序域中, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>请使用方法 (如)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1965">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="6567e-1966">有关此方法的所有重载所共有的信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1966">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1967"><paramref name="assemblyString" /> 为 <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="6567e-1967"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6567e-1968"><paramref name="assemblyString" /> 。</span><span class="sxs-lookup"><span data-stu-id="6567e-1968"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1969"><paramref name="assemblyString" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1969"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1970">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1970">-or-</span></span> 
<span data-ttu-id="6567e-1971">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1971">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1972">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1972">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1973">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1973">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-1974">加载包含证据的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1974">to load an assembly with evidence.</span></span> <span data-ttu-id="6567e-1975">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1975">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-1976">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1976">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-1977">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-1977">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-1978">用于读取格式不是 "file://" 或 "\\\UNC\dir\\" 或 "c:\\" 的路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-1978">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="6567e-1979"><see langword="byte" /> 类型的数组，它是包含已发出程序集的基于 COFF 的图像。</span><span class="sxs-lookup"><span data-stu-id="6567e-1979">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="6567e-1980"><see langword="byte" /> 类型的数组，它包含表示程序集符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="6567e-1980">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="6567e-1981">用于加载程序集的证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-1981">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="6567e-1982">加载带有基于通用对象文件格式 (COFF) 的图像的 <see cref="T:System.Reflection.Assembly" />，该图像包含已发出的 <see cref="T:System.Reflection.Assembly" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1982">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="6567e-1983">还加载表示 <see cref="T:System.Reflection.Assembly" /> 的符号的原始字节。</span><span class="sxs-lookup"><span data-stu-id="6567e-1983">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="6567e-1984">加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1984">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-1985">从开始, 使用此方法加载的程序集的信任级别与应用程序域的信任级别相同。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-1985">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="6567e-1986">此方法只应用于将程序集加载到当前应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-1986">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="6567e-1987">提供此方法是为了为无法调用静态<xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>方法的互操作性调用方提供便利。</span><span class="sxs-lookup"><span data-stu-id="6567e-1987">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="6567e-1988">若要将程序集加载到其他应用程序域中, <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>请使用方法 (如)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1988">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="6567e-1989">有关此方法的所有重载所共有的信息, 请参阅<xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29>方法重载。</span><span class="sxs-lookup"><span data-stu-id="6567e-1989">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-1990">下面的示例演示如何加载原始程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1990">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="6567e-1991">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-1991">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-1992">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-1992">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-1993"><paramref name="rawAssembly" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1993"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="6567e-1994"><paramref name="rawAssembly" /> 不是有效的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-1994"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="6567e-1995">- 或 -</span><span class="sxs-lookup"><span data-stu-id="6567e-1995">-or-</span></span> 
<span data-ttu-id="6567e-1996">当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高版本编译的。</span><span class="sxs-lookup"><span data-stu-id="6567e-1996">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-1997">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-1997">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="6567e-1998">一个程序集或模块用两个不同的证据加载了两次。</span><span class="sxs-lookup"><span data-stu-id="6567e-1998">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6567e-1999"><paramref name="securityEvidence" /> 不是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-1999"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="6567e-2000">未启用旧版 CAS 策略时，<paramref name="securityEvidence" /> 应为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2000">When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-2001">提供证据。</span><span class="sxs-lookup"><span data-stu-id="6567e-2001">to provide evidence.</span></span> <span data-ttu-id="6567e-2002">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-2002">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="6567e-2003">安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2003">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-2004">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。</span><span class="sxs-lookup"><span data-stu-id="6567e-2004">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="6567e-2005">关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />、。</span><span class="sxs-lookup"><span data-stu-id="6567e-2005">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="6567e-2006">用于读取格式不是 "file://" 或 "\\\UNC\dir\\" 或 "c:\\" 的路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-2006">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2007">获取或设置一个值，该值指示是否对当前进程启用应用程序域的 CPU 和内存监视。</span><span class="sxs-lookup"><span data-stu-id="6567e-2007">Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</span></span> <span data-ttu-id="6567e-2008">一旦对进程启用了监视，则无法将其禁用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2008">Once monitoring is enabled for a process, it cannot be disabled.</span></span></summary>
        <value><span data-ttu-id="6567e-2009">如果启用监视，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2009"><see langword="true" /> if monitoring is enabled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2010">此`static`属性 (`Shared` Visual Basic 中的属性) 控制进程中所有应用程序域的 CPU 和内存监视。</span><span class="sxs-lookup"><span data-stu-id="6567e-2010">This `static` property (`Shared` property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</span></span>  
  
 <span data-ttu-id="6567e-2011">如果尝试将此属性设置为`false` <xref:System.ArgumentException> , 则会引发异常, 即使属性的当前值为`false`。</span><span class="sxs-lookup"><span data-stu-id="6567e-2011">If you attempt to set this property to `false`, a <xref:System.ArgumentException> exception is thrown, even if the current value of the property is `false`.</span></span>  
  
 <span data-ttu-id="6567e-2012">启用监视后, 可以<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>使用、 <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>、 <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>和<xref:System.AppDomain.MonitoringTotalProcessorTime%2A>实例属性来监视单个应用程序域的 CPU 和内存使用情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-2012">Once monitoring is enabled, you can use the <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, and <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> instance properties to monitor CPU and memory use of individual application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6567e-2013">当前进程试图将值 <see langword="false" /> 赋予此属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-2013">The current process attempted to assign the value <see langword="false" /> to this property.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2014">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2014">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2015">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2015">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="6567e-2016">应用程序域资源监控</span><span class="sxs-lookup"><span data-stu-id="6567e-2016">Application Domain Resource Monitoring</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd"><span data-ttu-id="6567e-2017">&lt;appdomainResourceMonitoring&gt;元素</span><span class="sxs-lookup"><span data-stu-id="6567e-2017">&lt;appdomainResourceMonitoring&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2018">获取上次回收后保留下来的，已知由当前应用程序域引用的字节数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2018">Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</span></span></summary>
        <value><span data-ttu-id="6567e-2019">保留下来的字节数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2019">The number of surviving bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2020">每次垃圾回收都会更新统计信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-2020">The statistics are updated with each garbage collection.</span></span> <span data-ttu-id="6567e-2021">但是, 它们只能在完全的阻止性收集后保证准确;即, 包含所有代并在收集过程中停止应用程序的集合。</span><span class="sxs-lookup"><span data-stu-id="6567e-2021">However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</span></span> <span data-ttu-id="6567e-2022">例如, <xref:System.GC.Collect?displayProperty=nameWithType>方法重载执行完全阻塞的集合。</span><span class="sxs-lookup"><span data-stu-id="6567e-2022">For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload performs a full, blocking collection.</span></span> <span data-ttu-id="6567e-2023">(并发收集在后台发生, 不会阻止应用程序。)</span><span class="sxs-lookup"><span data-stu-id="6567e-2023">(Concurrent collection occurs in the background and does not block the application.)</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6567e-2024"><see langword="static" />（Visual Basic 中的 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2024">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2025">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2025">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2026">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2026">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="6567e-2027">应用程序域资源监控</span><span class="sxs-lookup"><span data-stu-id="6567e-2027">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2028">获取进程中所有应用程序域的上次回收后保留下来的总字节数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2028">Gets the total bytes that survived from the last collection for all application domains in the process.</span></span></summary>
        <value><span data-ttu-id="6567e-2029">进程的保留下来的总字节数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2029">The total number of surviving bytes for the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2030">在完全的阻塞回收后, 此数字表示托管堆上当前保留的字节数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2030">After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</span></span> <span data-ttu-id="6567e-2031">它应接近于<xref:System.GC.GetTotalMemory%2A>方法报告的数量。</span><span class="sxs-lookup"><span data-stu-id="6567e-2031">It should be close to the number reported by the <xref:System.GC.GetTotalMemory%2A> method.</span></span> <span data-ttu-id="6567e-2032">暂时回收后, 此数字表示暂时代中当前保留的字节数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2032">After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6567e-2033"><see langword="static" />（Visual Basic 中的 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2033">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2034">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2034">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2035">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2035">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="6567e-2036">应用程序域资源监控</span><span class="sxs-lookup"><span data-stu-id="6567e-2036">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2037">获取自从创建应用程序域后由应用程序域进行的所有内存分配的总大小（以字节为单位，不扣除已回收的内存）。</span><span class="sxs-lookup"><span data-stu-id="6567e-2037">Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</span></span></summary>
        <value><span data-ttu-id="6567e-2038">所有内存分配的总大小。</span><span class="sxs-lookup"><span data-stu-id="6567e-2038">The total size of all memory allocations.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6567e-2039"><see langword="static" />（Visual Basic 中的 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2039">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2040">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2040">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2041">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2041">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="6567e-2042">应用程序域资源监控</span><span class="sxs-lookup"><span data-stu-id="6567e-2042">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2043">获取自从进程启动后所有线程在当前应用程序域中执行时所使用的总处理器时间。</span><span class="sxs-lookup"><span data-stu-id="6567e-2043">Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</span></span></summary>
        <value><span data-ttu-id="6567e-2044">当前应用程序域的总处理器时间。</span><span class="sxs-lookup"><span data-stu-id="6567e-2044">Total processor time for the current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2045">为应用程序域报告的总时间包括进程中每个线程在该应用程序域中执行的时间。</span><span class="sxs-lookup"><span data-stu-id="6567e-2045">The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</span></span>  
  
 <span data-ttu-id="6567e-2046">调用到非托管代码的线程仍与某个应用程序域相关联, 并且为进行调用的应用程序域报告执行非托管代码所用的处理器时间。</span><span class="sxs-lookup"><span data-stu-id="6567e-2046">A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</span></span>  
  
 <span data-ttu-id="6567e-2047">当线程被阻止或处于休眠状态时, 它不会消耗处理器时间。</span><span class="sxs-lookup"><span data-stu-id="6567e-2047">When a thread is blocked or sleeping, it does not consume processor time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6567e-2048"><see langword="static" />（Visual Basic 中的 <see langword="Shared" />）<see cref="P:System.AppDomain.MonitoringIsEnabled" /> 属性设置为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2048">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2049">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2049">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2050">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2050">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="6567e-2051">应用程序域资源监控</span><span class="sxs-lookup"><span data-stu-id="6567e-2051">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2052">获取沙盒应用程序域的权限集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2052">Gets the permission set of a sandboxed application domain.</span></span></summary>
        <value><span data-ttu-id="6567e-2053">沙盒应用程序域的权限集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2053">The permission set of the sandboxed application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2054">使用<xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType>方法重载创建的沙盒应用程序域具有一组相同的权限, 即, 为加载到应用程序域中的所有部分受信任的程序集授予相同的权限集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2054">Sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="6567e-2055">沙盒应用程序域 (可选) 有一个从该权限集中免除的具有强名称的程序集的列表, 而是使用完全信任级别运行。</span><span class="sxs-lookup"><span data-stu-id="6567e-2055">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2056">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2056">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2057">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2057">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2058">当默认应用程序域的父进程存在时发生。</span><span class="sxs-lookup"><span data-stu-id="6567e-2058">Occurs when the default application domain's parent process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2059">此<xref:System.EventHandler>事件的可在进程结束前执行终止活动, 例如关闭文件、释放存储等。</span><span class="sxs-lookup"><span data-stu-id="6567e-2059">The <xref:System.EventHandler> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</span></span>  
  
 <span data-ttu-id="6567e-2060">从 .NET Framework 版本2.0 开始, 将在注册事件处理程序的每个应用程序域中引发此事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2060">Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-2061">在 .NET Framework 中, 所有<xref:System.AppDomain.ProcessExit>事件处理程序的总执行时间都受到限制, 就像所有终结器的总执行时间在进程关闭时受到限制。</span><span class="sxs-lookup"><span data-stu-id="6567e-2061">In .NET Framework, the total execution time of all <xref:System.AppDomain.ProcessExit> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</span></span> <span data-ttu-id="6567e-2062">默认值为两秒。</span><span class="sxs-lookup"><span data-stu-id="6567e-2062">The default is two seconds.</span></span> <span data-ttu-id="6567e-2063">非托管主机可以通过将[ICLRPolicyManager:: SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md)方法与[OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md)枚举值一起调用来更改此执行时间。</span><span class="sxs-lookup"><span data-stu-id="6567e-2063">An unmanaged host can change this execution time by calling the [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) method with the [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) enumeration value.</span></span> <span data-ttu-id="6567e-2064">此时间限制在 .NET Core 中不存在。</span><span class="sxs-lookup"><span data-stu-id="6567e-2064">This time limit does not exist in .NET Core.</span></span>  
  
 <span data-ttu-id="6567e-2065">在 .NET Framework 版本1.0 和1.1 中, 仅当在默认应用程序域中注册了事件处理程序时, 才会引发此事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2065">In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</span></span>  
  
 <span data-ttu-id="6567e-2066">若要为此事件注册事件处理程序, 你必须具有所需的权限, <xref:System.Security.SecurityException>否则将引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2066">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="6567e-2067">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2067">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2068">当程序集的解析在仅限反射的上下文中失败时发生。</span><span class="sxs-lookup"><span data-stu-id="6567e-2068">Occurs when the resolution of an assembly fails in the reflection-only context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2069">在仅反射上下文中, 不会自动解析依赖项。</span><span class="sxs-lookup"><span data-stu-id="6567e-2069">In the reflection-only context, dependencies are not resolved automatically.</span></span> <span data-ttu-id="6567e-2070">此事件的处理程序必须预加载或返回这些事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2070">They must be preloaded or returned by the handler for this event.</span></span> <span data-ttu-id="6567e-2071">当程序集具有尚未加载到仅反射上下文中的依赖项时, 将引发此事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2071">This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</span></span> <span data-ttu-id="6567e-2072">缺少的依赖项由<xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>属性指定。</span><span class="sxs-lookup"><span data-stu-id="6567e-2072">The missing dependency is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="6567e-2073">此<xref:System.ResolveEventHandler>事件的必须返回满足依赖项的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2073">The <xref:System.ResolveEventHandler> for this event must return an assembly that satisfies the dependency.</span></span> <span data-ttu-id="6567e-2074">返回的程序集必须加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="6567e-2074">The assembly that is returned must be loaded into the reflection-only context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-2075">仅当要加载到仅反射上下文中的程序集的缺失依赖项 (例如, 通过使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法) 时, 才引发此事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2075">This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method).</span></span> <span data-ttu-id="6567e-2076">如果找不到正在加载的程序集, 则不会引发此方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-2076">It is not raised if the assembly that you are loading cannot be found.</span></span>  
  
 <span data-ttu-id="6567e-2077">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]从开始<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , 属性返回请求未能解析程序集加载的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2077">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="6567e-2078">如果有多个可用版本, 知道发出请求的程序集的标识可能会很有用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2078">Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</span></span> <span data-ttu-id="6567e-2079">有关详细信息，请参阅 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6567e-2079">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6567e-2080">对于此事件, <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType>属性将在应用策略之前返回程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-2080">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
 <span data-ttu-id="6567e-2081">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2081">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2082">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2082">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2083">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2083">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-2084">返回已加载到应用程序域的只反射上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2084">Returns the assemblies that have been loaded into the reflection-only context of the application domain.</span></span></summary>
        <returns><span data-ttu-id="6567e-2085"><see cref="T:System.Reflection.Assembly" /> 对象数组，表示加载到应用程序域的只反射上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2085">An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2086">此方法返回已加载到仅反射上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2086">This method returns the assemblies that have been loaded into the reflection-only context.</span></span> <span data-ttu-id="6567e-2087">若要获取已加载执行的程序集, 请使用<xref:System.AppDomain.GetAssemblies%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="6567e-2087">To get the assemblies that have been loaded for execution, use the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2088">下面的代码示例将系统 .dll 程序集加载到执行上下文中, 然后加载到仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="6567e-2088">The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</span></span> <span data-ttu-id="6567e-2089"><xref:System.AppDomain.GetAssemblies%2A> 和<xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A>方法用于显示加载到每个上下文中的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2089">The <xref:System.AppDomain.GetAssemblies%2A> and <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> methods are used to display the assemblies loaded into each context.</span></span>  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2090">尝试对已卸载的应用程序域进行操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2090">An operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2091">获取基目录下的路径，在此程序集冲突解决程序应探测专用程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2091">Gets the path under the base directory where the assembly resolver should probe for private assemblies.</span></span></summary>
        <value><span data-ttu-id="6567e-2092">基目录下的路径，在此程序集冲突解决程序应探测专用程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2092">The path under the base directory where the assembly resolver should probe for private assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2093">私有程序集部署在与应用程序相同的目录结构中。</span><span class="sxs-lookup"><span data-stu-id="6567e-2093">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="6567e-2094">如果<xref:System.AppDomain.RelativeSearchPath%2A>属性指定的路径不在下<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, 则将其忽略。</span><span class="sxs-lookup"><span data-stu-id="6567e-2094">If the path specified by the <xref:System.AppDomain.RelativeSearchPath%2A> property is not under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, it is ignored.</span></span>  
  
 <span data-ttu-id="6567e-2095">此属性返回使用<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>设置的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2095">This property returns the value set using <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2096">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2096">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="6567e-2097">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-2097">for access to the path information.</span></span> <span data-ttu-id="6567e-2098">关联枚举：<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2098">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2099">当资源解析因资源不是程序集中的有效链接资源或嵌入资源而失败时发生。</span><span class="sxs-lookup"><span data-stu-id="6567e-2099">Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2100">此<xref:System.ResolveEventHandler>事件的可尝试查找包含该资源的程序集并将其返回。</span><span class="sxs-lookup"><span data-stu-id="6567e-2100">The <xref:System.ResolveEventHandler> for this event can attempt to locate the assembly containing the resource and return it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6567e-2101">如果解析失败, 则不会引发此事件, 因为找不到有效链接资源的文件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2101">This event is not raised if resolution fails because no file can be found for a valid linked resource.</span></span> <span data-ttu-id="6567e-2102">如果找不到清单资源流, 则会引发该方法, 但如果找不到单个资源键, 则不会引发此情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-2102">It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</span></span>  
  
 <span data-ttu-id="6567e-2103">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]从开始<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , 属性包含请求资源的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2103">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the resource.</span></span> <span data-ttu-id="6567e-2104">有关详细信息，请参阅 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6567e-2104">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6567e-2105">若要为此事件注册事件处理程序, 你必须具有所需的权限, <xref:System.Security.SecurityException>否则将引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2105">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="6567e-2106">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2106">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2107">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2107">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2108">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2108">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="domainPolicy"><span data-ttu-id="6567e-2109">安全策略级别。</span><span class="sxs-lookup"><span data-stu-id="6567e-2109">The security policy level.</span></span></param>
        <summary><span data-ttu-id="6567e-2110">为此应用程序域确定安全策略级别。</span><span class="sxs-lookup"><span data-stu-id="6567e-2110">Establishes the security policy level for this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2111">在将<xref:System.AppDomain>程序集加载到之前调用此方法, 以便安全策略生效。</span><span class="sxs-lookup"><span data-stu-id="6567e-2111">Call this method before an assembly is loaded into the <xref:System.AppDomain> in order for the security policy to have effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2112">下面的示例演示如何使用<xref:System.AppDomain.SetAppDomainPolicy%2A>方法设置应用程序域的安全策略级别。</span><span class="sxs-lookup"><span data-stu-id="6567e-2112">The following example demonstrates how to use the <xref:System.AppDomain.SetAppDomainPolicy%2A> method to set the security policy level of an application domain.</span></span>  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-2113"><paramref name="domainPolicy" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2113"><paramref name="domainPolicy" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="6567e-2114">已经设置了安全策略级别。</span><span class="sxs-lookup"><span data-stu-id="6567e-2114">The security policy level has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2115">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2115">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2116">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2116">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2117">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2117">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6567e-2118">到卷影副本位置的完全限定路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-2118">The fully qualified path to the shadow copy location.</span></span></param>
        <summary><span data-ttu-id="6567e-2119">确定指定目录路径为对程序集进行影像复制的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-2119">Establishes the specified directory path as the location where assemblies are shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2120">如果未设置该<xref:System.AppDomainSetup.ApplicationName%2A>属性, 则将忽略缓存路径。</span><span class="sxs-lookup"><span data-stu-id="6567e-2120">The cache path is ignored if the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set.</span></span> <span data-ttu-id="6567e-2121">请参阅 <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> 属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-2121">See the <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="6567e-2122">有关卷影复制的详细信息, 请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2122">For more information on shadow copying see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2123">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2123">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2124">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2124">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2125">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2125">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="6567e-2126">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="6567e-2126">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6567e-2127">为应用程序域属性分配值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2127">Assigns a value to an application domain property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-2128">要创建或更改的用户定义应用程序域属性的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-2128">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="6567e-2129">该属性的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2129">The value of the property.</span></span></param>
        <summary><span data-ttu-id="6567e-2130">为指定的应用程序域属性分配指定值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2130">Assigns the specified value to the specified application domain property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2131">使用此方法可在描述此实例的<xref:System.AppDomain>属性的名称数据对的内部缓存中插入项或修改项的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2131">Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="6567e-2132">缓存自动包含创建应用程序域时插入的预定义系统条目。</span><span class="sxs-lookup"><span data-stu-id="6567e-2132">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="6567e-2133">不能用此方法插入或修改系统项。</span><span class="sxs-lookup"><span data-stu-id="6567e-2133">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="6567e-2134">尝试修改系统条目的方法调用不起任何作用;方法不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-2134">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="6567e-2135">可以用<xref:System.AppDomain.GetData%2A>方法或中<xref:System.AppDomain.GetData%2A>描述的等效<xref:System.AppDomainSetup>属性检查系统项的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2135">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties described in <xref:System.AppDomain.GetData%2A>.</span></span>  
  
 <span data-ttu-id="6567e-2136">您可以通过将 "REGEX_DEFAULT_MATCH_TIMEOUT" 作为`name`参数的值<xref:System.TimeSpan>和表示超时值的值, 来设置默认超时间隔的值, 以便通过提供 "" 来计算正则表达式模式间隔作为`data`参数的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2136">You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span> <span data-ttu-id="6567e-2137">还可以通过此方法插入或修改自己的用户定义的名称数据对, 并通过<xref:System.AppDomain.GetData%2A>方法检查其值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2137">You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2138">下面的示例演示如何使用<xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29>方法创建新的值对。</span><span class="sxs-lookup"><span data-stu-id="6567e-2138">The following example demonstrates how to use the <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> method to create a new value pair.</span></span> <span data-ttu-id="6567e-2139">然后, 该示例使用<xref:System.AppDomain.GetData%2A>方法检索该值, 并将其显示在控制台中。</span><span class="sxs-lookup"><span data-stu-id="6567e-2139">The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2140">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2140">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2141">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2141">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2142">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2142">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Object" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="permission" Type="System.Security.IPermission" Index="2" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="6567e-2143">要创建或更改的用户定义应用程序域属性的名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-2143">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="6567e-2144">该属性的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2144">The value of the property.</span></span></param>
        <param name="permission"><span data-ttu-id="6567e-2145">检索属性时调用方需要具有的权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-2145">The permission to demand of the caller when the property is retrieved.</span></span></param>
        <summary><span data-ttu-id="6567e-2146">将指定值分配给指定应用程序域属性，检索该属性时要求调用方具有指定权限。</span><span class="sxs-lookup"><span data-stu-id="6567e-2146">Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2147">使用此方法可在描述应用程序域属性的名称/数据对的内部缓存中插入或修改自己的用户定义条目。</span><span class="sxs-lookup"><span data-stu-id="6567e-2147">Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</span></span> <span data-ttu-id="6567e-2148">插入项时, 可以指定在检索项时要强制执行的权限请求。此外, 还可以调用此方法, 通过将 "REGEX_DEFAULT_MATCH_TIMEOUT" 作为`name`参数的值<xref:System.TimeSpan>和表示参数值的值, 来设置默认超时间隔的值, 以计算正则表达式模式超时间隔作为`data`参数的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2148">When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span>  
  
 <span data-ttu-id="6567e-2149">不能使用此方法向系统定义的属性字符串分配安全要求。</span><span class="sxs-lookup"><span data-stu-id="6567e-2149">You cannot use this method to assign a security demand to a system-defined property string.</span></span>  
  
 <span data-ttu-id="6567e-2150">缓存自动包含创建应用程序域时插入的预定义系统条目。</span><span class="sxs-lookup"><span data-stu-id="6567e-2150">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="6567e-2151">不能用此方法插入或修改系统项。</span><span class="sxs-lookup"><span data-stu-id="6567e-2151">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="6567e-2152">尝试修改系统条目的方法调用不起任何作用;方法不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-2152">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="6567e-2153">可以通过<xref:System.AppDomain.GetData%2A>方法或<xref:System.AppDomain.GetData%2A>方法的 "备注" 部分中所述的<xref:System.AppDomainSetup>等效属性来检查系统项的值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2153">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method or the equivalent <xref:System.AppDomainSetup> properties described in the Remarks section for the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-2154"><paramref name="name" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2154"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6567e-2155"><paramref name="name" /> 指定系统定义的属性字符串，并且 <paramref name="permission" /> 不为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2155"><paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2156">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2156">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2157">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2157">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6567e-2158">完全限定路径，是存储动态程序集的子目录的基目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-2158">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</span></span></param>
        <summary><span data-ttu-id="6567e-2159">建立指定的目录路径，作为存储和访问动态生成的文件的子目录的基目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-2159">Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2160">此方法设置<xref:System.AppDomainSetup.DynamicBase%2A>与此实例关联的<xref:System.AppDomainSetup>内部的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-2160">This method sets the <xref:System.AppDomainSetup.DynamicBase%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2161">此方法现已过时, 不应用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2161">This method is now obsolete, and should not be used for new development.</span></span> <span data-ttu-id="6567e-2162">下面的示例演示如何使用未过时的<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>替代属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-2162">The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="6567e-2163">有关此示例的说明, 请参见<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>属性<xref:System.AppDomain.DynamicDirectory%2A>或属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-2163">For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2164">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2164">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2165">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2165">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2166">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2166">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy"><span data-ttu-id="6567e-2167"><see cref="T:System.Security.Principal.PrincipalPolicy" /> 值之一，指定要附加到线程的主体对象类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-2167">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="6567e-2168">指定在此应用程序域中执行时如果线程尝试绑定到用户，用户和标识对象应如何附加到该线程。</span><span class="sxs-lookup"><span data-stu-id="6567e-2168">Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2169">仅当你在使用<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>属性之前设置此值时, 设置此值才有效。</span><span class="sxs-lookup"><span data-stu-id="6567e-2169">Setting this value will only be effective if you set it before using the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="6567e-2170">例如, <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>如果将设置为给定主体 (例如, 一般主体), 然后<xref:System.AppDomain.SetPrincipalPolicy%2A>使用方法将设置<xref:System.Security.Principal.PrincipalPolicy>为, 则当前主体将保留<xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>为泛型主体。</span><span class="sxs-lookup"><span data-stu-id="6567e-2170">For example, if you set <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> to a given principal (for example, a generic principal) and then use the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to set the <xref:System.Security.Principal.PrincipalPolicy> to <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, the current principal will remain the generic principal.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2171">下面的示例演示对使用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法更改应用程序域的主体策略的线程的影响。</span><span class="sxs-lookup"><span data-stu-id="6567e-2171">The following example shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span> <span data-ttu-id="6567e-2172">它还显示了使用<xref:System.AppDomain.SetThreadPrincipal%2A>方法更改可附加到应用程序域中的线程的主体的效果。</span><span class="sxs-lookup"><span data-stu-id="6567e-2172">It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2173">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2173">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-2174">用于操作主体对象的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-2174">for ability to manipulate the principal object.</span></span> <span data-ttu-id="6567e-2175">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2175">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="6567e-2176">安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2176">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-2177">打开影像复制功能。</span><span class="sxs-lookup"><span data-stu-id="6567e-2177">Turns on shadow copying.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2178">有关卷影复制的详细信息, 请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2178">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2179">此方法现已过时, 不应用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2179">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2180">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2180">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2181">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2181">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2182">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2182">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="6567e-2183">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="6567e-2183">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6567e-2184">目录名列表，各名称用分号隔开。</span><span class="sxs-lookup"><span data-stu-id="6567e-2184">A list of directory names, where each name is separated by a semicolon.</span></span></param>
        <summary><span data-ttu-id="6567e-2185">确定指定目录路径为要进行影像复制的程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="6567e-2185">Establishes the specified directory path as the location of assemblies to be shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2186">默认情况下, 卷影副本包含通过探测找到的所有程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2186">By default, a shadow copy includes all assemblies found through probing.</span></span> <span data-ttu-id="6567e-2187">方法将卷影副本限制为`path`指定的目录中的程序集。 <xref:System.AppDomain.SetShadowCopyPath%2A></span><span class="sxs-lookup"><span data-stu-id="6567e-2187">The <xref:System.AppDomain.SetShadowCopyPath%2A> method restricts the shadow copy to the assemblies in the directories specified by `path`.</span></span>  
  
 <span data-ttu-id="6567e-2188"><xref:System.AppDomain.SetShadowCopyPath%2A>方法不指定要在其中搜索程序集的其他目录。</span><span class="sxs-lookup"><span data-stu-id="6567e-2188">The <xref:System.AppDomain.SetShadowCopyPath%2A> method does not specify additional directories to be searched for assemblies.</span></span> <span data-ttu-id="6567e-2189">要进行卷影复制的程序集必须已位于搜索路径中, 例如下<xref:System.AppDomain.BaseDirectory%2A>。</span><span class="sxs-lookup"><span data-stu-id="6567e-2189">Assemblies to be shadow-copied must already be located in the search path, for example under <xref:System.AppDomain.BaseDirectory%2A>.</span></span> <span data-ttu-id="6567e-2190"><xref:System.AppDomain.SetShadowCopyPath%2A>方法指定哪些搜索路径有资格被影像复制。</span><span class="sxs-lookup"><span data-stu-id="6567e-2190">The <xref:System.AppDomain.SetShadowCopyPath%2A> method specifies which search paths are eligible to be shadow-copied.</span></span>  
  
 <span data-ttu-id="6567e-2191">此方法设置<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>与此实例关联的<xref:System.AppDomainSetup>内部的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-2191">This method sets the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
 <span data-ttu-id="6567e-2192">有关卷影复制的详细信息, 请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2192">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2193">此方法现已过时, 不应用于新的开发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2193">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2194">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2194">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2195">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2195">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2196">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2196">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="6567e-2197">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="6567e-2197">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal"><span data-ttu-id="6567e-2198">要附加到线程的主体对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-2198">The principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="6567e-2199">设置在以下情况下要附加到线程的默认主体对象，即当线程在此应用程序域中执行时，如果线程尝试绑定到主体这种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-2199">Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6567e-2200">下面的示例演示如何使用<xref:System.AppDomain.SetThreadPrincipal%2A>方法更改可附加到在应用程序域中执行的线程的主体。</span><span class="sxs-lookup"><span data-stu-id="6567e-2200">The following example shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads that are executing in the application domain.</span></span> <span data-ttu-id="6567e-2201">它还显示对使用<xref:System.AppDomain.SetPrincipalPolicy%2A>方法更改应用程序域的主体策略的线程的影响。</span><span class="sxs-lookup"><span data-stu-id="6567e-2201">It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-2202"><paramref name="principal" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2202"><paramref name="principal" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="6567e-2203">已经设置了线程用户。</span><span class="sxs-lookup"><span data-stu-id="6567e-2203">The thread principal has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2204">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2204">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-2205">用于操作主体对象的能力。</span><span class="sxs-lookup"><span data-stu-id="6567e-2205">for ability to manipulate the principal object.</span></span> <span data-ttu-id="6567e-2206">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2206">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="6567e-2207">安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2207">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2208">获取此实例的应用程序域配置信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-2208">Gets the application domain configuration information for this instance.</span></span></summary>
        <value><span data-ttu-id="6567e-2209">应用程序域初始化信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-2209">The application domain initialization information.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2210">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2210">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2211">获取应用程序域是否配置为影像副本文件的指示。</span><span class="sxs-lookup"><span data-stu-id="6567e-2211">Gets an indication whether the application domain is configured to shadow copy files.</span></span></summary>
        <value><span data-ttu-id="6567e-2212">如果应用程序域配置为卷影副本文件，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2212"><see langword="true" /> if the application domain is configured to shadow copy files; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2213">有关详细信息, 请<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>参阅和[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2213">For more information, see <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2214">在卸载的应用程序域上尝试该操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2214">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="6567e-2215">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="6567e-2215">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="6567e-2216">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2216">Reserved for future use.</span></span> <span data-ttu-id="6567e-2217">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-2217">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="6567e-2218">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="6567e-2218">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="6567e-2219">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2219">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="6567e-2220">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="6567e-2220">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="6567e-2221">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="6567e-2221">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="6567e-2222">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="6567e-2222">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2223">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2223">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6567e-2224">有关`IDispatch::GetIDsOfNames`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="6567e-2224">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6567e-2225">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6567e-2225">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="6567e-2226">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-2226">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="6567e-2227">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="6567e-2227">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="6567e-2228">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="6567e-2228">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="6567e-2229">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-2229">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2230">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2230">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6567e-2231">有关`IDispatch::GetTypeInfo`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="6567e-2231">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6567e-2232">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6567e-2232">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="6567e-2233">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="6567e-2233">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="6567e-2234">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="6567e-2234">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2235">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2235">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6567e-2236">有关`IDispatch::GetTypeInfoCount`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="6567e-2236">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6567e-2237">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6567e-2237">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="6567e-2238">标识成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2238">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="6567e-2239">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2239">Reserved for future use.</span></span> <span data-ttu-id="6567e-2240">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="6567e-2240">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="6567e-2241">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="6567e-2241">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="6567e-2242">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="6567e-2242">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="6567e-2243">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="6567e-2243">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="6567e-2244">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="6567e-2244">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="6567e-2245">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="6567e-2245">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="6567e-2246">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="6567e-2246">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="6567e-2247">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="6567e-2247">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2248">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2248">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="6567e-2249">有关`IDispatch::Invoke`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="6567e-2249">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="6567e-2250">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="6567e-2250">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6567e-2251">获取一个字符串表示，包含应用程序域友好名称和任意上下文策略。</span><span class="sxs-lookup"><span data-stu-id="6567e-2251">Obtains a string representation that includes the friendly name of the application domain and any context policies.</span></span></summary>
        <returns><span data-ttu-id="6567e-2252">一个字符串，通过连接字符串“Name:”、应用程序域的友好名称以及上下文策略的字符串表示或字符串“There are no context policies”而成。</span><span class="sxs-lookup"><span data-stu-id="6567e-2252">A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6567e-2253">下面的代码示例显示<xref:System.AppDomain.ToString%2A>方法的返回值。</span><span class="sxs-lookup"><span data-stu-id="6567e-2253">The following code example displays the return value of the <xref:System.AppDomain.ToString%2A> method.</span></span>  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="6567e-2254">当前 <see cref="T:System.AppDomain" /> 表示的应用程序域已卸载。</span><span class="sxs-lookup"><span data-stu-id="6567e-2254">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2255">在对类型的解析失败时发生。</span><span class="sxs-lookup"><span data-stu-id="6567e-2255">Occurs when the resolution of a type fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2256">当<xref:System.AppDomain.TypeResolve>公共语言运行时无法确定可创建请求类型的程序集时, 将发生此事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2256">The <xref:System.AppDomain.TypeResolve> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</span></span> <span data-ttu-id="6567e-2257">如果类型是在动态程序集中定义的, 或者该类型未在动态程序集中定义, 但运行时不知道在哪个程序集中定义了该类型, 则可能会发生这种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-2257">This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</span></span> <span data-ttu-id="6567e-2258">当使用未用程序集<xref:System.Type.GetType%2A?displayProperty=nameWithType>名称限定的类型名称调用时, 可能会出现后一种情况。</span><span class="sxs-lookup"><span data-stu-id="6567e-2258">The latter situation can occur when <xref:System.Type.GetType%2A?displayProperty=nameWithType> is called with a type name that is not qualified with the assembly name.</span></span>  
  
 <span data-ttu-id="6567e-2259">此<xref:System.ResolveEventHandler>事件的可尝试查找和创建类型。</span><span class="sxs-lookup"><span data-stu-id="6567e-2259">The <xref:System.ResolveEventHandler> for this event can attempt to locate and create the type.</span></span>  
  
 <span data-ttu-id="6567e-2260">但是, 如果<xref:System.AppDomain.TypeResolve>运行时知道在某些程序集中找不到类型, 则不会发生该事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2260">However, the <xref:System.AppDomain.TypeResolve> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</span></span> <span data-ttu-id="6567e-2261">例如, 如果在静态程序集中找不到该类型, 则不会发生此事件, 因为运行时知道类型不能动态添加到静态程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2261">For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</span></span>  
  
 <span data-ttu-id="6567e-2262">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]从开始<xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> , 属性包含请求该类型的程序集。</span><span class="sxs-lookup"><span data-stu-id="6567e-2262">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the type.</span></span> <span data-ttu-id="6567e-2263">有关详细信息，请参阅 <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6567e-2263">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6567e-2264">若要为此事件注册事件处理程序, 你必须具有所需的权限, <xref:System.Security.SecurityException>否则将引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2264">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="6567e-2265">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2265">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2266">下面的示例演示<xref:System.AppDomain.TypeResolve>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2266">The following sample demonstrates the <xref:System.AppDomain.TypeResolve> event.</span></span>  
  
 <span data-ttu-id="6567e-2267">若要运行此代码示例, 必须提供完全限定的程序集名称。</span><span class="sxs-lookup"><span data-stu-id="6567e-2267">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="6567e-2268">有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2268">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2269">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2269">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2270">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2270">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6567e-2271">当某个异常未被捕获时出现。</span><span class="sxs-lookup"><span data-stu-id="6567e-2271">Occurs when an exception is not caught.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2272">此事件提供未捕获的异常的通知。</span><span class="sxs-lookup"><span data-stu-id="6567e-2272">This event provides notification of uncaught exceptions.</span></span> <span data-ttu-id="6567e-2273">它允许应用程序在系统默认处理程序向用户报告异常并终止应用程序之前记录有关异常的信息。</span><span class="sxs-lookup"><span data-stu-id="6567e-2273">It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</span></span> <span data-ttu-id="6567e-2274">如果提供了有关应用程序状态的足够信息, 则可以执行其他操作, 例如保存程序数据以便以后恢复。</span><span class="sxs-lookup"><span data-stu-id="6567e-2274">If sufficient information about the state of the application is available, other actions may be undertaken - such as saving program data for later recovery.</span></span> <span data-ttu-id="6567e-2275">建议注意, 因为在未处理异常时, 程序数据可能会损坏。</span><span class="sxs-lookup"><span data-stu-id="6567e-2275">Caution is advised, because program data can become corrupted when exceptions are not handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-2276">在 .NET Framework 版本1.0 和1.1 中, 将在引发此事件之前向用户报告应用程序终止和调试选项, 而不是在之后发出。</span><span class="sxs-lookup"><span data-stu-id="6567e-2276">In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</span></span>  
  
 <span data-ttu-id="6567e-2277">可以在任何应用程序域中处理此事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2277">This event can be handled in any application domain.</span></span> <span data-ttu-id="6567e-2278">但是, 在发生异常的应用程序域中不一定会引发该事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2278">However, the event is not necessarily raised in the application domain where the exception occurred.</span></span> <span data-ttu-id="6567e-2279">仅当在未查找适用的异常处理程序的情况下展开了线程的整个堆栈后, 才会处理异常, 因此可以引发事件的第一个位置是该线程源自的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-2279">An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-2280">在 .NET Framework 版本1.0 和1.1 中, 此事件仅发生在启动应用程序时由系统创建的默认应用程序域中。</span><span class="sxs-lookup"><span data-stu-id="6567e-2280">In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</span></span> <span data-ttu-id="6567e-2281">如果应用程序创建了其他应用程序域, 则在那些应用程序域中为此事件指定委托不起作用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2281">If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</span></span>  
  
 <span data-ttu-id="6567e-2282"><xref:System.AppDomain.UnhandledException>如果事件是在默认应用程序域中处理的, 无论线程在哪个应用程序域中启动, 都将为任何线程中的任何未经处理的异常引发此事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2282">If the <xref:System.AppDomain.UnhandledException> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</span></span> <span data-ttu-id="6567e-2283">如果该线程是在具有事件处理<xref:System.AppDomain.UnhandledException>程序的应用程序域中启动的, 则该事件会在该应用程序域中引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2283">If the thread started in an application domain that has an event handler for <xref:System.AppDomain.UnhandledException>, the event is raised in that application domain.</span></span> <span data-ttu-id="6567e-2284">如果该应用程序域不是默认应用程序域, 并且在默认应用程序域中也有一个事件处理程序, 则在这两个应用程序域中都会引发该事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2284">If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</span></span>  
  
 <span data-ttu-id="6567e-2285">例如, 假设某个线程在应用程序域 "AD1" 中启动, 调用应用程序域 "AD2" 中的方法, 并在其中调用应用程序域 "AD3" 中的方法, 该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-2285">For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</span></span> <span data-ttu-id="6567e-2286">可在其中<xref:System.AppDomain.UnhandledException>引发事件的第一个应用程序域为 "AD1"。</span><span class="sxs-lookup"><span data-stu-id="6567e-2286">The first application domain in which the <xref:System.AppDomain.UnhandledException> event can be raised is "AD1".</span></span> <span data-ttu-id="6567e-2287">如果该应用程序域不是默认应用程序域, 则还可以在默认应用程序域中引发该事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2287">If that application domain is not the default application domain, the event can also be raised in the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-2288">当<xref:System.AppDomain.UnhandledException>事件的事件处理程序正在执行时, 公共语言运行时将挂起线程中止。</span><span class="sxs-lookup"><span data-stu-id="6567e-2288">The common language runtime suspends thread aborts while event handlers for the <xref:System.AppDomain.UnhandledException> event are executing.</span></span>  
  
 <span data-ttu-id="6567e-2289">如果事件处理程序有一个<xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute>具有相应标志的属性, 则该事件处理程序将被视为受约束的执行区域。</span><span class="sxs-lookup"><span data-stu-id="6567e-2289">If the event handler has a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</span></span>  
  
 <span data-ttu-id="6567e-2290">从开始<xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> , 对于损坏进程状态 (如堆栈溢出或访问冲突) 的异常, 不会引发此事件, 除非事件处理程序是安全关键的并且具有属性。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="6567e-2290">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="6567e-2291">在 .NET Framework 版本1.0 和1.1 中, 在主应用程序线程之外的其他线程中发生的未经处理的异常将由运行时捕获, 因此不会导致应用程序终止。</span><span class="sxs-lookup"><span data-stu-id="6567e-2291">In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</span></span> <span data-ttu-id="6567e-2292">因此, <xref:System.AppDomain.UnhandledException>可以在应用程序终止的情况下引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2292">Thus, it is possible for the <xref:System.AppDomain.UnhandledException> event to be raised without the application terminating.</span></span> <span data-ttu-id="6567e-2293">从 .NET Framework 版本2.0 开始, 已删除子线程中未经处理的异常的此项支撑, 因为此类无提示故障的累积影响包括性能下降、损坏的数据和锁定, 所有这些操作都难以debug.exe.</span><span class="sxs-lookup"><span data-stu-id="6567e-2293">Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</span></span> <span data-ttu-id="6567e-2294">有关详细信息, 包括运行时未终止的事例的列表, 请参阅[托管线程中的异常](~/docs/standard/threading/exceptions-in-managed-threads.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2294">For more information, including a list of cases in which the runtime does not terminate, see [Exceptions in Managed Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="6567e-2295">若要为此事件注册事件处理程序, 你必须具有所需的权限, <xref:System.Security.SecurityException>否则将引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2295">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="6567e-2296">有关处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2296">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
## <a name="other-events-for-unhandled-exceptions"></a><span data-ttu-id="6567e-2297">未经处理的异常的其他事件</span><span class="sxs-lookup"><span data-stu-id="6567e-2297">Other Events for Unhandled Exceptions</span></span>  
 <span data-ttu-id="6567e-2298">对于某些应用程序模型, <xref:System.AppDomain.UnhandledException>如果主应用程序线程中出现未经处理的异常, 则事件可能会被其他事件抢占。</span><span class="sxs-lookup"><span data-stu-id="6567e-2298">For certain application models, the <xref:System.AppDomain.UnhandledException> event can be preempted by other events if the unhandled exception occurs in the main application thread.</span></span>  
  
 <span data-ttu-id="6567e-2299">在使用 Windows 窗体的应用程序中, 主应用程序线程中的未<xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType>处理异常将导致引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2299">In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> event to be raised.</span></span> <span data-ttu-id="6567e-2300">如果处理此事件, 则默认行为是未经处理的异常不会终止应用程序, 但应用程序仍处于未知状态。</span><span class="sxs-lookup"><span data-stu-id="6567e-2300">If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</span></span> <span data-ttu-id="6567e-2301">在这种情况下<xref:System.AppDomain.UnhandledException> , 不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2301">In that case, the <xref:System.AppDomain.UnhandledException> event is not raised.</span></span> <span data-ttu-id="6567e-2302">此行为可以通过使用应用程序配置文件进行更改, 也可以通过使用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType>方法在将<xref:System.Windows.Forms.Application.ThreadException>事件处理程序<xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType>挂钩之前更改模式。</span><span class="sxs-lookup"><span data-stu-id="6567e-2302">This behavior can be changed by using the application configuration file, or by using the <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> method to change the mode to <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> before the <xref:System.Windows.Forms.Application.ThreadException> event handler is hooked up.</span></span> <span data-ttu-id="6567e-2303">这仅适用于主应用程序线程。</span><span class="sxs-lookup"><span data-stu-id="6567e-2303">This applies only to the main application thread.</span></span> <span data-ttu-id="6567e-2304">对于其他线程中引发的未经处理的异常, 会引发事件。<xref:System.AppDomain.UnhandledException></span><span class="sxs-lookup"><span data-stu-id="6567e-2304">The <xref:System.AppDomain.UnhandledException> event is raised for unhandled exceptions thrown in other threads.</span></span>  
  
 <span data-ttu-id="6567e-2305">从 Microsoft Visual Studio 2005 开始, Visual Basic 应用程序框架为主应用程序线程中的未处理异常提供另一个事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2305">Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</span></span> <span data-ttu-id="6567e-2306">请参阅<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType>事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2306">See the <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="6567e-2307">此事件有一个事件参数对象, 其名称与使用<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>的事件参数对象同名, 但具有不同的属性。</span><span class="sxs-lookup"><span data-stu-id="6567e-2307">This event has an event arguments object with the same name as the event arguments object used by <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, but with different properties.</span></span> <span data-ttu-id="6567e-2308">特别是<xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> , 此事件参数对象具有属性, 该属性允许应用程序继续运行, 忽略未经处理的异常 (并使应用程序处于未知状态)。</span><span class="sxs-lookup"><span data-stu-id="6567e-2308">In particular, this event arguments object has an <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</span></span> <span data-ttu-id="6567e-2309">在这种情况下<xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> , 不会引发事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2309">In that case, the <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> event is not raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2310">下面的示例演示了<xref:System.AppDomain.UnhandledException>该事件。</span><span class="sxs-lookup"><span data-stu-id="6567e-2310">The following example demonstrates the <xref:System.AppDomain.UnhandledException> event.</span></span> <span data-ttu-id="6567e-2311">它定义了一个事件处理`MyHandler`程序, 该事件处理程序在默认应用程序域中引发未经处理的异常时调用。</span><span class="sxs-lookup"><span data-stu-id="6567e-2311">It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain.</span></span> <span data-ttu-id="6567e-2312">然后, 它将引发两个异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-2312">It then throws two exceptions.</span></span> <span data-ttu-id="6567e-2313">第一个由**try/catch**块处理。</span><span class="sxs-lookup"><span data-stu-id="6567e-2313">The first is handled by a **try/catch** block.</span></span> <span data-ttu-id="6567e-2314">第二个未处理并在`MyHandle`应用程序终止前调用例程。</span><span class="sxs-lookup"><span data-stu-id="6567e-2314">The second is unhandled and invokes the `MyHandle` routine before the application terminates.</span></span>  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="6567e-2315">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="6567e-2315">requires full trust for the immediate caller.</span></span> <span data-ttu-id="6567e-2316">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="6567e-2316">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain"><span data-ttu-id="6567e-2317">要卸载的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-2317">An application domain to unload.</span></span></param>
        <summary><span data-ttu-id="6567e-2318">卸载指定的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-2318">Unloads the specified application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6567e-2319">在 .NET Framework 版本2.0 中, 有一个专用于卸载应用程序域的线程。</span><span class="sxs-lookup"><span data-stu-id="6567e-2319">In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</span></span> <span data-ttu-id="6567e-2320">这提高了可靠性, 尤其是在承载 .NET Framework 时。</span><span class="sxs-lookup"><span data-stu-id="6567e-2320">This improves reliability, especially when the .NET Framework is hosted.</span></span> <span data-ttu-id="6567e-2321">线程调用<xref:System.AppDomain.Unload%2A>时, 目标域标记为要卸载。</span><span class="sxs-lookup"><span data-stu-id="6567e-2321">When a thread calls <xref:System.AppDomain.Unload%2A>, the target domain is marked for unloading.</span></span> <span data-ttu-id="6567e-2322">专用线程尝试卸载域, 并中止域中的所有线程。</span><span class="sxs-lookup"><span data-stu-id="6567e-2322">The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</span></span> <span data-ttu-id="6567e-2323">例如, 如果线程不会中止, 例如因为它正在执行非托管代码, 或由于正在执行`finally`块, 则在最初调用<xref:System.AppDomain.Unload%2A>的线程中引发<xref:System.CannotUnloadAppDomainException>一段时间。</span><span class="sxs-lookup"><span data-stu-id="6567e-2323">If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a `finally` block, then after a period of time a <xref:System.CannotUnloadAppDomainException> is thrown in the thread that originally called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="6567e-2324">如果最终无法中止的线程结束, 则不会卸载目标域。</span><span class="sxs-lookup"><span data-stu-id="6567e-2324">If the thread that could not be aborted eventually ends, the target domain is not unloaded.</span></span> <span data-ttu-id="6567e-2325">因此, 不能保证在 .NET Framework `domain`版本2.0 中卸载, 因为它可能无法终止执行线程。</span><span class="sxs-lookup"><span data-stu-id="6567e-2325">Thus, in the .NET Framework version 2.0 `domain` is not guaranteed to unload, because it might not be possible to terminate executing threads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6567e-2326">在某些情况下, <xref:System.AppDomain.Unload%2A>调用会立即<xref:System.CannotUnloadAppDomainException>导致, 例如, 在终结器中调用它。</span><span class="sxs-lookup"><span data-stu-id="6567e-2326">In some cases, calling <xref:System.AppDomain.Unload%2A> causes an immediate <xref:System.CannotUnloadAppDomainException>, for example if it is called in a finalizer.</span></span>  
  
 <span data-ttu-id="6567e-2327">中`domain`的线程<xref:System.Threading.Thread.Abort%2A>使用<xref:System.Threading.ThreadAbortException>方法终止, 后者会在线程中引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2327">The threads in `domain` are terminated using the <xref:System.Threading.Thread.Abort%2A> method, which throws a <xref:System.Threading.ThreadAbortException> in the thread.</span></span> <span data-ttu-id="6567e-2328">尽管线程应立即终止, 但它可以在`finally`子句中继续执行的时间不能被预测。</span><span class="sxs-lookup"><span data-stu-id="6567e-2328">Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a `finally` clause.</span></span>  
  
## <a name="version-compatibility"></a><span data-ttu-id="6567e-2329">版本兼容性</span><span class="sxs-lookup"><span data-stu-id="6567e-2329">Version Compatibility</span></span>  
 <span data-ttu-id="6567e-2330">在 .NET Framework 版本1.0 和1.1 中, 如果调用<xref:System.AppDomain.Unload%2A>的线程运行在中`domain`, 则将启动另一个线程来执行卸载操作。</span><span class="sxs-lookup"><span data-stu-id="6567e-2330">In the .NET Framework version 1.0 and 1.1 if the thread that calls <xref:System.AppDomain.Unload%2A> is running in `domain`, another thread is started to perform the unload operation.</span></span> <span data-ttu-id="6567e-2331">如果`domain`无法卸载<xref:System.CannotUnloadAppDomainException> , 则将在该线程中引发, 而不是在调用<xref:System.AppDomain.Unload%2A>的原始线程中引发。</span><span class="sxs-lookup"><span data-stu-id="6567e-2331">If `domain` cannot be unloaded, a <xref:System.CannotUnloadAppDomainException> is thrown in that thread, not in the original thread that called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="6567e-2332">但是, 如果调用<xref:System.AppDomain.Unload%2A>的线程在外部`domain`运行, 则该线程将收到异常。</span><span class="sxs-lookup"><span data-stu-id="6567e-2332">However, if the thread that calls <xref:System.AppDomain.Unload%2A> is running outside `domain`, that thread receives the exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6567e-2333">下面的代码示例演示如何卸载应用程序域。</span><span class="sxs-lookup"><span data-stu-id="6567e-2333">The following code example shows how to unload an application domain.</span></span>  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6567e-2334"><paramref name="domain" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2334"><paramref name="domain" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><span data-ttu-id="6567e-2335"><paramref name="domain" /> 未能卸载。</span><span class="sxs-lookup"><span data-stu-id="6567e-2335"><paramref name="domain" /> could not be unloaded.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="6567e-2336">在卸载进程期间出错。</span><span class="sxs-lookup"><span data-stu-id="6567e-2336">An error occurred during the unload process.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="6567e-2337">为此事件添加事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="6567e-2337">to add an event handler for this event.</span></span> <span data-ttu-id="6567e-2338">关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />:。</span><span class="sxs-lookup"><span data-stu-id="6567e-2338">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="6567e-2339">安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</span><span class="sxs-lookup"><span data-stu-id="6567e-2339">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
