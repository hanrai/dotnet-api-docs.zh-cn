<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e9d6419b429a43792fc965aa3ddbec68dbfbbdb8" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68398348" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供一些方法，用于创建、处理、搜索数组并对数组进行排序，从而充当公共语言运行时中所有数组的基类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Array>类不是<xref:System.Collections>命名空间的一部分。 但是, 它仍被视为集合, 因为它基于<xref:System.Collections.IList>接口。  
  
 <xref:System.Array>类是支持数组的语言实现的基类。 但是, 只有系统和编译器才能显式从<xref:System.Array>类派生。 用户应使用该语言提供的数组构造。  
  
 元素是中<xref:System.Array>的一个值。 的长度<xref:System.Array>是它可以包含的元素总数。 的下限<xref:System.Array>是其第一个元素的索引。 <xref:System.Array>可以有任何下限, 但默认情况下它的下限为零。 <xref:System.Array> 使用<xref:System.Array.CreateInstance%2A>创建类的实例时, 可以定义其他下限。多维<xref:System.Array>可以为每个维度提供不同的界限。 数组最多可以有32个维度。  
  
 与<xref:System.Collections>命名空间中的类不同<xref:System.Array> , 具有固定的容量。 若要增加容量, 必须创建具有所需<xref:System.Array>容量的新对象, 将旧<xref:System.Array>对象中的元素复制到新对象, 并删除旧<xref:System.Array>对象。  

 数组大小限制为总计4000000000个元素, 在任何给定维度中限制为0X7FEFFFFF 的最大索引 (字节数组的0X7FFFFFC7 和单字节结构的数组)。
  
 **仅 .NET Framework:** 默认情况下, 的最大大小<xref:System.Array>为 2 gb。 在64位环境中, 可以通过在运行时环境中将[gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md)配置`enabled`元素的属性设置为来`true`避免大小限制。
  
 一维数组实现<xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>、 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType>和泛型接口。<xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> 实现在运行时提供给数组, 因此, 泛型接口不会出现在<xref:System.Array>类的声明语法中。 此外, 没有可通过将数组强制转换为泛型接口类型 (显式接口实现) 来访问的接口成员的引用主题。 将数组强制转换为这些接口之一时要注意的关键一点是, 添加、插入或删除元素的成员会引发<xref:System.NotSupportedException>。  
  
 <xref:System.Type>对象提供有关数组类型声明的信息。 <xref:System.Array>具有相同数组类型的对象共享相同<xref:System.Type>的对象。  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType>和<xref:System.Type.GetElementType%2A?displayProperty=nameWithType>可能不会返回所需的<xref:System.Array>结果, 因为如果数组强制转换为类型<xref:System.Array>, 则结果是对象, 而不是数组。 即, `typeof(System.Array).IsArray`返回`false`, 并`typeof(System.Array).GetElementType`返回。 `null`  
  
 <xref:System.Array.Copy%2A?displayProperty=nameWithType>方法不仅复制同一类型的数组中的元素, 还复制不同类型的标准数组之间的元素; 它会自动处理类型强制转换。  
  
 某些方法<xref:System.Array.CreateInstance%2A>(如<xref:System.Array.Copy%2A> <xref:System.Array.CopyTo%2A>、 <xref:System.Array.SetValue%2A>、、和) 提供接受64位整数作为参数以容纳大容量数组的重载。 <xref:System.Array.GetValue%2A> <xref:System.Array.LongLength%2A>和<xref:System.Array.GetLongLength%2A>返回64位整数, 指示数组的长度。  
  
 <xref:System.Array>不保证会对进行排序。  必须<xref:System.Array>先对进行排序, 才能执行需要排序的<xref:System.Array.BinarySearch%2A> <xref:System.Array>操作 (如)。  
  
 使用本机代码中的指针<xref:System.NotSupportedException> 对象不受支持,并将为多个方法引发。<xref:System.Array>  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Array.Copy%2A?displayProperty=nameWithType>复制类型为 integer 的数组和类型<xref:System.Object>为的数组之间的元素。  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 下面的代码示例创建并初始化<xref:System.Array>并显示其属性和元素。  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型的<see langword="Shared" />公共静态 (在 Visual Basic) 成员是线程安全的。 但不保证所有实例成员都是线程安全的。  
  
此实现不提供的同步 (线程安全) 包装<see cref="T:System.Array" />器; 但是, <see cref="T:System.Array" />基于的 .NET Framework 类使用<see cref="P:System.Array.SyncRoot" />属性提供自己的集合的同步版本。  
  
枚举整个集合本质上不是一个线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">数组（C# 编程指南）</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Visual Basic 中的数组</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要包装在只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装器中的从零开始的一维数组。</param>
        <summary>返回指定数组的只读包装。</summary>
        <returns>指定数组的只读 <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> 包装。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要防止对数组进行任何修改, 只需要通过此包装公开数组。  
  
 只读集合就是一个集合, 其中包含阻止修改集合的包装器;因此, 如果对基础集合进行了更改, 只读集合将反映这些更改。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的示例将数组包装为只读<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>。  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用二进制搜索算法在一维的排序 <see cref="T:System.Array" /> 中搜索值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由数组中每个元素和指定对象实现的 <see cref="T:System.IComparable" /> 接口，在整个一维排序数组中搜索特定元素。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 <xref:System.Array>如果不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引大于数组的上限, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 或的`array`每个元素都必须实现<xref:System.IComparable>接口, 该接口用于比较。 `value` 的`array`元素必须已根据<xref:System.IComparable>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
> [!NOTE]
>  如果`value`未<xref:System.IComparable>实现<xref:System.IComparable> 接口,则在搜索开始之前,`array`不会对的元素进行测试。 如果搜索遇到不实现<xref:System.IComparable>的元素, 则会引发异常。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 与的`null`比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable>实现确定给定元素如何与`null`进行比较。  
  
 此方法是 O ( `n`log) 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.BinarySearch%2A> <xref:System.Array>在中查找特定的对象。  
  
> [!NOTE]
>  创建数组时, 其元素采用升序排序顺序。 <xref:System.Array.BinarySearch%2A>方法要求数组按升序排序。  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> 的类型与 <paramref name="array" />的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
或 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在整个一维排序数组中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 <xref:System.Array>如果不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引大于数组的上限, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 比较器自定义元素的比较方式。 例如, 可以将<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>用作比较器来执行不区分大小写的字符串搜索。  
  
 如果`comparer`不`array` <xref:System.Collections.IComparer>为, 则使用指定的实现将的元素与指定的值进行比较。 `null` 的`array`元素必须已根据`comparer`定义的排序顺序按递增的值排序; 否则, 结果可能不正确。  
  
 如果`comparer` <xref:System.IComparable>为`null`, 则使用由元素本身或指定的值提供的实现进行比较。 的`array`元素必须已根据<xref:System.IComparable>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`为`null` <xref:System.IComparable> 且`array`未实现接口,则在搜索开始之前,不会对的元素进行测试。<xref:System.IComparable> `value` 如果搜索遇到不实现<xref:System.IComparable>的元素, 则会引发异常。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 与的`null`比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable>实现确定给定元素如何与`null`进行比较。  
  
 此方法是 O ( `n`log) 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" />的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由一维排序数组中每个元素和指定的值实现的 <see cref="T:System.IComparable" /> 接口，在该数组的一个元素范围内搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 <xref:System.Array>如果不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引大于数组的上限, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 或的`array`每个元素都必须实现<xref:System.IComparable>接口, 该接口用于比较。 `value` 的`array`元素必须已根据<xref:System.IComparable>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
> [!NOTE]
>  如果`value`未<xref:System.IComparable>实现<xref:System.IComparable> 接口,则在搜索开始之前,`array`不会对的元素进行测试。 如果搜索遇到不实现<xref:System.IComparable>的元素, 则会引发异常。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 与的`null`比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable>实现确定给定元素如何与`null`进行比较。  
  
 此方法的运算复杂度为 O `n`(log), `n`其中`length`, 为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
或 
 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的排序一维 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.IComparer" /> 接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 <xref:System.Array>如果不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引大于数组的上限, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 比较器自定义元素的比较方式。 例如, 可以将<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>用作比较器来执行不区分大小写的字符串搜索。  
  
 如果`comparer`不`array` <xref:System.Collections.IComparer>为, 则使用指定的实现将的元素与指定的值进行比较。 `null` 的`array`元素必须已根据`comparer`定义的排序顺序按递增的值排序; 否则, 结果可能不正确。  
  
 如果`comparer` <xref:System.IComparable>为`null`, 则使用由元素本身或指定的值提供的实现进行比较。 的`array`元素必须已根据<xref:System.IComparable>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`为`null` <xref:System.IComparable> 且`array`未实现接口,则在搜索开始之前,不会对的元素进行测试。<xref:System.IComparable> `value` 如果搜索遇到不实现<xref:System.IComparable>的元素, 则会引发异常。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 使用<xref:System.IComparable>时`null` , 与的比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable>实现确定给定元素如何与`null`进行比较。  
  
 此方法的运算复杂度为 O `n`(log), `n`其中`length`, 为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
或 
 <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="value" /> 不实现 <see cref="T:System.IComparable" /> 接口，并且搜索遇到不实现 <see cref="T:System.IComparable" /> 接口的元素。</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由 <see cref="T:System.Array" /> 中每个元素和指定对象实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在整个一维排序数组中搜索特定元素。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 如果`array`不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引等于数组的大小, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 `T`必须实现<xref:System.IComparable%601>用于比较的泛型接口。 的`array`元素必须已根据<xref:System.IComparable%601>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 与的`null`比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable%601>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable%601>实现确定给定元素如何与`null`进行比较。  
  
 此方法是 O ( `n`log) 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>和泛型方法重载。 创建一个字符串数组, 无特定顺序。  
  
 显示、排序并再次显示数组。 若要使用<xref:System.Array.BinarySearch%2A>方法, 必须对数组进行排序。  
  
> [!NOTE]
>  对<xref:System.Array.Sort%2A>和泛型方法的<xref:System.Array.BinarySearch%2A>调用与对其非泛型方法的调用没有任何区别, 因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型. 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 然后, 使用泛型方法重载搜索两个字符串, 一个字符串不在数组中, 另一个是。 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 此<xref:System.Array.BinarySearch%2A>方法的数组和返回值将传递`ShowWhere`给泛型方法, 该方法显示索引值 (如果找到该字符串), 否则为搜索字符串在数组中所处的元素。 如果字符串不在数组中, 则该索引为负, 因此该`ShowWhere`方法采用按位求补 ( C#和中的 ~ 运算符C++, `Xor`Visual Basic 中为-1) 以获取列表中较大的第一个元素的索引。比搜索字符串多。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  
  
或 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在整个一维排序数组中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 <xref:System.Array>如果不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引等于数组的大小, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 比较器自定义元素的比较方式。 例如, 可以将<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>用作比较器来执行不区分大小写的字符串搜索。  
  
 如果`comparer`不`array` <xref:System.Collections.Generic.IComparer%601>为, 则使用指定的泛型接口实现将的元素与指定的值进行比较。 `null` 的`array`元素必须已根据`comparer`定义的排序顺序按递增的值排序; 否则, 结果可能不正确。  
  
 如果`comparer` <xref:System.IComparable%601>为`null`, 则使用提供`T`的泛型接口实现进行比较。 的`array`元素必须已根据<xref:System.IComparable%601>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
> [!NOTE]
>  如果`comparer`为`null` <xref:System.IComparable%601> ,并且`value`不实现`array`泛型接口, 则在搜索开始之前, 不会测试<xref:System.IComparable%601>的元素。 如果搜索遇到不实现<xref:System.IComparable%601>的元素, 则会引发异常。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 与的`null`比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable%601>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable%601>实现确定给定元素如何与`null`进行比较。  
  
 此方法是 O ( `n`log) 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和泛型方法重载。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>` ( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 显示、排序并再次显示数组。 若要使用<xref:System.Array.BinarySearch%2A>方法, 必须对数组进行排序。  
  
> [!NOTE]
>  对<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和泛型方法的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>调用与对其非泛型方法的调用没有任何区别, 因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型. 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 然后, 使用泛型方法重载搜索两个字符串, 一个字符串不在数组中, 另一个是。 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 此<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法的数组和返回值将传递`ShowWhere`给泛型方法, 该方法显示索引值 (如果找到该字符串), 否则为搜索字符串在数组中所处的元素。 如果字符串不是 n 数组, 则该索引为负, 因此该`ShowWhere`方法采用按位求补 ( C#和中的 ~ 运算符C++, `Xor` Visual Basic 中为-1) 以获取列表中大于的第一个元素的索引。搜索字符串。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <summary>使用由 <see cref="T:System.Array" /> 中每个元素和指定值实现的 <see cref="T:System.IComparable`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 如果数组不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引等于数组的大小, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 `T`必须实现<xref:System.IComparable%601>用于比较的泛型接口。 的`array`元素必须已根据<xref:System.IComparable%601>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 与的`null`比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable%601>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable%601>实现确定给定元素如何与`null`进行比较。  
  
 此方法的运算复杂度为 O `n`(log), `n`其中`length`, 为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维排序 <see cref="T:System.Array" />。</param>
        <param name="index">要搜索的范围的起始索引。</param>
        <param name="length">要搜索的范围的长度。</param>
        <param name="value">要搜索的对象。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 实现。</param>
        <summary>使用指定 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口，在一维排序数组的某个元素范围中搜索值。</summary>
        <returns>如果找到 <paramref name="value" />，则为指定 <paramref name="array" /> 中的指定 <paramref name="value" /> 的索引；否则为负数。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 小于 <paramref name="array" /> 中的一个或多个元素，则返回的负数是大于 <paramref name="value" /> 的第一个元素的索引的按位求补。 如果找不到 <paramref name="value" /> 且 <paramref name="value" /> 大于 <paramref name="array" /> 中的所有元素，则返回的负数是（最后一个元素的索引加 1）的按位求补。 如果使用非排序的 <paramref name="array" /> 调用此方法，返回值则可能不正确并且可能会返回负数，即使 <paramref name="value" /> 存在于 <paramref name="array" /> 中也是如此。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不支持搜索包含负索引的数组。 `array`在调用此方法之前必须进行排序。  
  
 如果数组不包含指定的值, 则该方法返回一个负整数。 可以将按位求补运算符 ( C# `Not`在 Visual Basic 中为) 应用于负结果, 以生成索引。 如果此索引等于数组的大小, 则数组`value`中没有大于的元素。 否则, 它是大于的第一个元素`value`的索引。  
  
 比较器自定义元素的比较方式。 例如, 可以将<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>用作比较器来执行不区分大小写的字符串搜索。  
  
 如果`comparer`不`array` <xref:System.Collections.Generic.IComparer%601>为, 则使用指定的泛型接口实现将的元素与指定的值进行比较。 `null` 的`array`元素必须已根据`comparer`定义的排序顺序按递增的值排序; 否则, 结果可能不正确。  
  
 如果`comparer` <xref:System.IComparable%601> `T`为`null`, 则使用为类型提供的泛型接口实现来完成比较。 的`array`元素必须已根据<xref:System.IComparable%601>实现定义的排序顺序按递增值排序; 否则, 结果可能不正确。  
  
 允许重复元素。 如果包含多个等于的元素`value`, 则此方法只返回其中一个匹配项的索引, 而不是第一个匹配项的索引。 <xref:System.Array>  
  
 `null`始终可以与任何其他引用类型进行比较;因此, 使用<xref:System.IComparable%601>时`null` , 与的比较不会生成异常。  
  
> [!NOTE]
>  对于测试的每个`value`元素, 都将传递<xref:System.IComparable%601>到适当的实现`value` , `null`即使是。 也就是说, 该<xref:System.IComparable%601>实现确定给定元素如何与`null`进行比较。  
  
 此方法的运算复杂度为 O `n`(log), `n`其中`length`, 为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
或 
 <paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="value" /> 的类型与 <paramref name="array" /> 的元素不兼容。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="T" /> 不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">需要清除其元素的数组。</param>
        <param name="index">要清除的一系列元素的起始索引。</param>
        <param name="length">要清除的元素数。</param>
        <summary>将数组中的某个范围的元素设置为每个元素类型的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将数组中的每个元素重置为元素类型的默认值。 它将引用类型 (包括<xref:System.String>元素) 的元素设置为`null`, 并将值类型的元素设置为下表中显示的默认值。  
  
|类型|值|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|所有整型和浮点型数值类型|0 (零)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|其他值类型|类型字段的默认值|  
  
 已清除元素的范围在多维数组的行与行之间进行换行。  
  
 此方法仅清除元素的值;它不会删除元素本身。 数组具有固定的大小;因此, 无法添加或删除元素。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.Clear%2A>方法来重置一维二维数组中的整数值。  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 下面的示例定义了`TimeZoneTime`一个<xref:System.TimeZoneInfo>包含字段和<xref:System.DateTimeOffset>字段的结构。 然后, 它调用<xref:System.Array.Clear%2A>方法以清除两元素值数组中的`TimeZoneTime`一个元素。 方法<xref:System.TimeZoneInfo>将已`null`清除元素的值设置为对象的默认值, 即, <xref:System.DateTimeOffset>对象<xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>的默认值为。  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。  
  
或 
<paramref name="index" /> 和 <paramref name="length" /> 大于 <paramref name="array" /> 的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.Array" /> 的浅表副本。</summary>
        <returns><see cref="T:System.Array" /> 的浅表副本。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅复制的元素<xref:System.Array>(无论它们是引用类型还是值类型), 而不复制引用引用的对象。 <xref:System.Array> 新<xref:System.Array>点中对与原始<xref:System.Array>点中的引用相同的对象的引用。  
  
 相反, 的深层副本<xref:System.Array>会复制元素以及元素直接或间接引用的所有内容。  
  
 克隆与原始<xref:System.Type> <xref:System.Array>副本相同。  
  
 此方法是 O (`n`) 运算, 其中`n`是<xref:System.Array.Length%2A>。  
  
   
  
## Examples  
 下面的代码示例克隆一个<xref:System.Globalization.CultureInfo?displayProperty=nameWithType>数组, 并演示浅表副本的行为。  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="sourceIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="destinationIndex" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 32 位整数，它表示 <paramref name="sourceArray" /> 中复制开始处的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 32 位整数，它表示 <paramref name="destinationArray" /> 中存储开始处的索引。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。  保证在复制未成功完成的情况下撤消所有更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 和`destinationArray`参数必须具有相同的维数。  该`sourceArray`类型必须`destinationArray` 与<xref:System.ArrayTypeMismatchException>类型相同或派生, 否则将引发。  与<xref:System.Array.Copy%2A>不同<xref:System.Array.ConstrainedCopy%2A> , 在执行任何操作之前, 验证数组类型的兼容性。  
  
 在多维数组之间复制时, 数组的行为类似于一维数组, 其中的行 (或列) 在概念上是端到端的布局。 例如, 如果一个数组有三行 (或两列), 其中每个行都有四个元素, 则从该数组的开头复制六个元素将复制第一行 (或列) 的所有四个元素和第二行 (或列) 的前两个元素。 若要从第三行 (或列) 的第二个元素开始`sourceIndex`复制, 必须是第一行 (或列) 的上限加上第二行 (或列) 加两行的长度。  
  
 如果`sourceArray` `sourceArray` `destinationArray`和`destinationArray`重叠, 此方法的行为就像在覆盖之前将的原始值保留在临时位置。  
  
 [C++]  
  
 此方法等效于标准 C/C++函数`memmove`, 而不`memcpy`是。  
  
 数组可以是引用类型的数组或值类型数组。  如果`sourceArray` <xref:System.Object>和`destinationArray`既是引用类型数组, 或是同时为类型的数组, 则执行浅表复制。 的<xref:System.Array>浅表副本是新<xref:System.Array>的, 其中包含对与原始<xref:System.Array>元素相同的元素的引用。 不复制元素本身或元素所引用的任何内容。 相反, 的深层副本<xref:System.Array>会复制元素以及元素直接或间接引用的所有内容。  
  
 如果此方法在复制时引发异常, 则`destinationArray`将保持不变; <xref:System.Array.ConstrainedCopy%2A>因此, 可以在受约束的执行区域<xref:System.Runtime.ConstrainedExecution.Cer>() 中使用。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
或 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 类型与 <paramref name="destinationArray" /> 类型不同，且不派生自后者。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。  
  
或 
 <paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  
  
- 或 - 
 <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">源数组元素的类型。</typeparam>
        <typeparam name="TOutput">目标数组元素的类型。</typeparam>
        <param name="array">要转换为目标类型的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="converter">用于将每个元素从一种类型转换为另一种类型的 <see cref="T:System.Converter`2" />。</param>
        <summary>将一种类型的数组转换为另一种类型的数组。</summary>
        <returns>目标类型的数组，包含从源数组转换而来的元素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Converter%602>是一个方法委托, 该委托将对象转换为目标类型。  的元素`array`分别传递<xref:System.Converter%602>到, 并将转换后的元素保存到新数组中。  
  
 源`array`保持不变。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例定义了一个名`PointFToPoint`为的方法<xref:System.Drawing.PointF> , 该方法<xref:System.Drawing.Point>将结构转换为结构。 然后, 该示例<xref:System.Drawing.PointF>创建一个结构数组, `Converter<PointF, Point>`创建委托 (`Converter(Of PointF, Point)`在 Visual Basic 中) 以表示`PointFToPoint`方法, 并将委托传递给<xref:System.Array.ConvertAll%2A>方法。 方法将输入列表的每个元素传递`PointFToPoint`给方法, 并将转换后的元素放入新的<xref:System.Drawing.Point>结构列表。 <xref:System.Array.ConvertAll%2A> 将显示这两个列表。  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
或 
 <paramref name="converter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将一个 <see cref="T:System.Array" /> 的一部分元素复制到另一个 <see cref="T:System.Array" /> 中，并根据需要执行类型强制转换和装箱。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。 长度指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 和`destinationArray`参数必须具有相同的维数。 此外, `destinationArray`必须已设置了维度, 并且必须具有足够数量的元素来容纳所复制的数据。  
  
 在多维数组之间复制时, 数组的行为类似于一维数组, 其中的行 (或列) 在概念上是端到端的布局。 例如, 如果一个数组有三行 (或两列), 其中每个行都有四个元素, 则从该数组的开头复制六个元素将复制第一行 (或列) 的所有四个元素和第二行 (或列) 的前两个元素。  
  
 如果`sourceArray` `sourceArray` `destinationArray`和`destinationArray`重叠, 此方法的行为就像在覆盖之前将的原始值保留在临时位置。  
  
 [C++]  
  
 此方法等效于标准 C/C++函数`memmove`, 而不`memcpy`是。  
  
 数组可以是引用类型的数组或值类型数组。 根据需要执行类型 downcasting。  
  
-   从引用类型数组复制到值类型数组时, 每个元素都将取消装箱, 然后复制。 从值类型的数组复制到引用类型的数组时, 每个元素都进行装箱, 然后复制。  
  
-   在从引用类型或值类型的数组复制到<xref:System.Object>数组时<xref:System.Object> , 将创建来保存每个值或引用, 然后复制。 从<xref:System.Object>数组复制到引用类型或值类型的数组时, 如果不可能进行赋值<xref:System.InvalidCastException> , 则会引发。  
  
-   如果`sourceArray` <xref:System.Object>和`destinationArray`既是引用类型数组, 或是同时为类型的数组, 则执行浅表复制。 的<xref:System.Array>浅表副本是新<xref:System.Array>的, 其中包含对与原始<xref:System.Array>元素相同的元素的引用。 不复制元素本身或元素所引用的任何内容。 相反, 的深层副本<xref:System.Array>会复制元素以及元素直接或间接引用的所有内容。  
  
 如果数组的类型不兼容,则会引发。<xref:System.ArrayTypeMismatchException> 类型兼容性定义如下:  
  
-   类型与自身兼容。  
  
-   值类型与<xref:System.Object>和兼容, 具有由该值类型实现的接口类型。 仅当某个值类型直接实现该接口时, 才会将该值类型视为已连接。 断开连接的类型不兼容。  
  
-   如果从源类型到目标类型的复制是扩大转换, 则两个内部 (预定义) 值类型是兼容的。 扩大转换从不会丢失信息, 而收缩转换可能会丢失信息。 例如, 将32位有符号整数转换为64位有符号整数是扩大转换, 将64位有符号整数转换为32位带符号整数是收缩转换。 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
-   Nonintrinsic (用户定义) 值类型仅与自身兼容。  
  
-   枚举具有到<xref:System.Enum>及其基础类型的隐式转换。  
  
 如果中`sourceArray`的每个元素都需要向下转换 (例如, 从基类到派生类或从接口到对象), 并且不能将一个或多个元素强制转换为中`destinationArray`的相应类型<xref:System.InvalidCastException> , 则会引发。  
  
 如果此方法在复制时引发异常, `destinationArray`则的状态为 undefined。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
或 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。  
  
或 
 <paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="length">一个 64 位整数，它表示要复制的元素数目。 该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</param>
        <summary>从第一个元素开始复制 <see cref="T:System.Array" /> 中的一系列元素，将它们粘贴到另一 <see cref="T:System.Array" /> 中（从第一个元素开始）。 长度指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 和`destinationArray`参数必须具有相同的维数。 此外, `destinationArray`必须已设置了维度, 并且必须具有足够数量的元素来容纳所复制的数据。  
  
 在多维数组之间复制时, 数组的行为类似于一维数组, 其中的行 (或列) 在概念上是端到端的布局。 例如, 如果一个数组有三行 (或两列), 其中每个行都有四个元素, 则从该数组的开头复制六个元素将复制第一行 (或列) 的所有四个元素和第二行 (或列) 的前两个元素。  
  
 如果`sourceArray` `sourceArray` `destinationArray`和`destinationArray`重叠, 此方法的行为就像在覆盖之前将的原始值保留在临时位置。  
  
 [C++]  
  
 此方法等效于标准 C/C++函数`memmove`, 而不`memcpy`是。  
  
 数组可以是引用类型的数组或值类型数组。 根据需要执行类型 downcasting。  
  
-   从引用类型数组复制到值类型数组时, 每个元素都将取消装箱, 然后复制。 从值类型的数组复制到引用类型的数组时, 每个元素都进行装箱, 然后复制。  
  
-   在从引用类型或值类型的数组复制到<xref:System.Object>数组时<xref:System.Object> , 将创建来保存每个值或引用, 然后复制。 从<xref:System.Object>数组复制到引用类型或值类型的数组时, 如果不可能进行赋值<xref:System.InvalidCastException> , 则会引发。  
  
-   如果`sourceArray` <xref:System.Object>和`destinationArray`既是引用类型数组, 或是同时为类型的数组, 则执行浅表复制。 的<xref:System.Array>浅表副本是新<xref:System.Array>的, 其中包含对与原始<xref:System.Array>元素相同的元素的引用。 不复制元素本身或元素所引用的任何内容。 相反, 的深层副本<xref:System.Array>会复制元素以及元素直接或间接引用的所有内容。  
  
 如果数组的类型不兼容,则会引发。<xref:System.ArrayTypeMismatchException> 类型兼容性定义如下:  
  
-   类型与自身兼容。  
  
-   值类型与<xref:System.Object>和兼容, 具有由该值类型实现的接口类型。 仅当某个值类型直接实现该接口时, 才会将该值类型视为已连接。 断开连接的类型不兼容。  
  
-   如果从源类型到目标类型的复制是扩大转换, 则两个内部 (预定义) 值类型是兼容的。 扩大转换从不会丢失信息, 而收缩转换可能会丢失信息。 例如, 将32位有符号整数转换为64位有符号整数是扩大转换, 将64位有符号整数转换为32位带符号整数是收缩转换。 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
-   Nonintrinsic (用户定义) 值类型仅与自身兼容。  
  
-   枚举具有到<xref:System.Enum>及其基础类型的隐式转换。  
  
 如果中`sourceArray`的每个元素都需要向下转换 (例如, 从基类到派生类或从接口到对象), 并且不能将一个或多个元素强制转换为中`destinationArray`的相应类型<xref:System.InvalidCastException> , 则会引发。  
  
 如果此方法在复制时引发异常, `destinationArray`则的状态为 undefined。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
或 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于 <paramref name="sourceArray" /> 中的元素数。  
  
或 
 <paramref name="length" /> 大于 <paramref name="destinationArray" /> 中的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 32 位整数，它表示 <paramref name="sourceArray" /> 中复制开始处的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 32 位整数，它表示 <paramref name="destinationArray" /> 中存储开始处的索引。</param>
        <param name="length">一个 32 位整数，它表示要复制的元素数目。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。 长度和索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 和`destinationArray`参数必须具有相同的维数。 此外, `destinationArray`必须已设置了维度, 并且必须具有足够数量的元素`destinationIndex` , 才能容纳复制的数据。  
  
 在多维数组之间复制时, 数组的行为类似于一维数组, 其中的行 (或列) 在概念上是端到端的布局。 例如, 如果一个数组有三行 (或两列), 其中每个行都有四个元素, 则从该数组的开头复制六个元素将复制第一行 (或列) 的所有四个元素和第二行 (或列) 的前两个元素。 若要从第三行 (或列) 的第二个元素开始`sourceIndex`复制, 必须是第一行 (或列) 的上限加上第二行 (或列) 加两行的长度。  
  
 如果`sourceArray` `sourceArray` `destinationArray`和`destinationArray`重叠, 此方法的行为就像在覆盖之前将的原始值保留在临时位置。  
  
 [C++]  
  
 此方法等效于标准 C/C++函数`memmove`, 而不`memcpy`是。  
  
 数组可以是引用类型的数组或值类型数组。 根据需要执行类型 downcasting。  
  
-   从引用类型数组复制到值类型数组时, 每个元素都将取消装箱, 然后复制。 从值类型的数组复制到引用类型的数组时, 每个元素都进行装箱, 然后复制。  
  
-   在从引用类型或值类型的数组复制到<xref:System.Object>数组时<xref:System.Object> , 将创建来保存每个值或引用, 然后复制。 从<xref:System.Object>数组复制到引用类型或值类型的数组时, 如果不可能进行赋值<xref:System.InvalidCastException> , 则会引发。  
  
-   如果`sourceArray` <xref:System.Object>和`destinationArray`既是引用类型数组, 或是同时为类型的数组, 则执行浅表复制。 的<xref:System.Array>浅表副本是新<xref:System.Array>的, 其中包含对与原始<xref:System.Array>元素相同的元素的引用。 不复制元素本身或元素所引用的任何内容。 相反, 的深层副本<xref:System.Array>会复制元素以及元素直接或间接引用的所有内容。  
  
 如果数组的类型不兼容,则会引发。<xref:System.ArrayTypeMismatchException> 类型兼容性定义如下:  
  
-   类型与自身兼容。  
  
-   值类型与<xref:System.Object>和兼容, 具有由该值类型实现的接口类型。 仅当某个值类型直接实现该接口时, 才会将该值类型视为已连接。 断开连接的类型不兼容。  
  
-   如果从源类型到目标类型的复制是扩大转换, 则两个内部 (预定义) 值类型是兼容的。 扩大转换从不会丢失信息, 而收缩转换可能会丢失信息。 例如, 将32位有符号整数转换为64位有符号整数是扩大转换, 将64位有符号整数转换为32位带符号整数是收缩转换。 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
-   Nonintrinsic (用户定义) 值类型仅与自身兼容。  
  
-   枚举具有到<xref:System.Enum>及其基础类型的隐式转换。  
  
 如果中`sourceArray`的每个元素都需要向下转换 (例如, 从基类到派生类或从接口到对象), 并且不能将一个或多个元素强制转换为中`destinationArray`的相应类型<xref:System.InvalidCastException> , 则会引发。  
  
 如果此方法在复制时引发异常, `destinationArray`则的状态为 undefined。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何从一个<xref:System.Array>类型<xref:System.Object>复制到一个整型类型<xref:System.Array>的另一个。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
或 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> 少于 <paramref name="sourceArray" /> 的第一个维度的下限。  
  
- 或 - 
 <paramref name="destinationIndex" /> 少于 <paramref name="destinationArray" /> 的第一个维度的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" /> 末尾的元素数。  
  
或 
 <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="sourceIndex" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationArray" Type="System.Array" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="destinationIndex" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int64" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sourceArray">包含要复制的数据的 <see cref="T:System.Array" />。</param>
        <param name="sourceIndex">一个 64 位整数，它表示复制开始处的 <paramref name="sourceArray" /> 中的索引。</param>
        <param name="destinationArray">接收数据的 <see cref="T:System.Array" />。</param>
        <param name="destinationIndex">一个 64 位整数，它表示存储开始处的 <paramref name="destinationArray" /> 中的索引。</param>
        <param name="length">一个 64 位整数，它表示要复制的元素数目。 该整数必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间（包括这两个值）。</param>
        <summary>复制 <see cref="T:System.Array" /> 中的一系列元素（从指定的源索引开始），并将它们粘贴到另一 <see cref="T:System.Array" /> 中（从指定的目标索引开始）。 长度和索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `sourceArray` 和`destinationArray`参数必须具有相同的维数。 此外, `destinationArray`必须已设置了维度, 并且必须具有足够数量的元素`destinationIndex` , 才能容纳复制的数据。  
  
 在多维数组之间复制时, 数组的行为类似于一维数组, 其中的行 (或列) 在概念上是端到端的布局。 例如, 如果一个数组有三行 (或两列), 其中每个行都有四个元素, 则从该数组的开头复制六个元素将复制第一行 (或列) 的所有四个元素和第二行 (或列) 的前两个元素。 若要从第三行 (或列) 的第二个元素开始`sourceIndex`复制, 必须是第一行 (或列) 的上限加上第二行 (或列) 加两行的长度。  
  
 如果`sourceArray` `sourceArray` `destinationArray`和`destinationArray`重叠, 此方法的行为就像在覆盖之前将的原始值保留在临时位置。  
  
 [C++]  
  
 此方法等效于标准 C/C++函数`memmove`, 而不`memcpy`是。  
  
 数组可以是引用类型的数组或值类型数组。 根据需要执行类型 downcasting。  
  
-   从引用类型数组复制到值类型数组时, 每个元素都将取消装箱, 然后复制。 从值类型的数组复制到引用类型的数组时, 每个元素都进行装箱, 然后复制。  
  
-   在从引用类型或值类型的数组复制到<xref:System.Object>数组时<xref:System.Object> , 将创建来保存每个值或引用, 然后复制。 从<xref:System.Object>数组复制到引用类型或值类型的数组时, 如果不可能进行赋值<xref:System.InvalidCastException> , 则会引发。  
  
-   如果`sourceArray` <xref:System.Object>和`destinationArray`既是引用类型数组, 或是同时为类型的数组, 则执行浅表复制。 的<xref:System.Array>浅表副本是新<xref:System.Array>的, 其中包含对与原始<xref:System.Array>元素相同的元素的引用。 不复制元素本身或元素所引用的任何内容。 相反, 的深层副本<xref:System.Array>会复制元素以及元素直接或间接引用的所有内容。  
  
 如果数组的类型不兼容,则会引发。<xref:System.ArrayTypeMismatchException> 类型兼容性定义如下:  
  
-   类型与自身兼容。  
  
-   值类型与<xref:System.Object>和兼容, 具有由该值类型实现的接口类型。 仅当某个值类型直接实现该接口时, 才会将该值类型视为已连接。 断开连接的类型不兼容。  
  
-   如果从源类型到目标类型的复制是扩大转换, 则两个内部 (预定义) 值类型是兼容的。 扩大转换从不会丢失信息, 而收缩转换可能会丢失信息。 例如, 将32位有符号整数转换为64位有符号整数是扩大转换, 将64位有符号整数转换为32位带符号整数是收缩转换。 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
-   Nonintrinsic (用户定义) 值类型仅与自身兼容。  
  
-   枚举具有到<xref:System.Enum>及其基础类型的隐式转换。  
  
 如果中`sourceArray`的每个元素都需要向下转换 (例如, 从基类到派生类或从接口到对象), 并且不能将一个或多个元素强制转换为中`destinationArray`的相应类型<xref:System.InvalidCastException> , 则会引发。  
  
 如果此方法在复制时引发异常, `destinationArray`则的状态为 undefined。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何从一个<xref:System.Array>类型<xref:System.Object>复制到一个整型类型<xref:System.Array>的另一个。  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> 为 <see langword="null" />。  
  
或 
 <paramref name="destinationArray" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 具有不同的秩。</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> 和 <paramref name="destinationArray" /> 属于不兼容的类型。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="sourceArray" /> 中至少有一个元素无法转换为 <paramref name="destinationArray" /> 的类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> 超出了 <paramref name="sourceArray" /> 的有效索引范围。  
  
或 
 <paramref name="destinationIndex" /> 超出了 <paramref name="destinationArray" /> 的有效索引范围。  
  
或 
 <paramref name="length" /> 小于 0 或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> 大于从 <paramref name="sourceIndex" /> 到 <paramref name="sourceArray" />末尾的元素数。  
  
- 或 - 
 <paramref name="length" /> 大于从 <paramref name="destinationIndex" /> 到 <paramref name="destinationArray" /> 末尾的元素数。</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前一维数组的所有元素复制到指定的一维数组中。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">一维数组，它是从当前数组复制的元素的目标。</param>
        <param name="index">一个 32 位整数，它表示 <paramref name="array" /> 中复制开始处的索引。</param>
        <summary>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将当前数组实例的所有元素复制到`array`目标数组, 从索引`index`开始。 `array`目标数组必须已设置了维度, 并且必须具有足够数量的元素来容纳复制的元素。 否则，该方法将引发异常。  
  
 此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。 如果不<xref:System.Collections.ICollection?displayProperty=nameWithType>显式需要实现, 请使用<xref:System.Array.Copy%2A>以避免额外的间接寻址。  
  
 如果此方法在复制时引发异常, `array`则的状态为 undefined。  
  
 此方法是 O (`n`) 运算, 其中`n`是<xref:System.Array.Length%2A>。它仅执行浅表复制。  
  
   
  
## Examples  
 下面的代码示例演示如何将复制<xref:System.Array>到另<xref:System.Array>一个。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下面的代码示例演示如何使用非零<xref:System.Array>下限将<xref:System.Array>复制到另一个。 请注意, 将复制<xref:System.Array>整个源, 包括覆盖目标<xref:System.Array>中现有元素的空元素。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
或 
源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
        <exception cref="T:System.RankException">源数组是多维数组。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="array">一维数组，它是从当前数组复制的元素的目标。</param>
        <param name="index">一个 64 位整数，它表示 <paramref name="array" /> 中复制开始处的索引。</param>
        <summary>从指定的目标数组索引处开始，将当前一维数组的所有元素复制到指定的一维数组中。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法将当前数组实例的所有元素复制到`array`目标数组, 从索引`index`开始。 `array`目标数组必须已设置了维度, 并且必须具有足够数量的元素来容纳复制的元素。 否则，该方法将引发异常。  
  
 此方法支持<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。 如果不<xref:System.Collections.ICollection?displayProperty=nameWithType>显式需要实现, 请使用<xref:System.Array.Copy%2A>以避免额外的间接寻址。  
  
 如果此方法在复制时引发异常, `array`则的状态为 undefined。  
  
 此方法是 O (`n`) 运算, 其中`n`是<xref:System.Array.Length%2A>。它仅执行浅表复制。  
  
   
  
## Examples  
 下面的代码示例演示如何将复制<xref:System.Array>到另<xref:System.Array>一个。  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 下面的代码示例演示如何使用非零<xref:System.Array>下限将<xref:System.Array>复制到另一个。 请注意, 将复制<xref:System.Array>整个源, 包括覆盖目标<xref:System.Array>中现有元素的空元素。  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> 是多维的。  
  
或 
源数组中的元素数大于从 <paramref name="index" /> 到目标 <paramref name="array" /> 的末尾之间的可用元素数。</exception>
        <exception cref="T:System.ArrayTypeMismatchException">无法自动将源 <see cref="T:System.Array" /> 的类型转换为目标 <paramref name="array" /> 的类型。</exception>
        <exception cref="T:System.RankException">源 <see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidCastException">源 <see cref="T:System.Array" /> 中至少有一个元素无法转换为目标 <paramref name="array" /> 的类型。</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Array" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length">要创建的 <see cref="T:System.Array" /> 的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的一维 <see cref="T:System.Array" />。</summary>
        <returns>使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和长度的新的一维 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类不同<xref:System.Array> , <xref:System.Array.CreateInstance%2A>提供方法, 而不是公共构造函数, 以允许进行后期绑定访问。  
  
 引用类型的元素将初始化为`null`。 值类型元素初始化为零。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化一维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
或 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一个 32 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。</param>
        <summary>创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。 维的长度在一个 32 位整数数组中指定。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类不同<xref:System.Array> , <xref:System.Array.CreateInstance%2A>提供方法, 而不是公共构造函数, 以允许进行后期绑定访问。  
  
 `lengths`数组中的元素数必须等于新<xref:System.Array>中的维数。 `lengths`数组中的每个元素都必须在新<xref:System.Array>中指定相应维度的长度。  
  
 引用类型的元素将初始化为`null`。 值类型元素初始化为零。  
  
 此方法是 O (`n`) 运算, 其中`n`是中`lengths`所有值的乘积。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化多维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。  
  
或 
 <paramref name="lengths" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  
  
或 
<paramref name="lengths" /> 数组包含的元素少于一个。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 中的任何值都小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lengths" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一个 64 位整数数组，它表示要创建的 <see cref="T:System.Array" /> 中每个维度的大小。 数组中的每个整数都必须介于零和 <see cref="F:System.Int32.MaxValue" /> 之间，（包括零和 System.Int32.MaxValue）。</param>
        <summary>创建索引从零开始、具有指定 <see cref="T:System.Type" /> 和维长的多维 <see cref="T:System.Array" />。 维度的长度在一个 64 位整数数组中指定。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的新多维 <see cref="T:System.Array" />，该数组每个维具有指定长度，且使用从零开始的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类不同<xref:System.Array> , <xref:System.Array.CreateInstance%2A>提供方法, 而不是公共构造函数, 以允许进行后期绑定访问。  
  
 `lengths`数组中的元素数必须等于新<xref:System.Array>中的维数。 `lengths`数组中的每个元素都必须在新<xref:System.Array>中指定相应维度的长度。  
  
 引用类型的元素将初始化为`null`。 值类型元素初始化为零。  
  
 此方法是 O (`n`) 运算, 其中`n`是中`lengths`所有值的乘积。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化多维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。  
  
或 
 <paramref name="lengths" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  
  
或 
<paramref name="lengths" /> 数组包含的元素少于一个。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
或 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 中的所有值都小于零或大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</param>
        <param name="length2">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Array" /> 和维长的二维 <see cref="T:System.Type" />。</summary>
        <returns>使用从零开始的索引、具有指定 <see cref="T:System.Array" /> 的新的二维 <see cref="T:System.Type" />，其每个维度都为指定的长度。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类不同<xref:System.Array> , <xref:System.Array.CreateInstance%2A>提供方法, 而不是公共构造函数, 以允许进行后期绑定访问。  
  
 引用类型的元素将初始化为`null`。 值类型元素初始化为零。  
  
 此方法是 O`n`() 运算, 其中`n`是`length1`和`length2`的乘积。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化二维<xref:System.Array>。  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
或 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> 小于零。  
  
或 
 <paramref name="length2" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="lengths">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的大小。</param>
        <param name="lowerBounds">一维数组，它包含要创建的 <see cref="T:System.Array" /> 的每个维度的下限（起始索引）。</param>
        <summary>创建具有指定下限、指定 <see cref="T:System.Array" /> 和维长的多维 <see cref="T:System.Type" />。</summary>
        <returns>新的指定 <see cref="T:System.Array" /> 的多维 <see cref="T:System.Type" />，每个维度都有指定的长度和下限。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类不同<xref:System.Array> , <xref:System.Array.CreateInstance%2A>提供方法, 而不是公共构造函数, 以允许进行后期绑定访问。  
  
 `lengths` 和`lowerBounds`数组必须具有相同数量的元素。 `lengths`数组中的元素数必须等于新<xref:System.Array>中的维数。  
  
 `lengths`数组中的每个元素都必须在新<xref:System.Array>中指定相应维度的长度。  
  
 `lowerBounds`数组中的每个元素都必须指定新<xref:System.Array>中的相应维度的下限。 通常, .NET Framework 类库和许多编程语言不处理非零的下限。  
  
 引用类型的元素将初始化为`null`。 值类型元素初始化为零。  
  
 此方法是 O (`n`) 运算, 其中`n`是中`lengths`所有值的乘积。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化具有指定下限<xref:System.Array>的多维。  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。  
  
或 
 <paramref name="lengths" /> 为 <see langword="null" />。  
  
或 
 <paramref name="lowerBounds" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。  
  
或 
<paramref name="lengths" /> 数组包含的元素少于一个。  
  
或 
<paramref name="lengths" /> 和 <paramref name="lowerBounds" /> 数组包含的元素数不同。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="lengths" /> 中的任何值都小于零。  
  
或 
<paramref name="lowerBounds" /> 中的任意一个值都很大，因此，维的下限和长度的和大于 <see cref="F:System.Int32.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="length3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="elementType">要创建的 <see cref="T:System.Array" /> 的 <see cref="T:System.Type" />。</param>
        <param name="length1">要创建的 <see cref="T:System.Array" /> 的第一维的大小。</param>
        <param name="length2">要创建的 <see cref="T:System.Array" /> 的第二维的大小。</param>
        <param name="length3">要创建的 <see cref="T:System.Array" /> 的第三维的大小。</param>
        <summary>创建使用从零开始的索引、具有指定 <see cref="T:System.Type" /> 和维长的三维 <see cref="T:System.Array" />。</summary>
        <returns>每个维具有指定长度、使用从零开始的索引的指定 <see cref="T:System.Type" /> 的新三维 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与大多数类不同<xref:System.Array> , <xref:System.Array.CreateInstance%2A>提供方法, 而不是公共构造函数, 以允许进行后期绑定访问。  
  
 引用类型的元素将初始化为`null`。 值类型元素初始化为零。  
  
 此方法的运算复杂度为`n`O (), `n`其中是`length1`、 `length2`和`length3`的乘积。  
  
   
  
## Examples  
 下面的代码示例演示如何创建和初始化<xref:System.Array>三维。  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> 不是有效的 <see cref="T:System.Type" />。</exception>
        <exception cref="T:System.NotSupportedException">不支持 <paramref name="elementType" />。 例如，不支持 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="elementType" /> 为开放式泛型类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> 小于零。  
  
- 或 - 
 <paramref name="length2" /> 小于零。  
  
或 
 <paramref name="length3" /> 小于零。</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <summary>返回一个空数组。</summary>
        <returns>空数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索的元素的条件。</param>
        <summary>确定指定数组包含的元素是否与指定谓词定义的条件匹配。</summary>
        <returns>如果 <paramref name="array" /> 包含一个或多个元素与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到, 当找到匹配项时将停止处理。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建<xref:System.Predicate%601>委托。 这些语言从上下文推断正确的委托并自动创建它。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例使用 lambda 表达式为<xref:System.Array.Exists%2A>方法指定匹配条件, 以检查行星是否以给定的字母开头, 或者是否在给定的数组中找到了行星。  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 下面的示例使用<xref:System.Array.Exists%2A>方法来指示字符串数组中的任何名称是否以指定字符开头。 该示例通过将`StringSearcher`字符串传递到要搜索的类构造函数来实例化对象。 方法与<xref:System.Predicate%601>委托具有相同的签名。 `StringSearcher.StartsWith` 调用方法时, 会将数组的每个成员传递给委托, 直到返回`true`或循环访问数组中的所有元素。 <xref:System.Array.Exists%2A>  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 你还可以使用 lambda 表达式, 而不是显式定义其签名与委托的签名对应的方法。 下面的示例将`StringSearcher`类`StartsWith`及其方法替换为 lambda 表达式。  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Lambda 表达式（C# 编程指南）</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Lambda 表达式 (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="match">用于定义要搜索的元素的条件的谓词。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的第一个匹配元素。</summary>
        <returns>如果找到与指定谓词定义的条件匹配的第一个元素，则为该元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果传递给它的对象与委托或 lambda 表达式中定义的条件相匹配, 则为方法的委托或lambda表达式。<xref:System.Predicate%601> `true`  的元素`array`分别传递<xref:System.Predicate%601>到, 从第一个元素开始, 到最后一个元素结束。  找到匹配项时将停止处理。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例将<xref:System.Predicate%601>委托<xref:System.Array.Find%2A>与泛型方法一起使用<xref:System.Drawing.Point>以搜索结构数组。 如果 X 和 Y 字段的`ProductGT10`乘积大于`true` 100000, 则委托表示的方法返回。 <xref:System.Array.Find%2A>方法为数组的每个元素调用委托, 并返回满足测试条件的第一个点。  
  
> [!NOTE]
>  Visual Basic 和C#用户不必显式创建委托或指定泛型方法的类型参数。 编译器根据您提供的方法参数确定必要的类型。  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 可以使用 lambda 表达式, 而不是使用必需的签名显式<xref:System.Predicate%601>定义方法, 实例化委托并将<xref:System.Array.Find%2A>委托传递给方法。 下面的示例与上一个示例相同, 不同之处在于它使用 lambda 表达式作为`match`参数。  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索的元素的条件。</param>
        <summary>检索与指定谓词定义的条件匹配的所有元素。</summary>
        <returns>如果找到一个其中所有元素均与指定谓词定义的条件匹配的 <see cref="T:System.Array" />，则为该数组；否则为一个空 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到, 并将与条件相匹配的元素保存在返回的数组中。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例创建一个50随机数数组, 其中的值的范围介于0到1000之间。 然后, 它使用<xref:System.Array.FindAll%2A>返回值范围为300到600的 lambda 表达式调用方法。 请注意, lambda 表达式被传递了一个名`x`为的参数; 这表示传递到的<xref:System.Predicate%601>单个数组成员。 另请注意, 在`lBound` lambda `uBound`表达式中可访问本地和变量。  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 下面的代码示例演示了<xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>和<xref:System.Array.FindAll%2A>泛型方法。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 泛型方法从开始处遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.Find%2A> 当`EndsWithSaurus`方法为元素 "Amargasaurus" `true`返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindLast%2A>泛型方法用于从末尾向后搜索数组。 它在位置5找到元素 "Dilophosaurus"。 <xref:System.Array.FindAll%2A>泛型方法用于返回数组, 该数组包含以 "saurus" 结尾的所有元素。 显示元素。  
  
 此代码示例还演示了<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
或 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词定义的条件匹配的元素，然后返回 <see cref="T:System.Array" /> 或其某个部分中第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中第一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向前搜索从第一个元素开始, 到最后一个元素结束。  
  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.FindIndex%2A>泛型方法的所有三个重载。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 方法重载从开始处遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 当`EndsWithSaurus`方法为位置1处的`true`元素返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于从位置2开始搜索数组, 并继续到数组末尾。 它在位置5找到元素。 最后, <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>使用方法重载在从位置2开始的三个元素的范围内进行搜索。 它将返回-1, 因为该范围中没有以 "saurus" 结尾的恐龙名称。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
或 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从指定索引到最后一个元素的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将从最后一个元素开始向前搜索并结束。`startIndex` <xref:System.Array>  
  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到。  
  
 此方法为 O`n`() 运算, 其中`n`是`array`从`startIndex`到末尾的元素数。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.FindIndex%2A>泛型方法的所有三个重载。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 方法重载从开始处遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 当`EndsWithSaurus`方法为位置1处的`true`元素返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于从位置2开始搜索数组, 并继续到数组末尾。 它在位置5找到元素。 最后, <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>使用方法重载在从位置2开始的三个元素的范围内进行搜索。 它将返回-1, 因为该范围中没有以 "saurus" 结尾的恐龙名称。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的一个元素，并返回 <see cref="T:System.Array" /> 中从指定的索引开始、包含指定元素个数的元素范围内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的第一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `startIndex` `startIndex` `count`如果<xref:System.Array> 大于0,则从开始向前搜索,并在plus减1处结束。`count`  
  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到。  
  
 此方法是 O (`n`) 运算, 其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.FindIndex%2A>泛型方法的所有三个重载。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 方法重载从开始处遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 当`EndsWithSaurus`方法为位置1处的`true`元素返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于从位置2开始搜索数组, 并继续到数组末尾。 它在位置5找到元素。 最后, <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>使用方法重载在从位置2开始的三个元素的范围内进行搜索。 它将返回-1, 因为该范围中没有以 "saurus" 结尾的恐龙名称。  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中的最后一个匹配元素。</summary>
        <returns>如果找到，则为与指定谓词所定义的条件相匹配的最后一个元素；否则为类型 <paramref name="T" /> 的默认值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到<xref:System.Array>, 并从最后一个元素开始向后移动, 并以第一个元素结束。  找到匹配项时将停止处理。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>和<xref:System.Array.FindAll%2A>泛型方法。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 泛型方法从开始处遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.Find%2A> 当`EndsWithSaurus`方法为元素 "Amargasaurus" `true`返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindLast%2A>泛型方法用于从末尾向后搜索数组。 它在位置5找到元素 "Dilophosaurus"。 <xref:System.Array.FindAll%2A>泛型方法用于返回数组, 该数组包含以 "saurus" 结尾的所有元素。 显示元素。  
  
 此代码示例还演示了<xref:System.Array.Exists%2A>和<xref:System.Array.TrueForAll%2A>泛型方法。  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>搜索与指定谓词定义的条件匹配的元素，然后返回 <see cref="T:System.Array" /> 或其某个部分中最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配元素的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向后搜索从最后一个元素开始, 到第一个元素结束。  
  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.FindLastIndex%2A>泛型方法的所有三个重载。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 方法重载从末尾开始向后遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 当`EndsWithSaurus`方法为位置5的元素`true`返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于从位置4开始搜索数组, 并向后移动到数组的开头。 它在位置1找到元素。 最后, <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>使用方法重载搜索从位置4开始的三个元素的范围并向后 (即元素4、3和 2)。 它将返回-1, 因为该范围中没有以 "saurus" 结尾的恐龙名称。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
或 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与由指定谓词定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向<xref:System.Array>后搜索`startIndex`从第一个元素开始和结束的位置。  
  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到。  
  
 此方法为 O`n`() 运算, 其中`n`是从开始`array`到`startIndex`的元素的数目。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.FindLastIndex%2A>泛型方法的所有三个重载。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 方法重载从末尾开始向后遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 当`EndsWithSaurus`方法为位置5的元素`true`返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于从位置4开始搜索数组, 并向后移动到数组的开头。 它在位置1找到元素。 最后, <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>使用方法重载搜索从位置4开始的三个元素的范围并向后 (即元素4、3和 2)。 它将返回-1, 因为该范围中没有以 "saurus" 结尾的恐龙名称。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="match"><see cref="T:System.Predicate`1" />，定义要搜索元素的条件。</param>
        <summary>搜索与指定谓词所定义的条件相匹配的元素，并返回 <see cref="T:System.Array" /> 中包含指定元素个数、到指定索引结束的元素范围内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到与 <paramref name="match" /> 定义的条件相匹配的最后一个元素，则为该元素的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `startIndex` `startIndex` `count`如果<xref:System.Array> 大于0,则搜索从开始,到从减号+1开始向后终止。`count`  
  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到。  
  
 此方法是 O (`n`) 运算, 其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.FindLastIndex%2A>泛型方法的所有三个重载。 创建一个字符串数组, 其中包含8个恐龙名称, 其中两个名称 (位置1和 5) 以 "saurus" 结尾。 此代码示例还定义了一个名为`EndsWithSaurus`的搜索谓词方法, 该方法接受一个字符串参数, 并返回一个布尔值, 指示输入字符串是否以 "saurus" 结尾。  
  
 方法重载从末尾开始向后遍历数组, 并将每个元素传递`EndsWithSaurus`给方法。 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> 当`EndsWithSaurus`方法为位置5的元素`true`返回时, 搜索将停止。  
  
> [!NOTE]
>  在C#和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>方法重载用于从位置4开始搜索数组, 并向后移动到数组的开头。 它在位置1找到元素。 最后, <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29>使用方法重载搜索从位置4开始的三个元素的范围并向后 (即元素4、3和 2)。 它将返回-1, 因为该范围中没有以 "saurus" 结尾的恐龙名称。  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
或 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">从零开始的一维 <see cref="T:System.Array" />，要对其元素执行操作。</param>
        <param name="action">要对 <paramref name="array" /> 的每个元素执行的 <see cref="T:System.Action`1" />。</param>
        <summary>对指定数组的每个元素执行指定操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Action%601>是对传递给它的对象执行操作的方法的委托。  的元素`array`分别传递<xref:System.Action%601>到。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Array.ForEach%2A>来显示整数数组中每个元素的平方。  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="action" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Collections.IEnumerator" /> 的 <see cref="T:System.Array" />。</summary>
        <returns><see cref="T:System.Collections.IEnumerator" /> 的一个 <see cref="T:System.Array" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 C#`for each`语句( C++在VisualBasic中)隐藏了枚举器的复杂性。`For Each` `foreach` 因此，建议使用 `foreach`，而不是直接操作枚举数。  
  
 枚举器可用于读取集合中的数据，但不能用于修改基础集合。  
  
 最初，枚举数定位在集合中第一个元素的前面。 <xref:System.Collections.IEnumerator.Reset%2A> 也会将枚举器放回此位置。  在此位置上，未定义 <xref:System.Collections.IEnumerator.Current%2A>。 因此，在读取 <xref:System.Collections.IEnumerator.MoveNext%2A> 的值之前，必须调用 <xref:System.Collections.IEnumerator.Current%2A> 将枚举器向前移动到集合的第一个元素。  
  
 在调用 <xref:System.Collections.IEnumerator.Current%2A> 或 <xref:System.Collections.IEnumerator.MoveNext%2A> 之前，<xref:System.Collections.IEnumerator.Reset%2A> 返回同一对象。 <xref:System.Collections.IEnumerator.MoveNext%2A> 将 <xref:System.Collections.IEnumerator.Current%2A> 设置为下一个元素。  
  
 如果<xref:System.Collections.IEnumerator.MoveNext%2A>越过集合的末尾, 则枚举器将定位在集合中最后一个元素之后, 并<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`。 当枚举器位于此位置时, 对<xref:System.Collections.IEnumerator.MoveNext%2A>的后续调用也将返回。 `false` 如果最后一次调用<xref:System.Collections.IEnumerator.MoveNext%2A>返回`false`, <xref:System.Collections.IEnumerator.Current%2A>则未定义。 若要再次将 <xref:System.Collections.IEnumerator.Current%2A> 设置为集合的第一个元素，可以调用 <xref:System.Collections.IEnumerator.Reset%2A> 并接着调用 <xref:System.Collections.IEnumerator.MoveNext%2A>。  
  
 只要集合保持不变，枚举数就保持有效。 如果对集合进行更改（如添加、修改或删除元素），则枚举数将失效且不可恢复，而且其行为是不确定的。  
  
 该枚举数不具有独占访问集合的权限；因此，枚举整个集合本质上不是一个线程安全的过程。  若要确保枚举过程中的线程安全性，可以在整个枚举过程中锁定集合。  若要允许多个线程访问集合以进行读写操作，则必须实现自己的同步。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.GetEnumerator%2A>来列出数组的元素。  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</param>
        <summary>获取一个 32 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</summary>
        <returns>一个 32 位整数，它表示指定维中的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的<xref:System.Array.GetLength%2A>一个示例是`GetLength(0)`, 它返回的第一个维度<xref:System.Array>中的元素数目。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Array.GetLength%2A>显示具有不同秩的两个数组的尺寸。  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
或 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="dimension"><see cref="T:System.Array" /> 的从零开始的维度，其长度需要确定。</param>
        <summary>获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的指定维中的元素数。</summary>
        <returns>一个 64 位整数，它表示指定维度中的元素数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的<xref:System.Array.GetLongLength%2A>一个示例是`GetLongLength(0)`, 它返回的第一个维度<xref:System.Array>中的元素数目。  
  
 此方法为 O (1) 操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
或 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">数组的从零开始的维度，其起始索引需要确定。</param>
        <summary>获取数组中指定维度第一个元素的索引。</summary>
        <returns>数组中指定维度第一个元素的索引。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)`返回数组的第一个维的起始索引, 并`GetLowerBound(Rank - 1)`返回数组的最后一个维的起始索引。  
  
 <xref:System.Array.GetLowerBound%2A>方法始终返回一个值, 该值指示数组下限的索引 (即使数组为空)。  
  
 请注意, 尽管 .NET Framework 中的大多数数组都是从零开始的 (也就是说, <xref:System.Array.GetLowerBound%2A>对于数组的每个维度, 该方法都返回零), 因此 .NET Framework 支持不是从零开始的数组。 此类数组可以用<xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29>方法创建, 也可以从非托管代码返回。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法来显示一维数组和二维数组的边界, 并显示其数组元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
或 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">数组的从零开始的维度，其上限需要确定。</param>
        <summary>获取数组中指定维度最后一个元素的索引。</summary>
        <returns>数组中指定维度最后一个元素的索引，或 -1（如果指定维度为空）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)`返回数组的第一个维中的最后一个索引, 并`GetUpperBound(Rank - 1)`返回数组最后一个维度的最后一个索引。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.GetLowerBound%2A>和<xref:System.Array.GetUpperBound%2A>方法来显示一维数组和二维数组的边界, 并显示其数组元素的值。  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> 小于零。  
  
或 
 <paramref name="dimension" /> 等于或大于 <see cref="P:System.Array.Rank" />。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Array" /> 中指定元素的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="index">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>获取一维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>一维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 和方法可以确定的值是否超出界限。 `index` <xref:System.Array.GetLowerBound%2A> <xref:System.Array.GetUpperBound%2A>  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">32 位整数的一维数组，它表示用于指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</param>
        <summary>获取多维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为一个 32 位整数数组。</summary>
        <returns>多维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中`indices`的元素数必须等于中的维数<xref:System.Array>。 `indices`数组中的所有元素都必须共同指定所需元素在多维<xref:System.Array>中的位置。  
  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>获取一维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>一维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 和方法可以确定的值是否超出界限。 `index` <xref:System.Array.GetLowerBound%2A> <xref:System.Array.GetUpperBound%2A>  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">一个 64 位整数的一维数组，它表示指定要获取的 <see cref="T:System.Array" /> 元素的位置的索引。</param>
        <summary>获取多维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为一个 64 位整数数组。</summary>
        <returns>多维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中`indices`的元素数必须等于中的维数<xref:System.Array>。 `indices`数组中的所有元素都必须共同指定所需元素在多维<xref:System.Array>中的位置。  
  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>获取二维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>二维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>获取二维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>二维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 32 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>获取三维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 32 位整数。</summary>
        <returns>三维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="index1">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 64 位整数，它表示要获取的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>获取三维 <see cref="T:System.Array" /> 中指定位置的值。 索引指定为 64 位整数。</summary>
        <returns>三维 <see cref="T:System.Array" /> 中指定位置的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 此方法为 O (1) 操作。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在一个一维数组或该数组的一系列元素中搜索指定对象，并返回其首个匹配项的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</summary>
        <returns>如果找到，则为 <paramref name="array" /> 中 <paramref name="value" /> 的第一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索一维数组`value`的所有元素。 若要确定`value`中`array`是否存在, 方法会通过调用每个元素的`Equals`方法来执行相等比较, 直到找到匹配项为止。 这意味着, 如果元素重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法, 则将调用该重写。  
  
 由于大多数数组的下限均为零, 因此如果`value`找不到, 则此方法通常返回-1。 如果数组的下限等于<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000), 并且`value`找不到, 则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7fffffff)。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 该示例调用<xref:System.Array.IndexOf%2A>方法的以下三种重载来查找字符串数组中字符串的索引:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, 用于确定字符串数组中字符串 "the" 的第一个匹配项。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, 用于确定第四个字符串中的第一个匹配项到字符串数组的最后一个元素。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, 用于确定字符串数组中字符串 "the" 的第一个匹配项, 该字符串是从最后一个成功匹配的元素到数组末尾的下一个元素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 范围从指定索引到该数组结尾。</summary>
        <returns>如果在从 <paramref name="startIndex" /> 到最后一个元素的 <paramref name="array" /> 中的元素范围中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索从索引`startIndex`处的元素到最后一个元素的一维数组。 若要确定`value`中`array`是否存在, 方法会通过调用每个元素的`Equals`方法来执行相等比较, 直到找到匹配项为止。 这意味着, 如果元素重写<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法, 则将调用该重写。  
  
 由于大多数数组的下限均为零, 因此如果`value`找不到, 则此方法通常返回-1。 如果数组的下限等于<xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000), 并且`value`找不到, 则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7fffffff)。  
  
 如果`startIndex` 等于<xref:System.Array.Length%2A?displayProperty=nameWithType>, 则此方法返回-1。 如果`startIndex` 大于<xref:System.ArgumentOutOfRangeException>, 则方法将引发。 <xref:System.Array.Length%2A?displayProperty=nameWithType>  
  
 此方法为 O`n`() 运算, 其中`n`是`array`从`startIndex`到末尾的元素数。  
  
   
  
## Examples  
 该示例调用<xref:System.Array.IndexOf%2A>方法的以下三种重载来查找字符串数组中字符串的索引:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, 用于确定字符串数组中字符串 "the" 的第一个匹配项。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, 用于确定第四个字符串中的第一个匹配项到字符串数组的最后一个元素。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, 用于确定字符串数组中字符串 "the" 的第一个匹配项, 该字符串是从最后一个成功匹配的元素到数组末尾的下一个元素。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <param name="count">要搜索的元素数。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围从指定数量的元素的指定索引开始。</summary>
        <returns>如果在从索引 <paramref name="startIndex" /> 到 <paramref name="startIndex" /> + <paramref name="count" /> - 1 的 <paramref name="array" /> 中找到了 <paramref name="value" /> 的第一个匹配项的索引，则为该索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`startIndex` `startIndex` `count`大于 0, 则此方法将从一维数组的元素搜索到减号1。 `count` 若要确定`value`中`array`是否存在, 方法会通过调用每个元素的`Equals`方法来执行相等比较, 直到找到匹配项为止。 这意味着, 如果元素重写<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法, 则将调用该重写。  
  
 由于大多数数组的下限均为零, 因此当找不到时`value` , 此方法通常返回-1。 如果数组的下限等于<xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000), 并且`value`找不到, 则此方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7fffffff)。  
  
 如果`startindex` 等于<xref:System.Array.Length%2A?displayProperty=nameWithType>, 则此方法返回-1。 如果`startIndex` 大于<xref:System.ArgumentOutOfRangeException>, 则方法将引发。 <xref:System.Array.Length%2A?displayProperty=nameWithType>  
  
 此方法是 O (`n`) 运算, 其中`n`是`count`。  
  
   
  
## Examples  
 该示例调用<xref:System.Array.IndexOf%2A>方法的以下三种重载来查找字符串数组中字符串的索引:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, 用于确定字符串数组中字符串 "the" 的第一个匹配项。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, 用于确定第四个字符串中的第一个匹配项到字符串数组的最后一个元素。  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, 用于确定字符串数组中字符串 "the" 的第一个匹配项, 该字符串是从最后一个成功匹配的元素到数组末尾的下一个元素。 若要确定`count`参数的值, 它将从起始索引中减去数组的上限并添加一个。  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>在一个一维数组中搜索指定对象，并返回其首个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索一维数组`value`的所有元素。 若要确定`value`中`array`是否存在, 方法通过对每个元素调用`T.Equals`方法来执行相等比较。 这意味着, 如果`T` <xref:System.Object.Equals%2A>重写方法, 则将调用该重写。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Array.IndexOf%2A>方法的所有三个泛型重载。 创建一个字符串数组, 其中有一个条目出现在索引位置0和索引位置5。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始处搜索数组, 并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于从索引位置3开始搜索数组, 并继续到数组末尾, 并查找字符串的第二个匹配项。 最后, <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>使用方法重载搜索两个条目的范围 (从第二个索引位置开始); 它返回-1, 因为该范围中没有搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 范围从指定索引到该数组结尾。</summary>
        <returns>如果在 <paramref name="value" /> 中从 <paramref name="array" /> 到最后一个元素这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为第一个匹配项的从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法搜索从到数组末尾处`startIndex`的元素的一维数组。 若要确定`value`中`array`是否存在, 方法通过对每个元素调用`T.Equals`方法来执行相等比较。 这意味着, 如果`T` <xref:System.Object.Equals%2A>重写方法, 则将调用该重写。  
  
 如果`startIndex` `startIndex`等于<xref:System.Array.Length%2A>, 则此方法返回-1 <xref:System.Array.Length%2A?displayProperty=nameWithType>。如果大于, 则该方法将引发<xref:System.ArgumentOutOfRangeException>。  
  
 此方法为 O`n`() 运算, 其中`n`是`array`从`startIndex`到末尾的元素数。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Array.IndexOf%2A>方法的所有三个泛型重载。 创建一个字符串数组, 其中有一个条目出现在索引位置0和索引位置5。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始处搜索数组, 并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于从索引位置3开始搜索数组, 并继续到数组末尾, 并查找字符串的第二个匹配项。 最后, <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>使用方法重载搜索两个条目的范围 (从第二个索引位置开始); 它返回-1, 因为该范围中没有搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维数组。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">从零开始的搜索的起始索引。 空数组中 0（零）为有效值。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>在一个一维数组的一系列元素中搜索指定对象，然后返回其首个匹配项的索引。 该元素系列的范围从指定数量的元素的指定索引开始。</summary>
        <returns>如果在从 <paramref name="count" /> 开始并且包含 <paramref name="startIndex" /> 中指定元素数量的 <paramref name="array" /> 元素范围中找到了 <paramref name="value" /> 第一个匹配项从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`startIndex` `startIndex` `count`大于 0, 则此方法将从一维数组的元素搜索到减号1。 `count` 若要确定`value`中`array`是否存在, 方法通过对每个元素调用`T.Equals`方法来执行相等比较。 这意味着, 如果`T` <xref:System.Object.Equals%2A>重写方法, 则将调用该重写。  
  
 如果`startIndex` 等于<xref:System.Array.Length%2A?displayProperty=nameWithType>, 则此方法返回-1。  如果`startIndex` 大于<xref:System.ArgumentOutOfRangeException>, 则方法将引发。 <xref:System.Array.Length%2A?displayProperty=nameWithType>  
  
 此方法是 O (`n`) 运算, 其中`n`是`count`。  
  
   
  
## Examples  
 下面的示例演示<xref:System.Array.IndexOf%2A>方法的所有三个泛型重载。 创建一个字符串数组, 其中有一个条目出现在索引位置0和索引位置5。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从开始处搜索数组, 并查找字符串的第一个匹配项。 <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于从索引位置3开始搜索数组, 并继续到数组末尾, 并查找字符串的第二个匹配项。 最后, <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>使用方法重载搜索两个条目的范围 (从第二个索引位置开始); 它返回-1, 因为该范围中没有搜索字符串的实例。  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
- 或 - 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通过调用值类型的无参数构造函数，初始化值类型 <see cref="T:System.Array" /> 的每一个元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法旨在帮助编译器支持值类型数组;大多数用户不需要此方法。 不能对引用类型数组使用。  
  
 如果不是值类型<xref:System.Array>或值类型没有无参数构造函数, <xref:System.Array>则不会修改。 <xref:System.Array>  
  
 值类型<xref:System.Array>可以有任何下限和任意数量的维度。  
  
 此方法是 O (`n`) 运算, 其中`n`是<xref:System.Array.Length%2A>。  
  
> [!CAUTION]
>  只能对具有构造函数的值类型使用此方法;但不具有构造函数的本机C#值类型。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</summary>
        <value>此属性对于所有数组总是 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>实现属性, 因为它是<xref:System.Collections.IList?displayProperty=nameWithType>接口所必需的。 <xref:System.Array.IsFixedSize%2A>  
  
 在创建数组后, 具有固定大小的数组不允许添加或删除元素, 但允许修改现有元素。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</summary>
        <value>此属性对于所有数组总是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>实现属性, 因为它是<xref:System.Collections.IList?displayProperty=nameWithType>接口所必需的。 <xref:System.Array.IsReadOnly%2A> 如果数组为只读, 则在创建数组后, 不允许添加、移除或修改元素。  
  
 如果需要只读集合, 请使用<xref:System.Collections> <xref:System.Collections.IList?displayProperty=nameWithType>实现接口的类。  
  
 如果将数组强制转换或转换为<xref:System.Collections.IList>接口对象, 则该<xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType>属性返回。 `false` 但是, 如果将数组强制转换或转换为<xref:System.Collections.Generic.IList%601>接口, 该属性将`IsReadOnly`返回`true`。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否同步对 <see cref="T:System.Array" /> 的访问（线程安全）。</summary>
        <value>此属性对于所有数组总是 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>实现属性, 因为它是<xref:System.Collections.ICollection?displayProperty=nameWithType>接口所必需的。 <xref:System.Array.IsSynchronized%2A>  
  
 基于<xref:System.Array>的 .NET Framework 类<xref:System.Array.SyncRoot%2A>使用属性提供自己的集合的同步版本。  
  
 使用数组的类也可以使用<xref:System.Array.SyncRoot%2A>属性来实现自己的同步。 同步代码必须对集合的 (而`SyncRoot`不是直接在集合上) 执行操作。 这样可确保对从其他对象派生的集合正确地执行操作。 具体而言, 它与可能同时修改集合的其他线程保持正确的同步。 请注意, 的<xref:System.Array.SyncRoot%2A>某些实现可能会<xref:System.Array>返回自身。  
  
 枚举集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.SyncRoot%2A>属性在整个枚举过程中锁定数组。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中某个值的最后一个匹配项的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>搜索指定的对象，并返回整个一维 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="value" /> 中找到 <paramref name="array" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从最后一个元素<xref:System.Array>开始向后搜索一维, 并在第一个元素处结束。  
  
 使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法将元素与指定的值进行比较。 如果元素类型为 nonintrinsic (用户定义) 类型, `Equals`则使用该类型的实现。  
  
 由于大多数数组的下限均为零, 因此当找不到时`value` , 此方法将返回-1。 在极少数情况下, 数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>等于并且`value`找不到, 此`System.Int32.MinValue - 1`方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 在 .NET Framework 版本2.0 中<xref:System.Object.Equals%2A> , 此方法使用的和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>来确定`value`参数指定的<xref:System.Object>是否存在。 在 .NET Framework 的早期版本中, 此决定<xref:System.Object.Equals%2A>是通过使用的和<xref:System.IComparable.CompareTo%2A>方法`value` <xref:System.Object>来进行的。  
  
 <xref:System.IComparable.CompareTo%2A>集合中的对象的参数方法。`item`  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定元素在数组中的最后一个匹配项的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的起始索引。</param>
        <summary>搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中从第一个元素到 <paramref name="array" /> 这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从第一个元素<xref:System.Array>开始向后搜索一维。`startIndex`  
  
 使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法将元素与指定的值进行比较。 如果元素类型为 nonintrinsic (用户定义) 类型, `Equals`则使用该类型的实现。  
  
 由于大多数数组的下限均为零, 因此当找不到时`value` , 此方法将返回-1。 在极少数情况下, 数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>等于并且`value`找不到, 此`System.Int32.MinValue - 1`方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 此方法为 O`n`() 运算, 其中`n`是从开始`array`到`startIndex`的元素的数目。  
  
 在 .NET Framework 版本2.0 中<xref:System.Object.Equals%2A> , 此方法使用的和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>来确定`value`参数指定的<xref:System.Object>是否存在。 在 .NET Framework 的早期版本中, 此决定<xref:System.Object.Equals%2A>是通过使用的和<xref:System.IComparable.CompareTo%2A>方法`value` <xref:System.Object>来进行的。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定元素在数组中的最后一个匹配项的索引。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要搜索的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的对象，并返回一维 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中到 <paramref name="array" /> 为止并且包含的元素个数为在 <paramref name="count" /> 中指定的个数的这部分元素中找到 <paramref name="startIndex" /> 的匹配项，则为最后一个匹配项的索引；否则为该数组的下限减 1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>如果`count` `startIndex` `startIndex`大于 0, 则从零开始向后搜索一维, 并在减号加1处结束。 `count`  
  
 使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法将元素与指定的值进行比较。 如果元素类型为 nonintrinsic (用户定义) 类型,`Equals`则使用该类型的实现。  
  
 由于大多数数组的下限均为零, 因此当找不到时`value` , 此方法将返回-1。 在极少数情况下, 数组的下限<xref:System.Int32.MinValue?displayProperty=nameWithType>等于并且`value`找不到, 此`System.Int32.MinValue - 1`方法返回<xref:System.Int32.MaxValue?displayProperty=nameWithType>。  
  
 此方法是 O (`n`) 运算, 其中`n`是`count`。  
  
 在 .NET Framework 版本2.0 中<xref:System.Object.Equals%2A> , 此方法使用的和<xref:System.IComparable.CompareTo%2A>方法<xref:System.Array>来确定`value`参数指定的<xref:System.Object>是否存在。 在 .NET Framework 的早期版本中, 此决定<xref:System.Object.Equals%2A>是通过使用的和<xref:System.IComparable.CompareTo%2A>方法`value` <xref:System.Object>来进行的。  
  
   
  
## Examples  
 下面的代码示例演示如何确定指定元素在数组中的最后一个匹配项的索引。 请注意, `count` `startIndex`方法是向后搜索; 因此, 必须小于或等于 (减去数组的下限加<xref:System.Array.LastIndexOf%2A> 1)。  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
或 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <summary>搜索指定的对象，并返回整个 <see cref="T:System.Array" /> 中最后一个匹配项的索引。</summary>
        <returns>如果在整个 <paramref name="array" /> 中找到 <paramref name="value" /> 的最后一个匹配项从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>向后搜索从最后一个元素开始, 到第一个元素结束。  
  
 使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法将元素与指定的值进行比较。 如果元素类型为 nonintrinsic (用户定义) 类型, `Equals`则使用该类型的实现。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.LastIndexOf%2A>方法的所有三个泛型重载。 创建一个字符串数组, 其中有一个条目出现在索引位置0和索引位置5。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从末尾搜索整个数组, 并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于从索引位置3开始向后搜索数组, 并继续到数组的开头, 并查找字符串的第一个匹配项。 最后, <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索由四个条目组成的范围, 从索引位置4开始并向后扩展 (也就是说, 它会搜索位于4、3、2和1位置的项); 此搜索将返回-1, 因为没有搜索实例此范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的对象，并返回 <see cref="T:System.Array" /> 中从第一个元素到指定索引这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="array" /> 中从第一个元素到 <paramref name="startIndex" /> 的元素范围中找到了该 <paramref name="value" /> 最后一个匹配项从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向<xref:System.Array>后搜索`startIndex`从第一个元素开始和结束的位置。  
  
 使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法将元素与指定的值进行比较。 如果元素类型为 nonintrinsic (用户定义) 类型, `Equals`则使用该类型的实现。  
  
 此方法为 O`n`() 运算, 其中`n`是从开始`array`到`startIndex`的元素的数目。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.LastIndexOf%2A>方法的所有三个泛型重载。 创建一个字符串数组, 其中有一个条目出现在索引位置0和索引位置5。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从末尾搜索整个数组, 并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于从索引位置3开始向后搜索数组, 并继续到数组的开头, 并查找字符串的第一个匹配项。 最后, <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索由四个条目组成的范围, 从索引位置4开始并向后扩展 (也就是说, 它会搜索位于4、3、2和1位置的项); 此搜索将返回-1, 因为没有搜索实例此范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要搜索的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="value">要在 <paramref name="array" /> 中查找的对象。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的对象，并返回 <see cref="T:System.Array" /> 中到指定索引为止包含指定个元素的这部分元素中最后一个匹配项的索引。</summary>
        <returns>如果在 <paramref name="startIndex" /> 中找到了包含 <paramref name="count" /> 中指定元素数并且到 <paramref name="array" /> 结尾的元素范围内的 <paramref name="value" /> 的最后一个匹配项的从零开始的索引，则为该索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `startIndex` `startIndex` `count`如果<xref:System.Array> 大于0,则搜索从开始,到从减号+1开始向后终止。`count`  
  
 使用<xref:System.Object.Equals%2A?displayProperty=nameWithType>方法将元素与指定的值进行比较。 如果元素类型为 nonintrinsic (用户定义) 类型, `Equals`则使用该类型的实现。  
  
 此方法是 O (`n`) 运算, 其中`n`是`count`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.LastIndexOf%2A>方法的所有三个泛型重载。 创建一个字符串数组, 其中有一个条目出现在索引位置0和索引位置5。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29>方法重载从末尾搜索整个数组, 并查找字符串的第二个匹配项。 <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29>方法重载用于从索引位置3开始向后搜索数组, 并继续到数组的开头, 并查找字符串的第一个匹配项。 最后, <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29>方法重载用于搜索由四个条目组成的范围, 从索引位置4开始并向后扩展 (也就是说, 它会搜索位于4、3、2和1位置的项); 此搜索将返回-1, 因为没有搜索实例此范围内的字符串。  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="array" /> 的有效索引范围。  
  
或 
 <paramref name="count" /> 小于零。  
  
- 或 - 
 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="array" /> 中指定有效部分。</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 的所有维度中的元素总数。</summary>
        <value><see cref="T:System.Array" /> 的所有维度中的元素总数；如果数组中无元素，则为零。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Array.Length%2A>属性来获取数组中的元素总数。 它还使用<xref:System.Array.GetUpperBound%2A>方法来确定多维数组的每个维度中的元素数。  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">数组是多维的，并且包括多于 <see cref="F:System.Int32.MaxValue" /> 个元素。</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个 64 位整数，该整数表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</summary>
        <value>一个 64 位整数，表示 <see cref="T:System.Array" /> 的所有维数中元素的总数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 检索此属性的值的运算复杂度为 O(1)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 的秩（维数）。 例如，一维数组返回 1，二维数组返回 2，依次类推。</summary>
        <value>该 <see cref="T:System.Array" /> 的秩（维数）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如, Visual Basic 代码  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 和C#代码  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 创建三个维度的数组, <xref:System.Array.Rank%2A>其属性的值为3。  
  
 交错数组 (数组的数组) 为一维数组;其<xref:System.Array.Rank%2A>属性的值为1。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的示例初始化一维数组、二维数组和交错数组, 并检索<xref:System.Array.Rank%2A>每个数组的属性。  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="newSize" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要调整大小的一维数组，该数组从零开始；如果为 <see langword="null" />，则新建具有指定大小的数组。</param>
        <param name="newSize">新数组的大小。</param>
        <summary>将一维数组的元素数更改为指定的新大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法分配一个具有指定大小的新数组, 将元素从旧数组复制到新数组, 然后将旧数组替换为新数组。 `array`必须为一维数组。  
  
 如果`array` 为`null`, 则此方法将创建一个具有指定大小的新数组。  
  
 如果`newSize` 大于<xref:System.Array.Length%2A>旧数组的, 则分配一个新数组, 并将所有元素从旧数组复制到新数组。  如果`newSize` 小于<xref:System.Array.Length%2A>旧数组的, 则分配一个新数组, 并将元素从旧数组复制到新数组, 直到填充新数组; 旧数组中的其余元素将被忽略。  如果`newSize`等于旧数组的<xref:System.Array.Length%2A> , 则此方法不执行任何操作。  
  
 此方法是 O (`n`) 运算, 其中`n`是`newSize`。  
  
 <xref:System.Array.Resize%2A>方法只调整一维数组的大小。 <xref:System.Array>类不包含用于调整多维数组大小的方法。 为此, 你必须提供自己的代码或在第三方库中调用专用方法。 下面的代码演示了一种可能的实现, 该方法用于调整*n*维数组的大小。  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 下面的示例演示调整大小如何影响数组。  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> 小于零。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>反转一维 <see cref="T:System.Array" /> 或部分 <see cref="T:System.Array" /> 中元素的顺序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要反转的一维 <see cref="T:System.Array" />。</param>
        <summary>反转整个一维 <see cref="T:System.Array" /> 中元素的顺序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用此方法之后`myArray[i]`, 中的元素 (其中`i`是数组中的任何索引) 移动到`myArray[j]`, where `j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
 如下面的示例所示, <xref:System.Array.Reverse%2A>可以使用方法反转交错数组。 它将使用当前区域性的日历中当前年份的每个月的一个元素来初始化交错数组。 每个元素都包含一个数组, 该数组包含的元素数量与该月份的天数相同。 该示例显示数组的内容, 调用<xref:System.Array.Reverse%2A>方法, 然后显示反向数组的内容。  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 下面的代码示例演示如何对中<xref:System.Array>的值进行反向排序。  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要反转的一维 <see cref="T:System.Array" />。</param>
        <param name="index">要反转的部分的起始索引。</param>
        <param name="length">要反转的部分中的元素数。</param>
        <summary>反转一维 <see cref="T:System.Array" /> 中某部分元素的元素顺序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用此方法之后`myArray[i]`, 中的元素 (其中`i`是数组中的任何索引) 移动到`myArray[j]`, where `j`等于`(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`。  
  
 <xref:System.Array.Reverse%2A>方法可用于反转交错数组。  
  
 此方法是 O (`n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对中<xref:System.Array>某个范围内的元素进行反向排序。  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将当前 <see cref="T:System.Array" /> 中的指定元素设置为指定值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>将某值设置给一维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 和方法可以确定的值是否超出界限。 `index` <xref:System.Array.GetLowerBound%2A> <xref:System.Array.GetUpperBound%2A>  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" />的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="indices">32 位整数的一维数组，它表示用于指定要设置的元素的位置的索引。</param>
        <summary>将某值设置给多维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为一个 32 位整数数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中`indices`的元素数必须等于中的维数<xref:System.Array>。 `indices`数组中的所有元素都必须共同指定所需元素在多维<xref:System.Array>中的位置。  
  
 和方法可以确定`indices`数组中是否有任何值超出界限。 <xref:System.Array.GetUpperBound%2A> <xref:System.Array.GetLowerBound%2A>  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的位置。</param>
        <summary>将某值设置给一维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 和方法可以确定的值是否超出界限。 `index` <xref:System.Array.GetLowerBound%2A> <xref:System.Array.GetUpperBound%2A>  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能转换为当前 <see cref="T:System.Array" />的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 超出当前 <see cref="T:System.Array" /> 的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="indices" Type="System.Int64[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="indices">64 位整数的一维数组，它表示用于指定要设置元素的位置索引。</param>
        <summary>将某值设置给多维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为一个 64 位整数数组。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中`indices`的元素数必须等于中的维数<xref:System.Array>。 `indices`数组中的所有元素都必须共同指定所需元素在多维<xref:System.Array>中的位置。  
  
 和方法可以确定`indices`数组中是否有任何值超出界限。 <xref:System.Array.GetUpperBound%2A> <xref:System.Array.GetLowerBound%2A>  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">当前 <see cref="T:System.Array" /> 中的维数不等于 <paramref name="indices" /> 中的元素数。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indices" /> 中的任何元素都超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <summary>将某值设置给二维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有两维。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 32 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>将某值设置给三维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 32 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index1" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index2" Type="System.Int64" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="index3" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">指定元素的新值。</param>
        <param name="index1">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第一维索引。</param>
        <param name="index2">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第二维索引。</param>
        <param name="index3">一个 64 位整数，它表示要设置的 <see cref="T:System.Array" /> 元素的第三维索引。</param>
        <summary>将某值设置给三维 <see cref="T:System.Array" /> 中指定位置的元素。 索引指定为 64 位整数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array.GetLowerBound%2A> 和<xref:System.Array.GetUpperBound%2A>方法可以确定任何索引是否超出界限。  
  
 有关转换的详细信息, 请<xref:System.Convert>参阅。  
  
 此方法为 O (1) 操作。  
  
> [!NOTE]
>  如果<xref:System.Array.SetValue%2A>用于分配`null`到值类型数组的元素, 则该元素的所有字段都初始化为零。 元素的值不是空引用, 并且无法通过搜索空引用来找到。  
  
   
  
## Examples  
 下面的代码示例演示如何在一维或多维数组中设置和获取特定值。  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有三维。</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> 不能强制转换为当前 <see cref="T:System.Array" /> 的元素类型。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> 或 <paramref name="index2" /> 或 <paramref name="index3" /> 超出当前 <see cref="T:System.Array" /> 的对应维度的有效索引的范围。</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>对一维数组中的元素进行排序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对整个一维 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的`array`每个元素都必须<xref:System.IComparable>实现接口, 以便与中`array`的其他每个元素进行比较。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`array`。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Array>使用默认比较器和反向排序顺序的自定义比较器对中的值进行排序。 请注意, 结果可能会根据当前<xref:System.Globalization.CultureInfo>情况而有所不同。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
或 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 实现，对两个一维 <see cref="T:System.IComparable" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 中的`keys` <xref:System.Array>每个键都必须<xref:System.IComparable>实现接口, 才能与其他每个键进行比较。  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`keys`。  
  
   
  
## Examples  
 下面的示例演示如何对两个关联的数组 (其中第一个数组包含键, 第二个数组包含值) 进行排序。 排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。 请注意, 结果可能会根据当前<xref:System.Globalization.CultureInfo>情况而有所不同。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
或 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维数组。</param>
        <param name="comparer">比较元素时要使用的实现。  
  
或 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，对一维 <see cref="T:System.Collections.IComparer" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer` `array`为`null`, 则的每个<xref:System.IComparable>元素都必须实现接口, 以便与中`array`的其他每个元素进行比较。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`array`。  
  
 .NET Framework 包括下表<xref:System.Collections.IComparer>中列出的预定义的实现。  
  
|实现|说明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较两个对象, 但执行字符串的不区分大小写的比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定来比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定来比较两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|使用类型的默认排序`T`顺序比较类型的两个对象。|  
  
 您还可以通过<xref:System.Collections.IComparer> `comparer`向参数提供您自己的实现的实例, 支持自定义比较。 该示例通过定义一个`ReverseComparer`类来为类型的实例反转默认排序顺序并执行不区分大小写的字符串比较, 来实现此目的。  
  
   
  
## Examples  
 下面的示例使用默认比较器对字符串数组中的值进行排序。 它还定义了一个<xref:System.Collections.IComparer>名为`ReverseComparer`的自定义实现, 它在执行不区分大小写的字符串比较时反转对象的默认排序顺序。 请注意, 输出可能因当前区域性而异。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
或 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
或 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" />，对两个一维 <see cref="T:System.Collections.IComparer" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 如果`comparer` `keys`为`null`, 则中的<xref:System.Array>每个键都必须实现接口,才能与其他每个<xref:System.IComparable>键进行比较。  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 .NET Framework 包括下表<xref:System.Collections.IComparer>中列出的预定义的实现。  
  
|实现|说明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较两个对象, 但执行字符串的不区分大小写的比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定来比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定来比较两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|使用类型的默认排序`T`顺序比较类型的两个对象。|  
  
 您还可以通过<xref:System.Collections.IComparer> `comparer`向参数提供您自己的实现的实例, 支持自定义比较。 该示例通过定义一个<xref:System.Collections.IComparer>实现来反转默认排序顺序并执行不区分大小写的字符串比较, 来实现此目的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`keys`。  
  
   
  
## Examples  
 下面的示例演示如何对两个关联的数组 (其中第一个数组包含键, 第二个数组包含值) 进行排序。 排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。 请注意, 结果可能会根据当前<xref:System.Globalization.CultureInfo>情况而有所不同。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
或 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
或 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>使用 <see cref="T:System.Array" /> 中每个元素的 <see cref="T:System.IComparable" /> 实现，对一维 <see cref="T:System.Array" /> 中某部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中`array`指定范围内的元素中的每个元素都<xref:System.IComparable>必须实现接口, 以便能够与中`array`的其他每个元素进行比较。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Array>使用默认比较器和反向排序顺序的自定义比较器对中的值进行排序。 请注意, 结果可能会根据当前<xref:System.Globalization.CultureInfo>情况而有所不同。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
或 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 实现，对两个一维 <see cref="T:System.IComparable" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 中`keys` 指定范围<xref:System.IComparable>内的元素中的每个键都必须实现接口,以便能够与其他每个键进行比较。<xref:System.Array>  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对两个关联的数组进行排序, 其中第一个数组包含键, 第二个数组包含值。 排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。 请注意, 结果可能会根据当前<xref:System.Globalization.CultureInfo>情况而有所不同。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
- 或 - 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的长度大于 <paramref name="items" />的长度。  
  
或 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
或 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">要排序的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
- 或 - 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" />，对一维 <see cref="T:System.Collections.IComparer" /> 的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer`为`null`, 中<xref:System.IComparable> `array`指定范围内的元素中的每个元素都必须实现接口, 以便与中的每个其他元素进行比较。 `array`  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 .NET Framework 包括下表<xref:System.Collections.IComparer>中列出的预定义的实现。  
  
|实现|说明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较两个对象, 但执行字符串的不区分大小写的比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定来比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定来比较两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|使用类型的默认排序`T`顺序比较类型的两个对象。|  
  
 您还可以通过<xref:System.Collections.IComparer> `comparer`向参数提供您自己的实现的实例, 支持自定义比较。 该示例通过定义一个`ReverseComparer`类来为类型的实例反转默认排序顺序并执行不区分大小写的字符串比较, 来实现此目的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Array>使用默认比较器和反向排序顺序的自定义比较器对中的值进行排序。 请注意, 结果可能会根据当前<xref:System.Globalization.CultureInfo>情况而有所不同。  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
- 或 - 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，<paramref name="array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="System.Array" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="keys">一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /><see cref="T:System.Array" /> 中每个关键字对应的项。  
  
或 
 如果为 <see langword="null" />，则只对 <paramref name="keys" /><see cref="T:System.Array" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时要使用的 <see cref="T:System.Collections.IComparer" /> 实现。  
  
或 
 若为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable" /> 实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" />，对两个一维 <see cref="T:System.Collections.IComparer" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 如果`comparer`为`null`, 则`keys` 中指定范围内的元素中的每个键都必须实现接口,才能与其他每个键进行比较。<xref:System.Array> <xref:System.IComparable>  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 .NET Framework 包括下表<xref:System.Collections.IComparer>中列出的预定义的实现。  
  
|实现|说明|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|比较两个对象, 但执行字符串的不区分大小写的比较。|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|使用当前区域性的排序约定来比较任意两个对象。|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|使用固定区域性的排序约定来比较两个对象。|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|使用类型的默认排序`T`顺序比较类型的两个对象。|  
  
 您还可以通过<xref:System.Collections.IComparer> `comparer`向参数提供您自己的实现的实例, 支持自定义比较。 该示例通过定义反向默认排序顺序<xref:System.Collections.IComparer>并执行不区分大小写的字符串比较的自定义实现来实现此目的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示如何对两个关联的数组进行排序, 其中第一个数组包含键, 第二个数组包含值。 排序是使用默认比较器和反向排序顺序的自定义比较器来完成的。 请注意, 结果可能会根据当前<xref:System.Globalization.CultureInfo>情况而有所不同。  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.RankException"><paramref name="keys" /><see cref="T:System.Array" /> 是多维的。  
  
- 或 - 
<paramref name="items" /><see cref="T:System.Array" /> 是多维的。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
- 或 - 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
- 或 - 
 <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
或 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。  
  
或 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable" /> 接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对整个 <see cref="T:System.Array" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的`array`每个元素都必须<xref:System.IComparable%601>实现泛型接口, 以便与中`array`的其他每个元素进行比较。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%29>泛型方法重载<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29>和泛型方法重载。 创建一个字符串数组, 无特定顺序。  
  
 显示、排序并再次显示数组。  
  
> [!NOTE]
>  对<xref:System.Array.Sort%2A>和泛型方法的<xref:System.Array.BinarySearch%2A>调用与对其非泛型方法的调用没有任何区别, 因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型. 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 然后, 使用泛型方法重载搜索两个字符串, 一个字符串不在数组中, 另一个是。 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> 此<xref:System.Array.BinarySearch%2A>方法的数组和返回值将传递`ShowWhere`给泛型方法, 该方法显示索引值 (如果找到该字符串), 否则为搜索字符串在数组中所处的元素。 如果字符串不是 n 数组, 则该索引为负, 因此该`ShowWhere`方法采用按位求补 ( C#和中的 ~ 运算符C++, `Xor` Visual Basic 中为-1) 以获取列表中大于的第一个元素的索引。搜索字符串。  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" /></param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型接口，对 <see cref="T:System.Collections.Generic.IComparer`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer` `array`为`null`, 则的每个<xref:System.IComparable%601>元素都必须实现泛型接口, 以便与中`array`的其他每个元素进行比较。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和泛型方法重载。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>` ( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 显示、排序并再次显示数组。 若要使用<xref:System.Array.BinarySearch%2A>方法, 必须对数组进行排序。  
  
> [!NOTE]
>  对<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和泛型方法的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>调用与对其非泛型方法的调用没有任何区别, 因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型. 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 然后, 使用泛型方法重载搜索两个字符串, 一个字符串不在数组中, 另一个是。 <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 此<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>方法的数组和返回值将传递`ShowWhere`给泛型方法, 该方法显示索引值 (如果找到该字符串), 否则为搜索字符串在数组中所处的元素。 如果字符串不是 n 数组, 则该索引为负, 因此该`ShowWhere`方法采用按位求补 ( C#和中的 ~ 运算符C++, `Xor` Visual Basic 中为-1) 以获取列表中大于的第一个元素的索引。搜索字符串。  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="comparison">比较元素时要使用的 <see cref="T:System.Comparison`1" />。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 对 <see cref="T:System.Comparison`1" /> 中的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`array`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29>方法重载。  
  
 此代码示例定义了一个名为`CompareDinosByLength`的字符串的替代比较方法。 此方法的工作方式如下:首先, 对这些比较的值`null`进行测试, 并将空引用视为小于非空引用。 其次, 比较字符串长度, 较长的字符串被认为更大。 第三, 如果长度相等, 则使用普通字符串比较。  
  
 创建一个字符串数组, 并以无特定顺序填充四个字符串。 此列表还包括一个空字符串和一个空引用。 显示列表, 使用<xref:System.Comparison%601> `CompareDinosByLength`表示方法的泛型委托进行排序, 并再次显示。  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
或 
 <paramref name="comparison" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparison" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparison" /> 可能不返回 0。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>使用 <see cref="T:System.Array" /> 的每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现，对 <see cref="T:System.Array" /> 中某个元素范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中`array`指定范围内的元素中的每个元素都<xref:System.IComparable%601>必须实现泛型接口, 以便能够与中`array`的每个其他元素进行比较。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> , 以及用于对数组中的范围进行排序的泛型方法重载。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>` ( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 此代码示例创建并显示一个恐龙名称数组, 其中包含三个 herbivores, 后跟三个 carnivores (tyrannosaurids)。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载用于对数组中最后三个元素进行排序, 然后将显示该元素。 泛型方法重载`ReverseCompare`用于将最后三个元素按相反的顺序进行排序。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 将再次显示完全混淆的恐龙。  
  
> [!NOTE]
>  对<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和泛型方法的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>调用与对其非泛型方法的调用没有任何区别, 因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型. 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要排序的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>使用指定的 <see cref="T:System.Array" /> 泛型接口，对 <see cref="T:System.Collections.Generic.IComparer`1" /> 中某个元素范围内的元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`comparer` `array`为`null`, 则中指定范围内的<xref:System.IComparable%601>元素中的每个元素都必须实现泛型接口, 以便能够与中`array`的每个其他元素进行比较。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> , 以及用于对数组中的范围进行排序的泛型方法重载。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>` ( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 此代码示例创建并显示一个恐龙名称数组, 其中包含三个 herbivores, 后跟三个 carnivores (tyrannosaurids)。 <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29>泛型方法重载用于对数组中最后三个元素进行排序, 然后将显示该元素。 泛型方法重载`ReverseCompare`用于将最后三个元素按相反的顺序进行排序。 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> 将再次显示完全混淆的恐龙。  
  
> [!NOTE]
>  对<xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>和泛型方法的<xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>调用与对其非泛型方法的调用没有任何区别, 因为 Visual Basic、 C#和C++从第一个参数的类型推断泛型类型参数的类型. 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="array" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="array" /> 中指定有效范围。  
  
或 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，并且 <paramref name="array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 泛型接口实现，对两个 <see cref="T:System.IComparable`1" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 中的`keys` <xref:System.Array>每个键都必须<xref:System.IComparable%601>实现泛型接口, 才能与其他每个键进行比较。  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`array`。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载, 用于对表示键和值的数组对进行排序。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>` ( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 此代码示例创建并显示一个恐龙名称数组 (密钥) 和一个整数数组, 表示每个恐龙的最大长度 (值)。 然后, 将数组排序并显示多次:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载和`ReverseCompare`实例用于反转成对数组的排序顺序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>重载用于对这两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反的顺序对这两个数组中的最后三个元素进行排序。  
  
> [!NOTE]
>  对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处, 因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" />的下限不匹配。  
  
或 
 <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" /> 泛型接口，对两个 <see cref="T:System.Collections.Generic.IComparer`1" /> 对象（一个包含关键字，另一个包含对应的项）进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 如果`comparer` `keys`为`null`, 则中的<xref:System.Array>每个键都必须实现泛型接口,才能与其他每个<xref:System.IComparable%601>键进行比较。  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O (`n` log `n`) <xref:System.Array.Length%2A>运算, 其中`n`是的`array`。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<x: system.object% 60% 602% 28% 60% 600% 5b% 5d% 2c% 60% 601% 5b% 5d% 2csystem.string, IComparer% 7b% 60% 600% 7d% 29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>,和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载, 用于对表示键和值的数组对进行排序。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>` ( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 此代码示例创建并显示一个恐龙名称数组 (密钥) 和一个整数数组, 表示每个恐龙的最大长度 (值)。 然后, 将数组排序并显示多次:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。  
  
-   [\], TValue x\<:% 60% 602% 28% 60% 600% 5b% 5d% 2c% 60% 601% 5b% 5d% 2csystem.string, IComparer% 7b% 60% 600% 7d% 29 > `ReverseCompare`重载, 实例用于反转排序顺序成对数组的。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>重载用于对这两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反的顺序对这两个数组中的最后三个元素进行排序。  
  
> [!NOTE]
>  对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处, 因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" />的下限不匹配。  
  
或 
 <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
或 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用每个关键字的 <see cref="T:System.Array" /> 泛型接口实现，对两个 <see cref="T:System.IComparable`1" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 中`keys` 指定范围<xref:System.IComparable%601>内的元素中的每个键都必须实现泛型接口,才能与其他每个键进行比较。<xref:System.Array>  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、[\]、TValue\<x: system.object% 60% 602% 28% 60% 600% 5b% 5d% 2c% 60% 601% 5b% 5d% 2csystem.string% 2csystem.string% 29 > 和<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>泛型方法重载, 用于对表示键和值的数组对进行排序。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>` ( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 此代码示例创建并显示一个恐龙名称数组 (密钥) 和一个整数数组, 表示每个恐龙的最大长度 (值)。 然后, 将数组排序并显示多次:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载和`ReverseCompare`实例用于反转成对数组的排序顺序。  
  
-   [\], TValue\<x: 2csystem.string% 60% 602% 28% 60% 600% 5b% 5d% 2c% 60% 601% 5b% 5d% 2csystem.string%% 29 > 重载用于对这两个数组的最后三个元素进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载用于按相反的顺序对这两个数组中的最后三个元素进行排序。  
  
> [!NOTE]
>  对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处, 因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
- 或 - 
 <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
或 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
- 或 - 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素不实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="items" Type="TValue[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">关键字数组元素的类型。</typeparam>
        <typeparam name="TValue">项数组元素的类型。</typeparam>
        <param name="keys">从零开始的一维 <see cref="T:System.Array" />，它包含要排序的关键字。</param>
        <param name="items">从零开始的一维 <see cref="T:System.Array" />，其中包含与 <paramref name="keys" /> 中的关键字对应的项；如果为 <see langword="null" />，则只对 <paramref name="keys" /> 进行排序。</param>
        <param name="index">排序范围的起始索引。</param>
        <param name="length">排序范围内的元素数。</param>
        <param name="comparer">比较元素时使用的 <see cref="T:System.Collections.Generic.IComparer`1" /> 泛型接口实现；如果为 <see langword="null" />，则使用每个元素的 <see cref="T:System.IComparable`1" /> 泛型接口实现。</param>
        <summary>基于第一个 <see cref="T:System.Array" /> 中的关键字，使用指定的 <see cref="T:System.Array" /> 泛型接口，对两个 <see cref="T:System.Collections.Generic.IComparer`1" /> 对象（一个包含关键字，另一个包含对应的项）的部分元素进行排序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `keys`中的<xref:System.Array>每个键在中`items`都有相应<xref:System.Array>的项。 当在排序过程中重定位某个键时, 中`items` <xref:System.Array>的相应项同样会重新定位。 `items`因此, <xref:System.Array>会根据中`keys`相应键的排列顺序对进行排序。 <xref:System.Array>  
  
 如果`comparer`为`null`, 则`keys` 中指定范围内的元素中的每个键都必须实现泛型接口,才能与其他每个键进行比较。<xref:System.Array> <xref:System.IComparable%601>  
  
 您可以排序是否有多个项大于键, 但不会对没有对应键的项进行排序。 如果键比项多, 则无法排序;这样做会引发<xref:System.ArgumentException>。  
  
 如果排序未成功完成, 则结果是不确定的。  
  
 此方法使用反省 sort (introsort) 算法, 如下所示:  
  
-   如果分区大小少于16个, 则使用[插入排序](https://en.wikipedia.org/wiki/Insertion_sort)算法。  
  
-   如果分区数超过 2 * Log<sup>N</sup>, 其中*N*为输入数组的范围, 则使用[Heapsort](https://en.wikipedia.org/wiki/Heapsort)算法。  
  
-   否则, 它将使用[快速排序](https://en.wikipedia.org/wiki/Quicksort)算法。  
  
 此实现执行不稳定的排序;也就是说, 如果两个元素相等, 则可能不会保留它们的顺序。 相反, 稳定排序会保留相等元素的顺序。  
  
 对于使用 Heapsort 和快速排序算法排序的数组, 在最坏的情况下, 此方法为 O`n` (log `n`) 运算, 其中`n`是`length`。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>、 <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>和 [\], TValue\<x:% 60% 602% 28% 60% 600% 5b% 5d% 2c% 60% 601% 5b% 5d% 2csystem.string% 2csystem.string%2Csystem.string IComparer% 7B% 60% 600% 7D% 29 > 泛型方法重载, 用于对表示键和值的数组对进行排序。  
  
 此代码示例定义了一个名为`ReverseCompare`的字符串的替代比较器, 该比较器实现了`IComparer<string>`( C++`IComparer(Of String)`在 Visual Basic `IComparer<String^>`中的 Visual) 泛型接口。 比较器调用<xref:System.String.CompareTo%28System.String%29>方法, 并反转比较数的顺序, 以便字符串排序为高到低而不是低到高。  
  
 此代码示例创建并显示一个恐龙名称数组 (密钥) 和一个整数数组, 表示每个恐龙的最大长度 (值)。 然后, 将数组排序并显示多次:  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>重载用于按照第一个数组中的恐龙名称顺序对这两个数组进行排序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>重载和`ReverseCompare`实例用于反转成对数组的排序顺序。  
  
-   <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>重载用于对这两个数组的最后三个元素进行排序。  
  
-   [\], TValue\<x:%% 3% 7% 28% 60% 600% 5b% 5d% 2c% 60% 601% 5b% 5d% 2csystem.string% 2csystem.string% 2csystem.string% IComparer% 7d% 29 > 重载用于对最后三个项进行排序 (& a)双向数组中的元素。  
  
> [!NOTE]
>  对泛型方法的调用与对它们的非泛型方法的调用没有任何不同之处, 因为C#Visual Basic、 C++和从前两个自变量的类型推断泛型类型参数的类型。 如果使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查 Microsoft 中间语言 (MSIL), 可以看到正在调用泛型方法。  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于 <paramref name="keys" /> 的下限。  
  
或 
 <paramref name="length" /> 小于零。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> 不是 <see langword="null" />，且 <paramref name="keys" /> 的下限与 <paramref name="items" /> 的下限不匹配。  
  
或 
 <paramref name="items" /> 不是 <see langword="null" />，并且 <paramref name="keys" /> 的长度大于 <paramref name="items" /> 的长度。  
  
或 
 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="keys" /><see cref="T:System.Array" /> 中指定有效范围。  
  
或 
 <paramref name="items" /> 不为 <see langword="null" />，且 <paramref name="index" /> 和 <paramref name="length" /> 未在 <paramref name="items" /><see cref="T:System.Array" /> 中指定有效范围。  
  
或 
<paramref name="comparer" /> 的实现导致排序时出现错误。 例如，将某个项与其自身比较时，<paramref name="comparer" /> 可能不返回 0。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> 为 <see langword="null" />，且 <paramref name="keys" /><see cref="T:System.Array" /> 中的一个或多个元素未实现 <see cref="T:System.IComparable`1" /> 泛型接口。</exception>
        <block subset="none" type="usage"><para>.NET Framework 4 及更早版本仅使用快速排序算法。 快速排序在某些情况下标识无效的比较器, 其中排序操作<see cref="T:System.IndexOutOfRangeException" />引发异常, 并向<see cref="T:System.ArgumentException" />调用方引发异常。 从开始<see cref="T:System.ArgumentException" /> , 以前引发的排序操作可能不会引发异常, 因为插入排序和 heapsort 算法未检测到无效的比较器。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 大多数情况下, 这适用于元素少于16个的数组。</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">在数组中执行不区分区域性的字符串操作</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性实现<xref:System.Collections.ICollection?displayProperty=nameWithType>接口。  
  
 基于<xref:System.Array>的 .NET Framework 类<xref:System.Array.SyncRoot%2A>使用属性提供自己的集合的同步版本。  
  
 使用数组的类也可以使用<xref:System.Array.SyncRoot%2A>属性来实现自己的同步。 同步代码必须对集合的 (而`SyncRoot`不是直接在集合上) 执行操作。 这样可确保对从其他对象派生的集合正确地执行操作。 具体而言, 它与可能同时修改集合的其他线程保持正确的同步。 请注意, 的<xref:System.Array.SyncRoot%2A>某些实现可能会<xref:System.Array>返回自身。  
  
 枚举集合本质上不是线程安全的过程。 即使某个集合已同步，其他线程仍可以修改该集合，这会导致枚举数引发异常。 若要确保枚举过程中的线程安全性，可以在整个枚举期间锁定集合，或者捕获由其他线程进行的更改所导致的异常。  
  
 检索此属性的值的运算复杂度为 O(1)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Array.SyncRoot%2A>属性在整个枚举过程中锁定数组。  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Array" /> 中包含的元素数。</summary>
        <value>集合中包含的元素数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.ICollection> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示对 <see cref="T:System.Array" /> 的访问是否同步（线程安全）。</summary>
        <value>如果对 <see cref="T:System.Array" /> 的访问是同步的（线程安全），则为 true；否则为 false。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</summary>
        <value>可用于同步对 <see cref="T:System.Array" /> 的访问的对象。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要添加到 <see cref="T:System.Collections.IList" /> 的对象。</param>
        <summary>调用此方法始终会引发 <see cref="T:System.NotSupportedException" /> 异常。</summary>
        <returns>不支持向数组添加值。 不返回任何值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType>实现将成员添加到集合。 但是, 因为数组具有固定大小 ( <xref:System.Array.IsFixedSize%2A>属性总是返回`true`), 所以<xref:System.NotSupportedException>此方法始终引发异常。  
  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除所有项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在当前列表中定位的对象。 要定位的元素对于引用类型可以是 <see langword="null" />。</param>
        <summary>确定某元素是否在 <see cref="T:System.Collections.IList" /> 中。</summary>
        <returns>如果在 <see langword="true" /> 中找到 <paramref name="value" />，则为 <see cref="T:System.Collections.IList" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要在当前列表中定位的对象。</param>
        <summary>确定 <see cref="T:System.Collections.IList" /> 中特定项的索引。</summary>
        <returns>如果在列表中找到，则为值的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">应插入 <paramref name="value" /> 的索引位置。</param>
        <param name="value">要插入的对象。</param>
        <summary>在 <see cref="T:System.Collections.IList" /> 中的指定索引处插入一个项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。  
  
或 
<see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> 在 <see cref="T:System.Collections.IList" /> 中是 null 引用。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否具有固定大小。</summary>
        <value>如果<see cref="T:System.Array" />具有固定大小, 则为 true; 否则为 false。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Array" /> 是否为只读。</summary>
        <value>如果是只读<see cref="T:System.Array" />的, 则为 true; 否则为 false。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要获取或设置的元素的索引。</param>
        <summary>获取或设置指定索引处的元素。</summary>
        <value>指定索引处的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> 小于零。  
  
- 或 - 
 <paramref name="index" /> 等于或大于 <see cref="P:System.Collections.ICollection.Count" />。</exception>
        <exception cref="T:System.ArgumentException">当前的 <see cref="T:System.Array" /> 不是正好有一维。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要从 <see cref="T:System.Collections.IList" /> 中删除的对象。</param>
        <summary>从 <see cref="T:System.Collections.IList" /> 中移除特定对象的第一个匹配项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。  
  
或 
<see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">要移除的元素的索引。</param>
        <summary>移除位于指定索引处的 <see cref="T:System.Collections.IList" /> 项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IList> 接口时使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">索引不是 <see cref="T:System.Collections.IList" /> 中的有效索引。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Collections.IList" /> 为只读。  
  
或 
<see cref="T:System.Collections.IList" /> 具有固定的大小。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">要与当前实例进行比较的对象。</param>
        <param name="comparer">一个将当前对象与 <paramref name="other" /> 进行比较的对象。</param>
        <summary>确定当前集合对象在排序顺序中的位置是位于另一个对象之前、之后还是与其位置相同。</summary>
        <returns>一个指示当前集合对象与其他对象的关系的整数，如下表所示。  
  
 <list type="table"><listheader><term> 返回值 
 </term><description> 说明 
 </description></listheader><item><term> -1 
 </term><description> 当前实例位于 <paramref name="other" /> 之前。  
  
 </description></item><item><term> 0 
 </term><description> 当前实例与 <paramref name="other" /> 位于同一位置。  
  
 </description></item><item><term> 1 
 </term><description> 当前实例位于 <paramref name="other" /> 之后。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IStructuralComparable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="other">要与当前实例进行比较的对象。</param>
        <param name="comparer">一个可确定当前实例与 <paramref name="other" /> 是否相等的对象。</param>
        <summary>确定某个对象与当前实例是否相等。</summary>
        <returns>如果两个对象相等，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="comparer">一个计算当前对象的哈希代码的对象。</param>
        <summary>返回当前实例的哈希代码。</summary>
        <returns>当前实例的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此成员是显式接口成员的实现。 它只能在 <xref:System.Array> 实例被强制转换为 <xref:System.Collections.IStructuralEquatable> 接口时使用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">数组元素的类型。</typeparam>
        <param name="array">要对照条件进行检查的从零开始的一维 <see cref="T:System.Array" />。</param>
        <param name="match">用于定义检查元素时要对照的条件的谓词。</param>
        <summary>确定数组中的每个元素是否都与指定谓词定义的条件匹配。</summary>
        <returns>如果 <paramref name="array" /> 中的每个元素都与指定谓词定义的条件匹配，则为 <see langword="true" />；否则为 <see langword="false" />。 如果数组中没有元素，则返回值为 <see langword="true" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 是一个方法委托, 如果传递给它的对象与委托中定义的条件相匹配, 则它将返回`true`。 <xref:System.Predicate%601>  的元素`array`分别传递<xref:System.Predicate%601>到, 并在委托为任何元素返回`false`时停止处理。  
  
 此方法为 O`n`() 运算, 其中`n`是<xref:System.Array.Length%2A>的`array`。  
  
   
  
## Examples  
 下面的示例确定字符串数组中每个元素的最后一个字符是否为数字。 它创建两个字符串数组。 第一个数组包含以字母字符结尾的字符串, 以及以数字字符结尾的字符串。第二个数组仅包含以数字字符结尾的字符串。 该示例还定义一个`EndWithANumber`方法, 该<xref:System.Predicate%601>方法的签名与委托匹配。 该示例将每个数组连同<xref:System.Array.TrueForAll%2A> `EndsWithANumber`表示方法的委托一起传递给方法。  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 下面的示例类似于第一个示例, 只不过它将字符串数组传递给<xref:System.Array.TrueForAll%2A>方法, 并使用 lambda 表达式来确定特定数组元素是否以数字的字符串表示形式结束。  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 在这两种情况<xref:System.Array.TrueForAll%2A>下, `false`方法会在遇到不以数字结尾的第一个数组元素时立即返回。 否则, 它将`true`在循环访问数组中的所有元素后返回。  
  
> [!NOTE]
>  由于两个示例显示, C#在和 Visual Basic 中, 无需显式创建`Predicate<string>`委托 (`Predicate(Of String)`在 Visual Basic 中)。 这些语言从上下文推断正确的委托并自动创建它。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> 为 <see langword="null" />。  
  
或 
 <paramref name="match" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>