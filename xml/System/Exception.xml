<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7f9ed0e4415bd82414aa633c9ee9d1f915b55ac8" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68400135" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示在应用程序执行过程中发生的错误。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此类是所有异常的基类。 当发生错误时, 系统或当前正在执行的应用程序会通过引发包含有关错误的信息的异常来报告该错误。 引发异常后, 它由应用程序或默认异常处理程序进行处理。  
  
 本节内容：  
  
 [错误和异常](#Errors)   
 [Try/catch 块](#TryCatch)   
 [异常类型功能](#Features)   
 [异常类属性](#Properties)   
 [性能注意事项](#Performance)   
 [重新引发异常](#Rethrow)   
 [选择标准异常](#Standard)   
 [实现自定义异常](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a>错误和异常  
 由于各种原因, 可能会发生运行时错误。 但是, 并非所有错误都应作为代码中的异常处理。 下面是一些可在运行时出现的错误以及相应的响应方法。  
  
-   **使用错误。** 使用错误表示程序逻辑中可能会导致异常的错误。 但是, 此错误应通过异常处理而不是通过修改错误的代码来解决。 例如, 以下示例中<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法的重写假定`obj`参数必须始终为非 null。  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     `null` <xref:System.Object.Equals%2A?displayProperty=nameWithType>当<xref:System.NullReferenceException> 可以通过在调用重写然后重新编译之前,通过修改源代码来显式测试null,从而导致`obj`出现的异常。 下面的示例包含处理`null`参数的正确源代码。  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     您可以使用<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>方法来识别调试生成中的使用错误, <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>并使用方法标识调试和发布版本中的使用错误, 而不是使用异常处理来处理使用错误。 有关详细信息，请参阅[托管代码中的断言](/visualstudio/debugger/assertions-in-managed-code)。  
  
-   **程序错误。** 程序错误是运行时错误, 不一定要通过编写无错误代码来避免此错误。  
  
     在某些情况下, 程序错误可能反映了预期的或例程错误情况。 在这种情况下, 你可能希望避免使用异常处理来处理程序错误, 然后重试该操作。 例如, 如果用户需要以特定格式输入日期, 则可以通过调用<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法来分析日期字符串, 该方法返回一个<xref:System.Boolean>指示分析操作是否成功的值, 而不是使用<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法, 如果无法将<xref:System.FormatException>日期字符串<xref:System.DateTime>转换为值, 则会引发异常。 同样, 如果用户尝试打开不存在的文件, 则可以先调用<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>方法以检查该文件是否存在, 如果不存在, 则提示用户是否要创建该文件。  
  
     在其他情况下, 程序错误反映了可以在代码中处理的意外错误情况。 例如, 即使你已检查以确保文件存在, 也可能会将其删除, 然后才能打开该文件, 否则它可能已损坏。 在这种情况下, 尝试通过实例化<xref:System.IO.StreamReader>对象或<xref:System.IO.File.Open%2A>调用方法打开文件可能会引发<xref:System.IO.FileNotFoundException>异常。 在这些情况下, 应使用异常处理从错误中恢复。  
  
-   **系统失败。** 系统故障是一个运行时错误, 无法通过编程方式进行处理。 例如, 如果公共语言运行时无法<xref:System.OutOfMemoryException>分配更多内存, 则任何方法都可能引发异常。 通常, 系统故障不是通过使用异常处理来处理的。 相反, 你可以使用事件 ( <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>例如), 并<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>调用方法来记录异常信息, 并在应用程序终止之前通知用户失败。  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a>Try/catch 块  
 公共语言运行时提供异常处理模型, 该模型基于作为对象的异常表示形式, 并将程序代码和异常处理代码`try`与块和`catch`块分离。 可以有一个或多个`catch`块, 每个块用于处理特定类型的异常, 或一个块旨在捕获比另一个块更具体的异常。  
  
 如果应用程序处理在执行应用程序代码块的过程中发生的异常, 则必须将代码放置在`try`语句中并将其`try`称为块。 处理`try`块引发的异常的应用程序代码放置在一个`catch` `catch`语句中, 称为块。 与块关联`catch`的零个或多个块, 每`catch`个块都包含一个类型筛选器, 用于确定它处理的异常的类型。 `try`  
  
 如果`try`块中发生异常, 则系统将按照它们在应用`catch`程序代码中出现的顺序搜索关联的块`catch` , 直到它找到处理异常的块。 如果 catch 块的类型筛选器指定`T`或从派生的任何类型, `T`则块将处理类型`T`为的异常。 `catch` 系统在找到处理异常的第一个`catch`块后停止搜索。 出于此原因, 在应用程序代码中`catch` , 处理类型的块必须在处理其基`catch`类型的块之前指定, 如本部分后面的示例中所示。 最后指定处理`System.Exception`程序的 catch 块。  
  
 如果与当前`try`块`catch`关联的所有块均未处理异常, 并且当前`try`块嵌套在当前调用的其他`try`块中, 则`catch`为与下一个关联的块搜索`try`封闭块。 如果未`catch`找到异常的块, 则系统会在当前调用中搜索先前的嵌套级别。 如果在`catch`当前调用中找不到异常的块, 则将在调用堆栈中向上传递异常, 并在上一堆栈帧中搜索`catch`处理异常的块。 调用堆栈的搜索将继续执行, 直到处理异常或调用堆栈上没有更多的帧为止。 如果到达调用堆栈顶部但未找到`catch`处理异常的块, 则默认异常处理程序将处理该异常, 并且应用程序将终止。  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a>异常类型功能  
 异常类型支持以下功能:  
  
-   描述错误的用户可读文本。 发生异常时, 运行时将向用户提供一条文本消息, 通知用户错误的性质, 并建议采取措施来解决问题。 此短信保存在异常对象<xref:System.Exception.Message%2A>的属性中。 在创建异常对象的过程中, 可以将文本字符串传递到构造函数, 以描述该特定异常的详细信息。 如果没有向构造函数提供错误消息参数, 则使用默认错误消息。 有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。  
  
-   引发异常时的调用堆栈的状态。 <xref:System.Exception.StackTrace%2A>属性带有一个可用于确定代码中错误发生位置的堆栈跟踪。 堆栈跟踪会列出调用的所有调用方法和源文件中的行号。  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a>异常类属性  
 <xref:System.Exception.Message%2A> <xref:System.Exception.Source%2A> <xref:System.Exception.HResult%2A> <xref:System.Exception.StackTrace%2A> <xref:System.Exception.HelpLink%2A> <xref:System.Exception.InnerException%2A>类包含多个属性, 这些属性可帮助标识代码位置、类型、帮助文件和异常的原因:、、、、、、 <xref:System.Exception><xref:System.Exception.TargetSite%2A>、和<xref:System.Exception.Data%2A>。  
  
 当两个或多个异常之间存在因果关系时<xref:System.Exception.InnerException%2A> , 属性将保留该信息。 为响应此内部异常而引发外部异常。 处理外部异常的代码可以使用以前的内部异常的信息更恰当地处理错误。 有关异常的补充信息可以存储为<xref:System.Exception.Data%2A>属性中的键/值对的集合。  
  
 在创建异常对象的过程中, 传递给构造函数的错误消息字符串应本地化, 并可通过使用<xref:System.Resources.ResourceManager>类从资源文件提供。 有关本地化资源的详细信息, 请参阅[创建附属程序集](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)和[打包和部署资源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主题。  
  
 若要为用户提供有关异常发生原因的详细信息, <xref:System.Exception.HelpLink%2A>属性可以将 URL (或 URN) 保存到帮助文件。  
  
 <xref:System.Exception>类使用的 HRESULT COR_E_EXCEPTION, 其值为0x80131500。  
  
 有关<xref:System.Exception>类的实例的初始属性值的列表, <xref:System.Exception.%23ctor%2A>请参见构造函数。  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a>性能注意事项  
 引发或处理异常消耗大量的系统资源和执行时间。 仅引发异常来处理真正非常特别的情况, 而不是处理可预测的事件或流控制。 例如, 在某些情况下, 例如在开发类库时, 如果方法参数无效, 则应引发异常, 因为你希望使用有效的参数调用方法。 无效的方法参数, 如果不是使用错误的结果, 则表示发生了异常情况。 相反, 如果用户输入无效, 则不会引发异常, 因为你可能希望用户偶尔输入无效数据。 相反, 请提供重试机制, 以便用户可以输入有效输入。 也不应使用异常来处理使用错误。 请改用[断言](/visualstudio/debugger/assertions-in-managed-code)来确定和更正使用错误。  
  
 此外, 如果返回代码足够, 则不要引发异常;不要将返回代码转换为异常;并且不要定期捕获异常、将其忽略, 然后继续处理。  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a>重新引发异常  
 在许多情况下, 异常处理程序只需要将异常传递给调用方。 最常见的情况是:  
  
-   一个类库, 用于包装对 .NET Framework 类库或其他类库中的方法的调用。  
  
-   遇到严重异常的应用程序或库。 异常处理程序可以记录异常, 然后重新引发异常。  
  
 重新引发异常的建议方法是只使用中C#的[throw](~/docs/csharp/language-reference/keywords/throw.md)语句和 Visual Basic 中的[throw](~/docs/visual-basic/language-reference/statements/throw-statement.md)语句, 而不包括表达式。 这可确保在异常传播到调用方时, 保留所有调用堆栈信息。 下面的示例阐释了这一点。 字符串扩展方法`FindOccurrences`将一个或多个调用包装到<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> , 但不事先验证其参数。  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 然后, 调用方`FindOccurrences`调用两次。 在第二次调用`FindOccurrences`中, 调用方将`null`作为搜索<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>字符串进行传递, 这将引发<xref:System.ArgumentNullException>异常。 此异常由`FindOccurrences`方法进行处理并传递回调用方。 由于 throw 语句与 no 表达式一起使用, 因此该示例的输出显示调用堆栈被保留。  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 相反, 如果使用引发异常,  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 语句时, 将不保留完全调用堆栈, 示例将生成以下输出:  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 一种更繁琐的替代方法是引发新异常, 并在内部异常中保留原始异常的调用堆栈信息。 然后, 调用方可以使用新异常的<xref:System.Exception.InnerException%2A>属性来检索堆栈帧以及有关原始异常的其他信息。 在这种情况下, throw 语句为:  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 处理异常的用户代码必须知道<xref:System.Exception.InnerException%2A>属性包含有关原始异常的信息, 如下面的异常处理程序所示。  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a>选择标准异常  
 当必须引发异常时, 通常可以使用 .NET Framework 中的现有异常类型, 而不是实现自定义异常。 在以下两种情况下, 应使用标准异常类型:  
  
-   引发的异常是由使用错误 (即, 调用方法的开发人员发出的程序逻辑中的错误) 引起的。 通常情况下<xref:System.ArgumentException>, 会引发异常, 如、 <xref:System.ArgumentNullException>、 <xref:System.InvalidOperationException>或。 <xref:System.NotSupportedException> 在实例化异常对象时, 为异常对象的构造函数提供的字符串应描述错误, 使开发人员能够修复该错误。 有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。  
  
-   你正在处理一个错误, 该错误可以通过现有 .NET Framework 异常传达给调用方。 应引发可能派生程度最高的异常。 例如, 如果某个方法要求参数为枚举类型的有效成员, 则应引发<xref:System.ComponentModel.InvalidEnumArgumentException> (派生程度最高的类) 而不是。 <xref:System.ArgumentException>  
  
 下表列出了常见的异常类型和引发这些类型的条件。  
  
|例外|条件|  
|---------------|---------------|  
|<xref:System.ArgumentException>|传递给方法的非 null 参数无效。|  
|<xref:System.ArgumentNullException>|传递给方法的参数是`null`。|  
|<xref:System.ArgumentOutOfRangeException>|参数超出了有效值的范围。|  
|<xref:System.IO.DirectoryNotFoundException>|部分目录路径无效。|  
|<xref:System.DivideByZeroException>|整数或<xref:System.Decimal>除法运算中的分母为零。|  
|<xref:System.IO.DriveNotFoundException>|驱动器不可用或不存在。|  
|<xref:System.IO.FileNotFoundException>|文件不存在。|  
|<xref:System.FormatException>|值的格式不正确, 无法通过转换方法 (如) `Parse`从字符串进行转换。|  
|<xref:System.IndexOutOfRangeException>|索引超出数组或集合的界限。|  
|<xref:System.InvalidOperationException>|对象的当前状态中的方法调用无效。|  
|<xref:System.Collections.Generic.KeyNotFoundException>|找不到用于访问集合中的成员的指定键。|  
|<xref:System.NotImplementedException>|未实现方法或操作。|  
|<xref:System.NotSupportedException>|不支持方法或操作。|  
|<xref:System.ObjectDisposedException>|对已释放的对象执行操作。|  
|<xref:System.OverflowException>|算术、强制转换或转换运算导致溢出。|  
|<xref:System.IO.PathTooLongException>|路径或文件名超出了系统定义的最大长度。|  
|<xref:System.PlatformNotSupportedException>|当前平台不支持此操作。|  
|<xref:System.RankException>|具有错误维数的数组将传递给方法。|  
|<xref:System.TimeoutException>|分配给操作的时间间隔已过期。|  
|<xref:System.UriFormatException>|使用了无效的统一资源标识符 (URI)。|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a>实现自定义异常  
 在以下情况下, 使用现有 .NET Framework 异常来处理错误条件是不够的:  
  
-   如果异常反映了无法映射到现有 .NET Framework 异常的唯一程序错误, 则为。  
  
-   当异常要求的处理与适用于现有 .NET Framework 异常的处理不同时, 或者必须从类似的异常中消除异常时。 例如, 如果在分析超出目标<xref:System.ArgumentOutOfRangeException>整数类型范围的字符串的数值表示形式时引发异常, 则不希望对由调用方提供的错误产生的错误使用相同的异常调用方法时相应的约束值。  
  
 <xref:System.Exception>类是 .NET Framework 中所有异常的基类。 许多派生类依赖于<xref:System.Exception>类的成员的继承行为; 它们不会重写的<xref:System.Exception>成员, 也不定义任何唯一成员。  
  
 定义自己的异常类:  
  
1.  定义继承自<xref:System.Exception>的类。 如有必要, 定义类所需的任何唯一成员以提供有关异常的其他信息。 例如, <xref:System.ArgumentException>类包含一个<xref:System.ArgumentException.ParamName%2A>属性, 该属性指定其自变量导致异常的参数的名称, 而<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>属性包含一个<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>指示超时间隔的属性。  
  
2.  如有必要, 请重写要更改或修改其功能的任何继承成员。 请注意, 的<xref:System.Exception>大多数现有派生类不会重写继承成员的行为。  
  
3.  确定自定义异常对象是否为可序列化。 序列化使你可以保存有关异常的信息, 并允许服务器和客户端代理共享上下文中的异常信息。 若要使异常对象可序列化, 请用<xref:System.SerializableAttribute>特性标记它。  
  
4.  定义异常类的构造函数。 通常, 异常类具有一个或多个以下构造函数:  
  
    -   <xref:System.Exception.%23ctor>, 它使用默认值来初始化新异常对象的属性。  
  
    -   <xref:System.Exception.%23ctor%28System.String%29>, 它使用指定的错误消息初始化新的异常对象。  
  
    -   <xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, 它使用指定的错误消息和内部异常初始化新的异常对象。  
  
    -   <xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, 它是`protected`从序列化数据中初始化新异常对象的构造函数。 如果已选择使异常对象可序列化, 则应实现此构造函数。  
  
 下面的示例演示如何使用自定义异常类。 它定义一个`NotPrimeException`异常, 当客户端尝试通过指定不是质数的起始数字来检索质数序列时, 将引发此异常。 异常定义了一个新的属性`NonPrime`, 该属性返回导致异常的非质数。 除了使用<xref:System.Runtime.Serialization.SerializationInfo>和序列化和<xref:System.Runtime.Serialization.StreamingContext> `NotPrimeException`参数实现受保护的无参数构造函数和构造函数以外, `NonPrime`类还定义了三个其他构造函数来支持属性。  每个构造函数都调用基类构造函数, 同时保留非质数的值。 `NotPrimeException`类还<xref:System.SerializableAttribute>用特性标记。  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 下面的示例中所示的类使用尼斯筛法的埃拉托色,计算从2到客户端在调用其类构造函数时指定的限制的质数序列。`PrimeNumberGenerator` 方法返回大于或等于指定下限的所有质数, 但`NotPrimeException`如果下限不是质数, 则会引发。 `GetPrimesFrom`  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 下面的示例对具有非质数的`GetPrimesFrom`方法进行两次调用, 其中一个值与应用程序域边界交叉。 在这两种情况下, 异常都将引发并在客户端代码中成功处理。  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 运行时和[!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] 对于[!INCLUDE[win8](~/includes/win8-md.md)], 在通过 non-.NET Framework 堆栈帧传播异常时, 某些异常信息通常会丢失。 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]从和[!INCLUDE[win81](~/includes/win81-md.md)]开始, 公共语言运行时将继续使用引发的原始<xref:System.Exception>对象, 除非在 non-.NET Framework 堆栈帧中修改了该异常。  
  
   
  
## Examples  
 下面的示例演示`catch`了定义用于处理<xref:System.ArithmeticException>错误的块。 此`catch`块还会<xref:System.DivideByZeroException>捕获错误, <xref:System.DivideByZeroException>因为派生<xref:System.ArithmeticException>自, 并且没有`catch`显式定义错误的<xref:System.DivideByZeroException>块。  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md">处理和引发异常</related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md">打包和部署桌面应用程序中的资源</related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1">托管代码中的断言</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将新实例的 <xref:System.Exception.Message%2A> 属性初始化为系统提供的消息，该消息描述错误并考虑当前系统区域性。  
  
 所有派生类应提供此无参数的构造函数。 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|系统提供的本地化说明。|  
  
   
  
## Examples  
 下面的代码示例派生了`Exception`一个使用预定义的消息的。 此代码演示如何使用派生类和基类`Exception`的无参数构造函数。  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">描述错误的消息。</param>
        <summary>用指定的错误消息初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数`message`使用<xref:System.Exception.Message%2A>参数初始化新实例的属性。 如果参数为`null`, 则与调用<xref:System.Exception.%23ctor%2A>构造函数相同。 `message`  
  
 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
   
  
## Examples  
 下面的代码示例`Exception`为特定条件派生。 此代码演示如何使用采用调用方指定消息作为参数的构造函数, 同时用于派生类和基类`Exception` 。  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</param>
        <summary>用序列化数据初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数在反序列化过程中调用，以便重建通过流传输的异常对象。 有关详细信息，请参阅[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。  
  
   
  
## Examples  
 下面的代码示例定义了一个派生`Exception`的可序列化类。 此代码强制执行被零除错误, 然后使用 (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) 构造函数创建派生异常的实例。 该代码将实例序列化为文件, 将该文件反序列化为一个新异常, 引发该异常, 然后捕获并显示该异常的数据。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException">类名为 <see langword="null" /> 或者 <see cref="P:System.Exception.HResult" /> 为零 (0)。</exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解释异常原因的错误消息。</param>
        <param name="innerException">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</param>
        <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Exception" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因前一个异常而直接引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。 <xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。  
  
 下表显示 <xref:System.Exception> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部异常引用。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
   
  
## Examples  
 下面的代码示例`Exception`为特定条件派生。 此代码演示如何使用将消息和内部异常作为参数的构造函数, 同时用于派生类和基类`Exception` 。  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取提供有关异常的其他用户定义信息的键/值对集合。</summary>
        <value>一个对象，它实现 <see cref="T:System.Collections.IDictionary" /> 接口并包含用户定义的键/值对的集合。 默认值为空集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用由属性返回的<xref:System.Collections.IDictionary?displayProperty=nameWithType>对象来存储和检索与异常相关的<xref:System.Exception.Data%2A>补充信息。 此信息采用任意数量的用户定义的键/值对的形式。 每个键/值对的关键组件通常为标识字符串, 而值对的值部分可以是任何类型的对象。  
  
## <a name="keyvalue-pair-security"></a>键/值对安全性  
 存储在由<xref:System.Exception.Data%2A>属性返回的集合中的键/值对是不安全的。 如果你的应用程序调用一系列嵌套例程, 并且每个例程包含异常处理程序, 则生成的调用堆栈包含这些异常处理程序的层次结构。 如果较低级别例程引发异常, 则调用堆栈层次结构中的任何高级异常处理程序都可以读取和/或修改任何其他异常处理程序存储在集合中的键/值对。 这意味着, 在键/值对中的信息已损坏的情况下, 必须确保键/值对中的信息不是机密信息, 并且应用程序将正常运行。  
  
## <a name="key-conflicts"></a>键冲突  
 当不同的异常处理程序指定访问键/值对所用的相同键时, 会发生键冲突。 开发应用程序时要格外小心, 因为键冲突的后果在于, 较低级别的异常处理程序可能会意外地与较高级别的异常处理程序通信, 这种通信可能会导致微妙的程序错误。 但是, 如果你小心, 可以使用密钥冲突来增强你的应用程序。  
  
## <a name="avoiding-key-conflicts"></a>避免密钥冲突  
 通过采用命名约定为键/值对生成唯一键, 避免键冲突。 例如, 命名约定可能产生一个键, 其中包含应用程序的句点分隔的名称、提供对的补充信息的方法以及唯一标识符。  
  
 假设两个应用程序 (名为产品和供应商) 都有一个名为 Sales 的方法。 "产品" 应用程序中的 "销售" 方法提供产品的标识号 (库存单位或 SKU)。 供应商应用程序的 Sales 方法提供供应商的标识号或 SID。 因此, 此示例的命名约定会生成密钥 "Products. 销售 SKU" 和 "供应商名称"。  
  
## <a name="exploiting-key-conflicts"></a>利用关键冲突  
 使用一个或多个特殊的预先安排密钥来控制处理, 从而利用密钥冲突。 假设在一种情况下, 调用堆栈层次结构中最高级别的异常处理程序将捕获由较低级别的异常处理程序引发的所有异常。 如果存在具有特殊键的键/值对, 则高级异常处理程序将以某种非标准的方式设置<xref:System.Collections.IDictionary>对象中剩余的键/值对的格式; 否则, 将以某种正常方式设置其余键/值对的格式。  
  
 现在, 假设在另一种情况下, 调用堆栈层次结构每个级别的异常处理程序都将捕获下一个较低级别的异常处理程序引发的异常。 此外, 每个异常处理程序知道<xref:System.Exception.Data%2A>属性返回的集合包含一组键/值对, 这些键/值对可使用一组预先安排的键进行访问。  
  
 每个异常处理程序使用预先安排的键集来使用该异常处理程序的唯一信息更新相应键/值对的值部分。 更新过程完成后, 异常处理程序会将异常引发到下一个更高级别的异常处理程序。 最后, 最高级别的异常处理程序访问键/值对, 并显示来自所有较低级别的异常处理程序的合并的更新信息。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Exception.Data%2A>属性添加和检索信息。  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，返回 <see cref="T:System.Exception" />，它是一个或多个并发的异常的根源。</summary>
        <returns>异常链中第一个被引发的异常。 如果当前异常的 <see cref="P:System.Exception.InnerException" /> 属性是 null 引用（Visual Basic 中为<see langword="Nothing" /> ），则此属性返回当前异常。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异常链包含一组异常, 以便将链中的每个异常作为其`InnerException`属性中引用的异常的直接结果引发。 对于给定链, 只能有一个例外, 即链中所有其他异常的根本原因。 此异常称为基本异常, 其`InnerException`属性始终包含空引用。  
  
 对于异常链中的所有异常, 该`GetBaseException`方法必须返回相同的对象 (基本异常)。  
  
 如果要查找异常的根本原因, 但不需要有关当前异常和第一个异常之间可能发生的异常的信息, 请使用方法。`GetBaseException`  
  
   
  
## Examples  
 下面的代码示例定义了两`Exception`个派生类。 它强制执行异常, 然后再次使用每个派生类再次引发异常。 此代码演示如何使用`GetBaseException`方法来检索原始异常。  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在需要控制异常内容或格式的类中, 将重写方法。<see langword="GetBaseException" /></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</param>
        <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</param>
        <summary>当在派生类中重写时，用关于异常的信息设置 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetObjectData` 使用针对于序列化的所有异常对象数据设置 <xref:System.Runtime.Serialization.SerializationInfo>。 反序列化期间，从通过流传输的 `SerializationInfo` 重建异常。  
  
   
  
## Examples  
 下面的代码示例定义了一个可`Exception`实现`GetObjectData`的派生可序列化类, 这将对两个属性进行少量更改, 然后调用基类来执行序列化。 该示例强制执行被零除错误, 然后创建派生异常的实例。 该代码将实例序列化为文件, 将该文件反序列化为一个新异常, 引发该异常, 然后捕获并显示该异常的数据。  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 参数为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前实例的运行时类型。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象，表示当前实例的确切运行时类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 存在用于支持 .NET Framework 基础结构的<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法,并在内部调用基本方法。<xref:System.Exception.GetType%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指向与此异常关联的帮助文件链接。</summary>
        <value>统一资源名称 (URN) 或统一资源定位器 (URL)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 表示帮助文件的返回值是 URN 或 URL。 例如, `HelpLink`值可以是:  
  
 "file:///C:/Applications/Bazzal/help.html#ErrorNum42"  
  
   
  
## Examples  
 下面的代码示例`Exception` `HelpLink`将引发, 它在其构造函数中设置属性, 然后捕获异常并`HelpLink`显示。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 HRESULT（一个分配给特定异常的编码数字值）。</summary>
        <value>HRESULT 值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HRESULT 是一个32位值, 分为三个不同的字段: 一个严重性代码、一个设施代码和一个错误代码。 严重性代码指示返回值是否表示信息、警告或错误。 设备代码标识导致错误的系统区域。 错误代码是分配用来表示异常的唯一编号。 每个异常都映射到不同的 HRESULT。 当托管代码引发异常时, 运行时将 HRESULT 传递给 COM 客户端。 如果非托管代码返回错误, 则 HRESULT 会转换为异常, 然后运行时将引发异常。 有关 HRESULT 值及其相应的 .NET Framework 异常的信息, 请[参阅如何:映射 Hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。 有关最有可能遇到的值的列表, 请参阅 Windows 文档中的[常见 HRESULT 值](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)。  
  
 从开始<xref:System.Exception.HResult%2A> , 属性的 setter 是受保护的, 而其 getter 是公共的。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]  在以前版本的 .NET Framework 中, getter 和 setter 都受到保护。  
  
   
  
## Examples  
 下面的代码示例定义了一个`Exception`派生类, 该`HResult`派生类在其构造函数中将属性设置为自定义值。  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9">如何：映射 HRESULT 和异常</related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx">常见的 HRESULT 值</related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取导致当前异常的 <see cref="T:System.Exception" /> 实例。</summary>
        <value>描述导致当前异常的错误的一个对象。 <see cref="P:System.Exception.InnerException" /> 属性返回的值与传递到 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 构造函数中的值相同，如果没有向构造函数提供内部异常值，则为 <see langword="null" /> 。 此属性是只读的。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当`X`异常作为上一个异常`Y`的直接结果引发时, <xref:System.Exception.InnerException%2A>的属性`X`应包含对的引用`Y`。  
  
 使用 <xref:System.Exception.InnerException%2A> 属性获取导致当前异常的异常集。  
  
 你可以创建一个新的异常来捕获更早的异常。 处理第二个异常的代码可以利用以前异常中的其他信息来更正确地处理错误。  
  
 假设有一个函数读取文件, 并设置该文件的数据的格式。 在此示例中, 当代码尝试读取文件<xref:System.IO.IOException>时, 将引发。 函数捕获<xref:System.IO.IOException>并<xref:System.IO.FileNotFoundException>引发。 可以保存<xref:System.IO.FileNotFoundException>在的<xref:System.IO.FileNotFoundException>属性中, 并启用捕获的代码来检查出现初始错误的原因。 <xref:System.Exception.InnerException%2A> <xref:System.IO.IOException>  
  
 <xref:System.Exception.InnerException%2A>属性 (包含对内部异常的引用) 是在初始化异常对象时设置的。  
  
   
  
## Examples  
 下面的示例演示如何引发和捕获引用内部异常的异常。  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述当前异常的消息。</summary>
        <value>解释异常原因的错误消息或空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 错误消息面向正在处理异常的开发人员。 <xref:System.Exception.Message%2A>属性的文本应完全描述错误, 如果可能, 还应说明如何纠正错误。 顶级异常处理程序可能会向最终用户显示消息, 因此您应该确保该消息的语法正确, 并且消息的每个句子都以句点结束。 不要使用问号或感叹号。 如果你的应用程序使用本地化的异常消息, 则应确保正确翻译它们。  
  
> [!IMPORTANT]
>  不要在不检查适当权限的情况下, 在异常消息中公开敏感信息。  
  
 <xref:System.Exception.Message%2A>属性的值包含在<xref:System.Exception.ToString%2A>返回的信息中。仅在创建时设置<xref:System.Exception.Message%2A>属性<xref:System.Exception>。 如果没有向当前实例的构造函数提供消息, 则系统提供使用当前系统区域性进行格式设置的默认消息。  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a>Windows 运行时和[!INCLUDE[net_v451](~/includes/net-v451-md.md)]  
 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]从和[!INCLUDE[win81](~/includes/win81-md.md)]开始, 从不属于 .NET Framework 的 Windows 运行时类型和成员传播而来的错误消息保真会得到改善。 具体而言, 来自可视化C++组件扩展 (C++/cx) 的异常消息现在将传播回 .NET Framework <xref:System.Exception>的对象。  
  
   
  
## Examples  
 下面的代码示例将引发<xref:System.Exception>异常, 然后捕获异常并<xref:System.Exception.Message%2A>使用属性显示异常的短信。
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果从属性引发异常, 并且需要将的<see cref="P:System.Exception.Message" />文本引用到设置或获取的属性参数, 请使用 "value" 作为属性参数的名称。</para></block>
        <block subset="none" type="overrides"><para>需要控制消息内容或格式的类中将重写属性。<see cref="P:System.Exception.Message" /> 当应用程序代码需要显示已被捕获的异常的相关信息时, 通常会访问此属性。  
  
应本地化错误消息。</para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当异常被序列化用来创建包含有关该异常的徐列出数据的异常状态对象时会出现该问题。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 异常状态对象实现<xref:System.Runtime.Serialization.ISafeSerializationData>接口。  
  
 当对<xref:System.Exception.SerializeObjectState>事件进行订阅时, 异常将反序列化并创建为空异常。 异常的构造函数不会运行, 并且异常状态也将进行反序列化。 然后通知异常状态对象的回调方法,以便可以将反序列化的数据推送到空异常中。<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A>  
  
 <xref:System.Exception.SerializeObjectState>事件使透明异常类型可以序列化和反序列化异常数据。 透明代码可以在其运行的权限集边界内执行命令, 但不能执行、调用、派生自或包含关键代码。  
  
 如果未对<xref:System.Exception.%23ctor%2A> 事件进行订阅,则使用构造函数照常进行<xref:System.Exception.SerializeObjectState>反序列化。  
  
 通常情况下, 会在<xref:System.Exception.SerializeObjectState>异常的构造函数中添加事件的处理程序, 以提供其序列化。 但由于在<xref:System.Exception.SerializeObjectState>事件处理程序执行时不执行构造函数, 因此, 序列化反序列化<xref:System.Runtime.Serialization.SerializationException>异常会在您尝试反序列化异常时引发异常。 若要避免此<xref:System.Exception.SerializeObjectState>情况, 还应<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>在方法中添加事件的处理程序。 有关说明, 请参阅示例部分。  
  
   
  
## Examples  
 下面的示例定义了`BadDivisionException`一个用于<xref:System.Exception.SerializeObjectState>处理事件的。 它还包含一个状态对象, 该对象是一个名为`BadDivisionExceptionState`的用于<xref:System.Runtime.Serialization.ISafeSerializationData>实现接口的嵌套结构。  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 当`BadDivisionException`发生浮点除数为零时, 将引发异常。 在第一个被零除的过程中, 该`BadDivisionException`示例实例化一个对象, 将其序列化, 并引发异常。 如果后续除法运算发生, 则此示例将反序列化以前序列化的对象, 重新它, 并引发异常。 为了提供对象序列化、反序列化、reserialization 和反序列化, 该<xref:System.Exception.SerializeObjectState>示例`BadDivisionException`在<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>类构造函数和实现中都添加了事件处理程序。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果此事件订阅并使用, 则继承层次结构中后面的所有派生类型都必须实现相同的序列化机制。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置导致错误的应用程序或对象的名称。</summary>
        <value>导致错误的应用程序或对象的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果未显式设置属性,则运行时自动将其设置为引发异常的程序集的名称。<xref:System.Exception.Source%2A>  
  
   
  
## Examples  
 下面的示例引发一个`Exception` , 它在`Source`其构造函数中设置属性, 然后捕获异常并`Source`显示。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">对象必须是运行时 <see cref="N:System.Reflection" /> 对象。</exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取调用堆栈上的即时框架字符串表示形式。</summary>
        <value>用于描述调用堆栈的直接帧的字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 执行堆栈将跟踪在给定时刻正在执行的所有方法。 对方法调用的跟踪称为堆栈跟踪。 堆栈跟踪列表提供了一种方法, 用于在发生异常的方法中跟踪调用堆栈。  
  
 <xref:System.Exception.StackTrace%2A>属性返回调用堆栈的帧, 该堆栈源自引发异常的位置。 您可以通过创建<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>类的新实例并使用其<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>方法来获取有关调用堆栈中的其他帧的信息。  
  
 当应用程序代码中引发异常时, 公共语言运行时 (CLR) 将更新堆栈跟踪 (通过使用`throw`关键字)。 如果在与最初引发异常的方法不同的方法中再次引发异常, 则堆栈跟踪同时包含最初引发异常的方法中的位置, 以及引发异常的方法中的位置。引发. 如果引发异常, 并在之后再次引发该异常, 则堆栈跟踪只包含引发异常的位置, 并且不包含最初引发异常的位置。  
  
 由于在优化过程中发生的代码转换 (如内联),属性可能不会按预期方式报告任意数量的方法调用。<xref:System.Exception.StackTrace%2A>  
  
   
  
## Examples  
 下面的代码示例引发`Exception` , 并`StackTrace`使用属性来捕获它并显示堆栈跟踪。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在需要控制堆栈跟踪内容或格式的类中, 会重写属性。<see langword="StackTrace" />  
  
默认情况下, 会在引发异常对象之前立即捕获堆栈跟踪。 当<see cref="P:System.Environment.StackTrace" />未引发异常时, 使用获取堆栈跟踪信息。</para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取引发当前异常的方法。</summary>
        <value>引发当前异常的 <see cref="T:System.Reflection.MethodBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果引发此异常的方法不可用, 且堆栈跟踪不是空引用 (`Nothing`在 Visual Basic 中), <xref:System.Exception.TargetSite%2A>将从堆栈跟踪中获取该方法。 如果堆栈跟踪为空引用，<xref:System.Exception.TargetSite%2A> 也返回空引用。  
  
> [!NOTE]
>  如果<xref:System.Exception.TargetSite%2A>异常处理程序处理跨应用程序域边界的异常, 则属性可能无法准确报告引发异常的方法的名称。  
  
   
  
## Examples  
 下面的代码示例引发`Exception` , 并`TargetSite`使用属性来捕获它并显示原始方法。  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建并返回当前异常的字符串表示形式。</summary>
        <returns>当前异常的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Exception.ToString%2A>返回当前异常的表示形式, 该异常旨在被人理解。 如果异常包含区分区域性的数据, `ToString`则需要使用返回的字符串表示形式来考虑当前系统区域性。 虽然对于返回的字符串的格式没有确切的要求, 但它应尝试反映用户认为对象的值。  
  
 的<xref:System.Exception.ToString%2A>默认实现将获取引发当前异常的类的名称、消息、对内部异常调用<xref:System.Exception.ToString%2A>的结果和调用<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>的结果。 如果这些成员中有任何`null`一个为, 则其值不包含在返回的字符串中。  
  
 如果没有错误消息或为空字符串 (""), 则不返回错误消息。 内部异常的名称和堆栈跟踪仅在不`null`返回时返回。  
  
 此方法重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例将引发异常, 并显示对此异常<xref:System.Exception.ToString%2A>调用的结果。 请注意, <xref:System.Exception.ToString%2A?displayProperty=nameWithType>当异常类实例出现在<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法的参数列表中时, 将隐式调用方法。  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>