<Type Name="Exception" FullName="System.Exception">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7f9ed0e4415bd82414aa633c9ee9d1f915b55ac8" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68400135" /></Metadata><TypeSignature Language="C#" Value="public class Exception : System.Runtime.InteropServices._Exception, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable beforefieldinit Exception extends System.Object implements class System.Runtime.InteropServices._Exception, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Exception" />
  <TypeSignature Language="VB.NET" Value="Public Class Exception&#xA;Implements _Exception, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Exception : System::Runtime::InteropServices::_Exception, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Exception = class&#xA;    interface ISerializable&#xA;    interface _Exception" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Exception</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Exception))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="d3e6c-101">表示在应用程序执行过程中发生的错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-101">Represents errors that occur during application execution.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-102">此类是所有异常的基类。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-102">This class is the base class for all exceptions.</span></span> <span data-ttu-id="d3e6c-103">当发生错误时, 系统或当前正在执行的应用程序会通过引发包含有关错误的信息的异常来报告该错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-103">When an error occurs, either the system or the currently executing application reports it by throwing an exception that contains information about the error.</span></span> <span data-ttu-id="d3e6c-104">引发异常后, 它由应用程序或默认异常处理程序进行处理。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-104">After an exception is thrown, it is handled by the application or by the default exception handler.</span></span>  
  
 <span data-ttu-id="d3e6c-105">本节内容：</span><span class="sxs-lookup"><span data-stu-id="d3e6c-105">In this section:</span></span>  
  
 <span data-ttu-id="d3e6c-106">[错误和异常](#Errors) </span><span class="sxs-lookup"><span data-stu-id="d3e6c-106">[Errors and exceptions](#Errors) </span></span>  
 <span data-ttu-id="d3e6c-107">[Try/catch 块](#TryCatch) </span><span class="sxs-lookup"><span data-stu-id="d3e6c-107">[Try/catch blocks](#TryCatch) </span></span>  
 <span data-ttu-id="d3e6c-108">[异常类型功能](#Features) </span><span class="sxs-lookup"><span data-stu-id="d3e6c-108">[Exception type features](#Features) </span></span>  
 <span data-ttu-id="d3e6c-109">[异常类属性](#Properties) </span><span class="sxs-lookup"><span data-stu-id="d3e6c-109">[Exception class properties](#Properties) </span></span>  
 <span data-ttu-id="d3e6c-110">[性能注意事项](#Performance) </span><span class="sxs-lookup"><span data-stu-id="d3e6c-110">[Performance considerations](#Performance) </span></span>  
 <span data-ttu-id="d3e6c-111">[重新引发异常](#Rethrow) </span><span class="sxs-lookup"><span data-stu-id="d3e6c-111">[Re-throwing an exception](#Rethrow) </span></span>  
 <span data-ttu-id="d3e6c-112">[选择标准异常](#Standard) </span><span class="sxs-lookup"><span data-stu-id="d3e6c-112">[Choosing standard exceptions](#Standard) </span></span>  
 [<span data-ttu-id="d3e6c-113">实现自定义异常</span><span class="sxs-lookup"><span data-stu-id="d3e6c-113">Implementing custom exceptions</span></span>](#Custom)  
  
<a name="Errors"></a>   
## <a name="errors-and-exceptions"></a><span data-ttu-id="d3e6c-114">错误和异常</span><span class="sxs-lookup"><span data-stu-id="d3e6c-114">Errors and exceptions</span></span>  
 <span data-ttu-id="d3e6c-115">由于各种原因, 可能会发生运行时错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-115">Run-time errors can occur for a variety of reasons.</span></span> <span data-ttu-id="d3e6c-116">但是, 并非所有错误都应作为代码中的异常处理。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-116">However, not all errors should be handled as exceptions in your code.</span></span> <span data-ttu-id="d3e6c-117">下面是一些可在运行时出现的错误以及相应的响应方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-117">Here are some categories of errors that can occur at run time and the appropriate ways to respond to them.</span></span>  
  
-   <span data-ttu-id="d3e6c-118">**使用错误。**</span><span class="sxs-lookup"><span data-stu-id="d3e6c-118">**Usage errors.**</span></span> <span data-ttu-id="d3e6c-119">使用错误表示程序逻辑中可能会导致异常的错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-119">A usage error represents an error in program logic that can result in an exception.</span></span> <span data-ttu-id="d3e6c-120">但是, 此错误应通过异常处理而不是通过修改错误的代码来解决。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-120">However, the error should be addressed not through exception handling but by modifying the faulty code.</span></span> <span data-ttu-id="d3e6c-121">例如, 以下示例中<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>方法的重写假定`obj`参数必须始终为非 null。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-121">For example, the override of the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method in the following example assumes that the `obj` argument must always be non-null.</span></span>  
  
     [!code-csharp[System.Exception.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors1.cs#4)]
     [!code-vb[System.Exception.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors1.vb#4)]  
  
     <span data-ttu-id="d3e6c-122">`null` <xref:System.Object.Equals%2A?displayProperty=nameWithType>当<xref:System.NullReferenceException> 可以通过在调用重写然后重新编译之前,通过修改源代码来显式测试null,从而导致`obj`出现的异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-122">The <xref:System.NullReferenceException> exception that results when `obj` is `null` can be eliminated by modifying the source code to explicitly test for null before calling the <xref:System.Object.Equals%2A?displayProperty=nameWithType> override and then re-compiling.</span></span> <span data-ttu-id="d3e6c-123">下面的示例包含处理`null`参数的正确源代码。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-123">The following example contains the corrected source code that handles a `null` argument.</span></span>  
  
     [!code-csharp[System.Exception.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/usageerrors2.cs#5)]
     [!code-vb[System.Exception.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/usageerrors2.vb#5)]  
  
     <span data-ttu-id="d3e6c-124">您可以使用<xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType>方法来识别调试生成中的使用错误, <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType>并使用方法标识调试和发布版本中的使用错误, 而不是使用异常处理来处理使用错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-124">Instead of using exception handling for usage errors, you can use the <xref:System.Diagnostics.Debug.Assert%2A?displayProperty=nameWithType> method to identify usage errors in debug builds, and the <xref:System.Diagnostics.Trace.Assert%2A?displayProperty=nameWithType> method to identify usage errors in both debug and release builds.</span></span> <span data-ttu-id="d3e6c-125">有关详细信息，请参阅[托管代码中的断言](/visualstudio/debugger/assertions-in-managed-code)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-125">For more information, see [Assertions in Managed Code](/visualstudio/debugger/assertions-in-managed-code).</span></span>  
  
-   <span data-ttu-id="d3e6c-126">**程序错误。**</span><span class="sxs-lookup"><span data-stu-id="d3e6c-126">**Program errors.**</span></span> <span data-ttu-id="d3e6c-127">程序错误是运行时错误, 不一定要通过编写无错误代码来避免此错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-127">A program error is a run-time error that cannot necessarily be avoided by writing bug-free code.</span></span>  
  
     <span data-ttu-id="d3e6c-128">在某些情况下, 程序错误可能反映了预期的或例程错误情况。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-128">In some cases, a program error may reflect an expected or routine error condition.</span></span> <span data-ttu-id="d3e6c-129">在这种情况下, 你可能希望避免使用异常处理来处理程序错误, 然后重试该操作。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-129">In this case, you may want to avoid using exception handling to deal with the program error and instead retry the operation.</span></span> <span data-ttu-id="d3e6c-130">例如, 如果用户需要以特定格式输入日期, 则可以通过调用<xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType>方法来分析日期字符串, 该方法返回一个<xref:System.Boolean>指示分析操作是否成功的值, 而不是使用<xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType>方法, 如果无法将<xref:System.FormatException>日期字符串<xref:System.DateTime>转换为值, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-130">For example, if the user is expected to input a date in a particular format, you can parse the date string by calling the <xref:System.DateTime.TryParseExact%2A?displayProperty=nameWithType> method, which returns a <xref:System.Boolean> value that indicates whether the parse operation succeeded, instead of using the <xref:System.DateTime.ParseExact%2A?displayProperty=nameWithType> method, which throws a <xref:System.FormatException> exception if the date string cannot be converted to a <xref:System.DateTime> value.</span></span> <span data-ttu-id="d3e6c-131">同样, 如果用户尝试打开不存在的文件, 则可以先调用<xref:System.IO.File.Exists%2A?displayProperty=nameWithType>方法以检查该文件是否存在, 如果不存在, 则提示用户是否要创建该文件。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-131">Similarly, if a user tries to open a file that does not exist, you can first call the <xref:System.IO.File.Exists%2A?displayProperty=nameWithType> method to check whether the file exists and, if it does not, prompt the user whether he or she wants to create it.</span></span>  
  
     <span data-ttu-id="d3e6c-132">在其他情况下, 程序错误反映了可以在代码中处理的意外错误情况。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-132">In other cases, a program error reflects an unexpected error condition that can be handled in your code.</span></span> <span data-ttu-id="d3e6c-133">例如, 即使你已检查以确保文件存在, 也可能会将其删除, 然后才能打开该文件, 否则它可能已损坏。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-133">For example, even if you've checked to ensure that a file exists, it may be deleted before you can open it, or it may be corrupted.</span></span> <span data-ttu-id="d3e6c-134">在这种情况下, 尝试通过实例化<xref:System.IO.StreamReader>对象或<xref:System.IO.File.Open%2A>调用方法打开文件可能会引发<xref:System.IO.FileNotFoundException>异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-134">In that case, trying to open the file by instantiating a <xref:System.IO.StreamReader> object or calling the <xref:System.IO.File.Open%2A> method may throw a <xref:System.IO.FileNotFoundException> exception.</span></span> <span data-ttu-id="d3e6c-135">在这些情况下, 应使用异常处理从错误中恢复。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-135">In these cases, you should use exception handling to recover from the error.</span></span>  
  
-   <span data-ttu-id="d3e6c-136">**系统失败。**</span><span class="sxs-lookup"><span data-stu-id="d3e6c-136">**System failures.**</span></span> <span data-ttu-id="d3e6c-137">系统故障是一个运行时错误, 无法通过编程方式进行处理。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-137">A system failure is a run-time error that cannot be handled programmatically in a meaningful way.</span></span> <span data-ttu-id="d3e6c-138">例如, 如果公共语言运行时无法<xref:System.OutOfMemoryException>分配更多内存, 则任何方法都可能引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-138">For example, any method can throw an <xref:System.OutOfMemoryException> exception if the common language runtime is unable to allocate additional memory.</span></span> <span data-ttu-id="d3e6c-139">通常, 系统故障不是通过使用异常处理来处理的。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-139">Ordinarily, system failures are not handled by using exception handling.</span></span> <span data-ttu-id="d3e6c-140">相反, 你可以使用事件 ( <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>例如), 并<xref:System.Environment.FailFast%2A?displayProperty=nameWithType>调用方法来记录异常信息, 并在应用程序终止之前通知用户失败。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-140">Instead, you may be able to use an event such as <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> and call the <xref:System.Environment.FailFast%2A?displayProperty=nameWithType> method to log exception information and notify the user of the failure before the application terminates.</span></span>  
  
<a name="TryCatch"></a>   
## <a name="trycatch-blocks"></a><span data-ttu-id="d3e6c-141">Try/catch 块</span><span class="sxs-lookup"><span data-stu-id="d3e6c-141">Try/catch blocks</span></span>  
 <span data-ttu-id="d3e6c-142">公共语言运行时提供异常处理模型, 该模型基于作为对象的异常表示形式, 并将程序代码和异常处理代码`try`与块和`catch`块分离。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-142">The common language runtime provides an exception handling model that is based on the representation of exceptions as objects, and the separation of program code and exception handling code into `try` blocks and `catch` blocks.</span></span> <span data-ttu-id="d3e6c-143">可以有一个或多个`catch`块, 每个块用于处理特定类型的异常, 或一个块旨在捕获比另一个块更具体的异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-143">There can be one or more `catch` blocks, each designed to handle a particular type of exception, or one block designed to catch a more specific exception than another block.</span></span>  
  
 <span data-ttu-id="d3e6c-144">如果应用程序处理在执行应用程序代码块的过程中发生的异常, 则必须将代码放置在`try`语句中并将其`try`称为块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-144">If an application handles exceptions that occur during the execution of a block of application code, the code must be placed within a `try` statement and is called a `try` block.</span></span> <span data-ttu-id="d3e6c-145">处理`try`块引发的异常的应用程序代码放置在一个`catch` `catch`语句中, 称为块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-145">Application code that handles exceptions thrown by a `try` block is placed within a `catch` statement and is called a `catch` block.</span></span> <span data-ttu-id="d3e6c-146">与块关联`catch`的零个或多个块, 每`catch`个块都包含一个类型筛选器, 用于确定它处理的异常的类型。 `try`</span><span class="sxs-lookup"><span data-stu-id="d3e6c-146">Zero or more `catch` blocks are associated with a `try` block, and each `catch` block includes a type filter that determines the types of exceptions it handles.</span></span>  
  
 <span data-ttu-id="d3e6c-147">如果`try`块中发生异常, 则系统将按照它们在应用`catch`程序代码中出现的顺序搜索关联的块`catch` , 直到它找到处理异常的块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-147">When an exception occurs in a `try` block, the system searches the associated `catch` blocks in the order they appear in application code, until it locates a `catch` block that handles the exception.</span></span> <span data-ttu-id="d3e6c-148">如果 catch 块的类型筛选器指定`T`或从派生的任何类型, `T`则块将处理类型`T`为的异常。 `catch`</span><span class="sxs-lookup"><span data-stu-id="d3e6c-148">A `catch` block handles an exception of type `T` if the type filter of the catch block specifies `T` or any type that `T` derives from.</span></span> <span data-ttu-id="d3e6c-149">系统在找到处理异常的第一个`catch`块后停止搜索。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-149">The system stops searching after it finds the first `catch` block that handles the exception.</span></span> <span data-ttu-id="d3e6c-150">出于此原因, 在应用程序代码中`catch` , 处理类型的块必须在处理其基`catch`类型的块之前指定, 如本部分后面的示例中所示。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-150">For this reason, in application code, a `catch` block that handles a type must be specified before a `catch` block that handles its base types, as demonstrated in the example that follows this section.</span></span> <span data-ttu-id="d3e6c-151">最后指定处理`System.Exception`程序的 catch 块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-151">A catch block that handles `System.Exception` is specified last.</span></span>  
  
 <span data-ttu-id="d3e6c-152">如果与当前`try`块`catch`关联的所有块均未处理异常, 并且当前`try`块嵌套在当前调用的其他`try`块中, 则`catch`为与下一个关联的块搜索`try`封闭块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-152">If none of the `catch` blocks associated with the current `try` block handle the exception, and the current `try` block is nested within other `try` blocks in the current call, the `catch` blocks associated with the next enclosing `try` block are searched.</span></span> <span data-ttu-id="d3e6c-153">如果未`catch`找到异常的块, 则系统会在当前调用中搜索先前的嵌套级别。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-153">If no `catch` block for the exception is found, the system searches previous nesting levels in the current call.</span></span> <span data-ttu-id="d3e6c-154">如果在`catch`当前调用中找不到异常的块, 则将在调用堆栈中向上传递异常, 并在上一堆栈帧中搜索`catch`处理异常的块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-154">If no `catch` block for the exception is found in the current call, the exception is passed up the call stack, and the previous stack frame is searched for a `catch` block that handles the exception.</span></span> <span data-ttu-id="d3e6c-155">调用堆栈的搜索将继续执行, 直到处理异常或调用堆栈上没有更多的帧为止。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-155">The search of the call stack continues until the exception is handled or until no more frames exist on the call stack.</span></span> <span data-ttu-id="d3e6c-156">如果到达调用堆栈顶部但未找到`catch`处理异常的块, 则默认异常处理程序将处理该异常, 并且应用程序将终止。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-156">If the top of the call stack is reached without finding a `catch` block that handles the exception, the default exception handler handles it and the application terminates.</span></span>  
  
<a name="Features"></a>   
## <a name="exception-type-features"></a><span data-ttu-id="d3e6c-157">异常类型功能</span><span class="sxs-lookup"><span data-stu-id="d3e6c-157">Exception type features</span></span>  
 <span data-ttu-id="d3e6c-158">异常类型支持以下功能:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-158">Exception types support the following features:</span></span>  
  
-   <span data-ttu-id="d3e6c-159">描述错误的用户可读文本。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-159">Human-readable text that describes the error.</span></span> <span data-ttu-id="d3e6c-160">发生异常时, 运行时将向用户提供一条文本消息, 通知用户错误的性质, 并建议采取措施来解决问题。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-160">When an exception occurs, the runtime makes a text message available to inform the user of the nature of the error and to suggest action to resolve the problem.</span></span> <span data-ttu-id="d3e6c-161">此短信保存在异常对象<xref:System.Exception.Message%2A>的属性中。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-161">This text message is held in the <xref:System.Exception.Message%2A> property of the exception object.</span></span> <span data-ttu-id="d3e6c-162">在创建异常对象的过程中, 可以将文本字符串传递到构造函数, 以描述该特定异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-162">During the creation of the exception object, you can pass a text string to the constructor to describe the details of that particular exception.</span></span> <span data-ttu-id="d3e6c-163">如果没有向构造函数提供错误消息参数, 则使用默认错误消息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-163">If no error message argument is supplied to the constructor, the default error message is used.</span></span> <span data-ttu-id="d3e6c-164">有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-164">For more information, see the <xref:System.Exception.Message%2A> property.</span></span>  
  
-   <span data-ttu-id="d3e6c-165">引发异常时的调用堆栈的状态。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-165">The state of the call stack when the exception was thrown.</span></span> <span data-ttu-id="d3e6c-166"><xref:System.Exception.StackTrace%2A>属性带有一个可用于确定代码中错误发生位置的堆栈跟踪。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-166">The <xref:System.Exception.StackTrace%2A> property carries a stack trace that can be used to determine where the error occurs in the code.</span></span> <span data-ttu-id="d3e6c-167">堆栈跟踪会列出调用的所有调用方法和源文件中的行号。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-167">The stack trace lists all the called methods and the line numbers in the source file where the calls are made.</span></span>  
  
<a name="Properties"></a>   
## <a name="exception-class-properties"></a><span data-ttu-id="d3e6c-168">异常类属性</span><span class="sxs-lookup"><span data-stu-id="d3e6c-168">Exception class properties</span></span>  
 <span data-ttu-id="d3e6c-169"><xref:System.Exception.Message%2A> <xref:System.Exception.Source%2A> <xref:System.Exception.HResult%2A> <xref:System.Exception.StackTrace%2A> <xref:System.Exception.HelpLink%2A> <xref:System.Exception.InnerException%2A>类包含多个属性, 这些属性可帮助标识代码位置、类型、帮助文件和异常的原因:、、、、、、 <xref:System.Exception><xref:System.Exception.TargetSite%2A>、和<xref:System.Exception.Data%2A>。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-169">The <xref:System.Exception> class includes a number of properties that help identify the code location, the type, the help file, and the reason for the exception: <xref:System.Exception.StackTrace%2A>, <xref:System.Exception.InnerException%2A>, <xref:System.Exception.Message%2A>, <xref:System.Exception.HelpLink%2A>, <xref:System.Exception.HResult%2A>, <xref:System.Exception.Source%2A>, <xref:System.Exception.TargetSite%2A>, and <xref:System.Exception.Data%2A>.</span></span>  
  
 <span data-ttu-id="d3e6c-170">当两个或多个异常之间存在因果关系时<xref:System.Exception.InnerException%2A> , 属性将保留该信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-170">When a causal relationship exists between two or more exceptions, the <xref:System.Exception.InnerException%2A> property maintains this information.</span></span> <span data-ttu-id="d3e6c-171">为响应此内部异常而引发外部异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-171">The outer exception is thrown in response to this inner exception.</span></span> <span data-ttu-id="d3e6c-172">处理外部异常的代码可以使用以前的内部异常的信息更恰当地处理错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-172">The code that handles the outer exception can use the information from the earlier inner exception to handle the error more appropriately.</span></span> <span data-ttu-id="d3e6c-173">有关异常的补充信息可以存储为<xref:System.Exception.Data%2A>属性中的键/值对的集合。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-173">Supplementary information about the exception can be stored as a collection of key/value pairs in the <xref:System.Exception.Data%2A> property.</span></span>  
  
 <span data-ttu-id="d3e6c-174">在创建异常对象的过程中, 传递给构造函数的错误消息字符串应本地化, 并可通过使用<xref:System.Resources.ResourceManager>类从资源文件提供。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-174">The error message string that is passed to the constructor during the creation of the exception object should be localized and can be supplied from a resource file by using the <xref:System.Resources.ResourceManager> class.</span></span> <span data-ttu-id="d3e6c-175">有关本地化资源的详细信息, 请参阅[创建附属程序集](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md)和[打包和部署资源](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md)主题。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-175">For more information about localized resources, see the [Creating Satellite Assemblies](~/docs/framework/resources/creating-satellite-assemblies-for-desktop-apps.md) and [Packaging and Deploying Resources](~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md) topics.</span></span>  
  
 <span data-ttu-id="d3e6c-176">若要为用户提供有关异常发生原因的详细信息, <xref:System.Exception.HelpLink%2A>属性可以将 URL (或 URN) 保存到帮助文件。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-176">To provide the user with extensive information about why the exception occurred, the <xref:System.Exception.HelpLink%2A> property can hold a URL (or URN) to a help file.</span></span>  
  
 <span data-ttu-id="d3e6c-177"><xref:System.Exception>类使用的 HRESULT COR_E_EXCEPTION, 其值为0x80131500。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-177">The <xref:System.Exception> class uses the HRESULT COR_E_EXCEPTION, which has the value 0x80131500.</span></span>  
  
 <span data-ttu-id="d3e6c-178">有关<xref:System.Exception>类的实例的初始属性值的列表, <xref:System.Exception.%23ctor%2A>请参见构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-178">For a list of initial property values for an instance of the <xref:System.Exception> class, see the <xref:System.Exception.%23ctor%2A> constructors.</span></span>  
  
<a name="Performance"></a>   
## <a name="performance-considerations"></a><span data-ttu-id="d3e6c-179">性能注意事项</span><span class="sxs-lookup"><span data-stu-id="d3e6c-179">Performance considerations</span></span>  
 <span data-ttu-id="d3e6c-180">引发或处理异常消耗大量的系统资源和执行时间。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-180">Throwing or handling an exception consumes a significant amount of system resources and execution time.</span></span> <span data-ttu-id="d3e6c-181">仅引发异常来处理真正非常特别的情况, 而不是处理可预测的事件或流控制。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-181">Throw exceptions only to handle truly extraordinary conditions, not to handle predictable events or flow control.</span></span> <span data-ttu-id="d3e6c-182">例如, 在某些情况下, 例如在开发类库时, 如果方法参数无效, 则应引发异常, 因为你希望使用有效的参数调用方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-182">For example, in some cases, such as when you're developing a class library, it's reasonable to throw an exception if a method argument is invalid, because you expect your method to be called with valid parameters.</span></span> <span data-ttu-id="d3e6c-183">无效的方法参数, 如果不是使用错误的结果, 则表示发生了异常情况。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-183">An invalid method argument, if it is not the result of a usage error, means that something extraordinary has occurred.</span></span> <span data-ttu-id="d3e6c-184">相反, 如果用户输入无效, 则不会引发异常, 因为你可能希望用户偶尔输入无效数据。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-184">Conversely, do not throw an exception if user input is invalid, because you can expect users to occasionally enter invalid data.</span></span> <span data-ttu-id="d3e6c-185">相反, 请提供重试机制, 以便用户可以输入有效输入。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-185">Instead, provide a retry mechanism so users can enter valid input.</span></span> <span data-ttu-id="d3e6c-186">也不应使用异常来处理使用错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-186">Nor should you use exceptions to handle usage errors.</span></span> <span data-ttu-id="d3e6c-187">请改用[断言](/visualstudio/debugger/assertions-in-managed-code)来确定和更正使用错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-187">Instead, use [assertions](/visualstudio/debugger/assertions-in-managed-code) to identify and correct usage errors.</span></span>  
  
 <span data-ttu-id="d3e6c-188">此外, 如果返回代码足够, 则不要引发异常;不要将返回代码转换为异常;并且不要定期捕获异常、将其忽略, 然后继续处理。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-188">In addition, do not throw an exception when a return code is sufficient; do not convert a return code to an exception; and do not routinely catch an exception, ignore it, and then continue processing.</span></span>  
  
<a name="Rethrow"></a>   
## <a name="re-throwing-an-exception"></a><span data-ttu-id="d3e6c-189">重新引发异常</span><span class="sxs-lookup"><span data-stu-id="d3e6c-189">Re-throwing an exception</span></span>  
 <span data-ttu-id="d3e6c-190">在许多情况下, 异常处理程序只需要将异常传递给调用方。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-190">In many cases, an exception handler simply wants to pass the exception on to the caller.</span></span> <span data-ttu-id="d3e6c-191">最常见的情况是:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-191">This most often occurs in:</span></span>  
  
-   <span data-ttu-id="d3e6c-192">一个类库, 用于包装对 .NET Framework 类库或其他类库中的方法的调用。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-192">A class library that in turn wraps calls to methods in the .NET Framework class library or other class libraries.</span></span>  
  
-   <span data-ttu-id="d3e6c-193">遇到严重异常的应用程序或库。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-193">An application or library that encounters a fatal exception.</span></span> <span data-ttu-id="d3e6c-194">异常处理程序可以记录异常, 然后重新引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-194">The exception handler can log the exception and then re-throw the exception.</span></span>  
  
 <span data-ttu-id="d3e6c-195">重新引发异常的建议方法是只使用中C#的[throw](~/docs/csharp/language-reference/keywords/throw.md)语句和 Visual Basic 中的[throw](~/docs/visual-basic/language-reference/statements/throw-statement.md)语句, 而不包括表达式。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-195">The recommended way to re-throw an exception is to simply use the [throw](~/docs/csharp/language-reference/keywords/throw.md) statement in C# and the [Throw](~/docs/visual-basic/language-reference/statements/throw-statement.md) statement in Visual Basic without including an expression.</span></span> <span data-ttu-id="d3e6c-196">这可确保在异常传播到调用方时, 保留所有调用堆栈信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-196">This ensures that all call stack information is preserved when the exception is propagated to the caller.</span></span> <span data-ttu-id="d3e6c-197">下面的示例阐释了这一点。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-197">The following example illustrates this.</span></span> <span data-ttu-id="d3e6c-198">字符串扩展方法`FindOccurrences`将一个或多个调用包装到<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> , 但不事先验证其参数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-198">A string extension method, `FindOccurrences`, wraps one or more calls to <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> without validating its arguments beforehand.</span></span>  
  
 [!code-csharp[System.Exception.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#6)]
 [!code-vb[System.Exception.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#6)]  
  
 <span data-ttu-id="d3e6c-199">然后, 调用方`FindOccurrences`调用两次。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-199">A caller then calls `FindOccurrences` twice.</span></span> <span data-ttu-id="d3e6c-200">在第二次调用`FindOccurrences`中, 调用方将`null`作为搜索<xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>字符串进行传递, 这将引发<xref:System.ArgumentNullException>异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-200">In the second call to `FindOccurrences`, the caller passes a `null` as the search string, which cases the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29?displayProperty=nameWithType> method to throw an <xref:System.ArgumentNullException> exception.</span></span> <span data-ttu-id="d3e6c-201">此异常由`FindOccurrences`方法进行处理并传递回调用方。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-201">This exception is handled by the `FindOccurrences` method and passed back to the caller.</span></span> <span data-ttu-id="d3e6c-202">由于 throw 语句与 no 表达式一起使用, 因此该示例的输出显示调用堆栈被保留。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-202">Because the throw statement is used with no expression, the output from the example shows that the call stack is preserved.</span></span>  
  
 [!code-csharp[System.Exception.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow1.cs#7)]
 [!code-vb[System.Exception.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow1.vb#7)]  
  
 <span data-ttu-id="d3e6c-203">相反, 如果使用引发异常,</span><span class="sxs-lookup"><span data-stu-id="d3e6c-203">In contrast, if the exception is re-thrown by using the</span></span>  
  
```csharp  
throw e  
```  
  
```vb  
Throw e  
```  
  
 <span data-ttu-id="d3e6c-204">语句时, 将不保留完全调用堆栈, 示例将生成以下输出:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-204">statement, the full call stack is not preserved, and the example would generate the following output:</span></span>  
  
```Output  
  
'a' occurs at the following character positions: 4, 7, 15  
  
An exception (ArgumentNullException) occurred.  
Message:  
   Value cannot be null.  
Parameter name: value  
  
Stack Trace:  
      at Library.FindOccurrences(String s, String f)  
   at Example.Main()  
  
```  
  
 <span data-ttu-id="d3e6c-205">一种更繁琐的替代方法是引发新异常, 并在内部异常中保留原始异常的调用堆栈信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-205">A slightly more cumbersome alternative is to throw a new exception, and to preserve the original exception's call stack information in an inner exception.</span></span> <span data-ttu-id="d3e6c-206">然后, 调用方可以使用新异常的<xref:System.Exception.InnerException%2A>属性来检索堆栈帧以及有关原始异常的其他信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-206">The caller can then use the new exception's <xref:System.Exception.InnerException%2A> property to retrieve stack frame and other information about the original exception.</span></span> <span data-ttu-id="d3e6c-207">在这种情况下, throw 语句为:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-207">In this case, the throw statement is:</span></span>  
  
 [!code-csharp[System.Exception.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#8)]
 [!code-vb[System.Exception.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#8)]  
  
 <span data-ttu-id="d3e6c-208">处理异常的用户代码必须知道<xref:System.Exception.InnerException%2A>属性包含有关原始异常的信息, 如下面的异常处理程序所示。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-208">The user code that handles the exception has to know that the <xref:System.Exception.InnerException%2A> property contains information about the original exception, as the following exception handler illustrates.</span></span>  
  
 [!code-csharp[System.Exception.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/rethrow3.cs#9)]
 [!code-vb[System.Exception.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/rethrow3.vb#9)]  
  
<a name="Standard"></a>   
## <a name="choosing-standard-exceptions"></a><span data-ttu-id="d3e6c-209">选择标准异常</span><span class="sxs-lookup"><span data-stu-id="d3e6c-209">Choosing standard exceptions</span></span>  
 <span data-ttu-id="d3e6c-210">当必须引发异常时, 通常可以使用 .NET Framework 中的现有异常类型, 而不是实现自定义异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-210">When you have to throw an exception, you can often use an existing exception type in the .NET Framework instead of implementing a custom exception.</span></span> <span data-ttu-id="d3e6c-211">在以下两种情况下, 应使用标准异常类型:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-211">You should use a standard exception type under these two conditions:</span></span>  
  
-   <span data-ttu-id="d3e6c-212">引发的异常是由使用错误 (即, 调用方法的开发人员发出的程序逻辑中的错误) 引起的。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-212">You are throwing an exception that is caused by a usage error (that is, by an error in program logic made by the developer who is calling your method).</span></span> <span data-ttu-id="d3e6c-213">通常情况下<xref:System.ArgumentException>, 会引发异常, 如、 <xref:System.ArgumentNullException>、 <xref:System.InvalidOperationException>或。 <xref:System.NotSupportedException></span><span class="sxs-lookup"><span data-stu-id="d3e6c-213">Typically, you would throw an exception such as <xref:System.ArgumentException>, <xref:System.ArgumentNullException>, <xref:System.InvalidOperationException>, or <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="d3e6c-214">在实例化异常对象时, 为异常对象的构造函数提供的字符串应描述错误, 使开发人员能够修复该错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-214">The string you supply to the exception object's constructor when instantiating the exception object should describe the error so that the developer can fix it.</span></span> <span data-ttu-id="d3e6c-215">有关更多信息，请参见 <xref:System.Exception.Message%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-215">For more information, see the <xref:System.Exception.Message%2A> property.</span></span>  
  
-   <span data-ttu-id="d3e6c-216">你正在处理一个错误, 该错误可以通过现有 .NET Framework 异常传达给调用方。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-216">You are handling an error that can be communicated to the caller with an existing .NET Framework exception.</span></span> <span data-ttu-id="d3e6c-217">应引发可能派生程度最高的异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-217">You should throw the most derived exception possible.</span></span> <span data-ttu-id="d3e6c-218">例如, 如果某个方法要求参数为枚举类型的有效成员, 则应引发<xref:System.ComponentModel.InvalidEnumArgumentException> (派生程度最高的类) 而不是。 <xref:System.ArgumentException></span><span class="sxs-lookup"><span data-stu-id="d3e6c-218">For example, if a method requires an argument to be a valid member of an enumeration type, you should throw an <xref:System.ComponentModel.InvalidEnumArgumentException> (the most derived class) rather than an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="d3e6c-219">下表列出了常见的异常类型和引发这些类型的条件。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-219">The following table lists common exception types and the conditions under which you would throw them.</span></span>  
  
|<span data-ttu-id="d3e6c-220">例外</span><span class="sxs-lookup"><span data-stu-id="d3e6c-220">Exception</span></span>|<span data-ttu-id="d3e6c-221">条件</span><span class="sxs-lookup"><span data-stu-id="d3e6c-221">Condition</span></span>|  
|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="d3e6c-222">传递给方法的非 null 参数无效。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-222">A non-null argument that is passed to a method is invalid.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="d3e6c-223">传递给方法的参数是`null`。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-223">An argument that is passed to a method is `null`.</span></span>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="d3e6c-224">参数超出了有效值的范围。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-224">An argument is outside the range of valid values.</span></span>|  
|<xref:System.IO.DirectoryNotFoundException>|<span data-ttu-id="d3e6c-225">部分目录路径无效。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-225">Part of a directory path is not valid.</span></span>|  
|<xref:System.DivideByZeroException>|<span data-ttu-id="d3e6c-226">整数或<xref:System.Decimal>除法运算中的分母为零。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-226">The denominator in an integer or <xref:System.Decimal> division operation is zero.</span></span>|  
|<xref:System.IO.DriveNotFoundException>|<span data-ttu-id="d3e6c-227">驱动器不可用或不存在。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-227">A drive is unavailable or does not exist.</span></span>|  
|<xref:System.IO.FileNotFoundException>|<span data-ttu-id="d3e6c-228">文件不存在。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-228">A file does not exist.</span></span>|  
|<xref:System.FormatException>|<span data-ttu-id="d3e6c-229">值的格式不正确, 无法通过转换方法 (如) `Parse`从字符串进行转换。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-229">A value is not in an appropriate format to be converted from a string by a conversion method such as `Parse`.</span></span>|  
|<xref:System.IndexOutOfRangeException>|<span data-ttu-id="d3e6c-230">索引超出数组或集合的界限。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-230">An index is outside the bounds of an array or collection.</span></span>|  
|<xref:System.InvalidOperationException>|<span data-ttu-id="d3e6c-231">对象的当前状态中的方法调用无效。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-231">A method call is invalid in an object's current state.</span></span>|  
|<xref:System.Collections.Generic.KeyNotFoundException>|<span data-ttu-id="d3e6c-232">找不到用于访问集合中的成员的指定键。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-232">The specified key for accessing a member in a collection cannot be found.</span></span>|  
|<xref:System.NotImplementedException>|<span data-ttu-id="d3e6c-233">未实现方法或操作。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-233">A method or operation is not implemented.</span></span>|  
|<xref:System.NotSupportedException>|<span data-ttu-id="d3e6c-234">不支持方法或操作。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-234">A method or operation is not supported.</span></span>|  
|<xref:System.ObjectDisposedException>|<span data-ttu-id="d3e6c-235">对已释放的对象执行操作。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-235">An operation is performed on an object that has been disposed.</span></span>|  
|<xref:System.OverflowException>|<span data-ttu-id="d3e6c-236">算术、强制转换或转换运算导致溢出。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-236">An arithmetic, casting, or conversion operation results in an overflow.</span></span>|  
|<xref:System.IO.PathTooLongException>|<span data-ttu-id="d3e6c-237">路径或文件名超出了系统定义的最大长度。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-237">A path or file name exceeds the maximum system-defined length.</span></span>|  
|<xref:System.PlatformNotSupportedException>|<span data-ttu-id="d3e6c-238">当前平台不支持此操作。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-238">The operation is not supported on the current platform.</span></span>|  
|<xref:System.RankException>|<span data-ttu-id="d3e6c-239">具有错误维数的数组将传递给方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-239">An array with the wrong number of dimensions is passed to a method.</span></span>|  
|<xref:System.TimeoutException>|<span data-ttu-id="d3e6c-240">分配给操作的时间间隔已过期。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-240">The time interval allotted to an operation has expired.</span></span>|  
|<xref:System.UriFormatException>|<span data-ttu-id="d3e6c-241">使用了无效的统一资源标识符 (URI)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-241">An invalid Uniform Resource Identifier (URI) is used.</span></span>|  
  
<a name="Custom"></a>   
## <a name="implementing-custom-exceptions"></a><span data-ttu-id="d3e6c-242">实现自定义异常</span><span class="sxs-lookup"><span data-stu-id="d3e6c-242">Implementing custom exceptions</span></span>  
 <span data-ttu-id="d3e6c-243">在以下情况下, 使用现有 .NET Framework 异常来处理错误条件是不够的:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-243">In the following cases, using an existing .NET Framework exception to handle an error condition is not adequate:</span></span>  
  
-   <span data-ttu-id="d3e6c-244">如果异常反映了无法映射到现有 .NET Framework 异常的唯一程序错误, 则为。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-244">When the exception reflects a unique program error that cannot be mapped to an existing .NET Framework exception.</span></span>  
  
-   <span data-ttu-id="d3e6c-245">当异常要求的处理与适用于现有 .NET Framework 异常的处理不同时, 或者必须从类似的异常中消除异常时。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-245">When the exception requires handling that is different from the handling that is appropriate for an existing .NET Framework exception, or the exception must be disambiguated from a similar exception.</span></span> <span data-ttu-id="d3e6c-246">例如, 如果在分析超出目标<xref:System.ArgumentOutOfRangeException>整数类型范围的字符串的数值表示形式时引发异常, 则不希望对由调用方提供的错误产生的错误使用相同的异常调用方法时相应的约束值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-246">For example, if you throw an <xref:System.ArgumentOutOfRangeException> exception when parsing the numeric representation of a string that is out of range of the target integral type, you would not want to use the same exception for an error that results from the caller not supplying the appropriate constrained values when calling the method.</span></span>  
  
 <span data-ttu-id="d3e6c-247"><xref:System.Exception>类是 .NET Framework 中所有异常的基类。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-247">The <xref:System.Exception> class is the base class of all exceptions in the .NET Framework.</span></span> <span data-ttu-id="d3e6c-248">许多派生类依赖于<xref:System.Exception>类的成员的继承行为; 它们不会重写的<xref:System.Exception>成员, 也不定义任何唯一成员。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-248">Many derived classes rely on the inherited behavior of the members of the <xref:System.Exception> class; they do not override the members of <xref:System.Exception>, nor do they define any unique members.</span></span>  
  
 <span data-ttu-id="d3e6c-249">定义自己的异常类:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-249">To define your own exception class:</span></span>  
  
1.  <span data-ttu-id="d3e6c-250">定义继承自<xref:System.Exception>的类。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-250">Define a class that inherits from <xref:System.Exception>.</span></span> <span data-ttu-id="d3e6c-251">如有必要, 定义类所需的任何唯一成员以提供有关异常的其他信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-251">If necessary, define any unique members needed by your class to provide additional information about the exception.</span></span> <span data-ttu-id="d3e6c-252">例如, <xref:System.ArgumentException>类包含一个<xref:System.ArgumentException.ParamName%2A>属性, 该属性指定其自变量导致异常的参数的名称, 而<xref:System.Text.RegularExpressions.RegexMatchTimeoutException>属性包含一个<xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A>指示超时间隔的属性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-252">For example, the <xref:System.ArgumentException> class includes a <xref:System.ArgumentException.ParamName%2A> property that specifies the name of the parameter whose argument caused the exception, and the <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> property includes a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException.MatchTimeout%2A> property that indicates the time-out interval.</span></span>  
  
2.  <span data-ttu-id="d3e6c-253">如有必要, 请重写要更改或修改其功能的任何继承成员。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-253">If necessary, override any inherited members whose functionality you want to change or modify.</span></span> <span data-ttu-id="d3e6c-254">请注意, 的<xref:System.Exception>大多数现有派生类不会重写继承成员的行为。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-254">Note that most existing derived classes of <xref:System.Exception> do not override the behavior of inherited members.</span></span>  
  
3.  <span data-ttu-id="d3e6c-255">确定自定义异常对象是否为可序列化。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-255">Determine whether your custom exception object is serializable.</span></span> <span data-ttu-id="d3e6c-256">序列化使你可以保存有关异常的信息, 并允许服务器和客户端代理共享上下文中的异常信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-256">Serialization enables you to save information about the exception and permits exception information to be shared by a server and a client proxy in a remoting context.</span></span> <span data-ttu-id="d3e6c-257">若要使异常对象可序列化, 请用<xref:System.SerializableAttribute>特性标记它。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-257">To make the exception object serializable, mark it with the <xref:System.SerializableAttribute> attribute.</span></span>  
  
4.  <span data-ttu-id="d3e6c-258">定义异常类的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-258">Define the constructors of your exception class.</span></span> <span data-ttu-id="d3e6c-259">通常, 异常类具有一个或多个以下构造函数:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-259">Typically, exception classes have one or more of the following constructors:</span></span>  
  
    -   <span data-ttu-id="d3e6c-260"><xref:System.Exception.%23ctor>, 它使用默认值来初始化新异常对象的属性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-260"><xref:System.Exception.%23ctor>, which uses default values to initialize the properties of a new exception object.</span></span>  
  
    -   <span data-ttu-id="d3e6c-261"><xref:System.Exception.%23ctor%28System.String%29>, 它使用指定的错误消息初始化新的异常对象。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-261"><xref:System.Exception.%23ctor%28System.String%29>, which initializes a new exception object with a specified error message.</span></span>  
  
    -   <span data-ttu-id="d3e6c-262"><xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, 它使用指定的错误消息和内部异常初始化新的异常对象。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-262"><xref:System.Exception.%23ctor%28System.String%2CSystem.Exception%29>, which initializes a new exception object with a specified error message and inner exception.</span></span>  
  
    -   <span data-ttu-id="d3e6c-263"><xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, 它是`protected`从序列化数据中初始化新异常对象的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-263"><xref:System.Exception.%23ctor%28System.Runtime.Serialization.SerializationInfo%2CSystem.Runtime.Serialization.StreamingContext%29>, which is a `protected` constructor that initializes a new exception object from serialized data.</span></span> <span data-ttu-id="d3e6c-264">如果已选择使异常对象可序列化, 则应实现此构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-264">You should implement this constructor if you've chosen to make your exception object serializable.</span></span>  
  
 <span data-ttu-id="d3e6c-265">下面的示例演示如何使用自定义异常类。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-265">The following example illustrates the use of a custom exception class.</span></span> <span data-ttu-id="d3e6c-266">它定义一个`NotPrimeException`异常, 当客户端尝试通过指定不是质数的起始数字来检索质数序列时, 将引发此异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-266">It defines a `NotPrimeException` exception that is thrown when a client tries to retrieve a sequence of prime numbers by specifying a starting number that is not prime.</span></span> <span data-ttu-id="d3e6c-267">异常定义了一个新的属性`NonPrime`, 该属性返回导致异常的非质数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-267">The exception defines a new property, `NonPrime`, that returns the non-prime number that caused the exception.</span></span> <span data-ttu-id="d3e6c-268">除了使用<xref:System.Runtime.Serialization.SerializationInfo>和序列化和<xref:System.Runtime.Serialization.StreamingContext> `NotPrimeException`参数实现受保护的无参数构造函数和构造函数以外, `NonPrime`类还定义了三个其他构造函数来支持属性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-268">Besides implementing a protected parameterless constructor and a constructor with <xref:System.Runtime.Serialization.SerializationInfo> and <xref:System.Runtime.Serialization.StreamingContext> parameters for serialization, the `NotPrimeException` class defines three additional constructors to support the `NonPrime` property.</span></span>  <span data-ttu-id="d3e6c-269">每个构造函数都调用基类构造函数, 同时保留非质数的值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-269">Each constructor calls a base class constructor in addition to preserving the value of the non-prime number.</span></span> <span data-ttu-id="d3e6c-270">`NotPrimeException`类还<xref:System.SerializableAttribute>用特性标记。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-270">The `NotPrimeException` class is also marked with the <xref:System.SerializableAttribute> attribute.</span></span>  
  
 [!code-csharp[System.Exception.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/notprimeexception.cs#1)]
 [!code-vb[System.Exception.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/notprimeexception.vb#1)]  
  
 <span data-ttu-id="d3e6c-271">下面的示例中所示的类使用尼斯筛法的埃拉托色,计算从2到客户端在调用其类构造函数时指定的限制的质数序列。`PrimeNumberGenerator`</span><span class="sxs-lookup"><span data-stu-id="d3e6c-271">The `PrimeNumberGenerator` class shown in the following example uses the Sieve of Eratosthenes to calculate the sequence of prime numbers from 2 to a limit specified by the client in the call to its class constructor.</span></span> <span data-ttu-id="d3e6c-272">方法返回大于或等于指定下限的所有质数, 但`NotPrimeException`如果下限不是质数, 则会引发。 `GetPrimesFrom`</span><span class="sxs-lookup"><span data-stu-id="d3e6c-272">The `GetPrimesFrom` method returns all prime numbers that are greater than or equal to a specified lower limit, but throws a `NotPrimeException` if that lower limit is not a prime number.</span></span>  
  
 [!code-csharp[System.Exception.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/primenumbergenerator.cs#2)]
 [!code-vb[System.Exception.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/primenumbergenerator.vb#2)]  
  
 <span data-ttu-id="d3e6c-273">下面的示例对具有非质数的`GetPrimesFrom`方法进行两次调用, 其中一个值与应用程序域边界交叉。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-273">The following example makes two calls to the `GetPrimesFrom` method with non-prime numbers, one of which crosses application domain boundaries.</span></span> <span data-ttu-id="d3e6c-274">在这两种情况下, 异常都将引发并在客户端代码中成功处理。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-274">In both cases, the exception is thrown and successfully handled in client code.</span></span>  
  
 [!code-csharp[System.Exception.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.class/cs/example.cs#3)]
 [!code-vb[System.Exception.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.class/vb/example.vb#3)]  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a><span data-ttu-id="d3e6c-275">Windows 运行时和[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d3e6c-275">Windows Runtime and [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span></span>  
 <span data-ttu-id="d3e6c-276">[!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] 对于[!INCLUDE[win8](~/includes/win8-md.md)], 在通过 non-.NET Framework 堆栈帧传播异常时, 某些异常信息通常会丢失。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-276">In [!INCLUDE[net_win8_profile](~/includes/net-win8-profile-md.md)] for [!INCLUDE[win8](~/includes/win8-md.md)], some exception information is typically lost when an exception is propagated through non-.NET Framework stack frames.</span></span> <span data-ttu-id="d3e6c-277">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]从和[!INCLUDE[win81](~/includes/win81-md.md)]开始, 公共语言运行时将继续使用引发的原始<xref:System.Exception>对象, 除非在 non-.NET Framework 堆栈帧中修改了该异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-277">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)] and [!INCLUDE[win81](~/includes/win81-md.md)], the common language runtime continues to use the original <xref:System.Exception> object that was thrown unless that exception was modified in a non-.NET Framework stack frame.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-278">下面的示例演示`catch`了定义用于处理<xref:System.ArithmeticException>错误的块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-278">The following example demonstrates a `catch` block that is defined to handle <xref:System.ArithmeticException> errors.</span></span> <span data-ttu-id="d3e6c-279">此`catch`块还会<xref:System.DivideByZeroException>捕获错误, <xref:System.DivideByZeroException>因为派生<xref:System.ArithmeticException>自, 并且没有`catch`显式定义错误的<xref:System.DivideByZeroException>块。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-279">This `catch` block also catches <xref:System.DivideByZeroException> errors, because <xref:System.DivideByZeroException> derives from <xref:System.ArithmeticException> and there is no `catch` block explicitly defined for <xref:System.DivideByZeroException> errors.</span></span>  
  
 [!code-cpp[CatchException#1](~/samples/snippets/cpp/VS_Snippets_CLR/CatchException/CPP/catchexception.cpp#1)]
 [!code-csharp[CatchException#1](~/samples/snippets/csharp/VS_Snippets_CLR/CatchException/CS/catchexception.cs#1)]
 [!code-vb[CatchException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CatchException/VB/catchexception.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/exceptions/index.md"><span data-ttu-id="d3e6c-280">处理和引发异常</span><span class="sxs-lookup"><span data-stu-id="d3e6c-280">Handling and Throwing Exceptions</span></span></related>
    <related type="Article" href="~/docs/framework/resources/packaging-and-deploying-resources-in-desktop-apps.md"><span data-ttu-id="d3e6c-281">打包和部署桌面应用程序中的资源</span><span class="sxs-lookup"><span data-stu-id="d3e6c-281">Packaging and Deploying Resources in Desktop Apps</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/70ab2522-6486-4076-a1a9-e0f11cd0f3a1"><span data-ttu-id="d3e6c-282">托管代码中的断言</span><span class="sxs-lookup"><span data-stu-id="d3e6c-282">Assertions in Managed Code</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d3e6c-283">初始化 <see cref="T:System.Exception" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-283">Initializes a new instance of the <see cref="T:System.Exception" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3e6c-284">初始化 <see cref="T:System.Exception" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-284">Initializes a new instance of the <see cref="T:System.Exception" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-285">此构造函数将新实例的 <xref:System.Exception.Message%2A> 属性初始化为系统提供的消息，该消息描述错误并考虑当前系统区域性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-285">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance to a system-supplied message that describes the error and takes into account the current system culture.</span></span>  
  
 <span data-ttu-id="d3e6c-286">所有派生类应提供此无参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-286">All the derived classes should provide this parameterless constructor.</span></span> <span data-ttu-id="d3e6c-287">下表显示 <xref:System.Exception> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-287">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="d3e6c-288">Property</span><span class="sxs-lookup"><span data-stu-id="d3e6c-288">Property</span></span>|<span data-ttu-id="d3e6c-289">“值”</span><span class="sxs-lookup"><span data-stu-id="d3e6c-289">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="d3e6c-290">空引用（在 Visual Basic 中为 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-290">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="d3e6c-291">系统提供的本地化说明。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-291">A system-supplied localized description.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-292">下面的代码示例派生了`Exception`一个使用预定义的消息的。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-292">The following code example derives an `Exception` that uses a predefined message.</span></span> <span data-ttu-id="d3e6c-293">此代码演示如何使用派生类和基类`Exception`的无参数构造函数。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-293">The code demonstrates the use of the parameterless constructor for the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/new.cpp#1)]
 [!code-csharp[System.Exception.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/new.cs#1)]
 [!code-vb[System.Exception.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/new.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new Exception : string -&gt; Exception" Usage="new System.Exception message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="d3e6c-294">描述错误的消息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-294">The message that describes the error.</span></span></param>
        <summary><span data-ttu-id="d3e6c-295">用指定的错误消息初始化 <see cref="T:System.Exception" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-295">Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-296">此构造函数`message`使用<xref:System.Exception.Message%2A>参数初始化新实例的属性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-296">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance by using the `message` parameter.</span></span> <span data-ttu-id="d3e6c-297">如果参数为`null`, 则与调用<xref:System.Exception.%23ctor%2A>构造函数相同。 `message`</span><span class="sxs-lookup"><span data-stu-id="d3e6c-297">If the `message` parameter is `null`, this is the same as calling the <xref:System.Exception.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="d3e6c-298">下表显示 <xref:System.Exception> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-298">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="d3e6c-299">Property</span><span class="sxs-lookup"><span data-stu-id="d3e6c-299">Property</span></span>|<span data-ttu-id="d3e6c-300">“值”</span><span class="sxs-lookup"><span data-stu-id="d3e6c-300">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="d3e6c-301">空引用（在 Visual Basic 中为 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-301">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="d3e6c-302">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-302">The error message string.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-303">下面的代码示例`Exception`为特定条件派生。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-303">The following code example derives an `Exception` for a specific condition.</span></span> <span data-ttu-id="d3e6c-304">此代码演示如何使用采用调用方指定消息作为参数的构造函数, 同时用于派生类和基类`Exception` 。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-304">The code demonstrates the use of the constructor that takes a caller-specified message as a parameter, for both the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/news.cpp#2)]
 [!code-csharp[System.Exception.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/news.cs#2)]
 [!code-vb[System.Exception.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/news.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Exception (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new Exception : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; Exception" Usage="new System.Exception (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="d3e6c-305">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-305">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</span></span></param>
        <param name="context"><span data-ttu-id="d3e6c-306"><see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-306">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</span></span></param>
        <summary><span data-ttu-id="d3e6c-307">用序列化数据初始化 <see cref="T:System.Exception" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-307">Initializes a new instance of the <see cref="T:System.Exception" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-308">此构造函数在反序列化过程中调用，以便重建通过流传输的异常对象。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-308">This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</span></span> <span data-ttu-id="d3e6c-309">有关详细信息，请参阅[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-309">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-310">下面的代码示例定义了一个派生`Exception`的可序列化类。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-310">The following code example defines a derived serializable `Exception` class.</span></span> <span data-ttu-id="d3e6c-311">此代码强制执行被零除错误, 然后使用 (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) 构造函数创建派生异常的实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-311">The code forces a divide-by-0 error and then creates an instance of the derived exception using the (<xref:System.Runtime.Serialization.SerializationInfo>, <xref:System.Runtime.Serialization.StreamingContext>) constructor.</span></span> <span data-ttu-id="d3e6c-312">该代码将实例序列化为文件, 将该文件反序列化为一个新异常, 引发该异常, 然后捕获并显示该异常的数据。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-312">The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</span></span>  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3e6c-313"><paramref name="info" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-313"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.Serialization.SerializationException"><span data-ttu-id="d3e6c-314">类名为 <see langword="null" /> 或者 <see cref="P:System.Exception.HResult" /> 为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-314">The class name is <see langword="null" /> or <see cref="P:System.Exception.HResult" /> is zero (0).</span></span></exception>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md"><span data-ttu-id="d3e6c-315">XML 和 SOAP 序列化</span><span class="sxs-lookup"><span data-stu-id="d3e6c-315">XML and SOAP Serialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Exception (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Exception(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new Exception : string * Exception -&gt; Exception" Usage="new System.Exception (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="d3e6c-316">解释异常原因的错误消息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-316">The error message that explains the reason for the exception.</span></span></param>
        <param name="innerException"><span data-ttu-id="d3e6c-317">导致当前异常的异常；如果未指定内部异常，则是一个 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-317">The exception that is the cause of the current exception, or a null reference (<see langword="Nothing" /> in Visual Basic) if no inner exception is specified.</span></span></param>
        <summary><span data-ttu-id="d3e6c-318">使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.Exception" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-318">Initializes a new instance of the <see cref="T:System.Exception" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-319">因前一个异常而直接引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-319">An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <xref:System.Exception.InnerException%2A> property.</span></span> <span data-ttu-id="d3e6c-320"><xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-320">The <xref:System.Exception.InnerException%2A> property returns the same value that is passed into the constructor, or a null reference (`Nothing` in Visual Basic) if the <xref:System.Exception.InnerException%2A> property does not supply the inner exception value to the constructor.</span></span>  
  
 <span data-ttu-id="d3e6c-321">下表显示 <xref:System.Exception> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-321">The following table shows the initial property values for an instance of <xref:System.Exception>.</span></span>  
  
|<span data-ttu-id="d3e6c-322">Property</span><span class="sxs-lookup"><span data-stu-id="d3e6c-322">Property</span></span>|<span data-ttu-id="d3e6c-323">“值”</span><span class="sxs-lookup"><span data-stu-id="d3e6c-323">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="d3e6c-324">内部异常引用。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-324">The inner exception reference.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="d3e6c-325">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-325">The error message string.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-326">下面的代码示例`Exception`为特定条件派生。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-326">The following code example derives an `Exception` for a specific condition.</span></span> <span data-ttu-id="d3e6c-327">此代码演示如何使用将消息和内部异常作为参数的构造函数, 同时用于派生类和基类`Exception` 。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-327">The code demonstrates the use of the constructor that takes a message and an inner exception as parameters, for both the derived class and the base `Exception` class.</span></span>  
  
 [!code-cpp[System.Exception.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Ctor/CPP/newsi.cpp#3)]
 [!code-csharp[System.Exception.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Ctor/CS/newsi.cs#3)]
 [!code-vb[System.Exception.Ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Ctor/VB/newsi.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary Data { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Data" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Data" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Data As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IDictionary ^ Data { System::Collections::IDictionary ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Data : System.Collections.IDictionary" Usage="System.Exception.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-328">获取提供有关异常的其他用户定义信息的键/值对集合。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-328">Gets a collection of key/value pairs that provide additional user-defined information about the exception.</span></span></summary>
        <value><span data-ttu-id="d3e6c-329">一个对象，它实现 <see cref="T:System.Collections.IDictionary" /> 接口并包含用户定义的键/值对的集合。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-329">An object that implements the <see cref="T:System.Collections.IDictionary" /> interface and contains a collection of user-defined key/value pairs.</span></span> <span data-ttu-id="d3e6c-330">默认值为空集合。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-330">The default is an empty collection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-331">使用由属性返回的<xref:System.Collections.IDictionary?displayProperty=nameWithType>对象来存储和检索与异常相关的<xref:System.Exception.Data%2A>补充信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-331">Use the <xref:System.Collections.IDictionary?displayProperty=nameWithType> object returned by the <xref:System.Exception.Data%2A> property to store and retrieve supplementary information relevant to the exception.</span></span> <span data-ttu-id="d3e6c-332">此信息采用任意数量的用户定义的键/值对的形式。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-332">The information is in the form of an arbitrary number of user-defined key/value pairs.</span></span> <span data-ttu-id="d3e6c-333">每个键/值对的关键组件通常为标识字符串, 而值对的值部分可以是任何类型的对象。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-333">The key component of each key/value pair is typically an identifying string, whereas the value component of the pair can be any type of object.</span></span>  
  
## <a name="keyvalue-pair-security"></a><span data-ttu-id="d3e6c-334">键/值对安全性</span><span class="sxs-lookup"><span data-stu-id="d3e6c-334">Key/Value Pair Security</span></span>  
 <span data-ttu-id="d3e6c-335">存储在由<xref:System.Exception.Data%2A>属性返回的集合中的键/值对是不安全的。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-335">The key/value pairs stored in the collection returned by the <xref:System.Exception.Data%2A> property are not secure.</span></span> <span data-ttu-id="d3e6c-336">如果你的应用程序调用一系列嵌套例程, 并且每个例程包含异常处理程序, 则生成的调用堆栈包含这些异常处理程序的层次结构。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-336">If your application calls a nested series of routines, and each routine contains exception handlers, the resulting call stack contains a hierarchy of those exception handlers.</span></span> <span data-ttu-id="d3e6c-337">如果较低级别例程引发异常, 则调用堆栈层次结构中的任何高级异常处理程序都可以读取和/或修改任何其他异常处理程序存储在集合中的键/值对。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-337">If a lower-level routine throws an exception, any upper-level exception handler in the call stack hierarchy can read and/or modify the key/value pairs stored in the collection by any other exception handler.</span></span> <span data-ttu-id="d3e6c-338">这意味着, 在键/值对中的信息已损坏的情况下, 必须确保键/值对中的信息不是机密信息, 并且应用程序将正常运行。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-338">This means you must guarantee that the information in the key/value pairs is not confidential and that your application will operate correctly if the information in the key/value pairs is corrupted.</span></span>  
  
## <a name="key-conflicts"></a><span data-ttu-id="d3e6c-339">键冲突</span><span class="sxs-lookup"><span data-stu-id="d3e6c-339">Key Conflicts</span></span>  
 <span data-ttu-id="d3e6c-340">当不同的异常处理程序指定访问键/值对所用的相同键时, 会发生键冲突。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-340">A key conflict occurs when different exception handlers specify the same key to access a key/value pair.</span></span> <span data-ttu-id="d3e6c-341">开发应用程序时要格外小心, 因为键冲突的后果在于, 较低级别的异常处理程序可能会意外地与较高级别的异常处理程序通信, 这种通信可能会导致微妙的程序错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-341">Use caution when developing your application because the consequence of a key conflict is that lower-level exception handlers can inadvertently communicate with higher-level exception handlers, and this communication might cause subtle program errors.</span></span> <span data-ttu-id="d3e6c-342">但是, 如果你小心, 可以使用密钥冲突来增强你的应用程序。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-342">However, if you are cautious you can use key conflicts to enhance your application.</span></span>  
  
## <a name="avoiding-key-conflicts"></a><span data-ttu-id="d3e6c-343">避免密钥冲突</span><span class="sxs-lookup"><span data-stu-id="d3e6c-343">Avoiding Key Conflicts</span></span>  
 <span data-ttu-id="d3e6c-344">通过采用命名约定为键/值对生成唯一键, 避免键冲突。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-344">Avoid key conflicts by adopting a naming convention to generate unique keys for key/value pairs.</span></span> <span data-ttu-id="d3e6c-345">例如, 命名约定可能产生一个键, 其中包含应用程序的句点分隔的名称、提供对的补充信息的方法以及唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-345">For example, a naming convention might yield a key that consists of the period-delimited name of your application, the method that provides supplementary information for the pair, and a unique identifier.</span></span>  
  
 <span data-ttu-id="d3e6c-346">假设两个应用程序 (名为产品和供应商) 都有一个名为 Sales 的方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-346">Suppose two applications, named Products and Suppliers, each has a method named Sales.</span></span> <span data-ttu-id="d3e6c-347">"产品" 应用程序中的 "销售" 方法提供产品的标识号 (库存单位或 SKU)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-347">The Sales method in the Products application provides the identification number (the stock keeping unit or SKU) of a product.</span></span> <span data-ttu-id="d3e6c-348">供应商应用程序的 Sales 方法提供供应商的标识号或 SID。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-348">The Sales method in the Suppliers application provides the identification number, or SID, of a supplier.</span></span> <span data-ttu-id="d3e6c-349">因此, 此示例的命名约定会生成密钥 "Products. 销售 SKU" 和 "供应商名称"。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-349">Consequently, the naming convention for this example yields the keys, "Products.Sales.SKU" and "Suppliers.Sales.SID".</span></span>  
  
## <a name="exploiting-key-conflicts"></a><span data-ttu-id="d3e6c-350">利用关键冲突</span><span class="sxs-lookup"><span data-stu-id="d3e6c-350">Exploiting Key Conflicts</span></span>  
 <span data-ttu-id="d3e6c-351">使用一个或多个特殊的预先安排密钥来控制处理, 从而利用密钥冲突。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-351">Exploit key conflicts by using the presence of one or more special, prearranged keys to control processing.</span></span> <span data-ttu-id="d3e6c-352">假设在一种情况下, 调用堆栈层次结构中最高级别的异常处理程序将捕获由较低级别的异常处理程序引发的所有异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-352">Suppose, in one scenario, the highest level exception handler in the call stack hierarchy catches all exceptions thrown by lower-level exception handlers.</span></span> <span data-ttu-id="d3e6c-353">如果存在具有特殊键的键/值对, 则高级异常处理程序将以某种非标准的方式设置<xref:System.Collections.IDictionary>对象中剩余的键/值对的格式; 否则, 将以某种正常方式设置其余键/值对的格式。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-353">If a key/value pair with a special key exists, the high-level exception handler formats the remaining key/value pairs in the <xref:System.Collections.IDictionary> object in some nonstandard way; otherwise, the remaining key/value pairs are formatted in some normal manner.</span></span>  
  
 <span data-ttu-id="d3e6c-354">现在, 假设在另一种情况下, 调用堆栈层次结构每个级别的异常处理程序都将捕获下一个较低级别的异常处理程序引发的异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-354">Now suppose, in another scenario, the exception handler at each level of the call stack hierarchy catches the exception thrown by the next lower-level exception handler.</span></span> <span data-ttu-id="d3e6c-355">此外, 每个异常处理程序知道<xref:System.Exception.Data%2A>属性返回的集合包含一组键/值对, 这些键/值对可使用一组预先安排的键进行访问。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-355">In addition, each exception handler knows the collection returned by the <xref:System.Exception.Data%2A> property contains a set of key/value pairs that can be accessed with a prearranged set of keys.</span></span>  
  
 <span data-ttu-id="d3e6c-356">每个异常处理程序使用预先安排的键集来使用该异常处理程序的唯一信息更新相应键/值对的值部分。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-356">Each exception handler uses the prearranged set of keys to update the value component of the corresponding key/value pair with information unique to that exception handler.</span></span> <span data-ttu-id="d3e6c-357">更新过程完成后, 异常处理程序会将异常引发到下一个更高级别的异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-357">After the update process is complete, the exception handler throws the exception to the next higher-level exception handler.</span></span> <span data-ttu-id="d3e6c-358">最后, 最高级别的异常处理程序访问键/值对, 并显示来自所有较低级别的异常处理程序的合并的更新信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-358">Finally, the highest level exception handler accesses the key/value pairs and displays the consolidated update information from all the lower-level exception handlers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-359">下面的示例演示如何使用<xref:System.Exception.Data%2A>属性添加和检索信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-359">The following example demonstrates how to add and retrieve information using the <xref:System.Exception.Data%2A> property.</span></span>  
  
 [!code-cpp[exception.data#1](~/samples/snippets/cpp/VS_Snippets_CLR/exception.data/CPP/data.cpp#1)]
 [!code-csharp[exception.data#1](~/samples/snippets/csharp/VS_Snippets_CLR/exception.data/CS/data.cs#1)]
 [!code-vb[exception.data#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/exception.data/VB/data.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.DictionaryEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetBaseException">
      <MemberSignature Language="C#" Value="public virtual Exception GetBaseException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Exception GetBaseException() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetBaseException" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetBaseException () As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Exception ^ GetBaseException();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseException : unit -&gt; Exception&#xA;override this.GetBaseException : unit -&gt; Exception" Usage="exception.GetBaseException " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetBaseException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3e6c-360">当在派生类中重写时，返回 <see cref="T:System.Exception" />，它是一个或多个并发的异常的根源。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-360">When overridden in a derived class, returns the <see cref="T:System.Exception" /> that is the root cause of one or more subsequent exceptions.</span></span></summary>
        <returns><span data-ttu-id="d3e6c-361">异常链中第一个被引发的异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-361">The first exception thrown in a chain of exceptions.</span></span> <span data-ttu-id="d3e6c-362">如果当前异常的 <see cref="P:System.Exception.InnerException" /> 属性是 null 引用（Visual Basic 中为<see langword="Nothing" /> ），则此属性返回当前异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-362">If the <see cref="P:System.Exception.InnerException" /> property of the current exception is a null reference (<see langword="Nothing" /> in Visual Basic), this property returns the current exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-363">异常链包含一组异常, 以便将链中的每个异常作为其`InnerException`属性中引用的异常的直接结果引发。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-363">A chain of exceptions consists of a set of exceptions such that each exception in the chain was thrown as a direct result of the exception referenced in its `InnerException` property.</span></span> <span data-ttu-id="d3e6c-364">对于给定链, 只能有一个例外, 即链中所有其他异常的根本原因。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-364">For a given chain, there can be exactly one exception that is the root cause of all other exceptions in the chain.</span></span> <span data-ttu-id="d3e6c-365">此异常称为基本异常, 其`InnerException`属性始终包含空引用。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-365">This exception is called the base exception and its `InnerException` property always contains a null reference.</span></span>  
  
 <span data-ttu-id="d3e6c-366">对于异常链中的所有异常, 该`GetBaseException`方法必须返回相同的对象 (基本异常)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-366">For all exceptions in a chain of exceptions, the `GetBaseException` method must return the same object (the base exception).</span></span>  
  
 <span data-ttu-id="d3e6c-367">如果要查找异常的根本原因, 但不需要有关当前异常和第一个异常之间可能发生的异常的信息, 请使用方法。`GetBaseException`</span><span class="sxs-lookup"><span data-stu-id="d3e6c-367">Use the `GetBaseException` method when you want to find the root cause of an exception but do not need information about exceptions that may have occurred between the current exception and the first exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-368">下面的代码示例定义了两`Exception`个派生类。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-368">The following code example defines two derived `Exception` classes.</span></span> <span data-ttu-id="d3e6c-369">它强制执行异常, 然后再次使用每个派生类再次引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-369">It forces an exception and then throws it again with each of the derived classes.</span></span> <span data-ttu-id="d3e6c-370">此代码演示如何使用`GetBaseException`方法来检索原始异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-370">The code shows the use of the `GetBaseException` method to retrieve the original exception.</span></span>  
  
 [!code-cpp[System.Exception.GetBaseException#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CPP/getbaseexc.cpp#1)]
 [!code-csharp[System.Exception.GetBaseException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetBaseException/CS/getbaseexc.cs#1)]
 [!code-vb[System.Exception.GetBaseException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetBaseException/VB/getbaseexc.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d3e6c-371">在需要控制异常内容或格式的类中, 将重写方法。<see langword="GetBaseException" /></span><span class="sxs-lookup"><span data-stu-id="d3e6c-371">The <see langword="GetBaseException" /> method is overridden in classes that require control over the exception content or format.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="exception.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="d3e6c-372">包含有关所引发异常的序列化对象数据的 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-372">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</span></span></param>
        <param name="context"><span data-ttu-id="d3e6c-373"><see cref="T:System.Runtime.Serialization.StreamingContext" />，它包含关于源或目标的上下文信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-373">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</span></span></param>
        <summary><span data-ttu-id="d3e6c-374">当在派生类中重写时，用关于异常的信息设置 <see cref="T:System.Runtime.Serialization.SerializationInfo" />。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-374">When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-375">`GetObjectData` 使用针对于序列化的所有异常对象数据设置 <xref:System.Runtime.Serialization.SerializationInfo>。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-375">`GetObjectData` sets a <xref:System.Runtime.Serialization.SerializationInfo> with all the exception object data targeted for serialization.</span></span> <span data-ttu-id="d3e6c-376">反序列化期间，从通过流传输的 `SerializationInfo` 重建异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-376">During deserialization, the exception is reconstituted from the `SerializationInfo` transmitted over the stream.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-377">下面的代码示例定义了一个可`Exception`实现`GetObjectData`的派生可序列化类, 这将对两个属性进行少量更改, 然后调用基类来执行序列化。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-377">The following code example defines a derived serializable `Exception` class that implements `GetObjectData`, which makes minor changes to two properties and then calls the base class to perform the serialization.</span></span> <span data-ttu-id="d3e6c-378">该示例强制执行被零除错误, 然后创建派生异常的实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-378">The example forces a divide-by-0 error and then creates an instance of the derived exception.</span></span> <span data-ttu-id="d3e6c-379">该代码将实例序列化为文件, 将该文件反序列化为一个新异常, 引发该异常, 然后捕获并显示该异常的数据。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-379">The code serializes the instance to a file, deserializes the file into a new exception, which it throws, and then catches and displays the exception's data.</span></span>  
  
 [!code-cpp[System.Exception.GetObjectData#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CPP/getobjdata.cpp#1)]
 [!code-csharp[System.Exception.GetObjectData#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.GetObjectData/CS/getobjdata.cs#1)]
 [!code-vb[System.Exception.GetObjectData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.GetObjectData/VB/getobjdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d3e6c-380"><paramref name="info" /> 参数为 null 引用（在 Visual Basic 中为 <see langword="Nothing" />）。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-380">The <paramref name="info" /> parameter is a null reference (<see langword="Nothing" /> in Visual Basic).</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="d3e6c-381">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-381">requires full trust for the immediate caller.</span></span> <span data-ttu-id="d3e6c-382">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-382">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="exception.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3e6c-383">获取当前实例的运行时类型。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-383">Gets the runtime type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="d3e6c-384">一个 <see cref="T:System.Type" /> 对象，表示当前实例的确切运行时类型。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-384">A <see cref="T:System.Type" /> object that represents the exact runtime type of the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-385">存在用于支持 .NET Framework 基础结构的<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法,并在内部调用基本方法。<xref:System.Exception.GetType%2A></span><span class="sxs-lookup"><span data-stu-id="d3e6c-385">The <xref:System.Exception.GetType%2A> method exists to support the .NET Framework infrastructure, and internally invokes the fundamental method, <xref:System.Object.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="HelpLink">
      <MemberSignature Language="C#" Value="public virtual string HelpLink { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HelpLink" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HelpLink" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property HelpLink As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ HelpLink { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.HelpLink : string with get, set" Usage="System.Exception.HelpLink" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.HelpLink</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-386">获取或设置指向与此异常关联的帮助文件链接。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-386">Gets or sets a link to the help file associated with this exception.</span></span></summary>
        <value><span data-ttu-id="d3e6c-387">统一资源名称 (URN) 或统一资源定位器 (URL)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-387">The Uniform Resource Name (URN) or Uniform Resource Locator (URL).</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-388">表示帮助文件的返回值是 URN 或 URL。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-388">The return value, which represents a help file, is a URN or URL.</span></span> <span data-ttu-id="d3e6c-389">例如, `HelpLink`值可以是:</span><span class="sxs-lookup"><span data-stu-id="d3e6c-389">For example, the `HelpLink` value could be:</span></span>  
  
 <span data-ttu-id="d3e6c-390">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</span><span class="sxs-lookup"><span data-stu-id="d3e6c-390">"file:///C:/Applications/Bazzal/help.html#ErrorNum42"</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-391">下面的代码示例`Exception` `HelpLink`将引发, 它在其构造函数中设置属性, 然后捕获异常并`HelpLink`显示。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-391">The following code example throws an `Exception` that sets the `HelpLink` property in its constructor and then catches the exception and displays `HelpLink`.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HResult">
      <MemberSignature Language="C#" Value="public int HResult { get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HResult" />
      <MemberSignature Language="DocId" Value="P:System.Exception.HResult" />
      <MemberSignature Language="VB.NET" Value="Public Property HResult As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:  property int HResult {  public:&#xA;int get(); protected:&#xA; void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.HResult : int with get, set" Usage="System.Exception.HResult" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-392">获取或设置 HRESULT（一个分配给特定异常的编码数字值）。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-392">Gets or sets HRESULT, a coded numerical value that is assigned to a specific exception.</span></span></summary>
        <value><span data-ttu-id="d3e6c-393">HRESULT 值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-393">The HRESULT value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-394">HRESULT 是一个32位值, 分为三个不同的字段: 一个严重性代码、一个设施代码和一个错误代码。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-394">HRESULT is a 32-bit value, divided into three different fields: a severity code, a facility code, and an error code.</span></span> <span data-ttu-id="d3e6c-395">严重性代码指示返回值是否表示信息、警告或错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-395">The severity code indicates whether the return value represents information, warning, or error.</span></span> <span data-ttu-id="d3e6c-396">设备代码标识导致错误的系统区域。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-396">The facility code identifies the area of the system responsible for the error.</span></span> <span data-ttu-id="d3e6c-397">错误代码是分配用来表示异常的唯一编号。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-397">The error code is a unique number that is assigned to represent the exception.</span></span> <span data-ttu-id="d3e6c-398">每个异常都映射到不同的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-398">Each exception is mapped to a distinct HRESULT.</span></span> <span data-ttu-id="d3e6c-399">当托管代码引发异常时, 运行时将 HRESULT 传递给 COM 客户端。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-399">When managed code throws an exception, the runtime passes the HRESULT to the COM client.</span></span> <span data-ttu-id="d3e6c-400">如果非托管代码返回错误, 则 HRESULT 会转换为异常, 然后运行时将引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-400">When unmanaged code returns an error, the HRESULT is converted to an exception, which is then thrown by the runtime.</span></span> <span data-ttu-id="d3e6c-401">有关 HRESULT 值及其相应的 .NET Framework 异常的信息, 请[参阅如何:映射 Hresult 和异常](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-401">For information about HRESULT values and their corresponding .NET Framework exceptions, see [How to: Map HRESULTs and Exceptions](~/docs/framework/interop/how-to-map-hresults-and-exceptions.md).</span></span> <span data-ttu-id="d3e6c-402">有关最有可能遇到的值的列表, 请参阅 Windows 文档中的[常见 HRESULT 值](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-402">See [Common HRESULT Values](https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx) in the Windows documentation for a list of the values you are most likely to encounter.</span></span>  
  
 <span data-ttu-id="d3e6c-403">从开始<xref:System.Exception.HResult%2A> , 属性的 setter 是受保护的, 而其 getter 是公共的。 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d3e6c-403">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Exception.HResult%2A> property's setter is protected, whereas its getter is public.</span></span>  <span data-ttu-id="d3e6c-404">在以前版本的 .NET Framework 中, getter 和 setter 都受到保护。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-404">In previous versions of the .NET Framework, both getter and setter are protected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-405">下面的代码示例定义了一个`Exception`派生类, 该`HResult`派生类在其构造函数中将属性设置为自定义值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-405">The following code example defines a derived `Exception` class that sets the `HResult` property to a custom value in its constructor.</span></span>  
  
 [!code-cpp[System.Exception.HResult#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.HResult/CPP/hresult.cpp#1)]
 [!code-csharp[System.Exception.HResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.HResult/CS/hresult.cs#1)]
 [!code-vb[System.Exception.HResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.HResult/VB/hresult.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/610b364b-2761-429d-9c4a-afbc3e66f1b9"><span data-ttu-id="d3e6c-406">如何：映射 HRESULT 和异常</span><span class="sxs-lookup"><span data-stu-id="d3e6c-406">How to: Map HRESULTs and Exceptions</span></span></related>
        <related type="ExternalDocumentation" href="https://msdn.microsoft.com/library/windows/desktop/aa378137.aspx"><span data-ttu-id="d3e6c-407">常见的 HRESULT 值</span><span class="sxs-lookup"><span data-stu-id="d3e6c-407">Common HRESULT Values</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InnerException">
      <MemberSignature Language="C#" Value="public Exception InnerException { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception InnerException" />
      <MemberSignature Language="DocId" Value="P:System.Exception.InnerException" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InnerException As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ InnerException { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InnerException : Exception" Usage="System.Exception.InnerException" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.InnerException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-408">获取导致当前异常的 <see cref="T:System.Exception" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-408">Gets the <see cref="T:System.Exception" /> instance that caused the current exception.</span></span></summary>
        <value><span data-ttu-id="d3e6c-409">描述导致当前异常的错误的一个对象。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-409">An object that describes the error that caused the current exception.</span></span> <span data-ttu-id="d3e6c-410"><see cref="P:System.Exception.InnerException" /> 属性返回的值与传递到 <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> 构造函数中的值相同，如果没有向构造函数提供内部异常值，则为 <see langword="null" /> 。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-410">The <see cref="P:System.Exception.InnerException" /> property returns the same value as was passed into the <see cref="M:System.Exception.#ctor(System.String,System.Exception)" /> constructor, or <see langword="null" /> if the inner exception value was not supplied to the constructor.</span></span> <span data-ttu-id="d3e6c-411">此属性是只读的。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-411">This property is read-only.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-412">当`X`异常作为上一个异常`Y`的直接结果引发时, <xref:System.Exception.InnerException%2A>的属性`X`应包含对的引用`Y`。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-412">When an exception `X` is thrown as a direct result of a previous exception `Y`, the <xref:System.Exception.InnerException%2A> property of `X` should contain a reference to `Y`.</span></span>  
  
 <span data-ttu-id="d3e6c-413">使用 <xref:System.Exception.InnerException%2A> 属性获取导致当前异常的异常集。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-413">Use the <xref:System.Exception.InnerException%2A> property to obtain the set of exceptions that led to the current exception.</span></span>  
  
 <span data-ttu-id="d3e6c-414">你可以创建一个新的异常来捕获更早的异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-414">You can create a new exception that catches an earlier exception.</span></span> <span data-ttu-id="d3e6c-415">处理第二个异常的代码可以利用以前异常中的其他信息来更正确地处理错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-415">The code that handles the second exception can make use of the additional information from the earlier exception to handle the error more appropriately.</span></span>  
  
 <span data-ttu-id="d3e6c-416">假设有一个函数读取文件, 并设置该文件的数据的格式。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-416">Suppose that there is a function that reads a file and formats the data from that file.</span></span> <span data-ttu-id="d3e6c-417">在此示例中, 当代码尝试读取文件<xref:System.IO.IOException>时, 将引发。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-417">In this example, as the code tries to read the file, an <xref:System.IO.IOException> is thrown.</span></span> <span data-ttu-id="d3e6c-418">函数捕获<xref:System.IO.IOException>并<xref:System.IO.FileNotFoundException>引发。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-418">The function catches the <xref:System.IO.IOException> and throws a <xref:System.IO.FileNotFoundException>.</span></span> <span data-ttu-id="d3e6c-419">可以保存<xref:System.IO.FileNotFoundException>在的<xref:System.IO.FileNotFoundException>属性中, 并启用捕获的代码来检查出现初始错误的原因。 <xref:System.Exception.InnerException%2A> <xref:System.IO.IOException></span><span class="sxs-lookup"><span data-stu-id="d3e6c-419">The <xref:System.IO.IOException> could be saved in the <xref:System.Exception.InnerException%2A> property of the <xref:System.IO.FileNotFoundException>, enabling the code that catches the <xref:System.IO.FileNotFoundException> to examine the cause of the initial error.</span></span>  
  
 <span data-ttu-id="d3e6c-420"><xref:System.Exception.InnerException%2A>属性 (包含对内部异常的引用) 是在初始化异常对象时设置的。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-420">The <xref:System.Exception.InnerException%2A> property, which holds a reference to the inner exception, is set upon initialization of the exception object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-421">下面的示例演示如何引发和捕获引用内部异常的异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-421">The following example demonstrates throwing and catching an exception that references an inner exception.</span></span>  
  
 [!code-cpp[InnerEx#1](~/samples/snippets/cpp/VS_Snippets_CLR/InnerEx/CPP/innerex.cpp#1)]
 [!code-csharp[InnerEx#1](~/samples/snippets/csharp/VS_Snippets_CLR/InnerEx/CS/innerex.cs#1)]
 [!code-vb[InnerEx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InnerEx/VB/innerex.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Message">
      <MemberSignature Language="C#" Value="public virtual string Message { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Message" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Message" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Message As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Message { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Message : string" Usage="System.Exception.Message" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Message</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-422">获取描述当前异常的消息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-422">Gets a message that describes the current exception.</span></span></summary>
        <value><span data-ttu-id="d3e6c-423">解释异常原因的错误消息或空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-423">The error message that explains the reason for the exception, or an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-424">错误消息面向正在处理异常的开发人员。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-424">Error messages target the developer who is handling the exception.</span></span> <span data-ttu-id="d3e6c-425"><xref:System.Exception.Message%2A>属性的文本应完全描述错误, 如果可能, 还应说明如何纠正错误。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-425">The text of the <xref:System.Exception.Message%2A> property should completely describe the error and, when possible, should also explain how to correct the error.</span></span> <span data-ttu-id="d3e6c-426">顶级异常处理程序可能会向最终用户显示消息, 因此您应该确保该消息的语法正确, 并且消息的每个句子都以句点结束。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-426">Top-level exception handlers may display the message to end-users, so you should ensure that it is grammatically correct and that each sentence of the message ends with a period.</span></span> <span data-ttu-id="d3e6c-427">不要使用问号或感叹号。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-427">Do not use question marks or exclamation points.</span></span> <span data-ttu-id="d3e6c-428">如果你的应用程序使用本地化的异常消息, 则应确保正确翻译它们。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-428">If your application uses localized exception messages, you should ensure that they are accurately translated.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d3e6c-429">不要在不检查适当权限的情况下, 在异常消息中公开敏感信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-429">Do not disclose sensitive information in exception messages without checking for the appropriate permissions.</span></span>  
  
 <span data-ttu-id="d3e6c-430"><xref:System.Exception.Message%2A>属性的值包含在<xref:System.Exception.ToString%2A>返回的信息中。仅在创建时设置<xref:System.Exception.Message%2A>属性<xref:System.Exception>。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-430">The value of the <xref:System.Exception.Message%2A> property is included in the information returned by <xref:System.Exception.ToString%2A>.The <xref:System.Exception.Message%2A> property is set only when creating an <xref:System.Exception>.</span></span> <span data-ttu-id="d3e6c-431">如果没有向当前实例的构造函数提供消息, 则系统提供使用当前系统区域性进行格式设置的默认消息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-431">If no message was supplied to the constructor for the current instance, the system supplies a default message that is formatted using the current system culture.</span></span>  
  
## <a name="windows-runtime-and-includenetv451includesnet-v451-mdmd"></a><span data-ttu-id="d3e6c-432">Windows 运行时和[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="d3e6c-432">Windows Runtime and [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span></span>  
 <span data-ttu-id="d3e6c-433">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]从和[!INCLUDE[win81](~/includes/win81-md.md)]开始, 从不属于 .NET Framework 的 Windows 运行时类型和成员传播而来的错误消息保真会得到改善。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-433">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)] and [!INCLUDE[win81](~/includes/win81-md.md)], the fidelity of error messages from exceptions that are propagated from Windows Runtime types and members that are not part of the .NET Framework is improved.</span></span> <span data-ttu-id="d3e6c-434">具体而言, 来自可视化C++组件扩展 (C++/cx) 的异常消息现在将传播回 .NET Framework <xref:System.Exception>的对象。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-434">In particular, exception messages from Visual C++ component extensions (C++/CX) are now propagated back into .NET Framework <xref:System.Exception> objects.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-435">下面的代码示例将引发<xref:System.Exception>异常, 然后捕获异常并<xref:System.Exception.Message%2A>使用属性显示异常的短信。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-435">The following code example throws and then catches an <xref:System.Exception> exception and displays the exception's text message using the <xref:System.Exception.Message%2A> property.</span></span>
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d3e6c-436">如果从属性引发异常, 并且需要将的<see cref="P:System.Exception.Message" />文本引用到设置或获取的属性参数, 请使用 "value" 作为属性参数的名称。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-436">If you throw an exception from a property, and you need to refer in the text of <see cref="P:System.Exception.Message" /> to the property argument that you set or get, use "value" as the name of the property argument.</span></span></para></block>
        <block subset="none" type="overrides"><para><span data-ttu-id="d3e6c-437">需要控制消息内容或格式的类中将重写属性。<see cref="P:System.Exception.Message" /></span><span class="sxs-lookup"><span data-stu-id="d3e6c-437">The <see cref="P:System.Exception.Message" /> property is overridden in classes that require control over message content or format.</span></span> <span data-ttu-id="d3e6c-438">当应用程序代码需要显示已被捕获的异常的相关信息时, 通常会访问此属性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-438">Application code typically accesses this property when it needs to display information about an exception that has been caught.</span></span>  
  
<span data-ttu-id="d3e6c-439">应本地化错误消息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-439">The error message should be localized.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="SerializeObjectState">
      <MemberSignature Language="C#" Value="protected event EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.Serialization.SafeSerializationEventArgs&gt; SerializeObjectState" />
      <MemberSignature Language="DocId" Value="E:System.Exception.SerializeObjectState" />
      <MemberSignature Language="VB.NET" Value="Protected Custom Event SerializeObjectState As EventHandler(Of SafeSerializationEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; event EventHandler&lt;System::Runtime::Serialization::SafeSerializationEventArgs ^&gt; ^ SerializeObjectState;" />
      <MemberSignature Language="F#" Value="member this.SerializeObjectState : EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " Usage="member this.SerializeObjectState : System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.Serialization.SafeSerializationEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-440">当异常被序列化用来创建包含有关该异常的徐列出数据的异常状态对象时会出现该问题。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-440">Occurs when an exception is serialized to create an exception state object that contains serialized data about the exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-441">异常状态对象实现<xref:System.Runtime.Serialization.ISafeSerializationData>接口。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-441">The exception state object implements the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.</span></span>  
  
 <span data-ttu-id="d3e6c-442">当对<xref:System.Exception.SerializeObjectState>事件进行订阅时, 异常将反序列化并创建为空异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-442">When the <xref:System.Exception.SerializeObjectState> event is subscribed to, the exception is deserialized and created as an empty exception.</span></span> <span data-ttu-id="d3e6c-443">异常的构造函数不会运行, 并且异常状态也将进行反序列化。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-443">The exception's constructor is not run, and the exception state is also deserialized.</span></span> <span data-ttu-id="d3e6c-444">然后通知异常状态对象的回调方法,以便可以将反序列化的数据推送到空异常中。<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A></span><span class="sxs-lookup"><span data-stu-id="d3e6c-444">The <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A> callback method of the exception state object is then notified so that it can push deserialized data into the empty exception.</span></span>  
  
 <span data-ttu-id="d3e6c-445"><xref:System.Exception.SerializeObjectState>事件使透明异常类型可以序列化和反序列化异常数据。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-445">The <xref:System.Exception.SerializeObjectState> event enables transparent exception types to serialize and deserialize exception data.</span></span> <span data-ttu-id="d3e6c-446">透明代码可以在其运行的权限集边界内执行命令, 但不能执行、调用、派生自或包含关键代码。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-446">Transparent code can execute commands within the bounds of the permission set it is operating within, but cannot execute, call, derive from, or contain critical code.</span></span>  
  
 <span data-ttu-id="d3e6c-447">如果未对<xref:System.Exception.%23ctor%2A> 事件进行订阅,则使用构造函数照常进行<xref:System.Exception.SerializeObjectState>反序列化。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-447">If the <xref:System.Exception.SerializeObjectState> event is not subscribed to, deserialization occurs as usual using the <xref:System.Exception.%23ctor%2A> constructor.</span></span>  
  
 <span data-ttu-id="d3e6c-448">通常情况下, 会在<xref:System.Exception.SerializeObjectState>异常的构造函数中添加事件的处理程序, 以提供其序列化。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-448">Typically, a handler for the <xref:System.Exception.SerializeObjectState> event is added in the exception's constructor to provide for its serialization.</span></span> <span data-ttu-id="d3e6c-449">但由于在<xref:System.Exception.SerializeObjectState>事件处理程序执行时不执行构造函数, 因此, 序列化反序列化<xref:System.Runtime.Serialization.SerializationException>异常会在您尝试反序列化异常时引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-449">But because the constructor is not executed when the <xref:System.Exception.SerializeObjectState> event handler executes, serializing a deserialized exception can throw a <xref:System.Runtime.Serialization.SerializationException> exception when you try to deserialize the exception.</span></span> <span data-ttu-id="d3e6c-450">若要避免此<xref:System.Exception.SerializeObjectState>情况, 还应<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>在方法中添加事件的处理程序。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-450">To avoid this, you should also add the handler for the <xref:System.Exception.SerializeObjectState> event in the <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d3e6c-451">有关说明, 请参阅示例部分。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-451">See the Examples section for an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-452">下面的示例定义了`BadDivisionException`一个用于<xref:System.Exception.SerializeObjectState>处理事件的。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-452">The following example defines a `BadDivisionException` that handles the <xref:System.Exception.SerializeObjectState> event.</span></span> <span data-ttu-id="d3e6c-453">它还包含一个状态对象, 该对象是一个名为`BadDivisionExceptionState`的用于<xref:System.Runtime.Serialization.ISafeSerializationData>实现接口的嵌套结构。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-453">It also contains a state object, which is a nested structure named `BadDivisionExceptionState` that implements the <xref:System.Runtime.Serialization.ISafeSerializationData> interface.</span></span>  
  
 [!code-csharp[System.Exception.SerializeObjectState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.serializeobjectstate/cs/example2.cs#1)]
 [!code-vb[System.Exception.SerializeObjectState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.serializeobjectstate/vb/example2.vb#1)]  
  
 <span data-ttu-id="d3e6c-454">当`BadDivisionException`发生浮点除数为零时, 将引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-454">The `BadDivisionException` exception is thrown when a floating-point division by zero occurs.</span></span> <span data-ttu-id="d3e6c-455">在第一个被零除的过程中, 该`BadDivisionException`示例实例化一个对象, 将其序列化, 并引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-455">During the first division by zero, the example instantiates a `BadDivisionException` object, serializes it, and throws the exception.</span></span> <span data-ttu-id="d3e6c-456">如果后续除法运算发生, 则此示例将反序列化以前序列化的对象, 重新它, 并引发异常。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-456">When subsequent divisions by zero occur, the example deserializes the  previously serialized object, reserializes it, and throws the exception.</span></span> <span data-ttu-id="d3e6c-457">为了提供对象序列化、反序列化、reserialization 和反序列化, 该<xref:System.Exception.SerializeObjectState>示例`BadDivisionException`在<xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType>类构造函数和实现中都添加了事件处理程序。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-457">To provide for object serialization, deserialization, reserialization, and deserialization, the example adds the <xref:System.Exception.SerializeObjectState> event handler both in the `BadDivisionException` class constructor and in the <xref:System.Runtime.Serialization.ISafeSerializationData.CompleteDeserialization%2A?displayProperty=nameWithType> implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d3e6c-458">如果此事件订阅并使用, 则继承层次结构中后面的所有派生类型都必须实现相同的序列化机制。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-458">If this event is subscribed to and used, all derived types that follow in the inheritance hierarchy must implement the same serialization mechanism.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public virtual string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Exception.Source" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Exception.Source" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.Source</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-459">获取或设置导致错误的应用程序或对象的名称。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-459">Gets or sets the name of the application or the object that causes the error.</span></span></summary>
        <value><span data-ttu-id="d3e6c-460">导致错误的应用程序或对象的名称。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-460">The name of the application or the object that causes the error.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-461">如果未显式设置属性,则运行时自动将其设置为引发异常的程序集的名称。<xref:System.Exception.Source%2A></span><span class="sxs-lookup"><span data-stu-id="d3e6c-461">If the <xref:System.Exception.Source%2A> property is not set explicitly, the runtime automatically sets it to the name of the assembly in which the exception originated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-462">下面的示例引发一个`Exception` , 它在`Source`其构造函数中设置属性, 然后捕获异常并`Source`显示。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-462">The following example throws an `Exception` that sets the `Source` property in its constructor and then catches the exception and displays `Source`.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d3e6c-463">对象必须是运行时 <see cref="N:System.Reflection" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-463">The object must be a runtime <see cref="N:System.Reflection" /> object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public virtual string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Exception.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Exception.StackTrace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.StackTrace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-464">获取调用堆栈上的即时框架字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-464">Gets a string representation of the immediate frames on the call stack.</span></span></summary>
        <value><span data-ttu-id="d3e6c-465">用于描述调用堆栈的直接帧的字符串。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-465">A string that describes the immediate frames of the call stack.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-466">执行堆栈将跟踪在给定时刻正在执行的所有方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-466">The execution stack keeps track of all the methods that are in execution at a given instant.</span></span> <span data-ttu-id="d3e6c-467">对方法调用的跟踪称为堆栈跟踪。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-467">A trace of the method calls is called a stack trace.</span></span> <span data-ttu-id="d3e6c-468">堆栈跟踪列表提供了一种方法, 用于在发生异常的方法中跟踪调用堆栈。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-468">The stack trace listing provides a way to follow the call stack to the line number in the method where the exception occurs.</span></span>  
  
 <span data-ttu-id="d3e6c-469"><xref:System.Exception.StackTrace%2A>属性返回调用堆栈的帧, 该堆栈源自引发异常的位置。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-469">The <xref:System.Exception.StackTrace%2A> property returns the frames of the call stack that originate at the location where the exception was thrown.</span></span> <span data-ttu-id="d3e6c-470">您可以通过创建<xref:System.Diagnostics.StackTrace?displayProperty=nameWithType>类的新实例并使用其<xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType>方法来获取有关调用堆栈中的其他帧的信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-470">You can obtain information about additional frames in the call stack by creating a new instance of the <xref:System.Diagnostics.StackTrace?displayProperty=nameWithType> class and using its <xref:System.Diagnostics.StackTrace.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="d3e6c-471">当应用程序代码中引发异常时, 公共语言运行时 (CLR) 将更新堆栈跟踪 (通过使用`throw`关键字)。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-471">The common language runtime (CLR) updates the stack trace whenever an exception is thrown in application code (by using the `throw` keyword).</span></span> <span data-ttu-id="d3e6c-472">如果在与最初引发异常的方法不同的方法中再次引发异常, 则堆栈跟踪同时包含最初引发异常的方法中的位置, 以及引发异常的方法中的位置。引发.</span><span class="sxs-lookup"><span data-stu-id="d3e6c-472">If the exception was rethrown in a method that is different than the method where it was originally thrown, the stack trace contains both the location in the method where the exception was originally thrown, and the location in the method where the exception was rethrown.</span></span> <span data-ttu-id="d3e6c-473">如果引发异常, 并在之后再次引发该异常, 则堆栈跟踪只包含引发异常的位置, 并且不包含最初引发异常的位置。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-473">If the exception is thrown, and later rethrown, in the same method, the stack trace only contains the location where the exception was rethrown and does not include the location where the exception was originally thrown.</span></span>  
  
 <span data-ttu-id="d3e6c-474">由于在优化过程中发生的代码转换 (如内联),属性可能不会按预期方式报告任意数量的方法调用。<xref:System.Exception.StackTrace%2A></span><span class="sxs-lookup"><span data-stu-id="d3e6c-474">The <xref:System.Exception.StackTrace%2A> property may not report as many method calls as expected because of code transformations, such as inlining, that occur during optimization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-475">下面的代码示例引发`Exception` , 并`StackTrace`使用属性来捕获它并显示堆栈跟踪。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-475">The following code example throws an `Exception` and then catches it and displays a stack trace using the `StackTrace` property.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d3e6c-476">在需要控制堆栈跟踪内容或格式的类中, 会重写属性。<see langword="StackTrace" /></span><span class="sxs-lookup"><span data-stu-id="d3e6c-476">The <see langword="StackTrace" /> property is overridden in classes that require control over the stack trace content or format.</span></span>  
  
<span data-ttu-id="d3e6c-477">默认情况下, 会在引发异常对象之前立即捕获堆栈跟踪。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-477">By default, the stack trace is captured immediately before an exception object is thrown.</span></span> <span data-ttu-id="d3e6c-478">当<see cref="P:System.Environment.StackTrace" />未引发异常时, 使用获取堆栈跟踪信息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-478">Use <see cref="P:System.Environment.StackTrace" /> to get stack trace information when no exception is being thrown.</span></span></para></block>
        <altmember cref="P:System.Environment.StackTrace" />
      </Docs>
    </Member>
    <Member MemberName="TargetSite">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase TargetSite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase TargetSite" />
      <MemberSignature Language="DocId" Value="P:System.Exception.TargetSite" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetSite As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodBase ^ TargetSite { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TargetSite : System.Reflection.MethodBase" Usage="System.Exception.TargetSite" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Exception.TargetSite</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d3e6c-479">获取引发当前异常的方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-479">Gets the method that throws the current exception.</span></span></summary>
        <value><span data-ttu-id="d3e6c-480">引发当前异常的 <see cref="T:System.Reflection.MethodBase" />。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-480">The <see cref="T:System.Reflection.MethodBase" /> that threw the current exception.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-481">如果引发此异常的方法不可用, 且堆栈跟踪不是空引用 (`Nothing`在 Visual Basic 中), <xref:System.Exception.TargetSite%2A>将从堆栈跟踪中获取该方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-481">If the method that throws this exception is not available and the stack trace is not a null reference (`Nothing` in Visual Basic), <xref:System.Exception.TargetSite%2A> obtains the method from the stack trace.</span></span> <span data-ttu-id="d3e6c-482">如果堆栈跟踪为空引用，<xref:System.Exception.TargetSite%2A> 也返回空引用。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-482">If the stack trace is a null reference, <xref:System.Exception.TargetSite%2A> also returns a null reference.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d3e6c-483">如果<xref:System.Exception.TargetSite%2A>异常处理程序处理跨应用程序域边界的异常, 则属性可能无法准确报告引发异常的方法的名称。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-483">The <xref:System.Exception.TargetSite%2A> property may not accurately report the name of the method in which an exception was thrown if the exception handler handles an exception across application domain boundaries.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-484">下面的代码示例引发`Exception` , 并`TargetSite`使用属性来捕获它并显示原始方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-484">The following code example throws an `Exception` and then catches it and displays the originating method using the `TargetSite` property.</span></span>  
  
 [!code-cpp[System.Exception.Properties#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Exception.Properties/CPP/properties.cpp#1)]
 [!code-csharp[System.Exception.Properties#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Exception.Properties/CS/properties.cs#1)]
 [!code-vb[System.Exception.Properties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Exception.Properties/VB/properties.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Exception.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="exception.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Exception.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d3e6c-485">创建并返回当前异常的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-485">Creates and returns a string representation of the current exception.</span></span></summary>
        <returns><span data-ttu-id="d3e6c-486">当前异常的字符串表示形式。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-486">A string representation of the current exception.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d3e6c-487"><xref:System.Exception.ToString%2A>返回当前异常的表示形式, 该异常旨在被人理解。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-487"><xref:System.Exception.ToString%2A> returns a representation of the current exception that is intended to be understood by humans.</span></span> <span data-ttu-id="d3e6c-488">如果异常包含区分区域性的数据, `ToString`则需要使用返回的字符串表示形式来考虑当前系统区域性。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-488">Where the exception contains culture-sensitive data, the string representation returned by `ToString` is required to take into account the current system culture.</span></span> <span data-ttu-id="d3e6c-489">虽然对于返回的字符串的格式没有确切的要求, 但它应尝试反映用户认为对象的值。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-489">Although there are no exact requirements for the format of the returned string, it should attempt to reflect the value of the object as perceived by the user.</span></span>  
  
 <span data-ttu-id="d3e6c-490">的<xref:System.Exception.ToString%2A>默认实现将获取引发当前异常的类的名称、消息、对内部异常调用<xref:System.Exception.ToString%2A>的结果和调用<xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>的结果。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-490">The default implementation of <xref:System.Exception.ToString%2A> obtains the name of the class that threw the current exception, the message, the result of calling <xref:System.Exception.ToString%2A> on the inner exception, and the result of calling <xref:System.Environment.StackTrace%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d3e6c-491">如果这些成员中有任何`null`一个为, 则其值不包含在返回的字符串中。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-491">If any of these members is `null`, its value is not included in the returned string.</span></span>  
  
 <span data-ttu-id="d3e6c-492">如果没有错误消息或为空字符串 (""), 则不返回错误消息。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-492">If there is no error message or if it is an empty string (""), then no error message is returned.</span></span> <span data-ttu-id="d3e6c-493">内部异常的名称和堆栈跟踪仅在不`null`返回时返回。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-493">The name of the inner exception and the stack trace are returned only if they are not `null`.</span></span>  
  
 <span data-ttu-id="d3e6c-494">此方法重写 <xref:System.Object.ToString%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-494">This method overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d3e6c-495">下面的示例将引发异常, 并显示对此异常<xref:System.Exception.ToString%2A>调用的结果。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-495">The following example causes an exception and displays the result of calling <xref:System.Exception.ToString%2A> on that exception.</span></span> <span data-ttu-id="d3e6c-496">请注意, <xref:System.Exception.ToString%2A?displayProperty=nameWithType>当异常类实例出现在<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>方法的参数列表中时, 将隐式调用方法。</span><span class="sxs-lookup"><span data-stu-id="d3e6c-496">Note that the <xref:System.Exception.ToString%2A?displayProperty=nameWithType> method is called implicitly when the Exception class instance appears in the argument list of the <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-cpp[System.Exception.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.exception.tostring/cpp/ToStringEx1.cpp#1)]
 [!code-csharp[System.Exception.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.exception.tostring/cs/ToStringEx1.cs#1)]
 [!code-vb[System.Exception.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.exception.tostring/vb/ToStringEx1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>