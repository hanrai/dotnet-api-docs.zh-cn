<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2d69eac39d76ab4f6abbe8aed3f1f8243ed3e998" /><Meta Name="ms.sourcegitcommit" Value="406d23aba879fbb482c6da0f64c8ef9494f6a944" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/31/2019" /><Meta Name="ms.locfileid" Value="68685992" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示类型声明：类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义，以及开放或封闭构造的泛型类型。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type`<xref:System.Reflection>功能的根, 是访问元数据的主要方式。 使用的成员<xref:System.Type>获取有关类型声明的信息, 有关类型的成员 (如构造函数、方法、字段、属性和类的事件), 以及部署类的模块和程序集。  
  
 无论其访问级别如何, 代码都无需权限即可使用反射来获取有关类型及其成员的信息。 代码不需要任何权限即可使用反射来访问公共成员, 或访问级别使其在正常编译过程中可见的其他成员。 但是, 为了使代码能够使用反射来访问通常不可访问的成员 (如私有或内部方法) 或类未继承的类型的受保护字段, 你的代码必须具有<xref:System.Security.Permissions.ReflectionPermission>。 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。  
  
 `Type`是允许多个实现的抽象基类。 系统将始终提供派生类`RuntimeType`。 在反射中, 所有以 word 运行时开头的类在系统中只为每个对象创建一次, 并支持比较运算。  
  
> [!NOTE]
>  在多线程方案中, 不要<xref:System.Type>锁定对象以便同步对`static`数据的访问。 其他不能进行控制的代码也可能会锁定您的类类型。 这可能会导致死锁。 相反, 通过锁定专用`static`对象来同步对静态数据的访问。  
  
> [!NOTE]
>  派生类可以访问调用代码的基类的受保护成员。 此外, 还允许访问调用代码的程序集的程序集成员。 作为一种规则, 如果允许在早期绑定代码中访问, 则还允许在后期绑定代码中访问。  
  
> [!NOTE]
>  扩展其他接口的接口不会继承扩展接口中定义的方法。  
  
 本节内容：  
  
 [类型对象表示哪些类型？](#WhatTypes)   
 [检索类型对象](#Retrieve)   
 [比较类型对象是否相等](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>类型对象表示哪些类型？  
 此类是线程安全的;多个线程可以同时从该类型的实例读取。 <xref:System.Type>类的实例可以表示以下任何类型:  
  
-   类  
  
-   值类型  
  
-   数组  
  
-   接口  
  
-   枚举  
  
-   委托  
  
-   构造的泛型类型和泛型类型定义  
  
-   构造的泛型类型、泛型类型定义和泛型方法定义的类型参数和类型参数  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>检索类型对象  
 可以<xref:System.Type>通过以下方式获取与特定类型关联的对象:  
  
-   实例<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法返回一个<xref:System.Type>对象, 该对象表示实例的类型。 由于所有托管类型都派生<xref:System.Object>自<xref:System.Object.GetType%2A> , 因此可在任何类型的实例上调用方法。  
  
     下面的示例调用<xref:System.Object.GetType%2A?displayProperty=nameWithType>方法以确定对象数组中每个对象的运行时类型。  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   静态<xref:System.Type.GetType%2A?displayProperty=nameWithType> 方法<xref:System.Type>返回对象, 该对象表示由其完全限定名称指定的类型。  
  
-   、和方法返回对象`Type` , 这些对象表示在模块中定义的类型。 <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType> <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType> 第一种方法可用于获取模块中定义的<xref:System.Type>所有公共和私有类型的对象数组。 (可以`Module` <xref:System.Type.Module%2A?displayProperty=nameWithType>通过或方法<xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>获取实例, 也可以通过属性获取的实例。) <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>  
  
-   对象包含若干方法, 用于检索在程序集中定义的类, 包括<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>、 <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>和<xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>。 <xref:System.Reflection.Assembly?displayProperty=nameWithType>  
  
-   <xref:System.Type.FindInterfaces%2A>方法返回某个类型支持的接口类型的筛选列表。  
  
-   方法返回表示元素的对象。<xref:System.Type.GetElementType%2A> `Type`  
  
-   <xref:System.Type.GetInterfaces%2A>和方法<xref:System.Type.GetInterface%2A>返回对象,这些<xref:System.Type>对象表示类型支持的接口类型。  
  
-   方法返回<xref:System.Type>对象的数组, 这些对象表示由任意一组对象指定的类型。 <xref:System.Type.GetTypeArray%2A> 对象是使用类型<xref:System.Object>的数组指定的。  
  
-   提供<xref:System.Type.GetTypeFromProgID%2A> 和<xref:System.Type.GetTypeFromCLSID%2A>方法是为了实现 COM 互操作性。 它们返回一个<xref:System.Type>对象, 该对象表示`ProgID`由或`CLSID`指定的类型。  
  
-   提供<xref:System.Type.GetTypeFromHandle%2A>方法以实现互操作性。 它将返回`Type`一个对象, 该对象表示由类句柄指定的类型。  
  
-   C# C++ 运算符、`GetType`运算符和 Visual Basic 运算符获取`Type`类型的对象。 `typeid` `typeof`  
  
-   方法返回一个<xref:System.Type>对象, 该对象表示构造的泛型类型 (如果其<xref:System.Type.ContainsGenericParameters%2A>属性返回`true`, 则为开放式构造类型); 否则返回一个封闭式构造类型。 <xref:System.Type.MakeGenericType%2A> 泛型类型只能在关闭时进行实例化。  
  
-   <xref:System.Type.MakeArrayType%2A> C#、`ref`和方法返回<xref:System.Type>分别表示指定类型的数组、指向指定类型的指针和引用参数类型的对象 (在中, <xref:System.Type.MakeByRefType%2A> <xref:System.Type.MakePointerType%2A> `ByRef`在 Visual Basic 中)。  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>比较类型对象是否相等  
 一个<xref:System.Type>表示类型的对象是唯一的; 即, 当且<xref:System.Type>仅当两个对象表示相同的类型时, 这就引用相同的对象。 这允许使用引用相等<xref:System.Type>性比较对象。 下面的示例对表示<xref:System.Type>若干整数值的对象进行比较, 以确定它们是否属于同一类型。  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 下面的示例演示了的<xref:System.Type>几个典型功能。 运算符C# `typeof` ( <xref:System.Type> <xref:System.String>Visual Basic中的运算符)用于获取表示的对象。`GetType` 在<xref:System.Type> <xref:System.Reflection.MethodInfo> <xref:System.String.Substring%2A?displayProperty=nameWithType>此对象中, 方法用于获取, 它表示采用起始位置和长度的重载。 <xref:System.Type.GetMethod%2A>
  
 为了标识重载签名, 该代码示例创建一个临时数组, 其中包含<xref:System.Type>表示`int`的两`Integer`个对象 (在 Visual Basic 中)。  
  
> [!NOTE]
>  为精确起见, 数组包含对当前应用程序域中表示<xref:System.Type> `int`的实例的两个引用。 对于任何类型, <xref:System.Type>每个应用程序域只有一个实例。  
  
 此代码示例使用<xref:System.Reflection.MethodInfo>来对字符串 "Hello, World!" <xref:System.String.Substring%2A>调用方法, 并显示结果。  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <block subset="none" type="overrides"><para>当从<see langword="Type" />继承时, 必须重写以下成员: 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md">查看类型信息</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Type" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类在类型对象的构造过程中调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在其中声明该类型的 <see cref="T:System.Reflection.Assembly" />。 对于泛型类型，则获取在其中定义该泛型类型的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <value>描述包含当前类型的程序集的 <see cref="T:System.Reflection.Assembly" /> 实例。 对于泛型类型，该实例描述包含泛型类型定义的程序集，而不是创建和使用特定构造类型的程序集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>对象表示构造泛型类型, 则此属性返回包含泛型类型定义的程序集。 例如, 假设你创建了一个名为 MyGenerics 的程序集, 该程序集包含`MyGenericStack<T>`泛型`MyGenericStack(Of T)`类型定义 ( `generic<T> ref class MyGenericStack`在C++中为 Visual Basic)。 如果在另一个程序集中`MyGenericStack<int>`创建`MyGenericStack(Of Integer)`的实例 (在 Visual Basic 中), <xref:System.Type.Assembly%2A>则构造类型的属性将返回<xref:System.Reflection.Assembly>一个表示 MyGenerics 的对象。  
  
 同样, 如果当前<xref:System.Type>对象表示一个未赋值的泛型参数`T`, 则此属性返回包含定义`T`的泛型类型的程序集。  
  
 如果该<xref:System.Type.Assembly%2A?displayProperty=nameWithType>属性在特定 .net 实现 (如 .net Core 或通用 Windows 平台) 上不可用, 请<xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>改用属性。      
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例显示与类关联的程序集名称和该类型的完全限定名称。  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取类型的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称。</summary>
        <value><see cref="T:System.Type" /> 的程序集限定名，其中包括从中加载 <see cref="T:System.Type" /> 的程序集的名称；或者为 <see langword="null" />（如果当前实例表示泛型类型参数）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类型的程序集限定名称包含类型名称 (包括其命名空间), 后跟一个逗号, 然后是程序集的显示名称。 使用<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性获取程序集的显示名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。 例如, "ProcessorArchitecture = msil"。 不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 所有支持公共语言运行时的编译器都发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|逗号 (,)|在程序集名称之前。|  
|加号 (+)|在嵌套类之前。|  
|Period (.)|表示命名空间标识符。|  
|方括号 ([])|在类型名称后, 表示该类型的数组。<br /><br /> 或<br /><br /> 对于泛型类型, 包含泛型类型参数列表。<br /><br /> 或<br /><br /> 在类型参数列表中, 包含程序集限定的类型。|  
  
 例如, 类的程序集限定名称可能如下所示:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 如果命名空间包含加号 (例如 TopNamespace + 命名空间), 则加号 (+) 前面将有一个转义符\\(), 以防止将其解释为嵌套分隔符。 反射会按如下所示发出此字符串:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 "+ +"\\变成 "\\++\\\\",而""\\变成 ""。  
  
 此限定名称可以保留, 以后用于加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。 <xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。 <xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。  
  
 类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。  
  
 泛型类型的泛型参数本身由程序集名称限定。 例如, 在的程序集限定类型`MyGenericClass<int>`名称 (`MyGenericClass(Of Integer)`在 Visual Basic 中) 中, `int`扩展<xref:System.Int32>为的程序集限定类型名称。  
  
 如果当前<xref:System.Type>对象表示泛型参数, 则此属性返回`null`。  
  
   
  
## Examples  
 下面的示例显示与类关联的程序集名称和该类型的完全限定名称。  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 下面的示例<xref:System.Type.ToString%2A>将方法返回的字符串`Name`与、 <xref:System.Type.FullName%2A>和<xref:System.Type.AssemblyQualifiedName%2A>属性进行比较。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Type" /> 关联的属性。</summary>
        <value>表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象，除非 <see cref="T:System.Type" /> 表示泛型类型形参，在此情况下该值未指定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes>枚举的某些成员是表示一组值的掩码。 每个组都包含一个其基础值为零的成员。 <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>例如, <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>组中成员的基础值为零, 这与<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>组中的<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>成员相同。 因此, 在测试这些值之前, 必须使用掩码。 说明如示例所示。  
  
> [!TIP]
>  大多数情况下, <xref:System.Type.IsClass%2A>、<xref:System.Type.IsAutoLayout%2A>和<xref:System.Type.IsSpecialName%2A>等属性比类型属性更易于使用。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性返回泛型类型定义的属性。 例如`MyGenericClass<int>` , 为 Visual Basic (`MyGenericClass(Of Integer)`在中为`MyGenericClass<T>` ) 返回的属性是 (`MyGenericClass(Of T)`在 Visual Basic 中) 的属性。  
  
 如果当前<xref:System.Type>表示泛型类型参数 (即, <xref:System.Type.IsGenericParameter%2A>如果属性返回`true` ), 则此属性返回<xref:System.Reflection.TypeAttributes>的值是未指定的。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.Attributes%2A>属性。  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 直接从中继承的类型。</summary>
        <value>当前 <see cref="T:System.Type" /> 直接从中继承的 <see cref="T:System.Type" />；或者如果当前 <see langword="null" /> 表示 <see langword="Type" /> 类或一个接口，则为 <see cref="T:System.Object" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基类型是当前类型直接从中继承的类型。 <xref:System.Object>是唯一没有基类型的类型, 因此`null`作为的基<xref:System.Object>类型返回。  
  
 接口从零个或多个基接口继承;因此, `null` `Type`如果该对象表示一个接口, 则此属性返回。 可以通过<xref:System.Type.GetInterfaces%2A>或<xref:System.Type.FindInterfaces%2A>确定基接口。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则基类型将反映泛型参数。 以下面的声明为例：  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 对于构造类型`C<int>` (`C(Of Integer)`在 Visual Basic 中), 该<xref:System.Type.BaseType%2A>属性返回`B<int>`。  
  
 如果当前<xref:System.Type>表示泛型类型定义的类型参数, <xref:System.Type.BaseType%2A>则返回类约束, 即类型参数必须继承的类。 如果没有类约束, <xref:System.Type.BaseType%2A>则返回。 <xref:System.Object?displayProperty=nameWithType>  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Type.BaseType%2A>属性。  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 下面的示例使用递归列出了在程序集中找到的每个类的完整继承层次结构。 该示例定义了一个名`C`为的类, 该类派生`B`自名为的类, 而后者又派生自`A`名为的类。  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 对象是否具有尚未被特定类型替代的类型参数。</summary>
        <value>如果 <see langword="true" /> 对象本身是泛型类型形参或者具有尚未提供特定类型的类型形参，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要创建类型的实例, 在类型本身的类型参数、任何封闭泛型类型或任何类型的元素中都不能有泛型类型定义或开放式构造类型。 另一种说法是, 在递归检查时, 类型不能包含泛型类型参数。  
  
 由于类型可能会很复杂, 因此做出此决定非常困难。 为方便起见, 若要减少出现错误的可能性<xref:System.Type.ContainsGenericParameters%2A> , 属性提供了一种标准方法来区分封闭式构造类型 (可以实例化和开放构造的类型, 这是不可能的)。 如果属性返回`true`, 则无法实例化该类型。 <xref:System.Type.ContainsGenericParameters%2A>  
  
 <xref:System.Type.ContainsGenericParameters%2A>属性以递归方式搜索类型参数。 例如, 它为元素`true`为类型`A<T>` (`A(Of T)`在 Visual Basic 中) 的数组返回, 即使数组本身不是泛型。 将此与为数组返回<xref:System.Type.IsGenericType%2A> `false`的属性的行为进行比较。  
  
 有关示例类和显示<xref:System.Type.ContainsGenericParameters%2A>属性值的表, 请参阅。 <xref:System.Type.IsGenericType%2A>  
  
   
  
## Examples  
 下面的示例定义了一个具有两个类型参数的泛型类, 然后定义了第一个派生自第一个类的泛型类。 派生类的基类具有两个类型参数: 第一个是<xref:System.Int32> , 第二个是派生类型的类型参数。 该示例显示有关这些泛型类的信息, 包括<xref:System.Type.GenericParameterPosition%2A>属性报告的位置。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />（如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数）。</summary>
        <value>如果当前 <see cref="T:System.Type" /> 表示泛型方法的一个类型参数，则为一个表示声明方法的 <see cref="T:System.Reflection.MethodBase" />；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 声明方法是泛型方法定义。 也就是说, 如果<xref:System.Type.DeclaringMethod%2A>不返回`null`, 则`DeclaringMethod.IsGenericMethodDefinition`返回`true`。  
  
 <xref:System.Type.DeclaringType%2A> 和<xref:System.Type.DeclaringMethod%2A>属性标识最初定义泛型类型参数的泛型类型定义或泛型方法定义:  
  
-   如果属性返回, 则表示泛型方法定义, 而当前<xref:System.Type>对象表示泛型方法定义的类型参数。 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> <xref:System.Type.DeclaringMethod%2A>  
  
-   `null` <xref:System.Type.DeclaringType%2A>如果属性返回, 则属性<xref:System.Type> <xref:System.Type>将始终返回表示泛型类型定义的对象, 并且当前对象表示该泛型类型的类型参数。 <xref:System.Type.DeclaringMethod%2A>定义.  
  
-   获取其<xref:System.Type.IsGenericParameter%2A>属性引发`false`的类型<xref:System.InvalidOperationException>的<xref:System.Type.DeclaringMethod%2A>属性。  
  
 属性返回的是<xref:System.Reflection.MethodInfo>泛型方法的, 或者<xref:System.Reflection.ConstructorInfo>是泛型构造函数的情况下的。 <xref:System.Reflection.MethodBase> <xref:System.Type.DeclaringMethod%2A>  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中, 不支持泛型构造函数。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义一个具有泛型方法的类, 为该方法分配一个类型自变量, 并调用生成的构造泛型方法。 它还显示有关泛型方法定义和构造方法的信息。 显示泛型方法定义的类型参数的信息时, 在`DisplayGenericMethodInfo`方法中, 示例代码显示了该方法的泛型类型参数的<xref:System.Type.DeclaringMethod%2A>属性值。  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用来声明当前的嵌套类型或泛型类型参数的类型。</summary>
        <value>如果当前的类型是嵌套类型，则为表示封闭类型的 <see cref="T:System.Type" /> 对象；如果当前的类型是泛型类型的类型参数，则为泛型类型的定义；如果当前的类型是泛型方法的类型参数，则为用来声明泛型方法的类型；否则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>对象表示泛型类型的类型参数, 则此属性返回泛型类型定义。  
  
 如果当前<xref:System.Type>对象表示泛型方法的类型参数, 则此属性返回包含泛型方法定义的类型。 如果类型为泛型, 则返回泛型类型定义。 也就是说, 下面的代码返回<xref:System.Collections.Generic.List%601> <xref:System.Collections.Generic.List%601.ConvertAll%2A>包含泛型方法的泛型类的泛型类型定义:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则<xref:System.Type.DeclaringType%2A>和<xref:System.Type.DeclaringMethod%2A>属性标识泛型类型定义或泛型方法定义, 其中泛型类型参数最初定义:  
  
-   如果属性返回, 则表示泛型方法定义, 而当前<xref:System.Type>对象表示泛型方法定义的类型参数。 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> <xref:System.Type.DeclaringMethod%2A>  
  
-   `null` <xref:System.Type.DeclaringType%2A>如果属性返回, 则属性<xref:System.Type> <xref:System.Type>将始终返回表示泛型类型定义的对象, 并且当前对象表示该泛型类型的类型参数。 <xref:System.Type.DeclaringMethod%2A>定义.  
  
-   获取其<xref:System.Type.IsGenericParameter%2A>属性引发`false`的类型<xref:System.InvalidOperationException>的<xref:System.Type.DeclaringType%2A>属性。  
  
   
  
## Examples  
 此示例显示派生类中方法的声明类型。  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取默认联编程序的引用，该程序实现的内部规则用于选择由 <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> 调用的合适成员。</summary>
        <value>系统使用的默认联编程序的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 随公共语言运行时提供的默认联编程序适用于除最特殊的情况以外的所有情况。 如果需要遵循与提供的默认联编程序不同的规则的联编程序, 请定义一个派生自<xref:System.Reflection.Binder>类的类型并`binder`使用其中一个<xref:System.Type.InvokeMember%2A>重载的参数传递该类型的实例。  
  
 反射对通用类型系统的可访问性规则建模。 例如, 如果调用方在同一程序集中, 则调用方不需要内部成员的特殊权限。 否则, 调用方需要<xref:System.Security.Permissions.ReflectionPermission>。 这与查找受保护的、私有的成员等的成员一致。  
  
 一般原则是<xref:System.Reflection.Binder.ChangeType%2A>只应执行不会丢失数据的扩大转换。 扩大转换的一个示例是将32位有符号整数的值转换为64位有符号整数的值。 这与收缩转换不同, 后者可能会丢失数据。 收缩转换的一个示例是将64位有符号整数转换为32位有符号整数。  
  
 下表列出了默认联编程序支持的转换。  
  
|源类型|目标类型|  
|-----------------|-----------------|  
|任何类型|其基类型。|  
|任何类型|它实现的接口。|  
|Char|Unt16、UInt32、Int32、UInt64、Int64、Single、Double|  
|Byte|Char、Unt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double|  
|SByte|Int16、Int32、Int64、Single、Double|  
|UInt16|UInt32、Int32、UInt64、Int64、Single、Double|  
|Int16|Int32、Int64、Single、Double|  
|UInt32|UInt64、Int64、Single、Double|  
|Int32|Int64、Single、Double|  
|UInt64|Single、Double|  
|Int64|Single、Double|  
|Single|Double|  
|非引用|按引用。|  
  
   
  
## Examples  
 下面的示例从`DefaultBinder`属性获取默认联编程序, 并通过将`DefaultBinder`值作为参数传递给<xref:System.Type.InvokeMember%2A>, 来调用 MyClass 的成员。  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>分隔 <see cref="T:System.Type" /> 的命名空间中的名称。 此字段为只读。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 类型的空数组。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示`EmptyTypes`了一个`GetConstructor`方法中使用的字段, 用于获取不带参数的构造函数。  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 或 <see cref="T:System.Type" /> 的基础系统类型相同。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。 为了使比较成功，<paramref name="o" /> 必须能够被强制转换或转换为类型 <see cref="T:System.Type" /> 的一个对象。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Object" /> 的基础系统类型相同。</summary>
        <returns>如果 <see langword="true" /> 的基础系统类型与当前 <paramref name="o" /> 的基础系统类型相同，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。 如果 ：此方法也会返回 <see langword="false" />。  
  
-   <paramref name="o" /> 为 <see langword="null" />。  
  
-   <paramref name="o" /> 不能强制转换或转换为 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。 它强制`o`转换为类型<xref:System.Type>的对象, 并调用<xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>方法。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.Equals%28System.Object%29>将各种<xref:System.Type>对象实例与各种<xref:System.Object>实例进行比较。  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 对于本示例, 特别要注意以下两个方面:  
  
-   <xref:System.Type> <xref:System.Reflection.TypeInfo>与表示整数<xref:System.Type>返回`true`的对象表示整数的对象比较,<xref:System.Reflection.TypeInfo>因为派生自。  
  
-   使用`List(Of String)`对象 (封闭式<xref:System.Type>泛型类型) <xref:System.Collections.Generic.IList%601>表示对象 (开放式泛型类型) 的对象比较返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">该对象，其基础系统类型将与当前 <see cref="T:System.Type" /> 的基础系统类型相比较。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 的基础系统类型是否与指定 <see cref="T:System.Type" /> 的基础系统类型相同。</summary>
        <returns>如果 <see langword="true" /> 的基础系统类型与当前 <paramref name="o" /> 的基础系统类型相同，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例使用`Equals`来比较两个类型。  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用在特性上的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段包含对<xref:System.Type.FindMembers%2A>方法使用的委托的引用。 此委托封装的方法采用两个参数: 第一个是<xref:System.Reflection.MemberInfo>对象, 第二个参数`Object`是。 方法确定`MemberInfo`对象是否与指定`Object`的条件匹配。 可以为类<xref:System.Reflection.FieldAttributes>、 <xref:System.Reflection.MethodAttributes>或<xref:System.Reflection.MethodImplAttributes>上的任何一个字段分配值。 `Object`  
  
 例如, `Object`可以为指定`FieldAttributes`字段的值, 例如 Public。 在这种情况下, `FilterAttribute`当调用委托时, 仅当`true` `MemberInfo`对象表示的方法使用元数据中的公共字段特性修饰时, 它才会返回。  
  
   
  
## Examples  
 下面的示例获取`FilterAttribute`委托, 将其作为参数传递<xref:System.Type.FindMembers%2A>给方法, 并显示指定的成员及其属性。  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于名称的区分大小写的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段包含对<xref:System.Type.FindMembers%2A>方法使用的委托的引用。 此委托封装的方法采用两个参数: 第一个是<xref:System.Reflection.MemberInfo>对象, 第二个参数`Object`是。 方法确定`MemberInfo`对象是否与指定`Object`的条件匹配。 向`Object`分配一个字符串值, 该字符串值可能包含尾随 "*" 通配符。 仅支持通配符结束字符串匹配。  
  
 例如, `Object`可以为分配值 "Byte *"。 在这种情况下, `FilterName`当调用委托时, 只有当`true` `MemberInfo`对象表示的方法具有以 "Byte" 开头的名称时, 它才会返回。  
  
   
  
## Examples  
 下面的代码示例获取与该用户定义`Application`类型相关联的方法。  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于名称的不区分大小写的成员筛选器。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此字段包含对<xref:System.Type.FindMembers%2A>方法使用的委托的引用。 此委托封装的方法采用两个参数: 第一个是<xref:System.Reflection.MemberInfo>对象, 第二个参数`Object`是。 方法确定`MemberInfo`对象是否与指定`Object`的条件匹配。 向`Object`分配一个字符串值, 该字符串值可能包含尾随 "*" 通配符。 仅支持通配符结束字符串匹配。  
  
 例如, `Object`可以为分配值 "ByTe *"。 在这种情况下, `FilterName`调用委托时, 仅当`MemberInfo`对象表示的方法具有以 "byte" 开头的名称时, 才返回 true, 忽略大小写。  
  
   
  
## Examples  
 下面的示例获取`MemberFilter`委托, 将其作为参数传递<xref:System.Type.FindMembers%2A>给方法, 并显示以字母 "c" 开头的`String`类的方法及其属性, 忽略大小写。  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="filter">对照 <paramref name="filterCriteria" /> 比较接口的委托。</param>
        <param name="filterCriteria">确定接口是否应包括在返回数组中的搜索判据。</param>
        <summary>返回表示接口（由当前 <see cref="T:System.Type" /> 所实现或继承）的筛选列表的 <see cref="T:System.Type" /> 对象数组。</summary>
        <returns>一个 <see cref="T:System.Type" /> 对象的数组，它表示由当前 <see cref="T:System.Type" /> 实现或继承的接口的已筛选的列表；如果当前 <see cref="T:System.Type" /> 未实现或继承与筛选器相匹配的接口，则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
 类提供<xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType>的和委托<xref:System.Reflection.TypeFilter?displayProperty=nameWithType>还可以用来<xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>代替委托 <xref:System.Reflection.Module?displayProperty=nameWithType> 。  
  
 此类实现的所有接口都是在搜索过程中考虑的, 无论是由基类还是此类本身来声明。  
  
 此方法搜索基类层次结构, 并返回每个类实现的每个匹配接口以及这些接口中每个接口实现的所有匹配接口 (即, 返回匹配接口的传递闭包)。 不返回重复的接口。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, <xref:System.Type.FindInterfaces%2A>则会搜索在类型参数上的约束中声明的所有接口, 以及通过接口继承的所有接口。在约束中声明。 如果当前<xref:System.Type>表示泛型类型的类型参数, <xref:System.Type.FindInterfaces%2A>则搜索该类型实现的所有接口, 无论它们是否与约束匹配。  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A>即使在非泛型类型上, 也可以返回泛型接口。 例如, 非泛型类型可能实现`IEnumerable<int>` (`IEnumerable(Of Integer)` Visual Basic)。  
  
   
  
## Examples  
 下面的示例查找指定类型实现或继承的指定接口, 然后显示接口名称。  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用静态初始值设定项时引发了异常。</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="memberType">枚举值的按位组合，它指示要搜索的成员的类型。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="filter">执行比较的委托，如果当前被检查的成员匹配 <see langword="true" />，则返回 <paramref name="filterCriteria" />；否则返回 <see langword="false" />。</param>
        <param name="filterCriteria">确定成员是否在 <see langword="MemberInfo" /> 对象数组中返回的搜索判据。  
  
<see langword="FieldAttributes" />、<see langword="MethodAttributes" /> 和 <see langword="MethodImplAttributes" /> 的字段可以和该类提供的 <see langword="FilterAttribute" /> 委托一起使用。</param>
        <summary>返回指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。</summary>
        <returns>指定成员类型的 <see cref="T:System.Reflection.MemberInfo" /> 对象的筛选数组。  
  
- 或 - 
如果当前 <see cref="T:System.Type" /> 没有与筛选条件相匹配的 <paramref name="memberType" /> 类型的成员，则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

此方法可由派生类重写。  
  
成员包括属性、方法、字段、事件等。  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>要使`bindingAttr`方法成功检索成员信息, 参数必须包含至少一个和中的至少一个和和。 `FindMembers` 

 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:  
  
-   指定`BindingFlags.Instance`在搜索中包含实例成员。  
  
-   指定`BindingFlags.Static`在搜索中包含静态成员。  
  
-   指定`BindingFlags.Public`在搜索中包括公共成员。  
  
-   指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
若要使用此方法获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
如果当前<xref:System.Type>表示泛型类型或泛型方法的类型参数, <xref:System.Type.FindMembers%2A>则会处理由类约束或类型参数的接口约束声明的任何成员。  

参数可以是类型<xref:System.Reflection.MemberFilter>的自定义委托, 也可以是以下预定义的委托之一: `filter`

- <xref:System.Type.FilterAttribute?displayProperty=nameWithType>, 它使用<xref:System.Reflection.FieldAttributes>、 <xref:System.Reflection.MethodAttributes>或<xref:System.Reflection.MethodImplAttributes>位掩码作为`filterCriteria`值。

- <xref:System.Type.FilterName?displayProperty=nameWithType>, 使用传递给`filterCriteria`的字符串对每个成员名称执行区分大小写的比较。

- <xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, 使用传递给`filterCriteria`的字符串对每个成员名称执行不区分大小写的比较。

## Examples  
 下面的示例查找与指定的搜索条件匹配的类中的所有成员, 然后显示匹配的成员。  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该类型的完全限定名称，包括其命名空间，但不包括程序集。</summary>
        <value>该类型的完全限定名，包括其命名空间，但不包括程序集；如果当前实例表示泛型类型参数、数组类型、指针类型或基于类型参数的 <see langword="null" /> 类型，或表示不属于泛型类型定义但包含无法解析的类型参数的泛型类型，则为 <see langword="byref" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如, 该<xref:System.String>类型的完全限定名为`System.String`。 将<xref:System.Type.AssemblyQualifiedName%2A>此与由属性返回的程序集限定名称 (包括全名和完整程序集名称) 进行比较。  
  
 如果当前类型表示封闭式泛型类型, 则由<xref:System.Type.FullName%2A>属性返回的字符串中的类型参数由其完整程序集名称限定, 即使泛型类型本身的字符串表示形式不是由它的完整程序集名称。 下面的示例演示了一个类型的 FullName 属性中的差异, 该类型表示泛型类型定义, 另一个表示封闭式泛型类型。  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 如果以下情况`null` , 此属性将返回:  
  
-   当前<xref:System.Type>对象表示泛型类型的类型参数。  
  
     下面的示例检索<xref:System.Nullable%601>类型的类型参数, 并尝试显示其<xref:System.Type.FullName%2A>属性。  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   当前<xref:System.Type>对象表示数组类型、指针类型`byref`或基于泛型类型参数的类型。  
  
     下面的示例定义一个泛型类型, `Generictype1<T>`其中包含三个方法`Display(T[])`:, 该方法传递类型为 T 的数组;, 它被传递 t 对象; 和`ChangeValue(ref T)`通过引用传递 t 对象。 `HandleT(T)` 因为C#和 Visual Basic 不允许我们将 T 定义为`HandleT`方法中的指针, 所以, 我们<xref:System.Type.MakePointerType%2A>必须对表示方法的参数类型<xref:System.Type>的对象调用方法, 以创建指向泛型类型的指针。 该示例的输出显示, 在所有三种情况下, <xref:System.Type.FullName%2A>属性为`null`。  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   当前类型包含尚未被特定类型 (即, <xref:System.Type.ContainsGenericParameters%2A>属性返回`true`) 替换的泛型类型参数, 但该类型不是泛型类型定义<xref:System.Type.IsGenericTypeDefinition%2A> (即, 属性返回`false`  
  
     在下面的示例中`Derived<T>` , 继承`Base<T>`自。 `null` <xref:System.Type.FullName%2A> `Derived<T>`属性获取对象, 该对象表示的基类型, 其属性返回。 <xref:System.Type> <xref:System.Type.BaseType%2A>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     若要获取<xref:System.Type.FullName%2A>不`null`是的<xref:System.Type.GetGenericTypeDefinition%2A> , 可以使用方法来获取泛型类型定义, 如示例中所示。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例显示指定类型的全名。  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 下面的示例<xref:System.Type.ToString%2A>将方法返回的字符串`Name`与、 <xref:System.Type.FullName%2A>和<xref:System.Type.AssemblyQualifiedName%2A>属性进行比较。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取描述当前泛型类型参数的协变和特殊约束的 <see cref="T:System.Reflection.GenericParameterAttributes" /> 标志。</summary>
        <value><see cref="T:System.Reflection.GenericParameterAttributes" /> 值的按位组合，用于描述当前泛型类型参数的协变和特殊约束。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性的值包含一些标志, 这些标志描述当前泛型类型参数是否是协变的, 以及描述任何特殊约束的标志。 使用值选择协变标志, 并<xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>使用值选择约束标志。 <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType>  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义了具有两`Test`个具有不同约束的类型参数的泛型类型。 当程序执行时, 使用<xref:System.Type.GenericParameterAttributes%2A>属性<xref:System.Type.GetGenericParameterConstraints%2A>和方法检查约束。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Type" /> 对象不是泛型类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Type" /> 对象表示泛型类型或泛型方法的类型参数时，获取类型参数在声明它的泛型类型或方法的类型参数列表中的位置。</summary>
        <value>类型参数在定义它的泛型类型或方法的类型参数列表中的位置。 位置编号从 0 开始。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GenericParameterPosition%2A>属性返回类型参数在最初定义该类型参数的泛型类型定义或泛型方法定义的参数列表中的位置。 <xref:System.Type.DeclaringType%2A> 和<xref:System.Type.DeclaringMethod%2A>属性标识泛型类型或方法定义:  
  
-   如果属性返回, 则表示泛型方法定义, 而当前<xref:System.Type>对象表示泛型方法定义的类型参数。 <xref:System.Reflection.MethodInfo> <xref:System.Reflection.MethodInfo> <xref:System.Type.DeclaringMethod%2A>  
  
-   `null` <xref:System.Type.DeclaringType%2A>如果属性返回, 则属性<xref:System.Type> <xref:System.Type>将始终返回表示泛型类型定义的对象, 并且当前对象表示该泛型类型的类型参数。 <xref:System.Type.DeclaringMethod%2A>定义.  
  
 若要为<xref:System.Type.GenericParameterPosition%2A>属性的值提供正确的上下文, 必须标识类型参数所属的泛型类型或方法。 例如, 请考虑以下代码中泛型方法`GetSomething`的返回值:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 返回`GetSomething`的类型取决于提供给类`A`和`GetSomething`自身的类型参数。 你可以获取<xref:System.Reflection.MethodInfo> `GetSomething`的, 以及可以获取返回类型的。 检查返回类型的类型参数时, <xref:System.Type.GenericParameterPosition%2A>对两者都返回0。 的`V`位置为 0, 因为`V`是类`A`的类型参数列表中的第一个类型参数。 的`X`位置为 0, 因为`X`是的类型参数列表`GetSomething`中的第一个类型参数。  
  
> [!NOTE]
>  如果当前<xref:System.Type>不表示类型参数, 则调用属性会导致异常。<xref:System.Type.GenericParameterPosition%2A> 检查开放式构造类型的类型参数时, 请使用<xref:System.Type.IsGenericParameter%2A>属性告诉它们是类型参数和类型。 <xref:System.Type.GenericParameterPosition%2A> <xref:System.Type.DeclaringMethod%2A> <xref:System.Type.DeclaringType%2A>属性为类型`true`参数返回; 您可以使用方法获取其位置, 并使用和属性来确定定义它的泛型方法或类型定义<xref:System.Type.IsGenericParameter%2A>.  
  
   
  
## Examples  
 下面的示例定义了一个具有两个类型参数的泛型类, 并定义了第一个派生自第一个类的泛型类。 派生类的基类具有两个类型参数: 第一个是<xref:System.Int32>, 第二个是派生类型的类型参数。 该示例显示有关这些泛型类的信息, 包括<xref:System.Type.GenericParameterPosition%2A>属性报告的位置。  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的类型不表示类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 返回 <see langword="false" />。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此类型泛型类型参数的数组。</summary>
        <value>此类型的泛型类型参数的数组。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性仅获取泛型类型参数;也就是说, 已为当前类型的泛型类型参数指定的类型。 如果当前类型是泛型类型定义, 则此属性返回一个空数组。  
  
> [!NOTE]
>  如果泛型类型在泛型方法或其他泛型类型中使用, 则它的某些泛型类型参数可能是封闭方法或类型的泛型类型参数。  
  
 若要获取表示泛型类型定义的类型的泛型类型参数, 请使用<xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>属性。 若要获取<xref:System.Reflection.TypeInfo>当前<xref:System.Type>对象的对象, 请使用<xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>扩展方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取数组中的维数。</summary>
        <returns>包含当前类型中维数的整数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示数组中的维度数。  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">此方法的功能在基类中不受支持，并且必须改为在派生类中实现。</exception>
        <exception cref="T:System.ArgumentException">当前类型不是数组。</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.Attributes" /> 属性，并获取枚举值的按位组合（它指示与 <see cref="T:System.Type" /> 关联的特性）。</summary>
        <returns>表示 <see cref="T:System.Reflection.TypeAttributes" /> 的属性集的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定构造函数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="types">表示需要的构造函数的参数个数、顺序和类型的 <see cref="T:System.Type" /> 对象的数组。  
  
- 或 - 
<see cref="T:System.Type" /> 对象的空数组，用于获取不带参数的构造函数。 这样的空数组由 <see langword="static" /> 字段 <see cref="F:System.Type.EmptyTypes" /> 提供。</param>
        <summary>搜索其参数与指定数组中的类型匹配的公共实例构造函数。</summary>
        <returns>为表示某个公共实例构造函数（该构造函数的参数与参数类型数组中的类型匹配）的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载查找公共实例构造函数, 不能用于获取类初始值设定项 (静态构造函数)。 若要获取类初始值设定项, 请使用采用<xref:System.Reflection.BindingFlags>的重载, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 如果请求的构造函数是非公共的, 则此方法`null`返回。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.ConstructorInfo>返回, 并将类型参数替换为相应的类型参数。 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法将始终返回`null`。  
  
   
  
## Examples  
 下面的示例获取的类型`MyClass`, <xref:System.Reflection.ConstructorInfo>获取对象, 并显示构造函数签名。  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
- 或 - 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="types"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
或 
获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。  
  
或 
 <see cref="F:System.Type.EmptyTypes" />。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与参数类型数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>使用指定绑定约束搜索其参数与指定自变量类型和修饰符匹配的构造函数。</summary>
        <returns>表示符合指定需求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果不存在完全匹配项, `binder`将尝试强制转换`types`数组中指定的参数类型, 以便选择匹配项。 如果无法选择匹配项`null` , 则返回。 `binder`  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共构造函数。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共构造函数 (即私有、内部和受保护的构造函数)。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法重载获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.ConstructorInfo>返回, 并将类型参数替换为相应的类型参数。 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法将始终返回`null`。  
  
   
  
## Examples  
 下面的程序获取类的`MyClass1`类型, <xref:System.Reflection.ConstructorInfo>获取与指定的绑定标志匹配的对象, 并显示该构造函数的签名。  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">对象，用于指定要使用的一套规则，这些规则涉及参数的顺序和布局、传递返回值的方式、用于参数的寄存器和清理堆栈的方式。</param>
        <param name="types"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
或 
获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>用指定绑定约束和指定调用约定，搜索其参数与指定参数类型及修饰符匹配的构造函数。</summary>
        <returns>表示符合指定要求的构造函数的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 如果不存在完全匹配项, `binder`将尝试强制转换`types`数组中指定的参数类型, 以便选择匹配项。 如果无法选择匹配项`null` , 则返回。 `binder`  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共构造函数。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共构造函数 (即私有、内部和受保护的构造函数)。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.ConstructorInfo>返回, 并将类型参数替换为相应的类型参数。 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法将始终返回`null`。  
  
   
  
## Examples  
 下面的示例获取的类型`MyClass1`, <xref:System.Reflection.ConstructorInfo>获取与指定的绑定标志匹配的对象, 并显示构造函数签名。  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">对象，用于指定要使用的一套规则，这些规则涉及参数的顺序和布局、传递返回值的方式、用于参数的寄存器和清理堆栈的方式。</param>
        <param name="types"><see cref="T:System.Type" /> 对象的数组，表示构造函数要获取的参数的个数、顺序和类型。  
  
- 或 - 
获取不使用参数的构造函数的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的构造函数。</summary>
        <returns>表示符合指定需求的构造函数的 <see cref="T:System.Reflection.ConstructorInfo" /> 对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 如果不存在完全匹配项, `binder`将尝试强制转换`types`数组中指定的参数类型, 以便选择匹配项。 如果无法选择匹配项`null` , 则返回。 `binder`  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共构造函数。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共构造函数 (即私有、内部和受保护的构造函数)。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 此方法实现 <xref:System.Type.GetConstructor%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
- 或 - 
 <paramref name="modifiers" /> 是多维的。  
  
- 或 - 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的构造函数。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 定义的所有公共构造函数。</summary>
        <returns><see cref="T:System.Reflection.ConstructorInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 定义的所有公共实例构造函数，但不包括类型初始值设定项（静态构造函数）。 如果没有为当前 <see cref="T:System.Type" /> 定义公共实例构造函数，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法的定义中的类型参数，则返回 <see cref="T:System.Reflection.ConstructorInfo" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetConstructors%2A>方法不按特定顺序 (如声明顺序) 返回构造函数。 你的代码不能依赖于构造函数的返回顺序, 因为该顺序会有所不同。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 此方法重载调用<xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>方法重载&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在VisualBasic中)。`Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> 它将找不到类初始值设定项 (静态构造函数)。 若要查找类初始值设定项, 请使用<xref:System.Reflection.BindingFlags>采用的重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.ConstructorInfo>返回类型参数替换为相应类型参数的对象。 例如, 如果`C<T>`类具有构造函数<xref:System.Reflection.ConstructorInfo> <xref:System.Type.GetConstructors%2A> `C(T t1)` (`Sub New(ByVal t1 As T)`在 Visual Basic 中), `C<int>` `C(int t1)`则C#将返回表示中的`Sub New(ByVal t1 As Integer)`基本)。  
  
 如果当前<xref:System.Type>表示泛型类型参数, 则该<xref:System.Type.GetConstructors%2A>方法返回空数组。  
  
   
  
## Examples  
 此示例显示具有两个实例<xref:System.Type.GetConstructors%2A>构造函数和一个静态构造函数的类的重载的输出。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此代码的输出为:  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `IsStatic`因为重载仅使用和, 所以静态构造函数既不由`for`表达式进行计数, 也不由计算。 <xref:System.Type.GetConstructors>  
  
 若要查找静态构造函数, <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>请使用重载, 并传递、 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、 `OR` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>的<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>组合 (逻辑), 如下面的代码示例所示:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 输出如下:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定 <see cref="T:System.Type" /> 搜索为当前 <see langword="BindingFlags" /> 定义的构造函数。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.ConstructorInfo" /> 定义的匹配指定绑定约束的所有构造函数的 <see cref="T:System.Type" /> 对象数组，包括类型初始值设定项（如果定义的话）。 如果当前 <see cref="T:System.Reflection.ConstructorInfo" /> 没有定义构造函数，或者定义的构造函数都不符合绑定约束，或者当前 <see cref="T:System.Type" /> 表示泛型类型或泛型方法定义的类型参数，则返回 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
`bindingAttr`可用于指定是只返回公共构造函数还是返回公共和非公共构造函数。  
  
以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的构造函数:  
  
- `BindingFlags.Static` 与`BindingFlags.NonPublic`一起指定以检索类初始值设定项 (静态构造函数)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。

- 同时`BindingFlags.Instance` `BindingFlags.NonPublic`指定和和,以检索实例构造函数。`BindingFlags.Public`   
  
有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  

<xref:System.Type.GetConstructors%2A>方法不按特定顺序 (如声明顺序) 返回构造函数。 你的代码不能依赖于构造函数的返回顺序, 因为该顺序会有所不同。  

如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.ConstructorInfo>返回类型参数替换为相应类型参数的对象。 例如, 如果`C<T>`类具有构造函数<xref:System.Reflection.ConstructorInfo> <xref:System.Type.GetConstructors%2A> `C(T t1)` (`Sub New(ByVal t1 As T)`在 Visual Basic 中), `C<int>` `C(int t1)`则C#将返回表示中的`Sub New(ByVal t1 As Integer)`基本)。  
  
如果当前<xref:System.Type>表示泛型类型参数, 则该<xref:System.Type.GetConstructors%2A>方法返回空数组。  
  
## Examples  

此示例显示具有两个实例<xref:System.Type.GetConstructors>构造函数和一个静态构造函数的类的重载的输出。  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 此代码的输出为:  
  
 2  
  
 False  
  
 False  
  
 <xref:System.Reflection.BindingFlags.Public> <xref:System.Reflection.BindingFlags.Instance> `IsStatic`因为重载仅使用和, 所以静态构造函数既不由`for`表达式进行计数, 也不由计算。 <xref:System.Type.GetConstructors%2A>  
  
 若要查找静态构造函数, <xref:System.Type.GetConstructors%2A>请使用重载, 并向其传递<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>、 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>、的组合 (逻辑或), 如下面的代码示例所示:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 输出如下:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>搜索为设置了 <see cref="T:System.Type" /> 的当前 <see cref="T:System.Reflection.DefaultMemberAttribute" /> 定义的成员。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有默认成员的 <see cref="T:System.Type" /> 对象数组。  
  
- 或 - 
如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetDefaultMembers%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。 你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。  
  
 此方法可由派生类重写。  
  
 成员包括属性、方法、字段、事件等。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MemberInfo>返回类型参数替换为相应类型参数的对象。 例如, 如果类`C<T>`具有一个返回`P` `T`的属性, 则在<xref:System.Type.GetDefaultMembers%2A>中`C<int>`调用`int P`将C#在`Property P As Integer`中返回 (在 Visual Basic 中)。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。  
  
   
  
## Examples  
 下面的示例获取的默认成员信息`MyClass`并显示默认成员。  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，返回当前数组、指针或引用类型包含的或引用的对象的 <see cref="T:System.Type" />。</summary>
        <returns>当前数组、指针或引用类型包含或引用的对象的 <see cref="T:System.Type" />；如果当前 <see langword="null" /> 不是数组或指针，不是按引用传递，或者表示泛型类型或泛型方法的定义中的泛型类型或类型参数，则为 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法`null` <xref:System.Array>为类返回。  
  
   
  
## Examples  
 下面的示例演示如何使用`GetElementType`方法。  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">要检索其名称的值。</param>
        <summary>返回当前枚举类型中具有指定值的常数的名称。</summary>
        <returns>当前枚举类型中具有指定值的成员的名称；如果未找到这样的常数，则为 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。  
  
或 
 <paramref name="value" /> 既不是当前类型，也不具有与当前类型相同的基础类型。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型中各个成员的名称。</summary>
        <returns>一个数组，其中包含枚举中各个成员的名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回值数组的元素按枚举常量的二进制值 (即无符号值) 排序。 如果数组包含具有相同值的枚举常量, 则不指定其对应名称的顺序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型的基础类型。</summary>
        <returns>当前枚举的基础类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, 和 Visual Basic 中C#的枚举的基础类型为<xref:System.Int32>。 可以指定其他整数类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。  
  
 或  
  
 枚举类型无效，因为它包含多个实例字段。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前枚举类型中各个常数的值组成的数组。</summary>
        <returns>包含值的数组。 该数组的元素按枚举常量的二进制值（无符号值）排序。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 声明或继承的特定事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">该字符串包含事件名称，该事件是由当前 <see cref="T:System.Type" /> 声明或继承的。</param>
        <summary>返回表示指定的公共事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</summary>
        <returns>如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。 否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例事件。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.EventInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例创建一个<xref:System.Reflection.EventInfo>对象, 并为指定的事件获取按钮类的事件。  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串包含由当前的 <see cref="T:System.Type" /> 声明或继承的事件的名称。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，返回表示指定事件的 <see cref="T:System.Reflection.EventInfo" /> 对象。</summary>
        <returns>如找到，则为表示由当前 <see cref="T:System.Type" /> 声明或继承的指定公共事件的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的事件:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共事件。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共事件 (即, 私有事件、内部事件和受保护事件)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的事件, 而不搜索只是继承的事件。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。 否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.EventInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>方法在类型中搜索名为 "单击" 的`static`公共或非公共事件 (`Shared`在 Visual Basic 中)。  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 声明或继承的事件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回由当前 <see cref="T:System.Type" /> 声明或继承的所有公共事件。</summary>
        <returns>表示由当前 <see cref="T:System.Reflection.EventInfo" /> 声明或继承的所有公共事件的 <see cref="T:System.Type" /> 对象数组。  
  
- 或 - 
如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有默认成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。 否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 <xref:System.Type.GetEvents%2A>方法不按特定顺序返回事件, 如字母顺序或声明顺序。 你的代码不能依赖于事件的返回顺序, 因为该顺序会有所不同。  
  
 此方法可由派生类重写。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.EventInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例获取对象的<xref:System.Reflection.EventInfo>数组, 获取`Button`类的所有事件, 并显示事件名称。 若要编译 Visual Basic 示例, 请使用以下命令行:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

- 或 -

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索由当前 <see cref="T:System.Type" /> 声明或继承的事件。</summary>
        <returns><see cref="T:System.Reflection.EventInfo" /> 对象的数组，表示当前 <see cref="T:System.Type" /> 所声明或继承的与指定绑定约束匹配的所有事件。  
  
或 
如果当前 <see cref="T:System.Reflection.EventInfo" /> 没有事件，或者如果没有一个事件匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetEvents%2A>方法不按特定顺序返回事件, 如字母顺序或声明顺序。 你的代码不能依赖于事件的返回顺序, 因为该顺序会有所不同。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的事件:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共事件。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共事件 (即, 私有事件、内部事件和受保护事件)。 仅返回基类的受保护事件和内部事件;不返回基类上的私有事件。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的事件, 而不搜索只是继承的事件。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果某个事件至少有一个公共方法或访问器, 则该事件将被视为 "公共"。 否则, 该事件将被视为私有事件, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.EventInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的事件。  
  
   
  
## Examples  
 下面的示例获取与指定绑定<xref:System.Reflection.EventInfo>标志匹配的对象的数组, 获取`Button`类的所有事件, 并显示事件名称。 若要编译 Visual Basic 示例, 请使用以下命令行:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的数据字段的名称的字符串。</param>
        <summary>搜索具有指定名称的公共字段。</summary>
        <returns>如找到，则为表示具有指定名称的公共字段的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例字段。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.FieldInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的字段。  
  
   
  
## Examples  
 下面的示例获取`Type`指定类的对象, <xref:System.Reflection.FieldInfo>获取该字段的对象, 并显示该字段的值。  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">此 <see cref="T:System.Type" /> 对象是尚未调用其 <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> 方法的 <see cref="T:System.Reflection.Emit.TypeBuilder" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的数据字段的名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>使用指定绑定约束搜索指定字段。</summary>
        <returns>表示符合指定需求的字段的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的字段:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包含公共字段。  
  
-   指定`BindingFlags.NonPublic`以包括搜索中的非公共字段 (即, 私有字段、内部字段和受保护字段)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的字段, 而不搜索只是继承的字段。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.FieldInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的字段。  
  
   
  
## Examples  
 下面的示例获取`Type`指定类的对象, <xref:System.Reflection.FieldInfo>获取与指定绑定标志匹配的字段的对象, 并显示该字段的值。  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的字段。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前 <see cref="T:System.Type" /> 的所有公共字段。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的所有公共字段的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的公共字段，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetFields%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回字段。 你的代码不能依赖于字段的返回顺序, 因为该顺序会有所不同。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.FieldInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的公共字段。  
  
   
  
## Examples  
 下面的示例演示`GetFields()`方法的用法。  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

- 或 -

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的字段。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的匹配指定绑定约束的所有字段的 <see cref="T:System.Type" /> 对象数组。  
  
- 或 - 
如果没有为当前 <see cref="T:System.Reflection.FieldInfo" /> 定义的字段，或者如果没有一个定义的字段匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索属性信息, 参数必须包含至少一个和, 以及至少一个和中的一个。 `GetFields(BindingFlags)` 

以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的字段:  
  
- 指定`BindingFlags.Instance`以包括实例方法。 

- 指定`BindingFlags.Static`以包括静态方法。 
    
- 指定`BindingFlags.Public`在搜索中包含公共字段。  
  
- 指定`BindingFlags.NonPublic`以包括搜索中的非公共字段 (即, 私有字段、内部字段和受保护字段)。 仅返回基类的受保护字段和内部字段;不返回基类上的私有字段。  
  
- 指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  

- 单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.PropertyInfo>数组。

以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
- `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的字段, 而不搜索只是继承的字段。  
  
有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
<xref:System.Type.GetFields%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回字段。 你的代码不能依赖于字段的返回顺序, 因为该顺序会有所不同。  

 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.FieldInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的公共字段。  
  
## Examples  
 下面的示例演示`GetFields(BindingFlags)`方法的用法。  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示封闭式泛型类型的类型参数或泛型类型定义的类型参数的 <see cref="T:System.Type" /> 对象的数组。</summary>
        <returns>表示泛型类型的类型实参的 <see cref="T:System.Type" /> 对象的数组。 如果当前类型不是泛型类型，则返回一个空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 数组元素按它们出现在泛型类型的类型参数列表中的顺序返回。  
  
-   如果当前类型是封闭式构造类型 (即, <xref:System.Type.ContainsGenericParameters%2A>属性返回`false`), 则<xref:System.Type.GetGenericArguments%2A>方法返回的数组包含已分配给泛型类型定义的泛型类型参数的类型。  
  
-   如果当前类型是泛型类型定义, 则数组包含类型参数。  
  
-   如果当前的类型是开放式构造类型 (即, <xref:System.Type.ContainsGenericParameters%2A>属性返回`true`), 并且未将特定类型分配给封闭泛型类型或方法的所有类型参数和类型参数, 则数组包含类型和类型参数。 <xref:System.Type.IsGenericParameter%2A>使用属性将它们区分开来。 有关此方案的演示, 请参阅<xref:System.Type.ContainsGenericParameters%2A>属性的代码示例。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetGenericArguments%2A>方法显示构造类型的类型参数及其泛型类型定义的类型参数。  
  
 此代码示例是为<xref:System.Type.IsGenericTypeDefinition%2A>属性提供的更大示例的一部分。 请参阅示例输出的更大示例。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前泛型类型参数约束的 <see cref="T:System.Type" /> 对象的数组。</summary>
        <returns>表示当前泛型类型参数上的约束的 <see cref="T:System.Type" /> 对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型参数上的每个约束都表示为<xref:System.Type>一个对象。 使用属性来确定约束是否为基类约束; 如果属性返回`false`, 则约束为接口约束。 <xref:System.Type.IsClass%2A> 如果类型参数没有类约束, 并且没有接口约束, 则返回空数组。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例定义了具有两`Test`个具有不同约束的类型参数的泛型类型。 当程序执行时, 使用<xref:System.Type.GenericParameterAttributes%2A>属性<xref:System.Type.GetGenericParameterConstraints%2A>和方法检查约束。  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Type" /> 对象不是泛型类型参数。 也就是说，<see cref="P:System.Type.IsGenericParameter" /> 属性将返回 <see langword="false" />。</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个表示可用于构造当前泛型类型的泛型类型定义的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示可用于构造当前类型的泛型类型的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型定义是可以从中构造其他类型的模板。 例如, 从泛型类型定义`G<T>` (用C#语法表示),`G<int>` `G(Of Integer)`在 Visual Basic 或`generic <typename T> ref class G`中C++), 您可以构造并实例化类型 (在 Visual Basic 中)。 `G(Of T)` 给定表示此构造类型的<xref:System.Type.GetGenericTypeDefinition%2A> 对象,方法返回泛型类型定义。<xref:System.Type>  
  
 如果两种构造类型是使用相同的类型参数从同一泛型类型定义创建的, 则<xref:System.Type.GetGenericTypeDefinition%2A>该方法将为<xref:System.Type>这两种类型返回相同的对象。  
  
 如果在已表示<xref:System.Type.GetGenericTypeDefinition%2A>泛型类型定义<xref:System.Type>的对象上调用方法, 则它将返回当前<xref:System.Type>。  
  
> [!IMPORTANT]
>  泛型类型的数组本身不是泛型。 在C#代码`A<int>[] v;`或 Visual Basic 代码`Dim v() As A(Of Integer)`中, 变量`v`的类型不是泛型。 用于<xref:System.Type.IsGenericType%2A>在调用<xref:System.Type.GetGenericTypeDefinition%2A>之前确定类型是否为泛型。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的代码示例使用普通实例创建创建构造类型的实例, 然后使用<xref:System.Type.GetType%2A>和<xref:System.Type.GetGenericTypeDefinition%2A>方法检索构造类型和泛型类型定义。 此示例使用泛型<xref:System.Collections.Generic.Dictionary%602>类型; 构造类型<xref:System.Collections.Generic.Dictionary%602>表示具有字符串键的`Test`对象的。  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前类型不是泛型类型。  也就是说，<see cref="P:System.Type.IsGenericType" /> 返回 <see langword="false" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>此实例的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例显示`System.Windows.Forms.Button`类的哈希代码。  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取由当前 <see cref="T:System.Type" /> 实现或继承的特定接口。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的接口名称的字符串。 对于泛型接口，这是重整名称。</param>
        <summary>搜索具有指定名称的接口。</summary>
        <returns>表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的搜索`name`区分大小写。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Type>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索接口约束以及从类或接口约束继承的任何接口。  
  
> [!NOTE]
>  对于泛型接口, `name`参数为错位名称, 以抑音符 (\`) 和类型参数的数目结尾。 这对于泛型接口定义和构造泛型接口都是如此。 例如, 若要查找`IExample<T>` (`IExample(Of T)`在 Visual Basic 中) `IExample<string>`或`IExample(Of String)` (在 Visual Basic 中), ``"IExample`1"``请搜索。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetInterface%28System.String%29>方法在<xref:System.Collections.Hashtable>类<xref:System.Runtime.Serialization.IDeserializationCallback>中搜索接口, 并列出接口的方法。  
  
 此代码示例还演示了<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法重载<xref:System.Type.GetInterfaceMap%2A>和方法。  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">当前 <see cref="T:System.Type" /> 表示实现具有不同类型参数的相同泛型接口的类型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的接口名称的字符串。 对于泛型接口，这是重整名称。</param>
        <param name="ignoreCase"><see langword="true" /> 表示对于用来指定简单接口名称的 <paramref name="name" /> 部分（该部分指定命名空间大小写必须正确）忽略其大小写。  
  
或 
 <see langword="false" /> 表示对 <paramref name="name" /> 的所有部分执行区分大小写的搜索。</param>
        <summary>当在派生类中重写时，搜索指定的接口，指定是否要对接口名称执行不区分大小写的搜索。</summary>
        <returns>表示具有指定名称且由当前的 <see cref="T:System.Type" /> 实现或继承的接口的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此`ignoreCase`参数仅适用于简单接口名称, 而不适用于命名空间。 指定命名空间`name`的部分必须具有正确的大小写, 否则将找不到该接口。 例如, 字符串 "system.icomparable" 查找<xref:System.IComparable>接口, 但字符串 "system.icomparable" 不会。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Type>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索接口约束以及从类或接口约束继承的任何接口。  
  
> [!NOTE]
>  对于泛型接口, `name`参数为错位名称, 以抑音符 (\`) 和类型参数的数目结尾。 这对于泛型接口定义和构造泛型接口都是如此。 例如, 若要查找`IExample<T>` (`IExample(Of T)`在 Visual Basic 中) `IExample<string>`或`IExample(Of String)` (在 Visual Basic 中), `"IExample`请搜索 "1"。  
  
   
  
## Examples  
 下面的代码示例使用<xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>方法为<xref:System.Collections.IEnumerable>接口执行不区分大小写的<xref:System.Collections.Hashtable>类搜索。  
  
 此代码示例还演示了<xref:System.Type.GetInterface%28System.String%29>方法重载<xref:System.Type.GetInterfaceMap%2A>和方法。  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">当前 <see cref="T:System.Type" /> 表示实现具有不同类型参数的相同泛型接口的类型。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="interfaceType">要检索其映射的接口类型。</param>
        <summary>返回指定接口类型的接口映射。</summary>
        <returns>表示 <paramref name="interfaceType" /> 的接口映射的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接口映射表示接口如何映射到实现该接口的类上的实际成员。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则在此方法返回的的<xref:System.Reflection.InterfaceMapping>元素中, 类型参数将替换为相应的类型参数。  
  
   
  
## Examples  
 下面的<xref:System.Type.GetInterfaceMap%2A>示例调用方法来确定<xref:System.IFormatProvider>接口如何映射到<xref:System.Globalization.CultureInfo>方法, 以及<xref:System.IAppDomainSetup>接口如何映射到<xref:System.AppDomainSetup>属性。 请注意, 由于<xref:System.IAppDomainSetup>接口定义了一组属性, 因此, 返回<xref:System.Reflection.InterfaceMapping>的对象为属性的 get 和 set 访问器包含单独<xref:System.Reflection.MethodInfo>的对象。  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">当前类型未实现 <paramref name="interfaceType" />。  
  
- 或 - 
<paramref name="interfaceType" /> 参数未引用接口。  
  
或

当前实例或 <paramref name="interfaceType" /> 参数是开放式泛型类型；即，<see cref="P:System.Type.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。

或


 <paramref name="interfaceType" /> 是一个泛型接口，而当前类型是一个数组类型。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前 <see cref="T:System.Type" /> 表示泛型类型参数；即， <see cref="P:System.Type.IsGenericParameter" /> 为 <see langword="true" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，获取由当前 <see cref="T:System.Type" /> 实现或继承的所有接口。</summary>
        <returns>表示由当前 <see cref="T:System.Type" /> 实现或继承的所有接口的 <see cref="T:System.Type" />对象数组。  
  
- 或 - 
如果没有由当前 <see cref="T:System.Type" /> 实现或继承的接口，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetInterfaces%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回接口。 你的代码不能依赖于接口的返回顺序, 因为该顺序会有所不同。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Type>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索接口约束以及从类或接口约束继承的任何接口。  
  
   
  
## Examples  
 下面的示例获取指定类的类型并显示该类型实现或继承的所有接口。 若要编译 Visual Basic 示例, 请使用以下编译器命令:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用静态初始值设定项时引发了异常。</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的指定成员。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共成员名称的字符串。</param>
        <summary>搜索具有指定名称的公共成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例成员。  
  
 成员包括属性、方法、字段、事件等。  
  
 <xref:System.Type.GetMember%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。 你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。  
  
 此方法重载将找不到类初始值设定项 (静态构造函数)。 若要查找类初始值设定项, 请使用<xref:System.Reflection.BindingFlags>采用的重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MemberInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。  
  
   
  
## Examples  
 下面的示例显示以字母 C 开头的`String`类的所有成员。  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的成员的名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>使用指定绑定约束搜索指定成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
 成员包括属性、方法、字段、事件等。  
  
 <xref:System.Type.GetMember%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。 你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共成员。  
  
-   指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法重载获取类初始值设定项 (静态构造函数), 必须为指定 "static `name`构造函数<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> "<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> , Visual Basic &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>并为`bindingAttr`. 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MemberInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。  
  
   
  
## Examples  
 下面的示例显示以字母 C 开头的`myString`类的所有公共静态成员。  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的成员的名称的字符串。</param>
        <param name="type">要搜索的值。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>使用指定绑定约束搜索指定成员类型的指定成员。</summary>
        <returns>一个表示具有指定名称的公共成员的 <see cref="T:System.Reflection.MemberInfo" /> 对象数组（如果找到的话）；否则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 成员包括属性、方法、字段、事件等。  
  
 <xref:System.Type.GetMember%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。 你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共成员。  
  
-   指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 若要使用此方法重载获取类初始值设定项 (静态构造函数`name`), 必须为`type`、和&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or`指定"静态构造函数"。对于为VisualBasic`bindingAttr`)。 <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MemberInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。  
  
   
  
## Examples  
 下面的示例显示以字母 C 开头的`myString`类的所有方法。  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">派生类必须提供一个实现。</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的成员（包括属性、方法、字段、事件等）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共成员。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.MemberInfo" /> 的所有公共成员的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果当前 <see cref="T:System.Reflection.MemberInfo" /> 没有公共成员，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

成员包括属性、方法、构造函数、字段、事件和嵌套类型。
  
 <xref:System.Type.GetMembers%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。 你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。  
  
 <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>此方法重载调用方法重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>在 Visual Basic 中)。<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; `Or` `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> 它将找不到类初始值设定项 (静态构造函数)。 若要查找类初始值设定项<xref:System.Type.GetMembers(System.Reflection.BindingFlags)> , 请调用重载<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ,<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>并&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>指定 (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MemberInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。 
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Type.GetMembers>方法重载来收集有关指定类的所有公共成员的信息。  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的成员。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MemberInfo" /> 定义的匹配指定绑定约束的所有成员的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Type" /> 定义成员，或者定义的成员均与绑定约束不匹配，则为空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

成员包括属性、方法、构造函数、字段、事件和嵌套类型。

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索方法信息, 参数必须包含至少一个和中的至少一个和和。 `GetMethods(BindingFlags)` 唯一的例外是使用<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>的方法调用, 它返回有关嵌套类型的成员信息。

以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员: 

- 指定`BindingFlags.Instance`以包括实例方法。 

- 指定`BindingFlags.Static`以包括静态方法。 
  
- 指定`BindingFlags.Public`在搜索中包含公共方法。  
  
- 指定`BindingFlags.NonPublic`以在搜索中包括非公共方法 (即私有、内部和保护的方法)。 仅返回基类的受保护方法和内部方法;不返回基类上的私有方法。  
  
- 指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  

- 单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.MethodInfo>数组。

以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
- `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。  
  
有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  

<xref:System.Type.GetMembers%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回成员。 你的代码不能依赖于成员的返回顺序, 因为该顺序会有所不同。  

 若要使用此方法重载获取类初始值设定项 (静态构造函数), <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>必须<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>指定&#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (`Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>在 Visual Basic 中)。 还可以使用<xref:System.Type.TypeInitializer%2A>属性获取类初始值设定项。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MemberInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的成员, 或者<xref:System.Object>如果没有类约束, 则搜索的成员。  

## Examples  
 下面的代码示例演示如何使用<xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>方法重载来收集有关指定类的所有公共实例成员的信息。  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <summary>搜索具有指定名称的公共方法。</summary>
        <returns>表示具有指定名称的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例方法。  
  
 如果重载了方法并且有多个公共方法, 该<xref:System.Type.GetMethod%28System.String%29>方法将<xref:System.Reflection.AmbiguousMatchException>引发异常。 在下面的示例中, 引发了异常, 因为有多个<xref:System.Int32.ToString%2A?displayProperty=nameWithType>方法的公共重载。  另一方面, 因为`Person.ToString`方法会重写<xref:System.Object.ToString%2A?displayProperty=nameWithType> , 因此不<xref:System.Type.GetMethod%28System.String%29>会重载, 所以方法可以检索<xref:System.Reflection.MethodInfo>对象。  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 可以执行以下操作之一来检索特定方法:  
  
-   调用方法, 并指定唯一`bindingAttr`标识该方法的参数。 <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> 例如, 如果由于类型具有静态和实例重载而引发异常, 则可以`bindingAttr`指定的<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>参数。  
  
-   <xref:System.Type.GetMethod%2A> 调用`types`包含参数的方法的重载, 该参数定义方法的参数的类型。  
  
-   <xref:System.Type.GetMethods>调用方法以检索包含属于某个类型的所有公共方法的数组。 然后, 你可以对其进行循环访问以识别`name`名为的重复方法。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。  
  
   
  
## Examples  
 下面的示例获取名为`MethodA`的方法。  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>使用指定绑定约束搜索指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:  
  
-   必须指定<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>才能获取返回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在搜索中包含公共方法。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>以在搜索中包括非公共方法 (即私有、内部和保护的方法)。  
  
-   指定<xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType>在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType>如果忽略, 则为`name`。  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果重载方法, 并且多个重载满足`bindingAttr`参数所指定的约束, 则该方法将<xref:System.Reflection.AmbiguousMatchException>引发异常。 在下面的示例中, 引发了异常, 因为:  
  
-   该`TestClass`类型具有两个`DisplayValue`方法的公共实例重载: `DisplayValue(String)`和`DisplayValue(String, Object[])`。  
  
-   此`TestClass`类型具有`Equals`方法的两个公共实例重载, 其中一个派生自<xref:System.Object>: `Equals(TestClass)`和`Equals(Object)`。  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 可以执行以下操作之一来检索特定方法:  
  
-   更改绑定约束。 在前面的示例中, 尝试检索由类型声明`Equals`的公共实例方法, 而不是成功检索。 `Equals(TestClass)`  
  
-   <xref:System.Type.GetMethod%2A> 调用`types`包含参数的方法的重载, 该参数定义方法的参数的类型。  
  
-   <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>调用方法以检索一个数组, 该数组包含属于具有指定绑定特性的类型的所有方法。 然后, 你可以对其进行循环访问以识别`name`名为的重复方法。 此方法在上一个示例的<xref:System.Reflection.AmbiguousMatchException>异常处理程序中进行了说明。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。  
  
   
  
## Examples  
 下面的示例获取与指定的绑定标志匹配的方法。  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <summary>搜索其参数与指定参数类型匹配的指定公共方法。</summary>
        <returns>表示其参数与指定参数类型匹配的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例方法。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。  
  
> [!NOTE]
>  `name`参数不能包括类型参数。 例如, C#代码`GetMethod("MyGenericMethod<int>")`搜索文本名称为 "`MyGenericMethod<int>`" 的方法, 而不是使用一个类型`int`的泛型参数的`MyGenericMethod`名为的方法。 应将与`GetMethod("MyGenericMethod")` `types`数组中的相应参数一起使用。  
  
   
  
## Examples  
 下面的示例查找的`MethodA`特定重载, 并指定各种参数类型。  
  
> [!NOTE]
>  该[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例`/unsafe`需要编译器选项。  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 下面的示例检索<xref:System.Reflection.MethodInfo> `Add`表示非泛型类型 ( <xref:System.Collections.ArrayList>类<xref:System.Collections.Generic.List%601> )、开放式泛型类型 (类) 和封闭式泛型类型 ( `List(Of String)`类型) 的方法的对象。  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 该示例定义了`GetAddMethod`一个检索相应<xref:System.Reflection.MethodInfo>对象的方法。 为了提供开放式`types`泛型类型的参数, 它将<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>调用方法。 为提供封闭式`types`泛型类型的参数, 它将检索<xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>属性的值。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称和指定参数的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共方法的名称的字符串。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>搜索其参数与指定参数类型及修饰符匹配的指定公共方法。</summary>
        <returns>表示符合指定要求的公共方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例方法。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMethod("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。 应将与`GetMethod("MyMethod")` `types`数组中的相应参数一起使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称和指定参数的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
- 或 - 
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
- 或 - 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
- 或 - 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>使用指定绑定约束，搜索其参数与指定参数类型及修饰符匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包含公共方法。  
  
-   指定`BindingFlags.NonPublic`在搜索中包含非公共方法 (即私有方法、内部方法和受保护的方法)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。  
  
   
  
## Examples  
 下面的示例查找的`MethodA`特定重载, 并指定绑定约束和各种参数类型。  
  
> [!NOTE]
>  该[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例`/unsafe`需要编译器选项。  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
- 或 - 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">该对象用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器和清理堆栈的方式。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
- 或 - 
空的 <see cref="T:System.Type" /> 对象数组（由 <see cref="F:System.Type.EmptyTypes" /> 字段提供），用来获取不采用参数的方法。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 仅当通过 COM 互操作进行调用时才使用，而且仅处理通过引用传递的参数。 默认的联编程序不处理此参数。</param>
        <summary>用指定的绑定约束和指定的调用约定，搜索参数与指定的参数类型及修饰符相匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 下表显示了在类型上反射时`GetXXX`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包含公共方法。  
  
-   指定`BindingFlags.NonPublic`在搜索中包含非公共方法 (即私有方法、内部方法和受保护的方法)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.MethodInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。  
  
> [!NOTE]
>  对于泛型方法, 请不要在中`name`包括类型参数。 例如, C#代码`GetMember("MyMethod<int>")`将搜索文本名称为 "`MyMethod<int>`" 的成员, 而不是使用一个类型`int`的泛型参数`MyMethod`的名为的方法。  
  
   
  
## Examples  
 下面的示例查找的`MethodA`特定重载, 指定绑定约束、调用约定和各种参数类型。  
  
> [!NOTE]
>  该[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] 示例`/unsafe`需要编译器选项。  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的方法名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="callConvention">该对象，用于指定要使用的一套规则，这些规则涉及自变量的顺序和布局、传递返回值的方式、用于自变量的寄存器以及哪个进程清理堆栈。</param>
        <param name="types">表示此方法要获取的参数的个数、顺序和类型的 <see cref="T:System.Type" /> 对象数组。  
  
或 
一个类型为 <see cref="T:System.Type" /> （即 Type[] types = new Type[0]）的空数组，用于获取一个不带参数的方法。  
  
或 
 <see langword="null" />。 如果 <paramref name="types" /> 为 <see langword="null" />，则参数不匹配。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束和指定的调用约定搜索其参数与指定的自变量类型和修饰符匹配的指定方法。</summary>
        <returns>表示符合指定要求的方法的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 如果 `types` 为 `null`，则参数不匹配。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包含公共方法。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共方法 (即私有、内部和保护的方法)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定绑定约束匹配的方法。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共方法。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的所有公共方法的 <see cref="T:System.Type" /> 对象数组。  
  
或 
如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的公共方法，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Type.GetMethods%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回方法。 你的代码不能依赖于方法的返回顺序, 因为该顺序会有所不同。  
  
 构造函数不包含在此调用所返回的方法的数组中。 单独调用`GetConstructors()`以获取构造函数方法。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
> [!NOTE]
>  在查找构造函数和方法时, 不能忽略参数。 在调用时, 只能省略参数。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MethodInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

- 或 -

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索为当前 <see cref="T:System.Type" /> 定义的方法。</summary>
        <returns>表示为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的匹配指定绑定约束的所有方法的 <see cref="T:System.Type" /> 对象数组。  
  
- 或 - 
如果没有为当前 <see cref="T:System.Reflection.MethodInfo" /> 定义的方法，或者如果没有一个定义的方法匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索方法信息, 参数必须包含至少一个和中的至少一个和和。 `GetMethods(BindingFlags)` 
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的方法:  
  
- 指定`BindingFlags.Instance`以包括实例方法。 

- 指定`BindingFlags.Static`以包括静态方法。 
  
- 指定`BindingFlags.Public`在搜索中包含公共方法。  
  
- 指定`BindingFlags.NonPublic`以在搜索中包括非公共方法 (即私有、内部和保护的方法)。 仅返回基类的受保护方法和内部方法;不返回基类上的私有方法。  
  
- 指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  

- 单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.MethodInfo>数组。
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
- `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的方法, 而不搜索简单继承的方法。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  

<xref:System.Type.GetMethods%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回方法。 你的代码不能依赖于方法的返回顺序, 因为该顺序会有所不同。  

如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.MethodInfo>返回类型参数替换为相应类型参数的对象。  
  
如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的方法, <xref:System.Object>如果没有类约束, 则搜索的方法。 
  
## Examples  
 下面的示例创建一个具有两个公共方法和一个受保护方法的类`Type` , 创建与`MyTypeClass`对应的对象, 获取所有公共和非公共方法, 并显示它们的名称。  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取嵌套在当前 <see cref="T:System.Type" /> 中的特定类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的嵌套类型的名称的字符串。</param>
        <summary>搜索具有指定名称的公共嵌套类型。</summary>
        <returns>如找到，则为表示具有指定名称的公共嵌套类型的对象；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的搜索`name`区分大小写。  
  
 使用嵌套类`name`的简单名称。 不要将其与外部类的名称限定。 对于泛型嵌套类, 请使用错位的名称-即, 追加一个重音符和泛型参数的数目。 例如, 使用字符串 "Inner\`1" 获取泛型嵌套类`Inner<T>` (`Inner(Of T)`在 Visual Basic 中)。 不要包含类型参数的特定于语言的语法。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型, 也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的嵌套类型的名称的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束搜索指定嵌套类型。</summary>
        <returns>表示符合指定要求的嵌套类型的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用嵌套类`name`的简单名称。 不要将其与外部类的名称限定。 对于泛型嵌套类, 请使用错位的名称-即, 追加一个重音符和泛型参数的数目。 例如, 使用字符串 "Inner\`1" 获取泛型嵌套类`Inner<T>` (`Inner(Of T)`在 Visual Basic 中)。 不要包含类型参数的特定于语言的语法。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的嵌套类型:  
  
-   必须指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>才能获取返回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在搜索中包括公共嵌套类型。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>以在搜索中包括非公共嵌套类型 (即私有、内部和受保护的嵌套类型)。  
  
 此方法只返回当前类型的嵌套类型。 它不会搜索当前类型的基类。 若要查找嵌套在基类中的类型, 必须遍历继承层次结构, 并在<xref:System.Type.GetNestedType%2A>每个级别调用。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>将被忽略。  
  
 仅<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>用标志或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>标志调用此方法将返回指定的嵌套类型, 并且不需要任何其他标志。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型, 也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取嵌套在当前 <see cref="T:System.Type" /> 中的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回嵌套在当前的 <see cref="T:System.Type" /> 中的公共类型。</summary>
        <returns><see cref="T:System.Type" /> 对象的数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的公共类型（搜索是非递归的）；如果当前的 <see cref="T:System.Type" /> 中没有嵌套公共类型，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.GetNestedTypes%2A>方法不按特定顺序返回类型, 如字母或声明顺序。 你的代码不能依赖于类型的返回顺序, 因为该顺序会有所不同。  
  
 仅返回立即嵌套在当前类型中的公共类型;搜索不是递归的。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型, 也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。  
  
   
  
## Examples  
 下面的示例在中`struct` `MyClass`定义一个嵌套类和一个, 然后使用类型获取嵌套`MyClass`类型的对象。  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>当在派生类中重写时，使用指定绑定约束搜索嵌套在当前 <see cref="T:System.Type" /> 中的类型。</summary>
        <returns><see cref="T:System.Type" /> 对象数组，这些对象表示嵌套在当前 <see cref="T:System.Type" /> 中的所有与指定的绑定约束匹配的类型（搜索是非递归的）；如果没有找到与绑定约束匹配的嵌套类型，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 嵌套类型的搜索不是递归的。  
  
 <xref:System.Type.GetNestedTypes%2A>方法不按特定顺序返回类型, 如字母或声明顺序。 你的代码不能依赖于类型的返回顺序, 因为该顺序会有所不同。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的嵌套类型:  
  
-   必须指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>才能获取返回。  
  
-   指定<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>在搜索中包括公共嵌套类型。  
  
-   指定<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>以在搜索中包括非公共嵌套类型 (即私有、内部和受保护的嵌套类型)。  
  
 此方法只返回当前类型的嵌套类型。 它不会搜索当前类型的基类。 若要查找嵌套在基类中的类型, 必须遍历继承层次结构, 并在<xref:System.Type.GetNestedTypes%2A>每个级别调用。  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>和<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>将被忽略。  
  
 仅<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>用标志或<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>标志调用此方法将返回指定的嵌套类型, 并且不需要任何其他标志。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的嵌套类型。  
  
 如果嵌套类型是泛型类型, 则此方法返回其泛型类型定义。 即使封闭泛型类型是封闭式构造类型, 也是如此。  
  
> [!NOTE]
>  如果当前<xref:System.Type>的表示在中C#定义的泛型类型, Visual Basic 或C++, 则其嵌套类型都是通用的, 即使它们不具有自己的泛型参数也是如此。 这不一定适用于动态程序集中定义的嵌套类型或用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md)编译的。  
  
 有关嵌套泛型类型以及如何从其泛型类型定义构造嵌套的泛型类型的信息, 请<xref:System.Type.MakeGenericType%2A>参阅。  
  
   
  
## Examples  
 下面的示例创建两个嵌套公共类和两个嵌套的受保护类, 并显示与指定绑定约束匹配的类的信息。  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回为当前 <see cref="T:System.Type" /> 的所有公共属性。</summary>
        <returns>表示当前 <see cref="T:System.Reflection.PropertyInfo" /> 的所有公共属性的 <see cref="T:System.Type" /> 对象数组。  
  
- 或 - 
如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有公共属性，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此重载<xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29>等效于`bindingAttr`使用与 Visual Basic `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`中C# `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`的相同的参数调用重载。 它将返回所有公共实例和静态属性, 这两个属性都由当前<xref:System.Type>对象所表示的类型以及从其基类型继承的类型定义。  
  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 <xref:System.Type.GetProperties%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回属性。 你的代码不能依赖属性的返回顺序, 因为该顺序会有所不同。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.PropertyInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
   
  
## Examples  
 下面的示例演示 `GetProperties` 方法的用法。  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。

或

 若为 <see cref="F:System.Reflection.BindingFlags.Default" />，则返回空数组。</param>
        <summary>当在派生类中重写时，使用指定绑定约束，搜索当前 <see cref="T:System.Type" /> 的属性。</summary>
        <returns>一个对象数组，它表示当前 <see cref="T:System.Type" /> 中与指定的绑定约束匹配的所有属性。  
  
或 
如果当前 <see cref="T:System.Reflection.PropertyInfo" /> 没有属性，或者如果没有一个属性匹配绑定约束，则为 <see cref="T:System.Type" /> 类型的空数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>为了使`bindingAttr`重载成功检索属性信息, 参数必须包含至少一个和, 以及至少一个和中的一个。 `GetProperties(BindingFlags)` 

以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:  
  
- 指定`BindingFlags.Instance`以包括实例方法。 

- 指定`BindingFlags.Static`以包括静态方法。 
  
- 指定`BindingFlags.Public`在搜索中包括公共属性。 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 
  
- 指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。 仅返回基类的受保护的和内部属性;不返回基类上的私有属性。  
  
- 指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  

- 单独`BindingFlags.Default`指定以返回空<xref:System.Reflection.PropertyInfo>数组。

 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
- `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
<xref:System.Type.GetProperties%2A>方法不按特定顺序 (如字母顺序或声明顺序) 返回属性。 你的代码不能依赖属性的返回顺序, 因为该顺序会有所不同。  

 如果当前<xref:System.Type>表示构造泛型类型, 则此方法<xref:System.Reflection.PropertyInfo>返回类型参数替换为相应类型参数的对象。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
   
  
## Examples  
 下面的示例定义了一个名`PropertyClass`为的类, 其中包含六个属性: 两个是公共的, 一个是专用的,`Friend`一个是专用的, 一个是内部的 (`Protected Friend`在 Visual Basic 中), 一个受保护 (在 Visual Basic 中)。 然后, 它会显示与指定绑定约束匹配的属性的一些基本属性信息 (属性名称和类型, 无论它是`get`读`set`写, 还是其和访问器的可见性)。  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的特定属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <summary>搜索具有指定名称的公共属性。</summary>
        <returns>表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
 出现这<xref:System.Reflection.AmbiguousMatchException>种情况的情况如下所示:  
  
-   类型包含两个具有相同名称但参数数目不同的索引属性。 若要解决多义性, 请使用<xref:System.Type.GetProperty%2A>方法的重载, 该重载指定参数类型。  
  
-   派生的类型声明一个属性, 该属性通过使用`new`修饰符 (`Shadows`在 Visual Basic 中) 隐藏同名的继承属性。 若要解决多义性问题, 请<xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>使用方法重载并<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>添加标志, 以将搜索限制为未继承的成员。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。 例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。 可以重载属性。  
  
 在C#中, 此功能称为索引器, 不能按名称引用。 默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。 例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。 如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索`Type`用户定义的类的对象, 检索该类的属性, 并显示属性名称。  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 在内部, 在元数据中, 名称为 "Item"。 尝试`PropertyInfo`使用反射必须指定此内部名称, 才能正确`PropertyInfo`返回属性。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <summary>使用指定的绑定约束搜索指定属性。</summary>
        <returns>表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共属性。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
 出现这<xref:System.Reflection.AmbiguousMatchException>种情况的情况如下所示:  
  
-   类型包含两个具有相同名称但参数数目不同的索引属性。 若要解决多义性, 请使用<xref:System.Type.GetProperty%2A>方法的重载, 该重载指定参数类型。  
  
-   派生的类型声明一个属性, 该属性使用`new`修饰符 (`Shadows`在 Visual Basic 中) 隐藏同名的继承属性。 若要解决多义性, 请<xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>包含以将搜索限制为未继承的成员。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。 例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。 可以重载属性。  
  
 在C#中, 此功能称为索引器, 不能按名称引用。 默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。 例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。 如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索用户定义的类的类型, 检索该类的属性, 并根据指定的绑定约束显示属性名称。  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <summary>搜索具有指定名称和返回类型的公共属性。</summary>
        <returns>表示具有指定名称的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。 例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。 可以重载属性。  
  
 在C#中, 此功能称为索引器, 不能按名称引用。 默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。 例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。 如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例定义一个具有一个属性的类, 并检索属性的名称和类型。  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到了多个具有指定名称的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 是 <see langword="null" />，或 <paramref name="returnType" /> 是 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <summary>搜索其参数与指定自变量类型匹配的指定公共属性。</summary>
        <returns>表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。 例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。 可以重载属性。  
  
 在C#中, 此功能称为索引器, 不能按名称引用。 默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。 例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。 如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例检索`Type`用户定义的类的对象, 检索该类的属性, 并显示由传递给`GetProperty`的参数指定的属性名称和属性类型。  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定自变量类型匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <summary>搜索其参数与指定自变量类型匹配的指定公共属性。</summary>
        <returns>表示其参数与指定参数类型匹配的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。 例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。 可以重载属性。  
  
 在C#中, 此功能称为索引器, 不能按名称引用。 默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。 例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。 如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定自变量类型匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的公共属性名的字符串。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
- 或 - 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>搜索其参数与指定自变量类型及修饰符匹配的指定公共属性。</summary>
        <returns>表示符合指定要求的公共属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 的搜索`name`区分大小写。 搜索包括公共静态和公共实例属性。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。 例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。 可以重载属性。  
  
 在C#中, 此功能称为索引器, 不能按名称引用。 默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。 例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。 如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。  
  
   
  
## Examples  
 下面的示例获取`Type`对应于`MyPropertyClass`的对象, 并且使用传递给`GetProperty`方法的参数检索此类的索引属性。  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称且与指定参数类型和修饰符匹配的属性。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
- 或 - 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>使用指定的绑定约束，搜索参数与指定的自变量类型及修饰符匹配的指定属性。</summary>
        <returns>表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果某个属性至少具有一个公共访问器, 则该属性将被视为 "公共"。 否则, 该属性将被视为私有属性, 并且<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>必须使用&#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (在 Visual Basic 中将值`Or`组合使用) 来获取它。  
  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共属性。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此方法将<xref:System.Reflection.PropertyInfo>返回, 并将类型参数替换为相应的类型参数。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法会搜索类约束的属性。  
  
## <a name="indexers-and-default-properties"></a>索引器和默认属性  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]、 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]和[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]具有用于访问索引属性的简化语法, 并允许一个索引属性作为其类型的默认值。 例如, 如果`myList`变量引用<xref:System.Collections.ArrayList>为, 则语法`myList[3]` (`myList(3)`在 Visual Basic 中) 检索索引为3的元素。 可以重载属性。  
  
 在C#中, 此功能称为索引器, 不能按名称引用。 默认情况下, C#索引器在元数据中显示为名为 "Item" 的索引属性。 但是, 类库开发人员可以使用<xref:System.Runtime.CompilerServices.IndexerNameAttribute>属性来更改元数据中索引器的名称。 例如, <xref:System.String>类具有一个名为<xref:System.String.Chars%2A>的索引器。 使用以外的其他语言创建的C#索引属性也可以包含除 Item 以外的其他名称。  
  
 若要确定某一类型是否具有默认属性, 请<xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>使用方法测试该<xref:System.Reflection.DefaultMemberAttribute>特性。 如果类型具有<xref:System.Reflection.DefaultMemberAttribute>, 则属性<xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>将返回默认属性的名称。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="types" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
或 
 <paramref name="modifiers" /> 是多维的。  
  
- 或 - 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="types" /> 的元素为 <see langword="null" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">包含要获取的属性名的字符串。</param>
        <param name="bindingAttr">枚举值的按位组合，这些值指定如何进行搜索。  
  
或 
 若为 <see cref="System.Reflection.BindingFlags.Default" />，则返回 <see langword="null" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载成员、强制自变量类型和通过反射调用成员。  
  
或 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。</param>
        <param name="returnType">属性的返回类型。</param>
        <param name="types">一个 <see cref="T:System.Type" /> 对象数组，表示要获取的索引属性的参数的数目、顺序和类型。  
  
或 
获取未被索引的属性的 <see cref="T:System.Type" /> 类型的空数组（即 Type[] types = new Type[0]）。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="types" /> 数组中的相应元素关联的特性。 默认的联编程序不处理此参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束搜索其参数与指定的参数类型和修饰符匹配的指定属性。</summary>
        <returns>表示符合指定要求的属性的对象（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Reflection.ParameterModifier> `modifiers` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`的自定义联编程序。 `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的属性:  
  
-   必须指定`BindingFlags.Instance`或`BindingFlags.Static`才能获取返回。  
  
-   指定`BindingFlags.Public`在搜索中包括公共属性。  
  
-   指定`BindingFlags.NonPublic`以在搜索中包括非公共属性 (即私有、内部和受保护的属性)。  
  
-   指定`BindingFlags.FlattenHierarchy`在层次`public`结构`protected`中包含和静态成员;`private`不包括继承类中的静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的属性, 而不搜索仅继承的属性。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">找到多个具有指定名称的属性且属性与指定绑定约束匹配。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="types" /> 为 <see langword="null" />。  
  
或 
<paramref name="types" /> 的其中一个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> 是多维的。  
  
- 或 - 
 <paramref name="modifiers" /> 是多维的。  
  
或 
 <paramref name="types" /> 和 <paramref name="modifiers" /> 的长度不相同。</exception>
        <exception cref="T:System.NotSupportedException">当前的类型是 <see cref="T:System.Reflection.Emit.TypeBuilder" />、<see cref="T:System.Reflection.Emit.EnumBuilder" /> 或 <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />。</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取表示指定类型的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" />。</summary>
        <returns>当前的 <see cref="T:System.Type" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，执行区分大小写的搜索。</summary>
        <returns>具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果知道程序集<xref:System.Type.GetType%2A>限定名称 (可<xref:System.Type>从<xref:System.Type.AssemblyQualifiedName>获取), 则可以使用方法获取其他程序集中的类型的对象。 <xref:System.Type.GetType%2A>导致加载中`typeName`指定的程序集。 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>您还可以使用方法加载程序集, 然后<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>使用或<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法来获取<xref:System.Type>对象。 如果类型位于您的程序在编译时已知的程序集中, 则使用`typeof`中C#的`GetType`或运算符更有效率 Visual Basic。
  
> [!NOTE]
>  如果`typeName`找不<xref:System.Type.GetType%28System.String%29>到, 则对方法的调用将`null`返回。 它不会引发异常。 若要控制是否引发异常, 请调用<xref:System.Type.GetType%2A> `throwOnError`具有参数的方法的重载。  
  
 <xref:System.Type.GetType%2A>仅适用于从磁盘加载的程序集。 如果调用<xref:System.Type.GetType%2A>查找<xref:System.Reflection.Emit>使用服务定义的动态程序集中定义的类型, 可能会出现不一致的行为。 此行为取决于动态程序集是否为持久性的, 即使用`RunAndSave` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举的或`Save`访问模式创建的。 如果动态程序集是持久性的, 并且在调用之前`GetType`已写入磁盘, 则加载程序将在磁盘上找到保存的程序集, 加载该程序集, 并从该程序集检索该类型。 如果在调用时`GetType`未将程序集保存到磁盘, 则该方法将返回。 `null` `GetType`不了解瞬态动态程序集;因此, 调用`GetType`以检索暂时性动态程序集中的类型会返回`null`。  
  
 若要`GetType`在动态模块上使用, 请订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并在`GetType`保存前调用。 否则, 将在内存中获取程序集的两个副本。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 不会搜索数组或 COM 类型, 除非已将它们加载到可用类的表中。  
  
 `typeName`可以是其命名空间限定的类型名称, 也可以是包含程序集名称规范的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包括命名空间, 但不包括程序集名称, 则此方法将按顺序搜索调用对象的程序集和 Mscorlib。 如果 typeName 完全限定了部分或完整的程序集名称, 则此方法将在指定的程序集中搜索。 如果程序集具有强名称, 则需要完整的程序集名称。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>属性返回完全限定的类型名称, 包括嵌套类型、程序集名称和泛型类型参数。 所有支持公共语言运行时的编译器都将发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。 例如, "ProcessorArchitecture = msil"。 不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。 还可以通过创建<xref:System.Reflection.AssemblyName>对象并将其传递给<xref:System.Reflection.Assembly.Load%2A>方法的适当重载来加载类型。 然后, 可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法从程序集加载类型。 另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|反撇号 (')|在一个或多个数字之前, 表示泛型类型名称末尾的类型参数的数目。|  
|方括号 ([])|为构造的泛型类型包含泛型类型参数列表;在类型参数列表中, 将程序集限定的类型括起来。|  
|逗号 (,)|在程序集名称之前。|  
|Period (.)|表示命名空间标识符。|  
|加号 (+)|在嵌套类之前。|  
  
 例如, 类的完全限定名称可能如下所示:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace + 命名空间, 则该字符串必须在加号 (+) 前面加上转义符\\(), 以防止它被解释为嵌套分隔符。 反射发出此字符串, 如下所示:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"\\变成 "\\++\\\\",而""\\变成 ""。  
  
 此限定名称可以保留, 以后用于加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。 <xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。 <xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。  
  
 类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。  
  
 泛型类型的名称以反撇号 (\`) 开头, 后跟数字, 表示泛型类型参数的数目。 此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型, 这些类型在同一范围内发生。 例如, `Tuple`反射从泛型方法`Tuple<T>` ` and ``\<T0, T1>` `2` `Tuple(Of T)`和中`Tuple(Of T0, T1)`的 Visual Basic 或和元组 (在视觉对象C#中) 返回错位的名称元组。  
  
 对于泛型类型, 类型参数列表括在括号中, 类型参数由逗号分隔。 例如, 泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。 具有类型的键<xref:System.Collections.Generic.Dictionary%602>的为的可表示为,如下所示<xref:System.String>: `MyType`  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要在类型参数列表中指定程序集限定类型, 请将程序集限定类型括在括号内。 否则, 分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。 例如, 可以按<xref:System.Collections.Generic.Dictionary%602>如下`MyType`所示指定一个 fromMyAssembly 的, 其中<xref:System.String>包含类型为的键:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  仅当程序集限定类型出现在类型参数列表中时, 才可以将其括在括号中。 用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特例。 例如, 字符串 "system.string <xref:System.Int32> " 1 [system.exception] 表示可以为 null。  
  
> [!NOTE]
>  在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。 例如, 可以为 null <xref:System.Boolean>的类型由`typeof(Nullable<bool>)`中C#的、 `Nullable<Boolean>::typeid` 、中C++的、和`GetType(Nullable(Of Boolean))` Visual Basic。  
  
 下表显示了`GetType`用于各种类型的语法。  
  
|获取|使用|  
|------------|---------|  
|可以为 null<xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|指向的非托管指针`MyType`|`Type.GetType("MyType*")`|  
|指向指向的指针的非托管指针`MyType`|`Type.GetType("MyType**")`|  
|托管指针或对的引用`MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为0的一维数组|`Type.GetType("MyType[]")`|  
|下限未知的一维数组|`Type.GetType("MyType[*]")`|  
|一维数组|括号中的逗号 (,) 的总计 n-1 次。 例如, `System.Object[,,]`表示一个`Object`三维数组。|  
|一维数组的数组|`Type.GetType("MyType[][]")`|  
|下限未知的矩形二维数组|`Type.GetType("MyType[,]")`|  
|具有一个类型参数的泛型类型|``Type.GetType("MyGenericType`1[MyType]")``|  
|具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有两个程序集限定类型参数的泛型类型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|具有程序集限定类型参数的程序集限定的泛型类型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|一个泛型类型, 其类型自变量是具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 下面的示例检索的类型`System.Int32` , 并使用该类型对象<xref:System.Type.FullName%2A>显示的属性`System.Int32`。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
- 或 - 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果知道程序集<xref:System.Type.GetType%2A>限定名称 (可<xref:System.Type>从<xref:System.Type.AssemblyQualifiedName>获取), 则可以使用方法获取其他程序集中的类型的对象。 <xref:System.Type.GetType%2A>导致加载中`typeName`指定的程序集。 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>您还可以使用方法加载程序集, 然后<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>使用或<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法来获取<xref:System.Type>对象。 如果类型位于您的程序在编译时已知的程序集中, 则使用`typeof`中C#的`GetType`或运算符更有效率 Visual Basic。
  
 `GetType`仅适用于从磁盘加载的程序集。 如果调用`GetType`查找<xref:System.Reflection.Emit>使用服务定义的动态程序集中定义的类型, 可能会出现不一致的行为。 此行为取决于动态程序集是否为持久性的, 即使用`RunAndSave` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举的或`Save`访问模式创建的。 如果动态程序集是持久性的, 并且在调用之前`GetType`已写入磁盘, 则加载程序将在磁盘上找到保存的程序集, 加载该程序集, 并从该程序集检索该类型。 如果在调用时`GetType`未将程序集保存到磁盘, 则该方法将返回。 `null` `GetType`不了解瞬态动态程序集;因此, 调用`GetType`以检索暂时性动态程序集中的类型会返回`null`。  
  
 若要`GetType`在动态模块上使用, 请订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并在`GetType`保存前调用。 否则, 将在内存中获取程序集的两个副本。  
  
 `throwOnError`参数指定当找不到该类型时所发生的情况, 还会取消某些其他异常条件, 如 "异常" 一节中所述。 引发一些异常, 而不考虑的值`throwOnError`。 例如, 如果找到类型但无法加载, 则<xref:System.TypeLoadException> `throwOnError`即使为`false`, 也会引发。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 不会搜索数组或 COM 类型, 除非已将它们加载到可用类的表中。  
  
 `typeName`可以是其命名空间限定的类型名称, 也可以是包含程序集名称规范的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包括命名空间, 但不包括程序集名称, 则此方法将按顺序搜索调用对象的程序集和 Mscorlib。 如果 typeName 完全限定了部分或完整的程序集名称, 则此方法将在指定的程序集中搜索。 如果程序集具有强名称, 则需要完整的程序集名称。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>属性返回完全限定的类型名称, 包括嵌套类型、程序集名称和泛型参数。 所有支持公共语言运行时的编译器都将发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。 例如, "ProcessorArchitecture = msil"。 不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。 还可以通过创建<xref:System.Reflection.AssemblyName>对象并将其传递给<xref:System.Reflection.Assembly.Load%2A>方法的适当重载来加载类型。 然后, 可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法从程序集加载类型。 另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|反撇号 (')|在一个或多个数字之前, 表示泛型类型名称末尾的类型参数的数目。|  
|方括号 ([])|为构造的泛型类型包含泛型类型参数列表;在类型参数列表中, 将程序集限定的类型括起来。|  
|逗号 (,)|在程序集名称之前。|  
|Period (.)|表示命名空间标识符。|  
|加号 (+)|在嵌套类之前。|  
  
 例如, 类的完全限定名称可能如下所示:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace + 命名空间, 则该字符串必须在加号 (+) 前面加上转义符\\(), 以防止它被解释为嵌套分隔符。 反射发出此字符串, 如下所示:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"\\变成 "\\++\\\\",而""\\变成 ""。  
  
 此限定名称可以保留, 以后用于加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。 <xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。 <xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。  
  
 类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。  
  
 泛型类型的名称以反撇号 (\`) 开头, 后跟数字, 表示泛型类型参数的数目。 此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型, 这些类型在同一范围内发生。 例如, `Tuple`反射从泛型方法`Tuple<T>` ` and ``\<T0, T1>` `2` `Tuple(Of T)`和中`Tuple(Of T0, T1)`的 Visual Basic 或和元组 (在视觉对象C#中) 返回错位的名称元组。  
  
 对于泛型类型, 类型参数列表括在括号中, 类型参数由逗号分隔。 例如, 泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。 具有类型的键<xref:System.Collections.Generic.Dictionary%602>的为的可表示为,如下所示<xref:System.String>: `MyType`  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要在类型参数列表中指定程序集限定类型, 请将程序集限定类型括在括号内。 否则, 分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。 例如, <xref:System.Collections.Generic.Dictionary%602>可以按如下`MyType`所示指定的 MyAssembly 中的, 其<xref:System.String>键类型为, 如下所示:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  仅当程序集限定类型出现在类型参数列表中时, 才可以将其括在括号中。 用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特例。 例如, 字符串 "system.string <xref:System.Int32> " 1 [system.exception] 表示可以为 null。  
  
> [!NOTE]
>  在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。 例如, 可以为 null <xref:System.Boolean>的类型由`typeof(Nullable<bool>)`中C#的、 `Nullable<Boolean>::typeid` 、中C++的、和`GetType(Nullable(Of Boolean))` Visual Basic。  
  
 下表显示了`GetType`用于各种类型的语法。  
  
|获取|使用|  
|------------|---------|  
|可以为 null<xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|指向的非托管指针`MyType`|`Type.GetType("MyType*")`|  
|指向指向的指针的非托管指针`MyType`|`Type.GetType("MyType**")`|  
|托管指针或对的引用`MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为0的一维数组|`Type.GetType("MyArray[]")`|  
|下限未知的一维数组|`Type.GetType("MyArray[*]")`|  
|一维数组|括号中的逗号 (,) 的总计 n-1 次。 例如, `System.Object[,,]`表示一个`Object`三维数组。|  
|二维数组的数组|`Type.GetType("MyArray[][]")`|  
|下限未知的矩形二维数组|`Type.GetType("MyArray[,]")`|  
|具有一个类型参数的泛型类型|``Type.GetType("MyGenericType`1[MyType]")``|  
|具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有两个程序集限定类型参数的泛型类型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|具有程序集限定类型参数的程序集限定的泛型类型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|一个泛型类型, 其类型自变量是具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 下面的示例检索的类型`System.Int32` , 并使用该类型对象<xref:System.Type.FullName%2A>显示的属性`System.Int32`。 如果类型对象引用不存在的程序集, 则此示例将引发异常。  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
- 或 - 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。 例如："MyType[,*,]"。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 是 <see langword="true" /> 并且未找到程序集或其依赖项之一。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 - 或 -  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的程序集限定名称。 请参阅 <see cref="P:System.Type.AssemblyQualifiedName" />。 如果该类型位于当前正在执行的程序集中或者 Mscorlib.dll 中，则提供由命名空间限定的类型名称就足够了。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">对 <see langword="true" /> 执行的搜索不区分大小写，则为 <paramref name="typeName" />；对 <see langword="false" /> 执行的搜索区分大小写，则为 <paramref name="typeName" />。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果知道程序集<xref:System.Type.GetType%2A>限定名称 (可<xref:System.Type>从<xref:System.Type.AssemblyQualifiedName>获取), 则可以使用方法获取其他程序集中的类型的对象。 <xref:System.Type.GetType%2A>导致加载中`typeName`指定的程序集。 <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>您还可以使用方法加载程序集, 然后<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>使用或<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>方法来获取<xref:System.Type>对象。 如果类型位于您的程序在编译时已知的程序集中, 则使用`typeof`中C#的`GetType`或运算符更有效率 Visual Basic。
  
 `GetType`仅适用于从磁盘加载的程序集。 如果调用`GetType`查找<xref:System.Reflection.Emit>使用服务定义的动态程序集中定义的类型, 可能会出现不一致的行为。 此行为取决于动态程序集是否为持久性的, 即使用`RunAndSave` <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>枚举的或`Save`访问模式创建的。 如果动态程序集是持久性的, 并且在调用之前`GetType`已写入磁盘, 则加载程序将在磁盘上找到保存的程序集, 加载该程序集, 并从该程序集检索该类型。 如果在调用时`GetType`未将程序集保存到磁盘, 则该方法将返回。 `null` `GetType`不了解瞬态动态程序集;因此, 调用`GetType`以检索暂时性动态程序集中的类型会返回`null`。  
  
 若要`GetType`在动态模块上使用, 请订阅<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件并在`GetType`保存前调用。 否则, 将在内存中获取程序集的两个副本。  
  
 `throwOnError`参数指定当找不到该类型时所发生的情况, 还会取消某些其他异常条件, 如 "异常" 一节中所述。 引发一些异常, 而不考虑的值`throwOnError`。 例如, 如果找到类型但无法加载, 则<xref:System.TypeLoadException> `throwOnError`即使为`false`, 也会引发。  
  
 下表显示了在类型上反射时`Get`方法返回的基类成员。  
  
|成员类型|Static|非静态|  
|-----------------|------------|-----------------|  
|构造函数|No|No|  
|字段|No|可以。 字段始终按名称和签名隐藏。|  
|事件|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
|方法|No|可以。 方法 (虚拟和非虚拟) 可按名称隐藏或按名称和签名隐藏。|  
|嵌套类型|No|No|  
|Property|不适用|通用类型系统规则是指继承与实现属性的方法相同。 反射将属性视为隐藏的名称和签名。 请参阅下面的注释2。|  
  
1.  按名称和签名隐藏将考虑签名的所有部分, 包括自定义修饰符、返回类型、参数类型、个 sentinel 和非托管调用约定。 这是二进制比较。  
  
2.  对于反射, 属性和事件是按名称和签名隐藏的。 如果在基类中同时具有 get 访问器和 set 访问器的属性, 但派生类只有 get 访问器, 则派生类属性将隐藏基类属性, 并且你将无法访问基类的资源库。  
  
3.  自定义属性不属于通用类型系统。  
  
 不会搜索数组或 COM 类型, 除非已将它们加载到可用类的表中。  
  
 `typeName`可以是其命名空间限定的类型名称, 也可以是包含程序集名称规范的程序集限定名称。 请参阅 <xref:System.Type.AssemblyQualifiedName%2A>。  
  
 如果`typeName`包括命名空间, 但不包括程序集名称, 则此方法将按顺序搜索调用对象的程序集和 Mscorlib。 如果 typeName 完全限定了部分或完整的程序集名称, 则此方法将在指定的程序集中搜索。 如果程序集具有强名称, 则需要完整的程序集名称。  
  
 <xref:System.Type.AssemblyQualifiedName%2A>属性返回完全限定的类型名称, 包括嵌套类型、程序集名称和类型参数。 所有支持公共语言运行时的编译器都将发出嵌套类的简单名称, 并且在查询时, 反射将按照以下约定构造错位的名称。  
  
> [!NOTE]
>  在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。 例如, "ProcessorArchitecture = msil"。 不过, 由于兼容性原因, 它不包含在由<xref:System.Type.AssemblyQualifiedName%2A>属性返回的字符串中。 还可以通过创建<xref:System.Reflection.AssemblyName>对象并将其传递给<xref:System.Reflection.Assembly.Load%2A>方法的适当重载来加载类型。 然后, 可以使用<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>方法从程序集加载类型。 另请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
|后面|含义|  
|---------------|-------------|  
|反斜杠 (\\)|转义符。|  
|反撇号 (')|在一个或多个数字之前, 表示泛型类型名称末尾的类型参数的数目。|  
|方括号 ([])|为构造的泛型类型包含泛型类型参数列表;在类型参数列表中, 将程序集限定的类型括起来。|  
|逗号 (,)|在程序集名称之前。|  
|Period (.)|表示命名空间标识符。|  
|加号 (+)|在嵌套类之前。|  
  
 例如, 类的完全限定名称可能如下所示:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 如果命名空间为 TopNamespace + 命名空间, 则该字符串必须在加号 (+) 前面加上转义符\\(), 以防止它被解释为嵌套分隔符。 反射发出此字符串, 如下所示:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 "+ +"\\变成 "\\++\\\\",而""\\变成 ""。  
  
 此限定名称可以保留, 以后用于加载<xref:System.Type>。 若要搜索并加载<xref:System.Type>, 请将与类型名称一起使用, 或者使用<xref:System.Type.GetType%2A>带有程序集限定类型名称的。 <xref:System.Type.GetType%2A>只有类型名称才会<xref:System.Type>在调用方的程序集中查找, 然后在系统程序集中查找。 <xref:System.Type.GetType%2A>具有程序集限定类型名称的将<xref:System.Type>在任何程序集中查找。  
  
 类型名称可能包含表示类型附加信息的尾随字符, 如类型是引用类型、指针类型还是数组类型。 若要检索不包含这些尾随字符的类型名称`t.GetElementType().ToString()`, 请`t`使用, 其中是类型。  
  
 空格在除程序集名称之外的所有类型名称组件中都是相关的。 在程序集名称中, "," 分隔符前面的空格是相关的, 但 "," 分隔符后面的空格将被忽略。  
  
 泛型类型的名称以反撇号 (\`) 开头, 后跟数字, 表示泛型类型参数的数目。 此名称重整的用途是允许编译器支持具有相同名称但具有不同数量的类型参数的泛型类型, 这些类型在同一范围内发生。 例如, `Tuple`反射从泛型方法`Tuple<T>` ` and ``\<T0, T1>` `2` `Tuple(Of T)`和中`Tuple(Of T0, T1)`的 Visual Basic 或和元组 (在视觉对象C#中) 返回错位的名称元组。  
  
 对于泛型类型, 类型参数列表括在括号中, 类型参数由逗号分隔。 例如, 泛型<xref:System.Collections.Generic.Dictionary%602>具有两个类型参数。 具有类型的键<xref:System.Collections.Generic.Dictionary%602>的为的可表示为,如下所示<xref:System.String>: `MyType`  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 若要在类型参数列表中指定程序集限定类型, 请将程序集限定类型括在括号内。 否则, 分隔程序集限定名称的各部分的逗号将解释为分隔附加类型参数。 例如, <xref:System.Collections.Generic.Dictionary%602>可以按如下`MyType`所示指定的 MyAssembly 中的, 其<xref:System.String>键类型为, 如下所示:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  仅当程序集限定类型出现在类型参数列表中时, 才可以将其括在括号中。 用于在类型参数列表中搜索限定类型和非限定类型的程序集的规则与限定和非限定非泛型类型的规则相同。  
  
 可以为 null 的类型是泛型类型的特例。 例如, 字符串 "system.string <xref:System.Int32> " 1 [system.exception] 表示可以为 null。  
  
> [!NOTE]
>  在C#、 C++和中 Visual Basic 你还可以使用类型运算符获取可以为 null 的类型。 例如, 可以为 null <xref:System.Boolean>的类型由`typeof(Nullable<bool>)`中C#的、 `Nullable<Boolean>::typeid` 、中C++的、和`GetType(Nullable(Of Boolean))` Visual Basic。  
  
 下表显示了`GetType`用于各种类型的语法。  
  
|获取|使用|  
|------------|---------|  
|可以为 null<xref:System.Int32>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|指向的非托管指针`MyType`|`Type.GetType("MyType*")`|  
|指向指向的指针的非托管指针`MyType`|`Type.GetType("MyType**")`|  
|托管指针或对的引用`MyType`|`Type.GetType("MyType&")`。 请注意，与指针不同，引用仅限于一个级别。|  
|父类和嵌套类|`Type.GetType("MyParentClass+MyNestedClass")`|  
|下限为0的一维数组|`Type.GetType("MyArray[]")`|  
|下限未知的一维数组|`Type.GetType("MyArray[*]")`|  
|一维数组|括号中的逗号 (,) 的总计 n-1 次。 例如, `System.Object[,,]`表示一个`Object`三维数组。|  
|二维数组的数组|`Type.GetType("MyArray[][]")`|  
|下限未知的矩形二维数组|`Type.GetType("MyArray[,]")`|  
|具有一个类型参数的泛型类型|``Type.GetType("MyGenericType`1[MyType]")``|  
|具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|具有两个程序集限定类型参数的泛型类型|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|具有程序集限定类型参数的程序集限定的泛型类型|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|一个泛型类型, 其类型自变量是具有两个类型参数的泛型类型|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
- 或 - 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法。 例如："MyType[,*,]"。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
- 或 - 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 当前加载的是公共语言运行时 2.0 版或更高版本，而程序集使用更高的版本编译。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。 如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。 以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。 如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。 如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。  
  
警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。 如果未提供任何程序集，则 <paramref name="typeResolver" /> 方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。  
  
警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <summary>获取具有指定名称的类型，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型，如果未找到该类型，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的使用方案以及有关`assemblyResolver`和`typeResolver`参数的详细信息<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>可在方法重载中找到。  
  
> [!NOTE]
>  如果`typeName`找不<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>到, 则对方法的调用将`null`返回。 它不会引发异常。 若要控制是否引发异常, 请调用<xref:System.Type.GetType%2A> `throwOnError`具有参数的方法的重载。  
  
 调用此方法重载<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>与调用方法重载和为`throwOnError`和`ignoreCase`参数指定`false`的方法相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
- 或 - 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。  
  
- 或 - 
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
或 
 <paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。 如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。 以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。 如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。 如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。  
  
警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。 如果未提供任何程序集，则该方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<see langword="false" /> 传递给该参数。  
  
警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <summary>获取具有指定名称的类型，指定在找不到该类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的使用方案以及有关`assemblyResolver`和`typeResolver`参数的详细信息<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>可在方法重载中找到。  
  
 调用此方法重载与调用<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>方法重载和为`ignoreCase`参数指定`false`的方法相同。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
- 或 - 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
- 或 - 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。  
  
或 
 <paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,*,]"）。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
- 或 - 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。  
  
或 
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
或 
 <paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的类型的名称。 如果提供了 <paramref name="typeResolver" /> 参数，则类型名称可以为 <paramref name="typeResolver" /> 能够解析的任何字符串。 如果提供了 <paramref name="assemblyResolver" /> 参数，或者使用了标准类型解析，则除非该类型位于当前正在执行的程序集或 Mscorlib.dll 中（在这种情况下足以提供其命名空间所限定的类型名称），否则 <paramref name="typeName" /> 必须为程序集限定的名称（请参见 <see cref="P:System.Type.AssemblyQualifiedName" />）。</param>
        <param name="assemblyResolver">一个方法，它定位并返回 <paramref name="typeName" /> 中指定的程序集。 以 <paramref name="assemblyResolver" /> 对象形式传递给 <see cref="T:System.Reflection.AssemblyName" /> 的程序集名称。 如果 <paramref name="typeName" /> 不包含程序集的名称，则不调用 <paramref name="assemblyResolver" />。 如果未提供 <paramref name="assemblyResolver" />，则执行标准程序集解析。  
  
警告   不要通过未知的或不受信任的调用方传递方法。 此操作可能会导致恶意代码特权提升。 仅使用你提供或者熟悉的方法。</param>
        <param name="typeResolver">一个方法，它在由 <paramref name="typeName" /> 或标准程序集解析返回的程序集中定位并返回 <paramref name="assemblyResolver" /> 所指定的类型。 如果未提供任何程序集，则该方法可以提供一个程序集。 该方法还采用一个参数以指定是否执行不区分大小写的搜索；<paramref name="ignoreCase" /> 的值传递给该参数。  
  
警告   不要通过未知的或不受信任的调用方传递方法。</param>
        <param name="throwOnError">如果为 <see langword="true" />，则在找不到该类型时引发异常；如果为 <see langword="false" />，则返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">对 <see langword="true" /> 执行的搜索不区分大小写，则为 <paramref name="typeName" />；对 <see langword="false" /> 执行的搜索区分大小写，则为 <paramref name="typeName" />。</param>
        <summary>获取具有指定名称的类型，指定是否执行区分大小写的搜索，在找不到类型时是否引发异常，（可选）提供自定义方法以解析程序集和该类型。</summary>
        <returns>具有指定名称的类型。 如果找不到该类型，则 <paramref name="throwOnError" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwOnError" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法重载及其关联的重载 (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>和<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) 将<xref:System.Type.GetType%2A>方法的默认实现替换为更灵活的实现。 通过提供自己的方法来解析类型名称以及包含它们的程序集的名称, 您可以执行以下操作:  
  
-   控制从其加载类型的程序集的版本。  
  
-   提供另一个查找不包括程序集名称的类型名称的位置。  
  
-   使用部分程序集名称加载程序集。  
  
-   返回不是<xref:System.Type?displayProperty=nameWithType>由公共语言运行时 (CLR) 创建的子类。  
  
 例如, 在版本容错序列化中, 此方法使你能够使用部分名称搜索 "最适合" 程序集。 此<xref:System.Type.GetType%2A>方法的其他重载需要程序集限定的类型名称, 包括版本号。  
  
 类型系统的其他实现可能需要返回不是由 CLR <xref:System.Type?displayProperty=nameWithType>创建的的子类; 该<xref:System.Type.GetType%2A>方法的其他重载返回的所有类型都是运行时类型。  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>使用说明  
 此方法重载及其关联重载分析`typeName`为类型名称和程序集名称, 然后解析名称。 程序集名称的解析出现在类型名称解析之前, 因为类型名称必须在程序集的上下文中解析。  
  
> [!NOTE]
>  如果不熟悉程序集限定类型名称的概念, 请参见<xref:System.Type.AssemblyQualifiedName%2A>属性。  
  
 如果`typeName`不是程序集限定名称, 则跳过程序集解析。 可在 mscorlib.dll 或当前正在执行的程序集的上下文中解析不合格的类型名称, 也可以选择在`typeResolver`参数中提供程序集。 包括或省略不同类型名称解析的程序集名称的效果在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。  
  
 一般使用说明:  
  
-   如果方法来自未知或`assemblyResolver`不`typeResolver`受信任的调用方, 请不要将方法传递给或。 仅使用你提供或者熟悉的方法。  
  
    > [!CAUTION]
    >  使用来自未知或不受信任调用方的方法可能会导致恶意代码特权提升。  
  
-   如果省略了`assemblyResolver`和/或`typeResolver`参数`throwOnError` , 则参数的值将传递给执行默认解析的方法。  
  
-   如果`throwOnError`为`typeResolver` <xref:System.IO.FileNotFoundException> `assemblyResolver` , 则此方法`null`在返回时引发, 而在返回`null`时引发。 <xref:System.TypeLoadException> `true`  
  
-   此方法不会捕获和`assemblyResolver` `typeResolver`引发的异常。 你负责解析程序方法引发的任何异常。  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>解析程序集  
 方法接收一个<xref:System.Reflection.AssemblyName>对象, 该对象是通过分析中`typeName`包含的字符串程序集名称生成的。 `assemblyResolver` 如果`typeName`不包含程序集名称, `assemblyResolver`则不会`typeResolver`调用并`null`将传递给。  
  
 如果`assemblyResolver`未提供, 则使用标准程序集探测来定位程序集。 如果`assemblyResolver`提供了, 则<xref:System.Type.GetType%2A>方法不执行标准探测; 在这种情况下, 您必须确保`assemblyResolver`您可以处理您传递给它的所有程序集。  
  
 如果`assemblyResolver`无法解析程序`null`集, 则该方法应返回。 如果`assemblyResolver`返回`throwOnError` `true`, 则不<xref:System.IO.FileNotFoundException>会调用, 也不会进行进一步的处理; 此外, 如果为, 则引发。 `null` `typeResolver`  
  
 如果传递到`assemblyResolver`的是部分名称, 则其一个或`null`多个部分为。 <xref:System.Reflection.AssemblyName> 例如, 如果它没有版本, <xref:System.Reflection.AssemblyName.Version%2A>则属性为。 `null` 如果属性、属性和<xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>方法全部返回`null`, 则仅提供程序集的简单名称。 <xref:System.Reflection.AssemblyName.CultureInfo%2A> <xref:System.Reflection.AssemblyName.Version%2A> `assemblyResolver`方法可以使用或忽略程序集名称的所有部分。  
  
 对于简单的和程序集限定的类型名称, 不同的程序集解析选项的作用在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>解析类型  
 如果`typeName`未指定程序集名称, `typeResolver`则始终调用。 如果`typeName`指定程序集名称, `typeResolver`则只有在成功解析程序集名称时才会调用。 如果`assemblyResolver`或标准程序集探测`null`返回`typeResolver` , 则不会调用。  
  
 `typeResolver`方法收到三个参数:  
  
-   要搜索`null`的程序集, `typeName`如果不包含程序集名称, 则为。  
  
-   类型的简单名称。 对于嵌套类型, 这是最外层的包含类型。 对于泛型类型, 这是泛型类型的简单名称。  
  
-   一个布尔值, 如果`true`要忽略类型名称的大小写, 则为。  
  
 实现确定使用这些参数的方式。 如果方法无法解析类型, 则应返回`null`。 `typeResolver` 如果`typeResolver`返回`true` <xref:System.TypeLoadException>且为, 则的<xref:System.Type.GetType%2A>此重载将引发。 `throwOnError` `null`  
  
 对于简单的和程序集限定的类型名称, 不同类型解析选项的效果在[混合名称解析](#mixed_name_resolution)部分中显示为一个表。  
  
#### <a name="resolving-nested-types"></a>解析嵌套类型  
 如果`typeName`是嵌套类型, 则仅将包含类型的最外面的名称`typeResolver`传递给。 当`typeResolver`返回此类型时<xref:System.Type.GetNestedType%2A> , 将以递归方式调用方法, 直到解析最内层的嵌套类型。  
  
#### <a name="resolving-generic-types"></a>解析泛型类型  
 <xref:System.Type.GetType%2A>递归调用以解析泛型类型:首先解析泛型类型本身, 然后解析其类型参数。 如果类型参数是泛型, <xref:System.Type.GetType%2A>则会以递归方式调用以解析其类型参数, 依此类推。  
  
 您提供的`assemblyResolver`和`typeResolver`的组合必须能够解析此递归的所有级别。 例如, 假设您提供了一个`assemblyResolver` , 用于控制的`MyAssembly`加载。 假设要解析泛型类型`Dictionary<string, MyType>` (`Dictionary(Of String, MyType)`在 Visual Basic 中)。 你可能会传递以下泛型类型名称:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 请注意`MyType` , 是唯一的程序集限定类型参数。 <xref:System.Collections.Generic.Dictionary%602> 和<xref:System.String>类的名称不是程序集限定的。 `null` <xref:System.Collections.Generic.Dictionary%602> <xref:System.String>必须能够处理程序集或`null`, 因为它将接收和。 `typeResolver` 它可以通过调用采用字符串的<xref:System.Type.GetType%2A>方法重载来处理这种情况, 因为两个非限定类型名称都在 mscorlib.dll 中:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 不会为字典类型和字符串类型调用方法,因为这些类型名称不是程序集限定名称。`assemblyResolver`  
  
 现在, 假设第一个`System.String`泛型参数类型为, `YourAssembly`而不`YourType`是:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 由于此程序集既不是 Mscorlib .dll, 也不是当前正在执行的`YourType`程序集, 因此无法在没有程序集限定名称的情况下解析。 `assemblyResolve`由于将以递归方式调用, 因此它必须能够处理这种情况。 它现在会`null`使用提供<xref:System.Reflection.AssemblyName>的对象`MyAssembly`执行程序集加载, 而不是为之外的程序集进行返回。  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 返回到[使用说明](#usage_notes)。  
  
#### <a name="resolving-type-names-with-special-characters"></a>解析包含特殊字符的类型名称  
 某些字符在程序集限定名称中具有特殊含义。 如果简单的类型名称包含这些字符, 则当简单名称是程序集限定名称的一部分时, 这些字符将导致分析错误。 若要避免分析错误, 必须使用反斜杠对特殊字符进行转义, 然后才能将程序集限定名称传递给<xref:System.Type.GetType%2A>方法。 例如, 如果类型`Strange]Type`为, 则必须将转义符添加到方括号的前面, 如下所示:。 `Strange\]Type`  
  
> [!NOTE]
>  不能在 Visual Basic 或C#中创建具有此类特殊字符的名称, 但可以使用 Microsoft 中间语言 (MSIL) 或发出动态程序集来创建它们。  
  
 下表显示了类型名称的特殊字符。  
  
|字符|含义|  
|---------------|-------------|  
|`,`跟|程序集限定名称的分隔符。|  
|`[]`(方括号)|作为后缀对, 指示数组类型;作为分隔符对, 包含泛型参数列表和程序集限定名称。|  
|`&`前面|作为后缀, 指示类型是引用类型。|  
|`*`红星|作为后缀, 指示类型是指针类型。|  
|`+`加大|嵌套类型的分隔符。|  
|`\`符号|转义符。|  
  
 诸如返回正确<xref:System.Type.AssemblyQualifiedName%2A>转义的字符串之类的属性。 必须将正确转义的<xref:System.Type.GetType%2A>字符串传递给方法。 相反, 该<xref:System.Type.GetType%2A>方法将正确的转义名称传递`typeResolver`给和的默认类型解析方法。 如果需要将名称与中`typeResolver`的非转义名称进行比较, 则必须删除转义符。  
  
 返回到[使用说明](#usage_notes)。  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>混合名称解析  
 下表总结了、 `assemblyResolver` `typeResolver`和默认名称解析之间的交互, 适用于中`typeName`的类型名称和程序集名称的所有组合:  
  
|类型名称的内容|程序集解析程序方法|类型解析程序方法|结果|  
|---------------------------|------------------------------|--------------------------|------------|  
|类型、程序集|null|null|等效于调用<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法重载。|  
|类型、程序集|规定|null|`assemblyResolver`返回程序集, 如果`null`无法解析程序集, 则返回。 如果对程序集进行解析, <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>则使用方法重载从程序集加载类型; 否则, 将不会尝试解析该类型。|  
|类型、程序集|null|规定|等效于将程序集名称转换为<xref:System.Reflection.AssemblyName>对象, 并<xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>调用方法重载以获取程序集。 如果对程序集进行解析, 则将其`typeResolver`传递到; `typeResolver`否则, 将不会调用, 也不会再尝试解析该类型。|  
|类型、程序集|规定|规定|`assemblyResolver`返回程序集, 如果`null`无法解析程序集, 则返回。 如果对程序集进行解析, 则将其`typeResolver`传递到; `typeResolver`否则, 将不会调用, 也不会再尝试解析该类型。|  
|类型|提供空值|null|等效于调用<xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>方法重载。 由于未提供程序集名称, 因此只会搜索 Mscorlib.dll 和当前正在执行的程序集。 如果`assemblyResolver`提供了, 则将其忽略。|  
|类型|提供空值|规定|`typeResolver`为程序集调用`null`并传递。 `typeResolver`可以提供任何程序集中的类型, 包括为此目的而加载的程序集。 如果`assemblyResolver`提供了, 则将其忽略。|  
|程序集|提供空值|提供空值|<xref:System.IO.FileLoadException>引发, 因为程序集名称被分析为程序集限定的类型名称。 这会导致无效的程序集名称。|  
  
 返回到:[使用说明](#usage_notes),[解析程序集](#resolving_assemblies),[解析类型](#resolving_types)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 是 <see langword="true" />，且找不到该类型。  
  
- 或 - 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
或 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
- 或 - 
 <paramref name="throwOnError" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
- 或 - 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 的数组。</exception>
        <exception cref="T:System.ArgumentException">当 <paramref name="typeName" /> 解析为类型名称和程序集名称时（例如，当简单类型名称包含未转义的特殊字符时），发生错误。  
  
- 或 - 
 <paramref name="throwOnError" /> 是 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,*,]"）。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
- 或 - 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。  
  
或 
 <paramref name="typeName" /> 包含无效的程序集名称。  
  
或 
 <paramref name="typeName" /> 是一个不含类型名称的有效程序集名称。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="args">要确定其类型的对象数组。</param>
        <summary>获取指定数组中对象的类型。</summary>
        <returns>表示 <see cref="T:System.Type" /> 中相应元素的类型的 <paramref name="args" /> 对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Type.GetTypeArray%2A>方法列出数组元素的类型。  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> 为 <see langword="null" />。  
  
- 或 - 
<paramref name="args" /> 的其中一个或多个元素为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用类初始值设定项，并且至少一个引发异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">要获取其基础代码的类型。</param>
        <summary>获取指定 <see cref="T:System.Type" /> 的基础类型代码。</summary>
        <returns>如果 <see cref="F:System.TypeCode.Empty" /> 为 <paramref name="type" />，则为基础类型代码或 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当从<xref:System.Type>继承时, 可以通过<xref:System.Type.GetTypeCodeImpl%2A>重写方法来更改此方法的行为。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.TypeCode>使用枚举。 在`WriteObjectInfo`方法内的决策块中<xref:System.TypeCode> , 将检查<xref:System.Object>参数的, 并将相应的消息写入控制台。  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Type" /> 实例的基础类型代码。</summary>
        <returns>基础类型的类型代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法`static`提供 (在中C#) 或`Shared` (在 Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29>方法的实现。 当从<xref:System.Type>继承时, 您可以重写此方法以提供您自己的<xref:System.Type.GetTypeCode%2A>实现。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取与指定类标识符 (CLSID) 关联的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <summary>获取与指定类标识符 (CLSID) 关联的类型。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:  
  
1.  通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。  
  
 有关说明, 请参阅示例。  
  
 重载<xref:System.Type.GetTypeFromCLSID%28System.Guid%29>将忽略<xref:System.Type> 在`clsid`基于参数实例化对象时可能发生的任何异常。 请注意, 如果`clsid`在注册表中找不到, 则不会引发异常。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 来检索表示 Microsoft word 应用程序的 COM 类型。 然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。 所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。 尽管方法返回<see cref="T:System.Type" />的对象与 .NET Framework 对象的 GUID 对应, 但无法通过调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法来使用<see cref="T:System.Type" />该对象创建类型实例, 如下面的示例所示。  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:  
  
1.  通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。  
  
 有关说明, 请参阅示例。  
  
 当指定<xref:System.OutOfMemoryException> `true`时, 将引发诸如之类的`throwOnError`异常, 但未注册的 clsid 将不会失败。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 来检索表示 Microsoft word 应用程序的 COM 类型。 然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。 如果在加载该类型时发生错误, 则会引发异常。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。 所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。 尽管方法返回<see cref="T:System.Type" />的对象与 .NET Framework 对象的 GUID 对应, 但无法通过调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法来使用<see cref="T:System.Type" />该对象创建类型实例, 如下面的示例所示。  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <summary>从指定服务器获取与指定类标识符 (CLSID) 关联的类型。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:  
  
1.  通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 从名为 computer17.central.contoso.com 的服务器中检索代表 Microsoft Word 应用程序的 COM 类型。 然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。 所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。 尽管方法返回<see cref="T:System.Type" />的对象与 .NET Framework 对象的 GUID 对应, 但无法通过调用<see cref="M:System.Activator.CreateInstance(System.Type)" />方法来使用<see cref="T:System.Type" />该对象创建类型实例, 如下面的示例所示。  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="clsid">要获取的类型的 CLSID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>从指定服务器获取与指定类标识符 (CLSID) 关联的类型，指定在加载该类型时如果发生错误是否引发异常。</summary>
        <returns><see langword="System.__ComObject" />，无论 CLSID 是否有效。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Type.GetTypeFromCLSID%2A>你知道 COM 对象的类标识符 (CLSID) 时, 该方法支持对 .NET Framework 应用程序的非托管 COM 对象进行后期绑定访问。  COM 类的类标识符是在注册表的 HKEY_CLASSES_ROOT\CLSID 项中定义的。 可以检索<xref:System.Type.IsCOMObject%2A>属性的值, 以确定此方法返回的类型是否为 COM 对象。  
  
> [!TIP]
>  您可以调用<xref:System.Type.GetTypeFromProgID%2A>方法来对您知道其编程标识符 (ProgID) 的 COM 对象进行后期绑定访问。  
  
 从其 CLSID 实例化非托管 COM 对象的过程分为两个步骤:  
  
1.  通过调用<xref:System.Type> `__ComObject` 方法来获取一个对象,该对象表示与CLSID<xref:System.Type.GetTypeFromCLSID%2A>相对应的。  
  
2.  <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>调用方法来实例化 COM 对象。  
  
 当指定<xref:System.OutOfMemoryException> `true`时, 将引发诸如之类的`throwOnError`异常, 但未注册的 clsid 将不会失败。  
  
   
  
## Examples  
 下面的示例使用 Microsoft Word[应用程序对象](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word)的 CLSID 从名为 computer17.central.contoso.com 的服务器中检索代表 Microsoft Word 应用程序的 COM 类型。 然后通过调用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来实例化该类型, 并通过调用[应用程序 Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word)方法关闭该类型。 如果在加载该类型时发生错误, 则会引发异常。  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>此方法用于处理 COM 对象, 而不是与 .NET Framework 对象一起使用。 所有托管对象 (包括对 COM 可见的对象, 即其<see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" />属性为<see langword="true" />) 都具有由<see cref="P:System.Type.GUID" />属性返回的 GUID。 尽管方法返回对应于特定托管对象的 GUID <see cref="M:System.Activator.CreateInstance(System.Type)" />的<see cref="T:System.Type" /> 对象,但你不能使用该对象通过调用方法来创建类型实例,如<see cref="T:System.Type" />以下 <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />示例所示展示.  
  
[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
相反, <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />只应使用来检索非托管 com 对象的 GUID, 并且传递给该<see cref="M:System.Activator.CreateInstance(System.Type)" />方法的<see cref="T:System.Type" />生成对象必须表示非托管 com 对象。</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">引用类型的对象。</param>
        <summary>获取由指定类型句柄引用的类型。</summary>
        <returns>如果 <see cref="T:System.RuntimeTypeHandle" /> 的 <see langword="null" /> 属性为 <see cref="P:System.RuntimeTypeHandle.Value" />，则为由指定的 <paramref name="handle" /> 引用的类型，或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄仅在获取它们的应用程序域中有效。  
  
   
  
## Examples  
 下面的示例<xref:System.Type.GetTypeFromHandle%2A>使用方法<xref:System.Type> <xref:System.RuntimeTypeHandle>从方法提供的中获取一个对象。<xref:System.Type.GetTypeHandle%2A>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型，如果在加载 <see cref="T:System.Type" /> 时遇到错误，则返回空值。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项，并且有与之关联的类型，则为与指定 ProgID 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 Progid 不在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>获取与指定程序标识符 (ProgID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 程序 Id 未在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。  
  
   
  
## Examples  
 下面的示例通过传递 ProgID 来检索一个类型, 并指定当 ProgID 无效时是否引发异常。 然后, 该示例显示与 ProgID 相关的 ClassID 以及任何适用的异常消息。  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未注册指定的 ProgID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的类型的 ProgID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <summary>从指定服务器获取与指定程序标识符 (progID) 关联的类型，如果在加载该类型时遇到错误则返回空值。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 程序 Id 未在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。  
  
   
  
## Examples  
 下面的示例通过传递 ProgID 和服务器名称来检索类型。 然后, 该示例显示与 ProgID 相关的 ClassID, 或如果 ProgID 或服务器名称无效, 则会引发异常。  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="progID">要获取的 <see cref="T:System.Type" /> 的 progID。</param>
        <param name="server">用于从中加载该类型的服务器。 如果服务器名称为 <see langword="null" />，则此方法会自动恢复到本地计算机上。</param>
        <param name="throwOnError"><see langword="true" /> 将引发所发生的任何异常。  
  
或 
 <see langword="false" /> 将忽略所发生的任何异常。</param>
        <summary>从指定服务器获取与指定程序标识符 (progID) 关联的类型，指定如果在加载该类型时发生错误是否引发异常。</summary>
        <returns>如果 <paramref name="progID" /> 是注册表中的有效项且有与之关联的类型，则为与指定程序标识符 (ProgID) 关联的类型；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了支持 COM。 程序 Id 未在 Microsoft .NET 框架中使用, 因为它们已被命名空间的概念取代。  
  
   
  
## Examples  
 下面的示例通过传递 ProgID 和服务器名称来检索类型。 然后, 该示例显示与 ProgID 相关的 ClassID, 并指定当 ProgID 或服务器名称无效时是否引发异常。  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">未注册指定的 progID。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">要获取类型句柄的对象。</param>
        <summary>获取指定对象的 <see cref="T:System.Type" /> 的句柄。</summary>
        <returns>指定 <see cref="T:System.Type" /> 的 <see cref="T:System.Object" /> 的句柄。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 句柄仅在获取它们的应用程序域中有效。  
  
   
  
## Examples  
 下面的示例定义类`MyClass1`, 获取其实例, 并检索对象的运行时句柄。  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Type" />关联的 GUID。</summary>
        <value>获取与 <see cref="T:System.Type" /> 关联的 GUID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GUID 与使用<xref:System.Runtime.InteropServices.GuidAttribute>特性的类型相关联。  
  
   
  
## Examples  
 下面的示例使用公共方法`MyClass1`创建类, `Type`创建与对应`MyClass1`的对象, 并使用`GUID` `Type`类的属性<xref:System.Guid>获取结构。  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示当前 <see cref="T:System.Type" /> 是包含还是引用另一类型，即当前 <see cref="T:System.Type" /> 是数组、指针还是通过引用传递。</summary>
        <value>如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如, 键入 GetType ("Int32 []")。HasElementType 返回`true`, 但键入 GetType ("Int32")。HasElementType 返回`false`。 HasElementType 还返回`true` "int32 *" 和 "int32 &"。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例返回`true`或`false` , 具体取决于对象是数组、引用类型还是指针。  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，实现 <see cref="P:System.Type.HasElementType" /> 属性，确定当前 <see cref="T:System.Type" /> 是否包含另一类型或对其引用；即，当前 <see cref="T:System.Type" /> 是否是数组、指针或由引用传递。</summary>
        <returns>如果 <see langword="true" /> 为数组、指针或按引用传递，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如, 键入 GetType ("Int32 []")。HasElementTypeImpl 返回`true`, 但键入 GetType ("Int32")。HasElementTypeImpl 返回`false`。 HasElementTypeImpl 还返回`true` "int32 *" 和 "int32 &"。  
  
   
  
## Examples  
 下面的示例定义类, `MyTypeDelegator`该类`HasElementTypeImpl`重写方法。 主类检查`HasElementType`属性, 并显示元素类型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>调用当前 <see cref="T:System.Type" /> 的特定成员。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
- 或 - 
空字符串 ("")，表示调用默认成员。  
  
或 
对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">枚举值的按位组合，这些值指定如何进行搜索。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
- 或 - 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <summary>使用指定的绑定约束并匹配指定的参数列表，调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:  
  
-   指定`BindingFlags.Public`在搜索中包括公共成员。  
  
-   指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有和受保护的成员)。  
  
-   指定`BindingFlags.FlattenHierarchy`以在层次结构中包含静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。  
  
 以下<xref:System.Reflection.BindingFlags>调用标志可用于表示要对成员执行的操作:  
  
-   `CreateInstance`调用构造函数。 `name`将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod`调用方法, 而不是构造函数或类型初始值设定项。 对于`SetField` 或`SetProperty`无效。 如果`InvokeMethod`自行指定, `BindingFlags.Public`则将自动`BindingFlags.Instance`包含、 `BindingFlags.Static`和。  
  
-   `GetField`获取字段的值。 对`SetField`无效。  
  
-   `SetField`设置字段的值。 对`GetField`无效。  
  
-   `GetProperty`获取属性。 对`SetProperty`无效。  
  
-   `SetProperty`设置属性。 对`GetProperty`无效。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下两个条件均为 true, 则将调用方法:  
  
-   方法声明中的参数数目等于`args`数组中的参数个数 (除非在成员上定义了默认参数, 并且`BindingFlags.OptionalParamBinding`指定了默认参数)。  
  
-   联编程序可以将每个参数的类型转换为参数的类型。  
  
 此联编程序将查找所有匹配的方法。 这些方法基于所请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`、 `GetProperty`等)。 方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。  
  
 选择方法后, 将调用该方法。 此时将检查可访问性。 搜索可根据与方法关联的可访问性属性控制要搜索的方法集。 <xref:System.Reflection.Binder>类的方法负责选择要调用的方法。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 默认联编程序将选择最特定的匹配项。  
  
 完全受信任的代码将忽略访问限制;也就是说, <xref:System.Reflection>只要代码完全受信任, 就可以访问和调用私有构造函数、方法、字段和属性。  
  
 通过指定`Type.InvokeMember` <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, 可以使用将字段设置为特定值。 例如, 如果要在类 C 上设置名为 F 的公共实例字段, 并且 F 为`String`, 则可以使用以下代码:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 如果 F 是`String[]`, 则可以使用以下代码:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 这会将 F 字段初始化为这个新的数组。 你还可以使用`Type.InvokeMember`来设置数组中的位置, 方法是提供值的索引, 然后使用如下所示的代码来设置下一个值:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。  
  
 调用`IDispatch`成员时, 可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。 例如, 如果 MyComMethod 为 3, 则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。 DispID 调用成员比按名称查找成员的速度更快。 在复杂的聚合方案中, DispID 有时是调用所需成员的唯一方法。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少. (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的示例使用`InvokeMember`来访问类型的成员。  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
或 
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
- 或 - 
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
- 或 - 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
- 或 - 
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
- 或 - 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
- 或 - 
对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
或 
其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
- 或 - 
当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 当前不支持此方法。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用于访问非公共成员, 而不考虑其授予集。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
- 或 - 
空字符串 ("")，表示调用默认成员。  
  
或 
对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">枚举值的按位组合，这些值指定如何进行搜索。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
- 或 - 
要使用 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="P:System.Type.DefaultBinder" />）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <param name="culture">表示要使用的全局化区域设置的对象，它对区域设置特定的转换可能是必需的，比如将数字 <see cref="T:System.String" /> 转换为 <see cref="T:System.Double" />。  
  
或 
要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</param>
        <summary>使用指定的绑定约束和匹配的指定参数列表及区域性来调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 尽管默认的联编程序不处理<xref:System.Globalization.CultureInfo> `culture` (参数), 但您可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`culture`的自定义联编程序。  
  
> [!NOTE]
>  不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:  
  
-   指定`BindingFlags.Public`在搜索中包括公共成员。  
  
-   指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。  
  
-   指定`BindingFlags.FlattenHierarchy`以在层次结构中包含静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。  
  
 以下<xref:System.Reflection.BindingFlags>调用标志可用于表示要对成员执行的操作:  
  
-   `CreateInstance`调用构造函数。 `name`将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod`调用方法, 而不是构造函数或类型初始值设定项。 对于`SetField` 或`SetProperty`无效。 如果`InvokeMethod`自行指定, `BindingFlags.Public`则将自动`BindingFlags.Instance`包含、 `BindingFlags.Static`和。  
  
-   `GetField`获取字段的值。 对`SetField`无效。  
  
-   `SetField`设置字段的值。 对`GetField`无效。  
  
-   `GetProperty`获取属性。 对`SetProperty`无效。  
  
-   `SetProperty`设置属性。 对`GetProperty`无效。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下两个条件均为 true, 则将调用方法:  
  
-   方法声明中的参数数目等于`args`数组中的参数个数 (除非在成员上定义了默认参数, 并且`BindingFlags.OptionalParamBinding`指定了默认参数)。  
  
-   联编程序可以将每个参数的类型转换为参数的类型。  
  
 此联编程序将查找所有匹配的方法。 这些方法基于所请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`、 `GetProperty`等)。 方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。  
  
 选择方法后, 将调用该方法。 此时将检查可访问性。 搜索可根据与方法关联的可访问性属性控制要搜索的方法集。 <xref:System.Reflection.Binder>类的方法负责选择要调用的方法。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 默认联编程序将选择最特定的匹配项。  
  
 完全受信任的代码将忽略访问限制;也就是说, 只要代码完全受信任, 就可以通过反射访问和调用私有构造函数、方法、字段和属性。  
  
 通过指定`Type.InvokeMember` <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, 可以使用将字段设置为特定值。 例如, 如果要在类 C 上设置名为 F 的公共实例字段, 并且 F 为`String` , 则可以使用以下代码:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 如果 F 是`String[]`, 则可以使用以下代码:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 这会将 F 字段初始化为这个新的数组。 你还可以使用`Type.InvokeMember`来设置数组中的位置, 方法是提供值的索引, 然后使用如下所示的代码来设置下一个值:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。  
  
 调用`IDispatch`成员时, 可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。 例如, 如果 MyComMethod 为 3, 则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。 DispID 调用成员比按名称查找成员的速度更快。 在复杂的聚合方案中, DispID 有时是调用所需成员的唯一方法。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少. (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
或 
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
- 或 - 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
- 或 - 
对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
或 
其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
或 
当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用于访问非公共成员, 而不考虑其授予集。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">字符串，它包含要调用的构造函数、方法、属性或字段成员的名称。  
  
或 
空字符串 ("")，表示调用默认成员。  
  
或 
对于 <see langword="IDispatch" /> 成员，则为一个表示 DispID 的字符串，例如"[DispID=3]"。</param>
        <param name="invokeAttr">枚举值的按位组合，这些值指定如何进行搜索。 访问可以是 <see langword="BindingFlags" /> 之一，如 <see langword="Public" />、<see langword="NonPublic" />、<see langword="Private" />、<see langword="InvokeMethod" /> 和 <see langword="GetField" /> 等。 查找类型无需指定。 如果省略查找的类型，则将使用 <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />。</param>
        <param name="binder">一个对象，该对象定义一组属性并启用绑定，而绑定可能涉及选择重载方法、强制参数类型和通过反射调用成员。  
  
或 
要使用 <see cref="P:System.Type.DefaultBinder" /> 的空引用（在 Visual Basic 中为 Nothing）。 请注意，为了成功地使用变量参数来调用方法重载，可能必须显式定义 <see cref="T:System.Reflection.Binder" /> 对象。</param>
        <param name="target">对其调用指定成员的对象。</param>
        <param name="args">包含传递给要调用的成员的参数的数组。</param>
        <param name="modifiers"><see cref="T:System.Reflection.ParameterModifier" /> 对象的数组，表示与 <paramref name="args" /> 数组中的相应元素关联的特性。 参数的关联的属性存储在成员的签名中。  
  
只有在调用 COM 组件时，默认联编程序才处理此参数。</param>
        <param name="culture">表示要使用的全局化区域设置的 <see cref="T:System.Globalization.CultureInfo" /> 对象，它对区域设置特定的转换可能是必需的，比如将数字 String 转换为 Double。  
  
或 
要使用当前线程的 <see langword="Nothing" /> 的空引用（在 Visual Basic 中为 <see cref="T:System.Globalization.CultureInfo" />）。</param>
        <param name="namedParameters">包含参数名称的数组，<paramref name="args" /> 数组中的值将传递给这些参数。</param>
        <summary>当在派生类中重写时，使用指定的绑定约束并匹配指定的参数列表、修饰符和区域性，调用指定成员。</summary>
        <returns>一个对象，表示被调用成员的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember`调用构造函数成员或方法成员, 获取或设置属性成员, 获取或设置数据字段成员, 或者获取或设置数组成员的元素。  
  
> [!NOTE]
>  不能使用<xref:System.Type.InvokeMember%2A>调用泛型方法。  
  
 调用`IDispatch`成员时, 可以使用字符串格式 "[DispID = # #]" 来指定 DispID 而不是成员名称。 例如, 如果 MyComMethod 为 3, 则可以指定字符串 "[DispID = 3]" 而不是 "MyComMethod"。 DispID 调用成员比按名称查找成员的速度更快。 在复杂的聚合方案中, DispID 有时是调用所需成员的唯一方法。  
  
 尽管默认联编程序不处理<xref:System.Reflection.ParameterModifier>或<xref:System.Globalization.CultureInfo> ( `modifiers`和`culture`参数), 但你可以使用抽象<xref:System.Reflection.Binder?displayProperty=nameWithType>类编写处理`modifiers`和`culture`. `ParameterModifier`仅在通过 COM 互操作进行调用时使用, 并且仅处理通过引用传递的参数。  
  
 `namedParameters` 数组中的每个参数对应 `args` 数组中的元素来获取值。 如果 `args` 的长度大于 `namedParameters` 的长度，则剩余的自变量值将按顺序传递。  
  
 `namedParameters`数组可用于更改输入数组中参数的顺序。 例如`M(string a, int b)` , `args`如果给定了方法 (`M(ByVal a As String, ByVal b As Integer)`在 Visual Basic 中) 和输入数组`{ 42, "x" }`, 则当为提供数组`{ "b", "a" }`时, 输入数组可以`namedParameters`保持不变。  
  
 以下<xref:System.Reflection.BindingFlags>筛选器标志可用于定义要包括在搜索中的成员:  
  
-   指定`BindingFlags.Public`在搜索中包括公共成员。  
  
-   指定`BindingFlags.NonPublic`以包括搜索中的非公共成员 (即, 私有成员、内部成员和受保护成员)。  
  
-   指定`BindingFlags.FlattenHierarchy`以在层次结构中包含静态成员。  
  
 以下<xref:System.Reflection.BindingFlags>修饰符标志可用于更改搜索的工作方式:  
  
-   `BindingFlags.IgnoreCase`如果忽略, 则为`name`。  
  
-   `BindingFlags.DeclaredOnly`仅搜索在上<xref:System.Type>声明的成员, 而不搜索简单继承的成员。  
  
 以下<xref:System.Reflection.BindingFlags>调用标志可用于表示要对成员执行的操作:  
  
-   `CreateInstance`调用构造函数。 `name`将被忽略。 与其他调用标志无效。  
  
-   `InvokeMethod`调用方法, 而不是构造函数或类型初始值设定项。 对于`SetField` 或`SetProperty`无效。 如果`InvokeMethod`自行指定, `BindingFlags.Public`则将自动`BindingFlags.Instance`包含、 `BindingFlags.Static`和。  
  
-   `GetField`获取字段的值。 对`SetField`无效。  
  
-   `SetField`设置字段的值。 对`GetField`无效。  
  
-   `GetProperty`获取属性。 对`SetProperty`无效。  
  
-   `SetProperty`设置属性。 对`GetProperty`无效。  
  
 有关更多信息，请参见<xref:System.Reflection.BindingFlags?displayProperty=nameWithType>。  
  
 如果以下两个条件均为 true, 则将调用方法:  
  
-   方法声明中的参数数目等于`args`数组中的参数个数 (除非在成员上定义了默认参数, 并且`BindingFlags.OptionalParamBinding`指定了默认参数)。  
  
-   联编程序可以将每个参数的类型转换为参数的类型。  
  
 此联编程序将查找所有匹配的方法。 这些方法基于所请求的绑定类型 (<xref:System.Reflection.BindingFlags>值`InvokeMethod`、 `GetProperty`等)。 方法集按名称、参数数目和在联编程序中定义的一组搜索修饰符进行筛选。  
  
 选择方法后, 将调用该方法。 此时将检查可访问性。 搜索可根据与方法关联的可访问性属性控制要搜索的方法集。 <xref:System.Reflection.Binder>类的方法负责选择要调用的方法。 <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 默认联编程序将选择最特定的匹配项。  
  
 `InvokeMember`可用于调用带有具有默认值的参数的方法。 若要绑定到这些方法, 需要<xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType>指定反射。 对于具有默认值的参数, 您可以提供不同的值, 也<xref:System.Reflection.Missing.Value?displayProperty=nameWithType>可以使用默认值。  
  
 例如, 假设有一个方法, 如 MyMethod (int x, float y = 2.0)。 若要调用此方法并只将第一个参数作为 MyMethod (4), 请传递上述绑定标志之一, 并为第一个参数和`Missing.Value`第二个参数传递两个参数, 即4。 除非你使用`Missing.Value`, 否则不能使用`Invoke`方法省略可选参数。 如果必须这样做, 请`InvokeMember`改用。  
  
 完全受信任的代码将忽略访问限制;也就是说, <xref:System.Reflection>只要代码完全受信任, 就可以访问和调用私有构造函数、方法、字段和属性。  
  
 通过指定`Type.InvokeMember` <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, 可以使用将字段设置为特定值。 例如, 如果要在类 C 上设置名为 F 的公共实例字段, 并且 F 为`String`, 则可以使用以下代码:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 如果 F 是`String[]`, 则可以使用以下代码:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 这会将 F 字段初始化为这个新的数组。 你还可以使用`Type.InvokeMember`来设置数组中的位置, 方法是提供值的索引, 然后使用如下所示的代码来设置下一个值:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 这会将 F 包含的数组中的字符串 "z" 更改为字符串 "b"。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少. (请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)  
>   
>  若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> 不包含 <see langword="CreateInstance" />，并且 <paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> 和 <paramref name="modifiers" /> 的长度不相同。  
  
或 
 <paramref name="invokeAttr" /> 不是有效的 <see cref="T:System.Reflection.BindingFlags" /> 属性。  
  
- 或 - 
 <paramref name="invokeAttr" /> 不包含以下某个绑定标志：<see langword="InvokeMethod" />、<see langword="CreateInstance" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="CreateInstance" /> 与 <see langword="InvokeMethod" />、<see langword="GetField" />、<see langword="SetField" />、<see langword="GetProperty" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetField" /> 和 <see langword="SetField" />。  
  
- 或 - 
 <paramref name="invokeAttr" /> 同时包含 <see langword="GetProperty" /> 和 <see langword="SetProperty" />。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="InvokeMethod" /> 与 <see langword="SetField" /> 或 <see langword="SetProperty" /> 的组合。  
  
或 
 <paramref name="invokeAttr" /> 包含 <see langword="SetField" />，并且 <paramref name="args" /> 具有多个元素。  
  
- 或 - 
命名的参数数组大于参数数组。  
  
或 
对 COM 对象调用了此方法，但以下绑定标志中有一个未传入：<see langword="BindingFlags.InvokeMethod" />、<see langword="BindingFlags.GetProperty" />、<see langword="BindingFlags.SetProperty" />、<see langword="BindingFlags.PutDispProperty" /> 或 <see langword="BindingFlags.PutRefDispProperty" />。  
  
- 或 - 
其中一个命名参数数组包含一个值为 <see langword="null" /> 的字符串。</exception>
        <exception cref="T:System.MethodAccessException">指定的成员是类初始值设定项。</exception>
        <exception cref="T:System.MissingFieldException">找不到此字段或属性。</exception>
        <exception cref="T:System.MissingMethodException">找不到与 <paramref name="args" /> 中的参数匹配的方法。  
  
或 
找不到具有 <paramref name="namedParameters" /> 中提供的参数名称的成员。  
  
或 
当前 <see cref="T:System.Type" /> 对象表示包含开放类型参数的类型，也就是说，<see cref="P:System.Type.ContainsGenericParameters" /> 将返回 <see langword="true" />。</exception>
        <exception cref="T:System.Reflection.TargetException">不能在 <paramref name="target" /> 上调用指定的成员。</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">多个方法与绑定条件匹配。</exception>
        <exception cref="T:System.InvalidOperationException">由 <paramref name="name" /> 表示的方法具有一个或多个未指定的泛型类型参数。 也就是说，此方法的 <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" /> 属性将返回 <see langword="true" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">用于访问非公共成员, 而不考虑其授予集。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为抽象的并且必须被重写。</summary>
        <value>如果 <see cref="T:System.Type" /> 是抽象的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Type.IsAbstract%2A>以下情况`true`下, 属性将返回:  
  
-   当前类型是抽象的;也就是说, 它不能进行实例化, 但只能充当派生类的基类。 在C#中, 抽象类标有[abstract](~/docs/csharp/language-reference/keywords/abstract.md)关键字;在 Visual Basic 中, 它们用[MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)关键字进行标记。  
  
-   当前类型是接口。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的<xref:System.Type>示例创建对象的数组, 这些对象表示以下类型: 如果指定的对象为`abstract`, 则包含类型返回`true` ; 否则返回`false`。  
  
-   `AbstractClass`, 抽象类 (在`abstract` C#和`MustInherit`中标记为的类 Visual Basic)。  
  
-   `DerivedClass`, 是从`AbstractClass`继承的类。  
  
-   `SingleClass`, 不可继承的类。 它在和`sealed` `NotInheritable` Visual Basic 中C#定义为。  
  
-   `ITypeInfo`, 接口。  
  
-   `ImplementingClass`, 是实现`ITypeInfo`接口的类。  
  
 方法只为`true` `AbstractClass`、抽象类和`ITypeInfo`接口返回。  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="AnsiClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AnsiClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>选择字符串格式特性。 字符串格式特性通过定义应如何解释字符串来增强互操作性。  
  
 如果当前<xref:System.Type>表示泛型类型, 则此属性适用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例获取字段信息并检查`AnsiClass`特性。  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示类型是否为数组。</summary>
        <value>如果当前类型是数组，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsArray%2A>属性`false`为类<xref:System.Array>返回。 如果当前实例`false` <xref:System.Type>是表示集合类型的对象或用于处理集合的接口 (如<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>), 则此方法也会返回。  
  
 若要检查数组, 请使用如下所示的代码:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 如果当前类型表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Type.IsArray%2A>属性。  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsArray" /> 属性并确定 <see cref="T:System.Type" /> 是否为数组。</summary>
        <returns>如果 <see langword="true" /> 是数组，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>类的实例必须返回`false` , 因为它是一个对象, 而不是一个数组。  
  
   
  
## Examples  
 下面的示例重写`IsArrayImpl` `MyTypeDelegator`类中的方法, 检查变量是否为数组, 并显示结果。  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">要与当前类型进行比较的类型。</param>
        <summary>确定指定类型的实例是否能分配给当前类型的变量。</summary>
        <returns>如果满足下列任一条件，则为 <see langword="true" />： 
-   <paramref name="c" /> 和当前实例表示相同类型。  
  
-   <paramref name="c" /> 是从当前实例直接或间接派生的。 如果继承于当前实例，则 <paramref name="c" /> 是从当前实例直接派生的；如果继承于从当前实例继承的接连一个或多个类，则 <paramref name="c" /> 是从当前实例间接派生的。  
  
-   当前实例是 <paramref name="c" /> 实现的一个接口。  
  
-   <paramref name="c" /> 是一个泛型类型参数，并且当前实例表示 <paramref name="c" /> 的约束之一。  
  
在以下示例中，当前实例是表示 <see cref="T:System.IO.Stream" /> 类的 <see cref="T:System.Type" /> 对象。 <c>GenericWithConstraint</c> 是一种泛型类型，其泛型类型参数必须为 <see cref="T:System.IO.Stream" /> 类型。 将其泛型类型参数传递到 <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> 表示可以将泛型类型参数的实例分配给 <see cref="T:System.IO.Stream" /> 对象。  
  
[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)] 
-   <paramref name="c" /> 表示一个值类型，并且当前实例表示 <c>Nullable&lt;c&gt;</c>（在 Visual Basic 中为 <c>Nullable(Of c)</c>）。  
  
 如果不满足上述任何一个条件或者 <paramref name="c" /> 为 <see langword="false" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法可用于确定是否可将的`c`实例分配给当前类型的实例, 当你处理的对象的类型在设计时是未知的并且允许有条件时, 该方法最有用<xref:System.Type.IsAssignableFrom%2A>赋值, 如下面的示例所示。  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 因此, 此方法可确保在运行时执行类似于下面的代码行, 而不<xref:System.InvalidCastException>会引发异常或类似的异常:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 此方法可由派生类重写。  
  
> [!NOTE]
>  泛型类型定义不可从封闭式构造类型赋值。 也就是说, 不能将封闭式构造类型`MyGenericList<int>` (`MyGenericList(Of Integer)`在 Visual Basic 中) 分配给类型`MyGenericList<T>`的变量。  
  
 如果参数的类型<xref:System.Reflection.Emit.TypeBuilder>为, 则结果基于要生成的类型。 `c` 下面的代码示例使用名为`B`的生成类型对此进行演示。  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 下面的示例演示了`IsAssignableFrom`使用定义的类、整数数组和泛型的方法。  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="AutoClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="AutoClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>选择字符串格式特性。 字符串格式特性通过定义应如何解释字符串来增强互操作性。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否由公共语言运行时自动放置的值。</summary>
        <value>如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了方便。 或者, 您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值选择类型布局特性, 然后测试是否<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>已设置。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、和枚举<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>值指示类型的字段在内存中的布局方式。<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>  
  
 对于动态类型, 可以在创建<xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>类型时指定。 在代码中, 将<xref:System.Runtime.InteropServices.StructLayoutAttribute> <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType>具有枚举值的属性应用到类型, 以使运行时确定对类进行布局的适当方式。  
  
> [!NOTE]
>  不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法确定<xref:System.Runtime.InteropServices.StructLayoutAttribute>是否已应用于类型。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果当前<xref:System.Type>表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由`MyGenericType<T>.`  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建类型的实例并显示<xref:System.Type.IsAutoLayout%2A>属性。  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">元数据和自描述组件</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否由引用传递。</summary>
        <value>如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取实际类型, 请取消引用通过引用传递的类型, 然后对该类型<xref:System.Type.GetElementType%2A>调用。  
  
   
  
## Examples  
 下面的示例演示如何使用`IsByRef`属性来检查指定类型是否由引用传递。 该示例定义了类`MyTypeDelegator`, 该类会`HasElementTypeImpl`重写方法。 主类检查`HasElementType`属性, 并显示元素类型。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsByRef" /> 属性并确定<see cref="T:System.Type" /> 是否通过引用传递。</summary>
        <returns>如果 <see cref="T:System.Type" /> 按引用传递，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个类或委托；即，不是值类型或接口。</summary>
        <value>如果 <see cref="T:System.Type" /> 是类，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回`true`类和委托的。 它会`false`返回值类型 (对于结构和枚举), 即使它们已装箱也是如此。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`true`。如果当前<xref:System.Type>表示构造泛型类型, 则当泛型类型定义`true`是类定义时, 此属性将返回; 也就是说, 它不定义接口或值类型。  
  
> [!NOTE]
>  此属性为`true` `Type`表示<xref:System.Enum> 和<xref:System.ValueType>类的实例返回。 这两个类分别是枚举和值类型的基类型, 但它们不是枚举或值类型本身。 有关详细信息, 请参阅<xref:System.Type.IsValueType%2A>和<xref:System.Type.IsEnum%2A>属性。  
  
 <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>枚举值将类型声明分为类或接口。但是, 类和值类型都是用<xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>特性标记的。 如果检索类型属性的值, 并使用<xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>该值来确定类型是否是类而不是值类型, 则还必须<xref:System.Type.IsValueType%2A>调用属性。 <xref:System.Reflection.TypeAttributes>枚举的示例包含附加信息以及 anexample。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建一个类型的实例, 并指示该类型是否为类。  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为 COM 对象。</summary>
        <value>如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对于`false` COM 接口返回, 因为它们不是对象。 COM 接口可由 Microsoft .NET Framework 对象实现。  
  
 还可以通过使用`Type` [tlbimp.exe (类型库导入程序)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)工具加载 com 类并获取该 com 类的对象。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int`> (`MyGenericType(Of Integer)` Visual Basic), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中重写时，实现 <see cref="P:System.Type.IsCOMObject" /> 属性并确定 <see cref="T:System.Type" /> 是否为 COM 对象。</summary>
        <returns>如果 <see langword="true" /> 为 COM 对象，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对于`false` COM 接口返回, 因为它们不是对象。 COM 接口可由 Microsoft .NET Framework 对象实现。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示此对象是否表示构造的泛型类型的值。 你可以创建构造型泛型类型的实例。</summary>
        <value>如果此对象表示构造泛型类型，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造的泛型类型已为其所有泛型类型参数提供显式类型。 它也称为封闭式泛型类型。  
  
 当此属性为`true`时, 可以创建当前类型的实例; 如果是`false`, 则不能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</summary>
        <value>如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 上下文会截获对类成员的调用, 并强制实施应用于类的策略, 如同步。 有关远程处理上下文的更多详细信息<xref:System.Runtime.Remoting.Contexts.Context>, 请参阅。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的`IsContextful`示例演示了<xref:System.Type>类<xref:System.Type.IsMarshalByRef%2A>的、 <xref:System.Type.IsPrimitive%2A>和属性。 它会检查给定的类型是否可在上下文中承载, 是否可以按引用进行封送处理, 以及该类型是否为基元数据类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsContextful" /> 属性并确定 <see cref="T:System.Type" /> 在上下文中是否可以被承载。</summary>
        <returns>如果 <see cref="T:System.Type" /> 能够在某个上下文中承载，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
 上下文会截获对类成员的调用, 并强制实施应用于类的策略, 如同步。  
  
   
  
## Examples  
 下面的示例演示`IsContextfulImpl`方法的用法。  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的 <see cref="T:System.Type" /> 是否表示枚举。</summary>
        <value>如果当前 <see langword="true" /> 表示枚举，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性为`true`枚举返回, 但不<xref:System.Enum>返回类型本身。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示如何使用`IsEnum`属性。  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">要测试的值。</param>
        <summary>返回一个值，该值指示当前的枚举类型中是否存在指定的值。</summary>
        <returns>如果指定的值是当前枚举类型的成员，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">当前类型不是一个枚举。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> 类型不能为枚举的基础类型。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="other">要测试是否与当前类型等效的 COM 类型。</param>
        <summary>确定两个 COM 类型是否具有相同的标识，以及是否符合类型等效的条件。</summary>
        <returns>如果 COM 类型等效，则为 <see langword="true" />；否则为 <see langword="false" />。 如果一个类型位于为执行加载的程序集中，而另一个类型位于已加载到仅限反射上下文的程序集中，则此方法也返回 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从开始, 公共语言运行时支持直接将 com 类型的类型信息嵌入到托管程序集中, 而不需要托管程序集从互操作获取 com 类型的类型信息[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]程序. 由于嵌入式类型信息仅包含托管程序集实际使用的类型和成员，因此两个托管程序集可能具有相同 COM 类型的不同视图。 每个托管程序集都有不同的 <xref:System.Type> 对象来表示其 COM 类型视图。 公共语言运行时支持接口、结构、枚举和委托等不同视图之间的类型等效性。  
  
 类型等效性意味着从一个托管程序集传递到另一个托管程序集的 COM 对象可以转换为接收程序集中适当的托管类型。 <xref:System.Type.IsEquivalentTo%2A>方法使程序集能够确定从另一个程序集获取的 com 对象与第一个程序集自己的嵌入互操作类型之一具有相同的 com 标识, 因此可以强制转换为该类型。  
  
 有关详细信息, 请参阅[类型等效性和嵌入的互操作类型](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否放置在显式指定的偏移量处的值。</summary>
        <value>如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了方便。 或者, 您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值选择类型布局特性, 然后测试是否<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>已设置。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、和枚举<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>值指示类型的字段在内存中的布局方式。 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>  
  
 对于动态类型, 可以在创建<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>类型时指定。 在代码中, 将<xref:System.Runtime.InteropServices.StructLayoutAttribute> <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>具有枚举值的属性应用到类型, 以指定显式指定字段开始的偏移量。  
  
> [!NOTE]
>  不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法确定<xref:System.Runtime.InteropServices.StructLayoutAttribute>是否已应用于类型。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建一个类型的实例, 并显示其<xref:System.Type.IsExplicitLayout%2A>属性的值。 它使用`MySystemTime`类, 该类也在的代码<xref:System.Runtime.InteropServices.StructLayoutAttribute>示例中。  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">元数据和自描述组件</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示泛型类型或方法的定义中的类型参数。</summary>
        <value>如果 <see cref="T:System.Type" /> 对象表示泛型类型定义或泛型方法定义的类型参数，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type>可以通过调用<xref:System.Type.GetGenericArguments%2A>表示<xref:System.Reflection.MethodInfo.GetGenericArguments%2A>泛型类型定义的<xref:System.Type>对象的方法<xref:System.Reflection.MethodInfo>或表示泛型方法的对象的方法来获取表示泛型类型参数的对象。定义.  
  
-   对于泛型类型或方法定义, <xref:System.Type.IsGenericParameter%2A>属性为所得数组的每个元素返回。 `true`  
  
-   对于封闭式构造类型或方法, <xref:System.Type.IsGenericParameter%2A>属性为该<xref:System.Type.GetGenericArguments%2A>方法`false`返回的数组的每个元素返回。  
  
-   对于开放构造的类型或方法, 数组的某些元素可能是特定类型, 而其他元素可能为类型参数。 <xref:System.Type.IsGenericParameter%2A>为`false`类型参数和`true`类型参数返回。 <xref:System.Type.ContainsGenericParameters%2A>属性的代码示例演示了混合类型和类型参数的泛型类。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.IsGenericParameter%2A>属性测试泛型类型中的泛型类型参数。  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型是否是泛型类型。</summary>
        <value><see langword="true" />如果当前类型是泛型类型, 则为; 否则为。否则为<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用属性来确定<xref:System.Type>对象是否表示泛型类型。 <xref:System.Type.IsGenericType%2A> 使用属性可确定<xref:System.Type>对象表示开放构造类型还是封闭式构造类型。 <xref:System.Type.ContainsGenericParameters%2A>  
  
> [!NOTE]
>  如果<xref:System.Type.IsGenericType%2A>直接类型`false`不是泛型, 则属性返回。 例如, 其元素属于类型`A<int>` (`A(Of Integer)`在 Visual Basic 中) 的数组本身不是泛型类型。  
  
 下表总结了泛型反射中使用的常用术语的固定条件。  
  
|术语|固定条件|  
|----------|---------------|  
|Generic Type Definition — 泛型类型定义|<xref:System.Type.IsGenericTypeDefinition%2A> 属性为 `true`。<br /><br /> 定义泛型类型。 构造类型是通过<xref:System.Type.MakeGenericType%2A> <xref:System.Type>对表示泛型类型定义并指定类型参数数组的对象调用方法创建的。<br /><br /> <xref:System.Type.MakeGenericType%2A>只能对泛型类型定义调用。<br /><br /> 任何泛型类型定义都是泛型类型 ( <xref:System.Type.IsGenericType%2A>属性为`true`), 但反之不成立。|  
|Generic Type — 泛型类型|<xref:System.Type.IsGenericType%2A> 属性为 `true`。<br /><br /> 可以是泛型类型定义、开放式构造类型或封闭式构造类型。<br /><br /> 请注意, 其元素类型为泛型的数组类型本身不是泛型类型。 表示指向泛型类型的指针<xref:System.Type>的对象也是如此。|  
|开放式构造类型|<xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。<br /><br /> 例如, 具有未分配的类型参数的泛型类型、嵌套在泛型类型定义中的类型或开放构造类型中的泛型类型, 或者具有<xref:System.Type.ContainsGenericParameters%2A> `true`属性所属的类型参数的泛型类型。<br /><br /> 不能创建开放式构造类型的实例。<br /><br /> 请注意, 并非所有开放式构造类型都是泛型的。 例如, 其元素类型为泛型类型定义的数组不是泛型类型, 而指向开放式构造类型的指针不是泛型类型。|  
|封闭式构造类型|<xref:System.Type.ContainsGenericParameters%2A> 属性为 `false`。<br /><br /> 递归检查时, 类型没有未分配的泛型参数。|  
|Generic Type Parameter — 泛型类型参数|<xref:System.Type.IsGenericParameter%2A> 属性为 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 属性为 `true`。<br /><br /> 在泛型类型定义中, 将在稍后赋值的类型的占位符。|  
|Generic Type Argument — 泛型类型参数|可以是任何类型, 包括泛型类型参数。<br /><br /> 类型参数指定为在创建构造的<xref:System.Type>泛型类型时传递<xref:System.Type.MakeGenericType%2A>给方法的对象数组。 如果要创建结果类型的实例, 则<xref:System.Type.ContainsGenericParameters%2A>该属性`false`必须为所有类型自变量。|  
  
 下面的代码示例和表说明了其中一些术语和固定条件。 `Derived`类特别感兴趣, 因为其基类型是一个构造类型, 该类型在其类型参数列表中混合了类型和类型参数。  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 下表显示在类`Base`、 `Derived`和`G`上使用和生成的示例。 当C++和C#代码相同时, 只显示一个条目。  
  
|示例|固定协定|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|对于此类型:<br /><br /> <xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `true`。|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|对于此类型:<br /><br /> <xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `true`。|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|对于变量`d`类型:<br /><br /> <xref:System.Type.IsGenericType%2A>为`false` , `d`因为是一个数组。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> 为 `false`。|  
|`T`、 `U`和`V` (显示在任何位置)|<xref:System.Type.IsGenericParameter%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericType%2A>是`false`因为没有办法将类型形参约束为泛型类型。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `false`。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>是`true`因为`T`、 `U`和是本身的泛型类型参数。`V` 这并不意味着有关稍后分配给它们的类型参数的任何信息。|  
|字段的类型`F`|<xref:System.Type.IsGenericType%2A> 为 `true`。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A>是`false`因为类型已分配给的`G`类型参数。 请注意, 这等效于调用<xref:System.Type.MakeGenericType%2A>方法。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>是`true`因为字段`F`的类型具有一个类型参数, 该类型参数是一个开放式构造类型。 构造类型是开放式的, 因为其类型参数 ( `Base`即) 为泛型类型定义。 这说明了<xref:System.Type.IsGenericType%2A>属性的递归特性。|  
|嵌套类`Nested`|<xref:System.Type.IsGenericType%2A>为`true`, 即使`Nested`类没有自己的泛型类型参数, 因为它嵌套在泛型类型中。<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> 为 `true`。 也就是说, 您可以调用<xref:System.Type.MakeGenericType%2A>方法并提供封闭`Derived`类型的类型参数。<br /><br /> <xref:System.Type.ContainsGenericParameters%2A>是`true`因为封闭`Derived`类型具有泛型类型参数。 这说明了<xref:System.Type.ContainsGenericParameters%2A>属性的递归特性。|  
  
   
  
## Examples  
 下面的代码示例显示了 "备注" <xref:System.Type.IsGenericType%2A>部分中<xref:System.Type.IsGenericParameter%2A>描述的<xref:System.Type.ContainsGenericParameters%2A>类型的、 <xref:System.Type.IsGenericTypeDefinition%2A>、和属性的值。 有关属性值的说明, 请参阅 "备注" 中附带的表。  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前 <see cref="T:System.Type" /> 是否表示可以用来构造其他泛型类型的泛型类型定义。</summary>
        <value>如果此 <see langword="true" /> 对象表示泛型类型定义，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 泛型类型定义是可以从中构造其他类型的模板。 例如, 从泛型类型定义`G<T>` (用C#语法表示),`G(Of Integer)` `G<int>` <xref:System.Type.MakeGenericType%2A>在 Visual Basic 或`generic <typename T> ref class G`中C++), 可以通过调用方法和包含的泛型参数列表 (在 Visual Basic 中) 构造和实例化类型。 `G(Of T)` <xref:System.Int32>键入。 给定表示此构造类型的<xref:System.Type.GetGenericTypeDefinition%2A> 对象后,方法将再次获取该泛型类型定义。<xref:System.Type>  
  
 <xref:System.Type.IsGenericTypeDefinition%2A>使用属性可确定是否可以从当前类型创建新类型。 如果属性返回`true`, 则可以调用方法来创建新的泛型类型。<xref:System.Type.MakeGenericType%2A> <xref:System.Type.IsGenericTypeDefinition%2A>  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
   
  
## Examples  
 下面的示例显示有关类型的信息, 包括该类型是否为泛型类型定义。 为构造类型、泛型类型定义和普通类型显示信息。  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否应用了 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> 属性，如果应用了该属性，则表示它是从 COM 类型库导入的。</summary>
        <value>如果 <see langword="true" /> 具有 <see cref="T:System.Type" />，则为 <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果当前<xref:System.Type>表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由`MyGenericType<T>.`  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="o">要与当前类型进行比较的对象。</param>
        <summary>确定指定的对象是否是当前 <see cref="T:System.Type" /> 的实例。</summary>
        <returns>如果满足下列任一条件，则为 <see langword="true" />：当前 <see langword="Type" /> 位于由 <paramref name="o" /> 表示的对象的继承层次结构中；当前 <see langword="Type" /> 是 <paramref name="o" /> 实现的接口。 如果不属于其中任一种情况，<paramref name="o" /> 为 <see langword="null" />，或者当前 <see langword="Type" /> 为开放式泛型类型（即 <see cref="P:System.Type.ContainsGenericParameters" /> 返回 <see langword="true" />），则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
> [!NOTE]
>  构造类型不是其泛型类型定义的实例。 也就是说, `MyGenericList<int>` (`MyGenericList(Of Integer)`在 Visual Basic) 不是的`MyGenericList<T>`实例 (`MyGenericList(Of T)`在 Visual Basic 中)。  
  
   
  
## Examples  
 下面的示例演示 `IsInstanceOfType` 方法的用法。  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是一个接口；即，不是类或值类型。</summary>
        <value>如果 <see langword="true" /> 是接口，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将<xref:System.Reflection.TypeAttributes.ClassSemanticsMask>类型声明与类、接口或值类型区分开来。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建一个接口, 检查接口类型, 并指示类`IsInterface`是否设置了属性。  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示当前类型的字段是否按顺序（定义顺序或发送到元数据的顺序）放置的值。</summary>
        <value>如果当前类型的 <see langword="true" /> 属性包括 <see cref="P:System.Type.Attributes" />，则为 <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此属性是为了方便。 或者, 您可以使用<xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>枚举值选择类型布局特性, 然后测试是否<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>已设置。 <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>、和枚举<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>值指示类型的字段在内存中的布局方式。 <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>  
  
 对于动态类型, 可以在创建<xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType>类型时指定。 在代码中, 将<xref:System.Runtime.InteropServices.StructLayoutAttribute> <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>具有枚举值的属性应用到类型, 以指定布局是连续的。  
  
> [!NOTE]
>  不能使用<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法确定<xref:System.Runtime.InteropServices.StructLayoutAttribute>是否已应用于类型。  
  
 有关详细信息, 请参阅公共语言基础结构 (CLI) 文档规范的9.1.2 部分:元数据定义和语义 "。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的示例创建类的<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>一个实例, 该类的枚举值<xref:System.Runtime.InteropServices.StructLayoutAttribute>已<xref:System.Type.IsLayoutSequential%2A>设置, 并检查属性, 并显示结果。  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md">元数据和自描述组件</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否按引用进行封送。</summary>
        <value>如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的`IsContextful`示例演示了<xref:System.Type>类<xref:System.Type.IsMarshalByRef%2A>的、 <xref:System.Type.IsPrimitive%2A>和属性。 它会检查给定的类型是否可在上下文中承载, 是否可以按引用进行封送处理, 以及该类型是否为基元数据类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsMarshalByRef" /> 属性并确定 <see cref="T:System.Type" /> 是否按引用来进行封送。</summary>
        <returns>如果 <see langword="true" /> 是由引用封送的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可由派生类重写。  
  
   
  
## Examples  
 下面的示例确定给定类型是否按引用进行封送并显示结果。  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示当前 <see cref="T:System.Type" /> 对象是否表示其定义嵌套在另一个类型的定义之内的类型的值。</summary>
        <value>如果 <see langword="true" /> 嵌套在另一个类型内，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性为所有`true`嵌套类型返回, 而不考虑可见性。 <xref:System.Type.IsNested%2A> 若要同时测试嵌套和可见性, 请使用相关的属性<xref:System.Type.IsNestedAssembly%2A> <xref:System.Type.IsNestedFamANDAssem%2A>、 <xref:System.Type.IsNestedPrivate%2A> <xref:System.Type.IsNestedFamily%2A> <xref:System.Type.IsNestedFamORAssem%2A>、、、或<xref:System.Type.IsNestedPublic%2A>。  
  
> [!NOTE]
>  <xref:System.Reflection.TypeAttributes.VisibilityMask>枚举成员选择类型的可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。 然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的程序集内可见。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并且仅在它自己的程序集中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。 然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对同时属于自己家族和自己程序集的类可见。</summary>
        <value>如果 <see cref="T:System.Type" /> 是嵌套的并且只对同时属于它自己的家族和它自己的程序集的类可见，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。  
  
> [!NOTE]
>  C#和 Visual Basic 语言不包括允许您定义嵌套类型的语义, 此嵌套类型仅在其自己的程序集中受保护的类型可见。 `protected internal`Visual Basic 中C#的`Protected Friend`可见性和可见性定义了对受保护类型和同一程序集中的类型可见的嵌套类型。  
  
 对象的系列定义为与其子类型相同<xref:System.Type>的所有对象。 <xref:System.Type>  
  
   
  
## Examples  
 下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。 然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只能在它自己的家族内可见。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并且仅在它自己的家族中可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。  
  
 对象的系列定义为完全相同<xref:System.Type>的所有对象及其子类型。 <xref:System.Type>  
  
   
  
## Examples  
 下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。 然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并且只对属于它自己的家族或属于它自己的程序集的类可见，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `protected internal`如果类型的可见性`Protected Friend`在 Visual Basic 中C# , <xref:System.Type.IsNestedFamORAssem%2A>则属性返回`true`。  
  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。  
  
 对象的系列定义为完全相同<xref:System.Type>的所有对象及其子类型。 <xref:System.Type>  
  
   
  
## Examples  
 下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。 然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否是嵌套的并声明为私有。</summary>
        <value>如果 <see langword="true" /> 是嵌套的并声明为私有，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。 然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示类是否是嵌套的并且声明为公共的。</summary>
        <value>如果类是嵌套的并且声明为公共的，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`false`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个外部类, 其中包含多个具有不同类型的可见性的嵌套类。 然后, 它检索父类型及其每个嵌套类型的<xref:System.Type>多个可见性相关属性的值。  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</summary>
        <value>如果 <see langword="true" /> 未声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要将此属性与嵌套类型一起使用;请改用<xref:System.Type.IsNestedPublic%2A>属性。  
  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性返回`false`。  
  
   
  
## Examples  
 此示例使用`IsNotPublic`属性获取类型的可见性。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 下面的代码示例演示了为何不能`IsPublic`将`IsNotPublic`和用于嵌套类。  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 对于嵌套类, `IsPublic`忽略和`IsNotPublic`的结果, 并`IsNestedPublic`只注意和`IsNestedPrivate`的结果。 此代码片段的反射输出如下所示:  
  
|类|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|包含当前请求的 URL 的|false|true|false|false|  
|B|false|false|true|false|  
|C|false|false|false|true|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为指针。</summary>
        <value>如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例演示`IsPointer`属性的用法。  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsPointer" /> 属性并确定 <see cref="T:System.Type" /> 是否为指针。</summary>
        <returns>如果 <see cref="T:System.Type" /> 是指针，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为基元类型之一。</summary>
        <value>如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基元类型<xref:System.Boolean>为、 <xref:System.Int16> <xref:System.UInt16> 、<xref:System.Int64>、、、 、<xref:System.UInt32>、 、、<xref:System.UInt64>、 、、<xref:System.IntPtr> <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UIntPtr> <xref:System.Char><xref:System.Double>、和<xref:System.Single>。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 下面的`IsContextful`示例演示了<xref:System.Type>类<xref:System.Type.IsMarshalByRef%2A>的、 <xref:System.Type.IsPrimitive%2A>和属性。 它会检查给定的类型是否可在上下文中承载, 是否可以按引用进行封送处理, 以及该类型是否为基元数据类型。  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，实现 <see cref="P:System.Type.IsPrimitive" /> 属性并确定 <see cref="T:System.Type" /> 是否为基元类型之一。</summary>
        <returns>如果 <see langword="true" /> 为基元类型之一，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基元<xref:System.Boolean>类型为<xref:System.Int16> 、<xref:System.Int32> 、、、<xref:System.Single>、、 、、<xref:System.UInt32>、、和。 <xref:System.Int64> <xref:System.UInt64> <xref:System.UInt16> <xref:System.Byte> <xref:System.SByte> <xref:System.Char> <xref:System.Double>  
  
   
  
## Examples  
 下面的示例确定给定的类型是否为基元类型并显示结果。  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为公共类型。</summary>
        <value>如果 <see langword="true" /> 声明为公共类型且不是嵌套类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不要将与嵌套类型一起使用;改<xref:System.Type.IsNestedPublic%2A>为使用。  
  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性返回`true`。  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType>选择可见性特性。  
  
   
  
## Examples  
 下面的示例创建一个实例`MyTestClass`, 检查`IsPublic`属性, 并显示结果。  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 对于嵌套类, `IsPublic`忽略和`IsNotPublic`的结果, 并<xref:System.Type.IsNestedPublic%2A>只注意和<xref:System.Type.IsNestedPrivate%2A>的结果。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Type" /> 是否声明为密封的。</summary>
        <value>如果 <see langword="true" /> 被声明为密封的，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示泛型类型的类型参数, 则此属性始终返回`true`。  
  
   
  
## Examples  
 下面的示例创建`sealed`类的实例, 检查`IsSealed`属性, 并显示结果。  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前的类型在当前信任级别上是安全关键的还是安全可靠关键的，并因此可以执行关键操作。</summary>
        <value>如果当前类型在当前信任级别上是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、和属性<xref:System.Type.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告类型的透明度级别。 <xref:System.Type.IsSecuritySafeCritical%2A> 下表显示了这些属性的组合:  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。 如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。 程序集及其所有类型都被视为透明。 仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。 相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。 您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。  
  
 有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性更改</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</summary>
        <value>如果当前类型在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.IsSecurityCritical%2A>、和属性<xref:System.Type.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告类型的透明度级别。 <xref:System.Type.IsSecuritySafeCritical%2A> 下表显示了这些属性的组合:  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。 如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。 程序集及其所有类型都被视为透明。 仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。 相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。 您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。  
  
 有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性更改</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前类型在当前信任级别上是否是透明的而无法执行关键操作。</summary>
        <value>如果该类型在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果此属性返回`true`, 则<xref:System.Type.IsSecurityCritical%2A>和<xref:System.Type.IsSecuritySafeCritical%2A>属性返回`false`。  
  
 <xref:System.Type.IsSecurityCritical%2A>、和属性<xref:System.Type.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告类型的透明度级别。 <xref:System.Type.IsSecuritySafeCritical%2A> 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
> [!IMPORTANT]
>  对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。 如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。 程序集及其所有类型都被视为透明。 仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。 相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。 您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。  
  
 有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。 有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 中的安全性更改</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为可序列化的。</summary>
        <value>如果 <see cref="T:System.Type" /> 是可序列化的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
在 .NET Standard 中定义的类型未标记<xref:System.SerializableAttribute>为。 相反, 每个 .NET 实现确定类型是否可序列化。 在运行时, 可以使用<xref:System.Type.IsSerializable%2A>属性来确定该实现是否支持对该类型的实例进行序列化。 有关详细信息和示例, 请参阅[如何确定 .NET Standard 对象是否可以序列化](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)。
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
   
  
## Examples  
 `MyTestClass`下面的示例创建类的一个实例, 设置 [Serializable] 特性, 并`IsSerializable`检查`true`或`false`的属性。  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示该类型是否具有需要特殊处理的名称。</summary>
        <value>如果该类型具有需要特殊处理的名称，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以或开头的名称包含下划线字符 (_)、属性访问器和运算符重载方法是可能需要某些编译器特殊处理的类型的示例。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="c">要与当前类型进行比较的类型。</param>
        <summary>确定当前 <see cref="T:System.Type" /> 是否派生自指定的 <see cref="T:System.Type" />。</summary>
        <returns>如果当前 <see langword="true" /> 派生于 <see langword="Type" />，则为 <paramref name="c" />；否则为 <see langword="false" />。 如果 <see langword="false" /> 和当前 <paramref name="c" /> 相等，此方法也返回 <see langword="Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以调用<xref:System.Type.IsSubclassOf%2A>方法来确定以下任何内容:  
  
-   一个类是否派生自另一个类。  
  
-   类型是否派生自<xref:System.ValueType>。 不过, <xref:System.Type.IsValueType%2A>是一种更有效的方法来确定类型是否为值类型。  
  
-   类型是否派生自<xref:System.Enum>。 不过, <xref:System.Type.IsEnum%2A>方法是一种更有效的方法来确定类型是否为枚举。  
  
-   类型是否为委托, 即是否从<xref:System.Delegate>或<xref:System.MulticastDelegate>派生。  
  
 <xref:System.Type.IsSubclassOf%2A>方法不能用于确定接口是派生自另一个接口, 还是类实现接口。 <xref:System.Type.IsAssignableFrom%2A>使用方法实现此目的, 如以下示例所示。  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则它从其类约束派生或从中<xref:System.Object?displayProperty=nameWithType>派生 (如果它没有类约束)。  
  
> [!NOTE]
>  除了与接口一起使用时<xref:System.Type.IsSubclassOf%2A> , 与<xref:System.Type.IsAssignableFrom%2A>相反。 也就是说, 如果`t1.IsSubclassOf(t2)`为`true`, 则`t2.IsAssignableFrom(t1)`也`true`是。  
  
 此方法可由派生类重写。  
  
   
  
## Examples  
 下面的示例创建一个名为`Class1`的类和一个名`DerivedC1`为的派生类。 它调用<xref:System.Type.IsSubclassOf%2A>方法以`DerivedC1`显示是的子类`Class1`。  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> 为 <see langword="null" />。</exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否为 <see langword="UnicodeClass" /> 选择了字符串格式属性 <see cref="T:System.Type" />。</summary>
        <value>如果为 <see langword="true" /> 选择了字符串格式属性 <see langword="UnicodeClass" />，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeAttributes.StringFormatMask>用于选择字符串格式特性。 字符串格式特性通过定义应如何解释字符串来增强互操作性。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回`false`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，通过该值指示 <see cref="T:System.Type" /> 是否为值类型。</summary>
        <value>如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 值类型是表示为位序列的类型;值类型不是类或接口。 在某些编程语言中, 值类型称为 "结构"。 枚举是值类型的一种特殊情况。  
  
 此属性`false` <xref:System.ValueType>为类返回, 因为<xref:System.ValueType>不是值类型本身。 它是所有值类型的基类, 因此可以为其分配任何值类型。 如果<xref:System.ValueType>自身是值类型, 则不可能。 将值类型分配给类型<xref:System.ValueType>的字段时, 这些值类型将装箱。  
  
 此属性为`true`枚举返回, 但不<xref:System.Enum>返回类型本身。 有关演示此行为的示例, 请参见<xref:System.Type.IsEnum%2A>。  
  
 此属性是只读的。  
  
   
  
## Examples  
 下面的示例创建一个类型`MyEnum`为的变量, 检查`IsValueType`属性, 并显示结果。  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>实现 <see cref="P:System.Type.IsValueType" /> 属性并确定 <see cref="T:System.Type" /> 是否是值类型；即，它不是值类或接口。</summary>
        <returns>如果 <see langword="true" /> 是值类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供此方法是为了实现备用类型系统。 它通常不在应用程序代码中使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示 <see cref="T:System.Type" /> 是否可由程序集之外的代码访问的值。</summary>
        <value>如果当前 <see langword="true" /> 是公共类型或公共嵌套类型从而使所有封闭类型都是公共类型，则为 <see cref="T:System.Type" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此属性确定类型是否为组件程序集的公共接口的一部分。  
  
   
  
## Examples  
 下面的代码示例测试两个类, 其中只有一个类在程序集外可见。  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回表示当前类型的数组的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示当前类型的一维数组（下限为零）。</summary>
        <returns>返回一个表示当前类型的一维数组（下限为零）的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法提供了一种方法, 用于生成在运行时计算其元素类型的数组类型。  
  
 **注意**公共语言运行时区分向量 (即, 始终从零开始的一维数组) 和多维数组。 向量 (始终只有一个维度) 不同于只具有一个维度的多维数组。 此方法重载仅可用于创建矢量类型, 并且是创建矢量类型的唯一方法。 <xref:System.Type.MakeArrayType%28System.Int32%29>使用方法重载创建多维数组类型。  
  
   
  
## Examples  
 下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
- 或 - 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank">数组的维数。 此数字必须小于或等于 32。</param>
        <summary>返回 <see cref="T:System.Type" /> 对象，该对象表示一个具有指定维数的当前类型的数组。</summary>
        <returns>表示当前类型的指定维数的数组的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakeArrayType%2A>方法提供了一种方法, 用于生成在运行时计算其元素类型的数组类型。  
  
> [!NOTE]
>  公共语言运行时区分向量 (即, 始终从零开始的一维数组) 和多维数组。 向量 (始终只有一个维度) 不同于只具有一个维度的多维数组。 不能使用此方法重载来创建矢量类型;如果`rank`为 1, 则此方法重载返回有一个维度的多维数组类型。 <xref:System.Type.MakeArrayType>使用方法重载来创建矢量类型。  
  
   
  
## Examples  
 下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> 无效。 例如，0 或负数。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
- 或 - 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。  
  
或 
 <paramref name="rank" /> 大于 32。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</summary>
        <returns>表示作为 <see cref="T:System.Type" /> 参数（在 Visual Basic 中为 <see langword="ref" /> 参数）传递时的当前类型的 <see langword="ByRef" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法提供了一种方法, `ref`用于生成`ByRef`参数列表的类型 (在 Visual Basic 中)。 <xref:System.Type.MakeByRefType%2A>  
  
 如果当前<xref:System.Type>对象表示<xref:System.Int32>, 则使用 Microsoft 中间语言 (MSIL) 的语法, 此方法返回表示`Int32&`的<xref:System.Type>对象。  
  
   
  
## Examples  
 下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
或 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">泛型类型定义。</param>
        <param name="typeArguments">类型参数数组。</param>
        <summary>创建一个泛型签名类型，该类型允许第三方重新实现反射，从而完全支持在查询类型成员时使用签名类型。</summary>
        <returns>泛型签名类型。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">将代替当前泛型类型的类型参数的类型数组。</param>
        <summary>替代由当前泛型类型定义的类型参数组成的类型数组的元素，并返回表示结果构造类型的 <see cref="T:System.Type" /> 对象。</summary>
        <returns><see cref="T:System.Type" /> 表示的构造类型通过以下方式形成：用 <paramref name="typeArguments" /> 的元素取代当前泛型类型的类型参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Type.MakeGenericType%2A>方法, 可以编写将特定类型分配给泛型类型定义的类型参数的代码, 从而<xref:System.Type>创建表示特定构造类型的对象。 您可以使用此<xref:System.Type>对象创建构造类型的运行时实例。  
  
 用<xref:System.Type.MakeGenericType%2A>构造的类型可以是开放的, 也就是说, 它们的某些类型参数可以是封闭泛型方法或类型的类型参数。 发出动态程序集时, 可以使用此类开放式构造类型。 例如, 请考虑以下代码`Base`中`Derived`的类和。  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 若要`Derived`在动态程序集中生成, 需要构造其基类型。 为此, 请使用泛型<xref:System.Type.MakeGenericType%2A>类型参数<xref:System.Int32>和<xref:System.Type>中`V` `Derived`的类型参数`Base`对表示类的对象调用方法。 因为类型和泛型类型参数均由<xref:System.Type>对象表示, 所以, 同时包含这两个参数的数组可传递<xref:System.Type.MakeGenericType%2A>给方法。  
  
> [!NOTE]
>  发出代码时, 构造`Base<int, V>`类型 (如) 非常有用, 但不能对<xref:System.Type.MakeGenericType%2A>此类型调用方法, 因为它不是泛型类型定义。 若要创建可以实例化的封闭式构造类型, 请首先调用<xref:System.Type.GetGenericTypeDefinition%2A>方法<xref:System.Type>获取表示泛型类型定义的对象, 然后使用所需<xref:System.Type.MakeGenericType%2A>的类型参数调用。  
  
 <xref:System.Object.GetType%2A> <xref:System.Object.GetType%2A> <xref:System.Type>返回的对象与通过调用生成的构造类型的方法获得的相同, 或从相同泛型创建的任何构造类型的方法相同。 <xref:System.Type> <xref:System.Type.MakeGenericType%2A>类型定义使用相同的类型参数。  
  
> [!NOTE]
>  泛型类型的数组本身不是泛型类型。 不能对<xref:System.Type.MakeGenericType%2A>数组类型`C<T>[]` (`Dim ac() As C(Of T)`如 Visual Basic) 调用。 若`C<T>[]`要从构造封闭式泛型类型, 请<xref:System.Type.GetElementType%2A>调用以获取泛型类型定义`C<T>`; 对<xref:System.Type.MakeGenericType%2A>泛型类型<xref:System.Type.MakeArrayType%2A>定义调用以创建构造类型; 最后调用方法用于创建数组类型的构造类型。 指针类型和`ref`类型 (`ByRef`在 Visual Basic) 中也是如此。  
  
 有关泛型反射中使用的术语的固定条件列表，请参阅 <xref:System.Type.IsGenericType%2A> 属性注解。  
  
## <a name="nested-types"></a>嵌套类型  
 如果使用C#、 C++或 Visual Basic 定义泛型类型, 则其嵌套类型都是泛型类型。 即使嵌套类型没有自己的类型参数, 也是如此, 因为所有这三种语言都包括嵌套类型的类型参数列表中的封闭类型的类型参数。 请考虑以下类:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 嵌套类`Inner`的类型参数列表具有两个类型参数`U`, `T`第一个参数是其封闭类的类型参数。 同样, 嵌套类`Innermost1`的类型参数列表具有三个类型参数`U`: `T`、和`V`, `T` `U`它们来自其封闭类。 嵌套类`Innermost2`有两个类型参数: `T`和`U`, 它们来自其封闭类。  
  
 如果封闭类型的参数列表具有多个类型参数, 则按顺序列出的所有类型参数都包含在嵌套类型的类型参数列表中。  
  
 若要从嵌套类型的泛型类型定义构造泛型类型, 请通过连接<xref:System.Type.MakeGenericType%2A>所有封闭类型的类型参数数组 (从最外面的泛型类型开始, 以嵌套类型本身的类型参数数组 (如果它具有其自己的类型参数)。 若要创建的`Innermost1`实例, 请使用包含三种类型的数组<xref:System.Type.MakeGenericType%2A>调用方法, 将其分配给 T、U 和 V。若要创建的`Innermost2`实例, 请使用包含两个类型的数组<xref:System.Type.MakeGenericType%2A>调用方法, 将其分配给 T 和 U。  
  
 语言以这种方式传播封闭类型的类型参数, 因此可以使用封闭类型的类型参数来定义嵌套类型的字段。 否则, 类型参数将不会位于嵌套类型体内的范围内。 通过在动态程序集中发出代码或使用[Ilasm (IL 汇编程序)](~/docs/framework/tools/ilasm-exe-il-assembler.md), 可以定义嵌套类型而无需传播封闭类型的类型参数。 对于 MSIL 组装器, 请考虑以下代码:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 在此示例中, 不能在类`T` `Innermost`中定义类型为或`U`的字段, 因为这些类型参数不在范围内。 以下汇编程序代码定义了嵌套类, 它们的行为方式与它们在、 C++Visual Basic 和C#中定义的方式相同:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 可以使用[Ildasm (IL 拆装器)](~/docs/framework/tools/ildasm-exe-il-disassembler.md)检查在高级语言中定义的嵌套类, 并观察此命名方案。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.MakeGenericType%2A>方法从<xref:System.Collections.Generic.Dictionary%602>类型的泛型类型定义中创建构造类型。 构造类型表示<xref:System.Collections.Generic.Dictionary%602>具有字符串键`Test`的对象的。  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前的类型不表示泛型类型定义。 也就是说，<see cref="P:System.Type.IsGenericTypeDefinition" /> 返回 <see langword="false" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> 为 <see langword="null" />。  
  
或 
<paramref name="typeArguments" /> 的任意元素为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeArguments" /> 中的元素数与当前泛型类型定义中的类型参数数不同。  
  
- 或 - 
<paramref name="typeArguments" /> 的所有元素都不满足为当前泛型类型的相应类型参数指定的约束。  
  
或 
 <paramref name="typeArguments" /> 包含一个元素，该元素是一个指针类型（<see cref="P:System.Type.IsPointer" /> 返回 <see langword="true" />）、by-ref 类型（<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />）或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。 派生类必须提供一个实现。</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md">反射类型和泛型类型</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md">如何：使用反射检查和实例化泛型类型</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示指向当前类型的指针的 <see cref="T:System.Type" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.MakePointerType%2A>方法提供了一种方法来生成参数列表的指针类型。  
  
 如果当前<xref:System.Type>对象表示<xref:System.Int32>, 则使用 Microsoft 中间语言 (MSIL) 的语法, 此方法返回表示`Int32*`的<xref:System.Type>对象。  
  
   
  
## Examples  
 下面的代码示例创建数组`ref` `ByRef` (在 Visual Basic 中) `Test`和类的指针类型。  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <exception cref="T:System.TypeLoadException">当前的类型是 <see cref="T:System.TypedReference" />。  
  
- 或 - 
当前的类型是 <see langword="ByRef" /> 类型。 也就是说，<see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" />。</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个指示此成员是类型还是嵌套类型的 <see cref="T:System.Reflection.MemberTypes" /> 值。</summary>
        <value>一个 <see cref="T:System.Reflection.MemberTypes" /> 值，指示此成员是类型还是嵌套类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性将<xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>重写。 因此, 在检查一<xref:System.Reflection.MemberInfo>组对象 (例如, <xref:System.Type.GetMembers%2A>返回<xref:System.Reflection.MemberInfo.MemberType%2A>的数组) 时, 当给定成员是嵌套<xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType>类型时, 属性将返回。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性应用于构造该类型的泛型类型定义。 例如, 如果<xref:System.Type>当前表示`MyGenericType<int>` (`MyGenericType(Of Integer)`在 Visual Basic 中), 则此属性的值由确定`MyGenericType<T>`。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性始终返回<xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例将该`MemberType`字段显示为`GetMember`方法的参数:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示 <see cref="T:System.Type" /> 信息中的缺少值。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Missing`使用字段通过反射调用以获取参数的默认值。 如果为参数值传入了<xref:System.ArgumentException> 字段,并且该参数没有默认值,则会引发。`Missing`  
  
   
  
## Examples  
 下面的代码示例演示如何使用`Missing`字段来调用方法及其默认参数。  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 此代码生成以下输出：  
  
 a = 10 b = 55.3 c = 12  
  
 a = 10 b = 1.3 c = 1  
  
 a = 10 b = 1.2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在其中定义当前 <see cref="T:System.Type" /> 的模块 (DLL)。</summary>
        <value>在其中定义当前 <see cref="T:System.Type" /> 的模块。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性返回定义了泛型类型定义的模块。 例如, 如果您创建了一个实例`MyGenericStack<int>`, 则构造的类型的属性将<xref:System.Type.Module%2A> `MyGenericStack<T>`返回定义的模块。  
  
 同样, 如果当前<xref:System.Type>表示泛型参数`T`, 则此属性返回包含定义`T`的泛型类型的程序集。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.Type.Namespace%2A>使用和`Module` <xref:System.Type>属性以及<xref:System.Type.ToString%2A>的方法。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中覆盖时，获取当前类型的名称。</summary>
        <value>当前类型的名称。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Type" /> 的命名空间。</summary>
        <value><see cref="T:System.Type" /> 的命名空间；如果当前实例没有命名空间或表示泛型参数，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 命名空间是逻辑设计时命名方便, 主要用于在应用程序中定义作用域, 并在单个层次结构中组织类和其他类型。 从运行时的角度来看, 没有任何命名空间。  
  
 如果当前<xref:System.Type>表示构造泛型类型, 则此属性返回包含泛型类型定义的命名空间。 同样, 如果当前<xref:System.Type>表示泛型参数`T`, 则此属性返回包含定义`T`的泛型类型定义的命名空间。  
  
 如果当前<xref:System.Type>对象表示泛型参数, 则此属性返回`null`。  
  
   
  
## Examples  
 下面的示例演示如何`Namespace`使用和<xref:System.Type.Module%2A> <xref:System.Type>属性以及<xref:System.Type.ToString%2A>的方法。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个对象。</param>
        <param name="right">要比较的第二个对象。</param>
        <summary>指示两个 <see cref="T:System.Type" /> 对象是否相等。</summary>
        <returns>如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">要比较的第一个对象。</param>
        <param name="right">要比较的第二个对象。</param>
        <summary>指示两个 <see cref="T:System.Type" /> 对象是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于获取该成员的类对象。</summary>
        <value><see langword="Type" /> 对象，通过它获取了此 <see cref="T:System.Type" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于<xref:System.Type>对象, 此属性的值始终与<xref:System.Type.DeclaringType%2A>属性的值相同。  
  
   
  
## Examples  
 此示例显示嵌套类的反射类型。  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要获取的 <see cref="T:System.Type" /> 的程序集限定名称。</param>
        <param name="throwIfNotFound">如果为 <see langword="true" />，则会在找不到该类型时引发 <see cref="T:System.TypeLoadException" />；如果为 <see langword="false" />，则在找不到该类型时返回 <see langword="null" />。 指定 <see langword="false" /> 还会取消某些其他异常条件，但并不取消所有条件。 请参见“异常”部分。</param>
        <param name="ignoreCase">如果为 <see langword="true" />，则执行不区分大小写的 <paramref name="typeName" /> 搜索；如果为 <see langword="false" />，则执行区分大小写的 <paramref name="typeName" /> 搜索。</param>
        <summary>获取具有指定名称的 <see cref="T:System.Type" />，指定是否执行区分大小写的搜索，以及在找不到类型时是否引发异常。 该类型只为反射加载，而不为执行加载。</summary>
        <returns>具有指定名称的类型（如果找到的话）；否则为 <see langword="null" />。 如果找不到该类型，则 <paramref name="throwIfNotFound" /> 参数指定是返回 <see langword="null" /> 还是引发异常。 在某些情况下，将引发异常，而不考虑 <paramref name="throwIfNotFound" /> 的值。 请参见“异常”部分。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果包含该类型的程序集尚未加载到仅反射上下文中, 则使用<xref:System.Type.ReflectionOnlyGetType%2A>方法等效于首先加载仅用于反射的程序集, 然后<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>使用方法, 然后通过调用程序集<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>的方法。 有关程序集限定名称的信息, 请参见<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>属性。 有关指定类型名称的更多详细信息, <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>请参阅方法重载。  
  
 如果程序集已加载以便执行, 则将另一个副本加载到仅反射上下文中。  
  
 `throwIfNotFound`参数指定当找不到该类型时所发生的情况, 还会取消某些其他异常条件, 如 "异常" 一节中所述。 引发一些异常, 而不考虑的值`throwIfNotFound`。 例如, 如果程序集无效, <xref:System.BadImageFormatException> `throwIfNotFound`即使为`false`, 也会引发。  
  
 有关使用仅反射上下文的详细信息, 请参阅[如何:将程序集加载到仅反射上下文中](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">调用了类初始值设定项，且该项引发了异常。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> 是 <see langword="true" />，且找不到该类型。  
  
或 
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效字符，例如嵌入的制表符。 
- 或 - 
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 为空字符串。  
  
或 
 <paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且 <paramref name="typeName" /> 表示大小无效的数组类型。  
  
或 
 <paramref name="typeName" /> 表示 <see cref="T:System.TypedReference" /> 对象数组。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> 不包括程序集名称。  
  
- 或 - 
 <paramref name="throwIfNotFound" /> 为 <see langword="true" />，且 <paramref name="typeName" /> 包含无效的语法（例如 "MyType[,*,]"）。  
  
或 
 <paramref name="typeName" /> 表示将指针类型、<see langword="ByRef" /> 类型或 <see cref="T:System.Void" /> 作为其类型参数之一的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示具有错误的类型参数数目的泛型类型。  
  
或 
 <paramref name="typeName" /> 表示泛型类型，并且其类型参数之一不满足相应类型参数的约束。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> 的值为 <see langword="true" />，且未找到程序集或程序集的某个依赖项。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了程序集或其依赖项之一，但无法加载它们。</exception>
        <exception cref="T:System.BadImageFormatException">程序集或其依赖项之一无效。  
  
 或  
  
 此程序集使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md">如何：将程序集加载到仅反射上下文中</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个描述当前类型的布局的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</summary>
        <value>获取一个描述当前类型的大致布局特性的 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute><xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法未返回。 而是使用此属性获取它。  
  
   
  
## Examples  
 下面的代码示例首先使用特殊的布局特性 (结构嵌套在类中) 来定义类、结构和结构。 然后, 该示例使用<xref:System.Type.StructLayoutAttribute%2A>属性<xref:System.Runtime.InteropServices.StructLayoutAttribute>获取每个类型的, 并显示特性的属性。  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">基类不支持调用的方法。</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="rgszNames">要映射的名称的传入数组。</param>
        <param name="cNames">要映射的名称的计数。</param>
        <param name="lcid">要在其中解释名称的区域设置上下文。</param>
        <param name="rgDispId">调用方分配的数组，用于接收与名称对应的 ID。</param>
        <summary>将一组名称映射为对应的一组调度标识符。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类, 不应从托管代码调用。 有关`IDispatch::GetIDsOfNames`的详细信息, 请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">要返回的类型信息。</param>
        <param name="lcid">类型信息的区域设置标识符。</param>
        <param name="ppTInfo">指向请求的类型信息对象的指针。</param>
        <summary>检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类, 不应从托管代码调用。 有关`IDispatch::GetTypeInfo`的详细信息, 请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">指向一个位置，该位置接收对象提供的类型信息接口的数量。</param>
        <summary>检索对象提供的类型信息接口的数量（0 或 1）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类, 不应从托管代码调用。 有关`IDispatch::GetTypeInfoCount`的详细信息, 请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">标识成员。</param>
        <param name="riid">留待将来使用。 必须为 IID_NULL。</param>
        <param name="lcid">要在其中解释自变量的区域设置上下文。</param>
        <param name="wFlags">描述调用的上下文的标志。</param>
        <param name="pDispParams">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</param>
        <param name="pVarResult">指向要存储结果的位置的指针。</param>
        <param name="pExcepInfo">指向一个包含异常信息的结构的指针。</param>
        <param name="puArgErr">第一个出错参数的索引。</param>
        <summary>提供对某一对象公开的属性和方法的访问。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于从非托管代码访问托管类, 不应从托管代码调用。 有关`IDispatch::Invoke`的详细信息, 请参阅 MSDN library。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前 <see langword="String" /> 的名称的 <see langword="Type" />。</summary>
        <returns>表示当前 <see cref="T:System.String" /> 的名称的 <see cref="T:System.Type" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法为所有基元类型返回完全限定的公共语言运行时命名空间和名称。 例如, C#指令`(long)0.Type().ToString()`返回 "system.string" 而不只是 "Int64"。  
  
 如果当前<xref:System.Type>表示泛型类型, 则类型及其类型参数由命名空间和嵌套类型限定, 而不是由程序集限定。 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此方法返回类型参数的非限定名称。  
  
   
  
## Examples  
 下面的示例演示如何<xref:System.Type.Namespace%2A>使用和<xref:System.Type.Module%2A> <xref:System.Type>属性以及`ToString`的方法。  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 下面的示例<xref:System.Type.ToString%2A>将方法返回的字符串`Name`与、 <xref:System.Type.FullName%2A>和<xref:System.Type.AssemblyQualifiedName%2A>属性进行比较。  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Type" /> 的句柄。</summary>
        <value>当前 <see cref="T:System.Type" /> 的句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle`封装指向表示类型的内部数据结构的指针。 此句柄在进程生存期内是唯一的。 该句柄仅在获取该句柄的应用程序域中有效。  
  
   
  
## Examples  
 下面的示例返回相应类型的句柄, 并将该句柄传递给一个方法, 该方法从句柄获取类型并显示该类型。  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">.NET Compact Framework 当前不支持此属性。</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取该类型的初始值设定项。</summary>
        <value>包含 <see cref="T:System.Type" /> 的类构造函数的名称的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type.FindMembers%2A>还可以通过方法或使用<xref:System.Reflection.BindingFlags>作为参数的、 <xref:System.Type.GetMembers%2A>、 <xref:System.Type.GetConstructor%2A>和<xref:System.Type.GetConstructors%2A>方法的<xref:System.Type.GetMember%2A>重载来使用类初始值设定项。  
  
 如果当前<xref:System.Type>表示泛型类型或泛型方法的定义中的类型参数, 则此属性返回`null`。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示表示该类型的公共语言运行时提供的类型。</summary>
        <value><see cref="T:System.Type" /> 的基础系统类型。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>