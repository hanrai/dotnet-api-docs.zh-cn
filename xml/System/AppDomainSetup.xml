<Type Name="AppDomainSetup" FullName="System.AppDomainSetup">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aaabb3e2c80a8f502ecaefbb58d9f4d492be7c81" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69421669" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomainSetup : IAppDomainSetup" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit AppDomainSetup extends System.Object implements class System.IAppDomainSetup" />
  <TypeSignature Language="DocId" Value="T:System.AppDomainSetup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomainSetup&#xA;Implements IAppDomainSetup" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomainSetup sealed : IAppDomainSetup" />
  <TypeSignature Language="F#" Value="type AppDomainSetup = class&#xA;    interface IAppDomainSetup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAppDomainSetup</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="95bd8-101">表示可以添加到 <see cref="T:System.AppDomain" /> 的实例的程序集绑定信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-101">Represents assembly binding information that can be added to an instance of <see cref="T:System.AppDomain" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-102">更改<xref:System.AppDomainSetup>实例的属性不会影响任何现有<xref:System.AppDomain>的。</span><span class="sxs-lookup"><span data-stu-id="95bd8-102">Changing the properties of an <xref:System.AppDomainSetup> instance does not affect any existing <xref:System.AppDomain>.</span></span> <span data-ttu-id="95bd8-103">当使用<xref:System.AppDomain> <xref:System.AppDomainSetup>实例作为参数调用方法时,它只会影响新创建的。<xref:System.AppDomain.CreateDomain%2A></span><span class="sxs-lookup"><span data-stu-id="95bd8-103">It can affect only the creation of a new <xref:System.AppDomain>, when the <xref:System.AppDomain.CreateDomain%2A> method is called with the <xref:System.AppDomainSetup> instance as a parameter.</span></span>  
  
 <span data-ttu-id="95bd8-104">此类实现 <xref:System.IAppDomainSetup> 接口。</span><span class="sxs-lookup"><span data-stu-id="95bd8-104">This class implements the <xref:System.IAppDomainSetup> interface.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="95bd8-105"><xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性的默认值为 false。</span><span class="sxs-lookup"><span data-stu-id="95bd8-105">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A> property is false.</span></span> <span data-ttu-id="95bd8-106">对于服务, 此设置是不安全的。</span><span class="sxs-lookup"><span data-stu-id="95bd8-106">This setting is unsafe for services.</span></span> <span data-ttu-id="95bd8-107">若要帮助防止服务下载部分受信任的代码, 请将此属性设置为 true</span><span class="sxs-lookup"><span data-stu-id="95bd8-107">To help prevent services from downloading partially trusted code, set this property to true</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482"><span data-ttu-id="95bd8-108">如何：配置应用程序域</span><span class="sxs-lookup"><span data-stu-id="95bd8-108">How To: Configure an Application Domain</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="95bd8-109">初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="95bd8-109">Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bd8-110">初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="95bd8-110">Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : ActivationContext -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationContext" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationContext"><span data-ttu-id="95bd8-111">要用于应用程序域的激活上下文。</span><span class="sxs-lookup"><span data-stu-id="95bd8-111">The activation context to be used for an application domain.</span></span></param>
        <summary><span data-ttu-id="95bd8-112">使用指定的激活上下文（用于基于清单的应用程序域激活）初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="95bd8-112">Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class with the specified activation context to use for manifest-based activation of an application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-113">为<xref:System.ActivationContext>指定的`activationContext`对象用于生成一个<xref:System.Runtime.Hosting.ActivationArguments>对象, 该对象包含激活新应用程序域所需的信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-113">The <xref:System.ActivationContext> object specified for `activationContext` is used to generate an <xref:System.Runtime.Hosting.ActivationArguments> object containing information required to activate a new application domain.</span></span> <span data-ttu-id="95bd8-114">可以<xref:System.Runtime.Hosting.ActivationArguments> 通过<xref:System.AppDomainSetup.ActivationArguments%2A>使用属性访问此对象。</span><span class="sxs-lookup"><span data-stu-id="95bd8-114">This <xref:System.Runtime.Hosting.ActivationArguments> object can be accessed by using the <xref:System.AppDomainSetup.ActivationArguments%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bd8-115"><paramref name="activationContext" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-115"><paramref name="activationContext" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ActivationArguments" />
        <altmember cref="T:System.Runtime.Hosting.ActivationArguments" />
        <altmember cref="T:System.ActivationContext" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AppDomainSetup (System.Runtime.Hosting.ActivationArguments activationArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Hosting.ActivationArguments activationArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.#ctor(System.Runtime.Hosting.ActivationArguments)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; AppDomainSetup(System::Runtime::Hosting::ActivationArguments ^ activationArguments);" />
      <MemberSignature Language="F#" Value="new AppDomainSetup : System.Runtime.Hosting.ActivationArguments -&gt; AppDomainSetup" Usage="new System.AppDomainSetup activationArguments" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="activationArguments" Type="System.Runtime.Hosting.ActivationArguments" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="activationArguments"><span data-ttu-id="95bd8-116">一个对象，指定以基于清单的方式激活新的应用程序域所需的信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-116">An object that specifies information required for the manifest-based activation of a new application domain.</span></span></param>
        <summary><span data-ttu-id="95bd8-117">使用基于清单的应用程序域激活所需的指定激活参数初始化 <see cref="T:System.AppDomainSetup" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="95bd8-117">Initializes a new instance of the <see cref="T:System.AppDomainSetup" /> class with the specified activation arguments required for manifest-based activation of an application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-118">为指定的`activationArguments`对象可以<xref:System.AppDomainSetup.ActivationArguments%2A>使用属性访问。</span><span class="sxs-lookup"><span data-stu-id="95bd8-118">The object specified for `activationArguments` can be accessed by using the <xref:System.AppDomainSetup.ActivationArguments%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bd8-119"><paramref name="activationArguments" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-119"><paramref name="activationArguments" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ActivationArguments">
      <MemberSignature Language="C#" Value="public System.Runtime.Hosting.ActivationArguments ActivationArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.Hosting.ActivationArguments ActivationArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ActivationArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property ActivationArguments As ActivationArguments" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::Hosting::ActivationArguments ^ ActivationArguments { System::Runtime::Hosting::ActivationArguments ^ get(); void set(System::Runtime::Hosting::ActivationArguments ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ActivationArguments : System.Runtime.Hosting.ActivationArguments with get, set" Usage="System.AppDomainSetup.ActivationArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Hosting.ActivationArguments</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-120">获取或设置与应用程序域的激活有关的数据。</span><span class="sxs-lookup"><span data-stu-id="95bd8-120">Gets or sets data about the activation of an application domain.</span></span></summary>
        <value><span data-ttu-id="95bd8-121">一个对象，其中包含与应用程序域的激活有关的数据。</span><span class="sxs-lookup"><span data-stu-id="95bd8-121">An object that contains data about the activation of an application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-122">如果将此属性设置为`null`, 则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="95bd8-122">No exception is thrown if this property is set to `null`.</span></span>  
  
 <span data-ttu-id="95bd8-123"><xref:System.Runtime.Hosting.ActivationArguments>对象提供的信息支持基于清单的激活。</span><span class="sxs-lookup"><span data-stu-id="95bd8-123">The information provided by the <xref:System.Runtime.Hosting.ActivationArguments> object supports manifest-based activation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95bd8-124">属性设置为 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 对象，该对象的应用程序标识不匹配 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 属性返回的 <see cref="T:System.Security.Policy.ApplicationTrust" /> 对象的应用程序标识。</span><span class="sxs-lookup"><span data-stu-id="95bd8-124">The property is set to an <see cref="T:System.Runtime.Hosting.ActivationArguments" /> object whose application identity does not match the application identity of the <see cref="T:System.Security.Policy.ApplicationTrust" /> object returned by the <see cref="P:System.AppDomainSetup.ApplicationTrust" /> property.</span></span> <span data-ttu-id="95bd8-125">如果 <see cref="P:System.AppDomainSetup.ApplicationTrust" /> 属性为 <see langword="null" />，则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="95bd8-125">No exception is thrown if the <see cref="P:System.AppDomainSetup.ApplicationTrust" /> property is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializer">
      <MemberSignature Language="C#" Value="public AppDomainInitializer AppDomainInitializer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainInitializer AppDomainInitializer" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializer" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializer As AppDomainInitializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainInitializer ^ AppDomainInitializer { AppDomainInitializer ^ get(); void set(AppDomainInitializer ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializer : AppDomainInitializer with get, set" Usage="System.AppDomainSetup.AppDomainInitializer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainInitializer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-126">获取或设置 <see cref="T:System.AppDomainInitializer" /> 委托，该委托表示在初始化应用程序域时调用的回调方法。</span><span class="sxs-lookup"><span data-stu-id="95bd8-126">Gets or sets the <see cref="T:System.AppDomainInitializer" /> delegate, which represents a callback method that is invoked when the application domain is initialized.</span></span></summary>
        <value><span data-ttu-id="95bd8-127">一个委托，表示在初始化应用程序域时调用的回调方法。</span><span class="sxs-lookup"><span data-stu-id="95bd8-127">A delegate that represents a callback method that is invoked when the application domain is initialized.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-128">若要将信息传递给回调方法, 请将字符串数组分配给<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-128">To pass information to the callback method, assign an array of strings to the <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> property.</span></span> <span data-ttu-id="95bd8-129">每次<xref:System.AppDomain>初始化时, 都会将数组传递给回调方法。</span><span class="sxs-lookup"><span data-stu-id="95bd8-129">The array is passed to the callback method each time an <xref:System.AppDomain> is initialized.</span></span>  
  
 <span data-ttu-id="95bd8-130">回调方法在新创建的应用程序域的上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="95bd8-130">The callback method is executed in the context of the newly created application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bd8-131">下面的示例<xref:System.AppDomainSetup>使用对象和默认应用程序`ChildDomain`域中的证据创建名为的子应用程序域。</span><span class="sxs-lookup"><span data-stu-id="95bd8-131">The following example creates a child application domain named `ChildDomain`, using an <xref:System.AppDomainSetup> object and evidence from the default application domain.</span></span> <span data-ttu-id="95bd8-132">属性设置为回调方法, 该方法`AppDomainInit`是在初始化子域时调用的。 <xref:System.AppDomainSetup.AppDomainInitializer%2A></span><span class="sxs-lookup"><span data-stu-id="95bd8-132">The <xref:System.AppDomainSetup.AppDomainInitializer%2A> property is set to the callback method `AppDomainInit`, which is invoked when the child domain is initialized.</span></span> <span data-ttu-id="95bd8-133">回调方法的参数放置在分配给<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性的字符串数组中。</span><span class="sxs-lookup"><span data-stu-id="95bd8-133">The arguments for the callback method are placed in an array of strings, which is assigned to the <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> property.</span></span> <span data-ttu-id="95bd8-134">创建子域时, 回调方法只是打印字符串。</span><span class="sxs-lookup"><span data-stu-id="95bd8-134">When the child domain is created, the callback method simply prints the strings.</span></span>  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainInitializerArguments">
      <MemberSignature Language="C#" Value="public string[] AppDomainInitializerArguments { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] AppDomainInitializerArguments" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainInitializerArguments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ AppDomainInitializerArguments { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainInitializerArguments : string[] with get, set" Usage="System.AppDomainSetup.AppDomainInitializerArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-135">获取或设置传给 <see cref="T:System.AppDomainInitializer" /> 委托所表示的回调方法的参数。</span><span class="sxs-lookup"><span data-stu-id="95bd8-135">Gets or sets the arguments passed to the callback method represented by the <see cref="T:System.AppDomainInitializer" /> delegate.</span></span> <span data-ttu-id="95bd8-136">在初始化应用程序域时将调用该回调方法。</span><span class="sxs-lookup"><span data-stu-id="95bd8-136">The callback method is invoked when the application domain is initialized.</span></span></summary>
        <value><span data-ttu-id="95bd8-137">一个字符串数组，当在 <see cref="T:System.AppDomainInitializer" /> 初始化过程中调用 <see cref="T:System.AppDomain" /> 委托所表示的回调方法时，该字符串数组将被传给该回调方法。</span><span class="sxs-lookup"><span data-stu-id="95bd8-137">An array of strings that is passed to the callback method represented by the <see cref="T:System.AppDomainInitializer" /> delegate, when the callback method is invoked during <see cref="T:System.AppDomain" /> initialization.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-138">使用属性指定在初始化过程中<xref:System.AppDomain>调用的回调方法。 <xref:System.AppDomainSetup.AppDomainInitializer%2A></span><span class="sxs-lookup"><span data-stu-id="95bd8-138">Use the <xref:System.AppDomainSetup.AppDomainInitializer%2A> property to specify a callback method that is invoked during <xref:System.AppDomain> initialization.</span></span> <span data-ttu-id="95bd8-139">如果未<xref:System.AppDomainSetup.AppDomainInitializer%2A>设置该属性, 则不使用分配给此属性的数组。</span><span class="sxs-lookup"><span data-stu-id="95bd8-139">If the <xref:System.AppDomainSetup.AppDomainInitializer%2A> property is not set, the array assigned to this property is not used.</span></span>  
  
 <span data-ttu-id="95bd8-140">回调方法在新创建的应用程序域的上下文中执行。</span><span class="sxs-lookup"><span data-stu-id="95bd8-140">The callback method is executed in the context of the newly created application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bd8-141">下面的代码示例`ChildDomain` <xref:System.AppDomainSetup>使用对象和默认应用程序域中的证据创建名为的子应用程序域。</span><span class="sxs-lookup"><span data-stu-id="95bd8-141">The following code example creates a child application domain named `ChildDomain`, using an <xref:System.AppDomainSetup> object and evidence from the default application domain.</span></span> <span data-ttu-id="95bd8-142">属性设置为回调方法, 该方法`AppDomainInit`是在初始化子域时调用的。 <xref:System.AppDomainSetup.AppDomainInitializer%2A></span><span class="sxs-lookup"><span data-stu-id="95bd8-142">The <xref:System.AppDomainSetup.AppDomainInitializer%2A> property is set to the callback method `AppDomainInit`, which is invoked when the child domain is initialized.</span></span> <span data-ttu-id="95bd8-143">回调方法的参数放置在分配给<xref:System.AppDomainSetup.AppDomainInitializerArguments%2A>属性的字符串数组中。</span><span class="sxs-lookup"><span data-stu-id="95bd8-143">The arguments for the callback method are placed in an array of strings, which is assigned to the <xref:System.AppDomainSetup.AppDomainInitializerArguments%2A> property.</span></span> <span data-ttu-id="95bd8-144">创建子域时, 回调方法只是打印字符串。</span><span class="sxs-lookup"><span data-stu-id="95bd8-144">When the child domain is created, the callback method simply prints the strings.</span></span>  
  
 [!code-cpp[AppDomainInitializer#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainInitializer/cpp/source.cpp#1)]
 [!code-csharp[AppDomainInitializer#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainInitializer/CS/source.cs#1)]
 [!code-vb[AppDomainInitializer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainInitializer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.AppDomainInitializer" />
        <altmember cref="P:System.AppDomainSetup.AppDomainInitializer" />
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerAssembly">
      <MemberSignature Language="C#" Value="public string AppDomainManagerAssembly { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerAssembly" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerAssembly As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerAssembly { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerAssembly : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-145">获取或设置程序集的显示名称，该程序集为使用 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域提供应用程序域管理器的类型。</span><span class="sxs-lookup"><span data-stu-id="95bd8-145">Gets or sets the display name of the assembly that provides the type of the application domain manager for application domains created using this <see cref="T:System.AppDomainSetup" /> object.</span></span></summary>
        <value><span data-ttu-id="95bd8-146">程序集的显示名称，该程序集提供应用程序域管理器的 <see cref="T:System.Type" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-146">The display name of the assembly that provides the <see cref="T:System.Type" /> of the application domain manager.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-147">若要指定应用程序域管理器的类型, 请同时设置此属性<xref:System.AppDomainSetup.AppDomainManagerType%2A>和属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-147">To specify the type of the application domain manager, set both this property and the <xref:System.AppDomainSetup.AppDomainManagerType%2A> property.</span></span> <span data-ttu-id="95bd8-148">如果未设置这些属性中的任何一个, 则将忽略另一个属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-148">If either of these properties is not set, the other is ignored.</span></span>  
  
 <span data-ttu-id="95bd8-149">如果未提供任何类型, 则将从与父应用程序域相同的类型 (即, 从中调用该<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法的应用程序域) 创建应用程序域管理器。</span><span class="sxs-lookup"><span data-stu-id="95bd8-149">If no type is provided, the application domain manager is created from the same type as the parent application domain (that is, the application domain from which the <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> method is called).</span></span>  
  
 <span data-ttu-id="95bd8-150">当加载应用程序域时, <xref:System.TypeLoadException>如果程序集不存在, 或者如果程序集不包含<xref:System.AppDomainSetup.AppDomainManagerType%2A>由属性指定的类型, 则会引发。</span><span class="sxs-lookup"><span data-stu-id="95bd8-150">When the application domain is loaded, <xref:System.TypeLoadException> is thrown if the assembly does not exist, or if the assembly does not contain the type specified by the <xref:System.AppDomainSetup.AppDomainManagerType%2A> property.</span></span> <span data-ttu-id="95bd8-151"><xref:System.IO.FileLoadException>如果找到程序集, 但版本信息不匹配, 则会引发。</span><span class="sxs-lookup"><span data-stu-id="95bd8-151"><xref:System.IO.FileLoadException> is thrown if the assembly is found but the version information does not match.</span></span>  
  
 <span data-ttu-id="95bd8-152">若要设置默认应用程序域的应用程序域管理器, 请使用 " [ \<运行时 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) " 部分中的[ \<b l y >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<y p e >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)元素在应用程序配置文件中, 或使用中<xref:System.AppDomainManager>所述的环境变量。</span><span class="sxs-lookup"><span data-stu-id="95bd8-152">To set the application domain manager for the default application domain, use the [\<appDomainManagerAssembly>](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) and [\<appDomainManagerType>](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elements in the [\<runtime>](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) section of the application configuration file, or use the environment variables described in <xref:System.AppDomainManager>.</span></span>  
  
 <span data-ttu-id="95bd8-153">此功能要求应用程序具有完全信任。</span><span class="sxs-lookup"><span data-stu-id="95bd8-153">This feature requires the application to have full trust.</span></span> <span data-ttu-id="95bd8-154">(例如, 在桌面上运行的应用程序具有完全信任。)如果应用程序不具有完全信任, <xref:System.TypeLoadException>则会引发。</span><span class="sxs-lookup"><span data-stu-id="95bd8-154">(For example, an application running on the desktop has full trust.) If the application does not have full trust, a <xref:System.TypeLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="95bd8-155">程序集显示名称的格式由<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>属性提供。</span><span class="sxs-lookup"><span data-stu-id="95bd8-155">The format of the assembly display name is given by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppDomainManagerType">
      <MemberSignature Language="C#" Value="public string AppDomainManagerType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppDomainManagerType" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.AppDomainManagerType" />
      <MemberSignature Language="VB.NET" Value="Public Property AppDomainManagerType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AppDomainManagerType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AppDomainManagerType : string with get, set" Usage="System.AppDomainSetup.AppDomainManagerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-156">获取或设置类型的全名，该类型可为使用此 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域提供应用程序域管理器。</span><span class="sxs-lookup"><span data-stu-id="95bd8-156">Gets or sets the full name of the type that provides the application domain manager for application domains created using this <see cref="T:System.AppDomainSetup" /> object.</span></span></summary>
        <value><span data-ttu-id="95bd8-157">类型的全名，其中包括命名空间。</span><span class="sxs-lookup"><span data-stu-id="95bd8-157">The full name of the type, including the namespace.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-158">若要指定应用程序域管理器的类型, 请同时设置此属性<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>和属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-158">To specify the type of the application domain manager, set both this property and the <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> property.</span></span> <span data-ttu-id="95bd8-159">如果未设置这些属性中的任何一个, 则将忽略另一个属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-159">If either of these properties is not set, the other is ignored.</span></span>  
  
 <span data-ttu-id="95bd8-160">如果未提供任何类型, 则将从与父应用程序域相同的类型 (即, 从中调用该<xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType>方法的应用程序域) 创建应用程序域管理器。</span><span class="sxs-lookup"><span data-stu-id="95bd8-160">If no type is provided, the application domain manager is created from the same type as the parent application domain (that is, the application domain from which the <xref:System.AppDomain.CreateDomain%2A?displayProperty=nameWithType> method is called).</span></span>  
  
 <span data-ttu-id="95bd8-161">当加载应用程序域时, <xref:System.TypeLoadException>如果<xref:System.AppDomainSetup.AppDomainManagerAssembly%2A>属性指定的程序集不包含此属性指定的类型, 则会引发。</span><span class="sxs-lookup"><span data-stu-id="95bd8-161">When the application domain is loaded, <xref:System.TypeLoadException> is thrown if the assembly specified by the <xref:System.AppDomainSetup.AppDomainManagerAssembly%2A> property does not contain the type specified by this property.</span></span>  
  
 <span data-ttu-id="95bd8-162">若要设置默认应用程序域的应用程序域管理器, 请使用 " [ \<运行时 >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) " 部分中的[ \<b l y >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md)和[ \<y p e >](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md)元素在应用程序配置文件中, 或使用中<xref:System.AppDomainManager>所述的环境变量。</span><span class="sxs-lookup"><span data-stu-id="95bd8-162">To set the application domain manager for the default application domain, use the [\<appDomainManagerAssembly>](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagerassembly-element.md) and [\<appDomainManagerType>](~/docs/framework/configure-apps/file-schema/runtime/appdomainmanagertype-element.md) elements in the [\<runtime>](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) section of the application configuration file, or use the environment variables described in <xref:System.AppDomainManager>.</span></span>  
  
 <span data-ttu-id="95bd8-163">此功能要求应用程序具有完全信任。</span><span class="sxs-lookup"><span data-stu-id="95bd8-163">This feature requires the application to have full trust.</span></span> <span data-ttu-id="95bd8-164">(例如, 在桌面上运行的应用程序具有完全信任。)如果应用程序不具有完全信任, <xref:System.TypeLoadException>则会引发。</span><span class="sxs-lookup"><span data-stu-id="95bd8-164">(For example, an application running on the desktop has full trust.) If the application does not have full trust, a <xref:System.TypeLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="95bd8-165">类型的完整名称的格式由<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性提供。</span><span class="sxs-lookup"><span data-stu-id="95bd8-165">The format of the full name of a type is given by the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationBase">
      <MemberSignature Language="C#" Value="public string ApplicationBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationBase" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationBase : string with get, set" Usage="System.AppDomainSetup.ApplicationBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-166">获取或设置包含该应用程序的目录的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-166">Gets or sets the name of the directory containing the application.</span></span></summary>
        <value><span data-ttu-id="95bd8-167">应用程序基目录的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-167">The name of the application base directory.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-168">应用程序基目录是程序集管理器开始探测程序集的位置。</span><span class="sxs-lookup"><span data-stu-id="95bd8-168">The application base directory is where the assembly manager begins probing for assemblies.</span></span>  
  
 <span data-ttu-id="95bd8-169"><xref:System.AppDomainSetup.ApplicationBase%2A>属性可以影响向应用程序域授予的权限。</span><span class="sxs-lookup"><span data-stu-id="95bd8-169">The <xref:System.AppDomainSetup.ApplicationBase%2A> property can influence which permissions are granted to an application domain.</span></span> <span data-ttu-id="95bd8-170">例如, 来自本地计算机的应用程序域通常基于其源位置获得完全信任。</span><span class="sxs-lookup"><span data-stu-id="95bd8-170">For example, an application domain originating from the local computer normally receives full trust based on its location of origin.</span></span> <span data-ttu-id="95bd8-171">但是, 如果<xref:System.AppDomainSetup.ApplicationBase%2A>将的<xref:System.AppDomain>属性设置为 intranet 目录的完整名称, 则该<xref:System.AppDomainSetup.ApplicationBase%2A>设置会将授予应用程序域的权限限制为 LocalIntranet grant, 即使应用程序域实际上来自本地计算机。</span><span class="sxs-lookup"><span data-stu-id="95bd8-171">However, if the <xref:System.AppDomainSetup.ApplicationBase%2A> property of that <xref:System.AppDomain> is set to the full name of an intranet directory, the <xref:System.AppDomainSetup.ApplicationBase%2A> setting restricts the permissions granted to the application domain to a LocalIntranet grant even though the application domain actually originates from the local computer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bd8-172">下面的示例演示如何使用<xref:System.AppDomainSetup.ApplicationBase%2A>属性设置程序集加载程序开始探测程序集以加载到新应用程序域中的位置。</span><span class="sxs-lookup"><span data-stu-id="95bd8-172">The following example demonstrates how to use the <xref:System.AppDomainSetup.ApplicationBase%2A> property to set the location where the assembly loader begins probing for assemblies to load into a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bd8-173">必须确保指定的文件夹存在。</span><span class="sxs-lookup"><span data-stu-id="95bd8-173">You must ensure that the folder you specify exists.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="95bd8-174">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-174">for access to the path information.</span></span> <span data-ttu-id="95bd8-175">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="95bd8-175">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.AppDomainSetup.ApplicationName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ApplicationName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-176">获取或设置应用程序的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-176">Gets or sets the name of the application.</span></span></summary>
        <value><span data-ttu-id="95bd8-177">应用程序的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-177">The name of the application.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95bd8-178">下面的示例演示如何在创建新<xref:System.AppDomainSetup.ApplicationName%2A>的应用程序域时设置属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-178">The following example shows how to set the <xref:System.AppDomainSetup.ApplicationName%2A> property when you create a new application domain.</span></span>  
  
 <span data-ttu-id="95bd8-179">该示例创建一个新的应用程序域, 然后调用<xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType>方法将示例程序集加载到新应用程序域中, 并创建`Worker`类的实例。</span><span class="sxs-lookup"><span data-stu-id="95bd8-179">The example creates a new application domain, and then calls the <xref:System.AppDomain.CreateInstanceAndUnwrap%2A?displayProperty=nameWithType> method to load the example assembly into the new application domain and create an instance of the `Worker` class.</span></span> <span data-ttu-id="95bd8-180">该类继承<xref:System.MarshalByRefObject>, 因此该示例可以<xref:System.AppDomain.CreateInstanceAndUnwrap%2A>使用`TestLoad`返回的代理来调用方法。 `Worker`</span><span class="sxs-lookup"><span data-stu-id="95bd8-180">The `Worker` class inherits <xref:System.MarshalByRefObject>, so the example can use the proxy returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A> to call the `TestLoad` method.</span></span>  
  
 <span data-ttu-id="95bd8-181">`TestLoad`方法加载指定的程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-181">The `TestLoad` method loads an assembly that you specify.</span></span> <span data-ttu-id="95bd8-182">您必须指定有效的完全限定的程序集名称或注释掉该<xref:System.Reflection.Assembly.Load%28System.String%29>方法。</span><span class="sxs-lookup"><span data-stu-id="95bd8-182">You must either specify a valid, fully qualified assembly name, or comment out the <xref:System.Reflection.Assembly.Load%28System.String%29> method.</span></span> <span data-ttu-id="95bd8-183">`TestLoad`方法列出加载到新应用程序域中的程序集, 并显示指定的程序集和示例程序集已加载。</span><span class="sxs-lookup"><span data-stu-id="95bd8-183">The `TestLoad` method lists the assemblies that are loaded into the new application domain, showing that your specified assembly and the example assembly are loaded.</span></span>  
  
 <span data-ttu-id="95bd8-184">该示例使用<xref:System.LoaderOptimizationAttribute>特性告诉程序集加载程序, 应用程序将如何跨应用程序域共享代码。</span><span class="sxs-lookup"><span data-stu-id="95bd8-184">The example uses the <xref:System.LoaderOptimizationAttribute> attribute to tell the assembly loader how the application will share code across application domains.</span></span>  
  
 [!code-cpp[ADMultiDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADMultiDomain/CPP/admultidomain.cpp#1)]
 [!code-csharp[ADMultiDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADMultiDomain/CS/admultidomain.cs#1)]
 [!code-vb[ADMultiDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADMultiDomain/VB/admultidomain.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); void set(System::Security::Policy::ApplicationTrust ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust with get, set" Usage="System.AppDomainSetup.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-185">获取或设置一个包含安全性和信任信息的对象。</span><span class="sxs-lookup"><span data-stu-id="95bd8-185">Gets or sets an object containing security and trust information.</span></span></summary>
        <value><span data-ttu-id="95bd8-186">包含安全和信任信息的对象。</span><span class="sxs-lookup"><span data-stu-id="95bd8-186">An object that contains security and trust information.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-187">当创建时`null` ,此属性为。<xref:System.AppDomainSetup></span><span class="sxs-lookup"><span data-stu-id="95bd8-187">This property is `null` when the <xref:System.AppDomainSetup> is created.</span></span> <span data-ttu-id="95bd8-188">更改后, 不能将其重置为空引用。</span><span class="sxs-lookup"><span data-stu-id="95bd8-188">Once changed, it cannot be reset to a null reference.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="95bd8-189">属性设置为 <see cref="T:System.Security.Policy.ApplicationTrust" /> 对象，该对象的应用程序标识不匹配 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 属性返回的 <see cref="T:System.Runtime.Hosting.ActivationArguments" /> 对象的应用程序标识。</span><span class="sxs-lookup"><span data-stu-id="95bd8-189">The property is set to an <see cref="T:System.Security.Policy.ApplicationTrust" /> object whose application identity does not match the application identity of the <see cref="T:System.Runtime.Hosting.ActivationArguments" /> object returned by the <see cref="P:System.AppDomainSetup.ActivationArguments" /> property.</span></span> <span data-ttu-id="95bd8-190">如果 <see cref="P:System.AppDomainSetup.ActivationArguments" /> 属性为 <see langword="null" />，则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="95bd8-190">No exception is thrown if the <see cref="P:System.AppDomainSetup.ActivationArguments" /> property is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bd8-191">属性设置为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-191">The property is set to <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CachePath">
      <MemberSignature Language="C#" Value="public string CachePath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CachePath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.CachePath" />
      <MemberSignature Language="VB.NET" Value="Public Property CachePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CachePath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CachePath : string with get, set" Usage="System.AppDomainSetup.CachePath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.CachePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-192">获取或设置特定于应用程序且从中对文件进行卷影复制的区域的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-192">Gets or sets the name of an area specific to the application where files are shadow copied.</span></span></summary>
        <value><span data-ttu-id="95bd8-193">从中对文件进行卷影复制的目录路径和文件名的完全限定名。</span><span class="sxs-lookup"><span data-stu-id="95bd8-193">The fully qualified name of the directory path and file name where files are shadow copied.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-194">为了使此属性生效, <xref:System.AppDomainSetup.ApplicationName%2A>还必须设置属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-194">In order for this property to have an effect, the <xref:System.AppDomainSetup.ApplicationName%2A> property must also be set.</span></span> <span data-ttu-id="95bd8-195">如果未<xref:System.AppDomainSetup.ApplicationName%2A>设置该属性<xref:System.AppDomainSetup.CachePath%2A> , 则将忽略属性, 并将卷影副本缓存位置默认为下载缓存。</span><span class="sxs-lookup"><span data-stu-id="95bd8-195">If the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set, the <xref:System.AppDomainSetup.CachePath%2A> property is ignored and the shadow copy cache location defaults to the download cache.</span></span>  
  
 <span data-ttu-id="95bd8-196">有关卷影复制的详细信息, 请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-196">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="95bd8-197">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-197">for access to the path information.</span></span> <span data-ttu-id="95bd8-198">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="95bd8-198">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="95bd8-199">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="95bd8-199">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ConfigurationFile">
      <MemberSignature Language="C#" Value="public string ConfigurationFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConfigurationFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ConfigurationFile" />
      <MemberSignature Language="VB.NET" Value="Public Property ConfigurationFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ConfigurationFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ConfigurationFile : string with get, set" Usage="System.AppDomainSetup.ConfigurationFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ConfigurationFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-200">获取或设置应用程序域的配置文件的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-200">Gets or sets the name of the configuration file for an application domain.</span></span></summary>
        <value><span data-ttu-id="95bd8-201">配置文件的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-201">The name of the configuration file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-202">配置文件描述应用程序域的搜索规则和配置数据。</span><span class="sxs-lookup"><span data-stu-id="95bd8-202">The configuration file describes the search rules and configuration data for the application domain.</span></span> <span data-ttu-id="95bd8-203">创建应用程序域的主机负责提供此数据, 因为有意义的值因情况而异。</span><span class="sxs-lookup"><span data-stu-id="95bd8-203">The host that creates the application domain is responsible for supplying this data because the meaningful values vary from situation to situation.</span></span>  
  
 <span data-ttu-id="95bd8-204">例如, 为每个应用程序、站点和计算机存储 ASP.NET 应用程序的配置数据, 而针对每个应用程序、用户和计算机存储可执行文件的配置数据。</span><span class="sxs-lookup"><span data-stu-id="95bd8-204">For example, the configuration data for ASP.NET applications is stored for each application, site, and computer, while the configuration data for an executable is stored for each application, user, and computer.</span></span> <span data-ttu-id="95bd8-205">只有主机知道特定情况下的配置数据细节。</span><span class="sxs-lookup"><span data-stu-id="95bd8-205">Only the host knows the specifics of the configuration data for a particular circumstance.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="95bd8-206">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-206">for access to the path information.</span></span> <span data-ttu-id="95bd8-207">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="95bd8-207">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68"><span data-ttu-id="95bd8-208">运行时设置架构</span><span class="sxs-lookup"><span data-stu-id="95bd8-208">Runtime Settings Schema</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DisallowApplicationBaseProbing">
      <MemberSignature Language="C#" Value="public bool DisallowApplicationBaseProbing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowApplicationBaseProbing" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowApplicationBaseProbing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowApplicationBaseProbing { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowApplicationBaseProbing : bool with get, set" Usage="System.AppDomainSetup.DisallowApplicationBaseProbing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-209">指定在搜索要加载的程序集时是否探测应用程序基路径和专用二进制路径。</span><span class="sxs-lookup"><span data-stu-id="95bd8-209">Specifies whether the application base path and private binary path are probed when searching for assemblies to load.</span></span></summary>
        <value><span data-ttu-id="95bd8-210">如果不允许探测，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-210"><see langword="true" /> if probing is not allowed; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="95bd8-211">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-211">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-212">如果属性为`true`, 则忽略属性的值。<xref:System.AppDomainSetup.ApplicationBase%2A> <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A></span><span class="sxs-lookup"><span data-stu-id="95bd8-212">If the <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> property is `true`, the value of the <xref:System.AppDomainSetup.ApplicationBase%2A> property is ignored.</span></span> <span data-ttu-id="95bd8-213">也就是说, 不会在<xref:System.AppDomainSetup.ApplicationBase%2A>属性所指定的目录中探测程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-213">That is, no assemblies are probed for in the directories specified by the <xref:System.AppDomainSetup.ApplicationBase%2A> property.</span></span> <span data-ttu-id="95bd8-214">此外, 将忽略<xref:System.AppDomainSetup.PrivateBinPath%2A>属性<xref:System.AppDomainSetup.PrivateBinPathProbe%2A>和属性的值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-214">In addition, the values of the <xref:System.AppDomainSetup.PrivateBinPath%2A> property and the <xref:System.AppDomainSetup.PrivateBinPathProbe%2A> property are ignored.</span></span> <span data-ttu-id="95bd8-215">不会在<xref:System.AppDomainSetup.PrivateBinPath%2A>属性所指定的目录中探测到的程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-215">No assemblies are probed for in the directories specified by the <xref:System.AppDomainSetup.PrivateBinPath%2A> property.</span></span>  
  
 <span data-ttu-id="95bd8-216"><xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>属性提供了对加载过程的附加控制层。</span><span class="sxs-lookup"><span data-stu-id="95bd8-216">The <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> property provides an additional layer of control over the loading process.</span></span> <span data-ttu-id="95bd8-217">在常规程序集加载序列中, 在引发<xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>事件之前会探测应用程序基。</span><span class="sxs-lookup"><span data-stu-id="95bd8-217">In the normal assembly loading sequence, the application base is probed before the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event is raised.</span></span> <span data-ttu-id="95bd8-218">但是, 某些应用程序可能需要从文档内的 OLE 复合文件, 或从非全局程序集缓存中或<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>属性指定的目录中的唯一已知位置加载程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-218">However, some applications might need to load assemblies from an OLE compound file within a document, or from a unique known location that is neither in the global assembly cache nor in the directories specified by the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> properties.</span></span> <span data-ttu-id="95bd8-219">此类应用程序可<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A>使用属性来避免正常探测导致的延迟, 并避免加载可能位于正常探测路径中的必要程序集的副本。</span><span class="sxs-lookup"><span data-stu-id="95bd8-219">Such applications can use the <xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A> property to avoid the delay caused by normal probing, and to avoid loading copies of the necessary assembly that might be located in the normal probing paths.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowBindingRedirects">
      <MemberSignature Language="C#" Value="public bool DisallowBindingRedirects { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowBindingRedirects" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowBindingRedirects As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowBindingRedirects { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowBindingRedirects : bool with get, set" Usage="System.AppDomainSetup.DisallowBindingRedirects" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-220">获取或设置一个值，该值指示应用程序域是否允许程序集绑定重定向。</span><span class="sxs-lookup"><span data-stu-id="95bd8-220">Gets or sets a value that indicates whether an application domain allows assembly binding redirection.</span></span></summary>
        <value><span data-ttu-id="95bd8-221">如果不允许程序集的重定向，则为 <see langword="true" />；如果允许，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-221"><see langword="true" /> if redirection of assemblies is not allowed; <see langword="false" /> if it is allowed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-222"><xref:System.AppDomainSetup.DisallowBindingRedirects%2A>属性设计为由服务和服务器应用程序使用, 其中程序集绑定重定向不是应用程序方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="95bd8-222">The <xref:System.AppDomainSetup.DisallowBindingRedirects%2A> property is designed to be used by services and server applications where assembly binding redirection is not part of the application scenario.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowCodeDownload">
      <MemberSignature Language="C#" Value="public bool DisallowCodeDownload { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowCodeDownload" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowCodeDownload" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowCodeDownload As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowCodeDownload { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowCodeDownload : bool with get, set" Usage="System.AppDomainSetup.DisallowCodeDownload" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-223">获取或设置一个值，该值指示应用程序域是否允许通过 HTTP 下载程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-223">Gets or sets a value that indicates whether HTTP download of assemblies is allowed for an application domain.</span></span></summary>
        <value><span data-ttu-id="95bd8-224">如果不允许通过 HTTP 下载程序集，则为<see langword="true" /> ；如果允许则为 <see langword="false" /> 。</span><span class="sxs-lookup"><span data-stu-id="95bd8-224"><see langword="true" /> if HTTP download of assemblies is not allowed; <see langword="false" /> if it is allowed.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-225">此<xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性旨在供服务和服务器应用程序使用, 在这些应用程序中从 intranet 或 Internet 下载代码不是应用程序方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="95bd8-225">The <xref:System.AppDomainSetup.DisallowCodeDownload%2A> property is designed to be used by services and server applications where downloading code from an intranet or the Internet is not part of the application scenario.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="95bd8-226"><xref:System.AppDomainSetup.DisallowCodeDownload%2A>属性的默认值为`false`。</span><span class="sxs-lookup"><span data-stu-id="95bd8-226">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A> property is `false`.</span></span> <span data-ttu-id="95bd8-227">对于服务, 此设置是不安全的。</span><span class="sxs-lookup"><span data-stu-id="95bd8-227">This setting is unsafe for services.</span></span> <span data-ttu-id="95bd8-228">若要帮助防止服务下载部分受信任的代码, 请将`true`此属性设置为。</span><span class="sxs-lookup"><span data-stu-id="95bd8-228">To help prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisallowPublisherPolicy">
      <MemberSignature Language="C#" Value="public bool DisallowPublisherPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisallowPublisherPolicy" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DisallowPublisherPolicy As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisallowPublisherPolicy { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisallowPublisherPolicy : bool with get, set" Usage="System.AppDomainSetup.DisallowPublisherPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-229">获取或设置一个值，该值指示是否将配置文件的 [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) 部分应用于应用程序域。</span><span class="sxs-lookup"><span data-stu-id="95bd8-229">Gets or sets a value that indicates whether the [&lt;publisherPolicy&gt;](~/docs/framework/configure-apps/file-schema/runtime/publisherpolicy-element.md) section of the configuration file is applied to an application domain.</span></span></summary>
        <value><span data-ttu-id="95bd8-230">如果应用程序域忽略配置文件的 <see langword="true" /> 节，则为 <see langword="&lt;publisherPolicy&gt;" />；如果接受所声明的发行者策略，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-230"><see langword="true" /> if the <see langword="&lt;publisherPolicy&gt;" /> section of the configuration file for an application domain is ignored; <see langword="false" /> if the declared publisher policy is honored.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-231"><xref:System.AppDomainSetup.DisallowPublisherPolicy%2A>属性专门适用于在本地加载的 Web 应用程序。</span><span class="sxs-lookup"><span data-stu-id="95bd8-231">The <xref:System.AppDomainSetup.DisallowPublisherPolicy%2A> property specifically applies to a Web application that is loaded locally.</span></span> <span data-ttu-id="95bd8-232">使用此属性可帮助防止恶意尝试在安全模式下执行不安全的 Web 应用程序。</span><span class="sxs-lookup"><span data-stu-id="95bd8-232">Use this property to help prevent a malicious attempt to execute an unsafe Web application in safe mode.</span></span>  
  
 <span data-ttu-id="95bd8-233">有关跳过发行者策略的详细信息, 请参阅[重定向程序集版本](~/docs/framework/configure-apps/redirect-assembly-versions.md)主题。</span><span class="sxs-lookup"><span data-stu-id="95bd8-233">For more information about bypassing publisher policy, see the [Redirecting Assembly Versions](~/docs/framework/configure-apps/redirect-assembly-versions.md) topic.</span></span> <span data-ttu-id="95bd8-234">有关安全模式的详细信息, 请参阅[运行时如何定位程序集](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)主题的 "检查配置文件" 部分。</span><span class="sxs-lookup"><span data-stu-id="95bd8-234">For more information about safe mode, see the "Examining the Configuration Files" section of the [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md) topic.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicBase">
      <MemberSignature Language="C#" Value="public string DynamicBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicBase" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.DynamicBase" />
      <MemberSignature Language="VB.NET" Value="Public Property DynamicBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicBase { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DynamicBase : string with get, set" Usage="System.AppDomainSetup.DynamicBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.DynamicBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-235">获取或设置动态生成的文件所在的目录的基目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-235">Gets or sets the base directory where the directory for dynamically generated files is located.</span></span></summary>
        <value><span data-ttu-id="95bd8-236"><see cref="P:System.AppDomain.DynamicDirectory" /> 所在的目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-236">The directory where the <see cref="P:System.AppDomain.DynamicDirectory" /> is located.</span></span>  

 <block subset="none" type="note"><para>  
 <span data-ttu-id="95bd8-237">该属性的返回值不同于分配的值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-237">The return value of this property is different from the value assigned.</span></span>
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## Remarks  
 <span data-ttu-id="95bd8-238">使用此属性可设置新应用程序域的动态目录所在的基目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-238">Use this property to set the base directory where the dynamic directory for the new application domain will be located.</span></span> <span data-ttu-id="95bd8-239">当新应用程序域中的代码加载程序集时, 程序集解析将首先在正常探测路径中查找。</span><span class="sxs-lookup"><span data-stu-id="95bd8-239">When code in the new application domain loads an assembly, assembly resolution looks first in the normal probing paths.</span></span> <span data-ttu-id="95bd8-240">如果它找不到程序集, 则会在动态目录中查找<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>属性返回的动态目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-240">If it does not find the assembly, it looks in the dynamic directory, which is returned by the <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="95bd8-241">新应用程序域将加载并执行的动态程序集可以放置在该处。</span><span class="sxs-lookup"><span data-stu-id="95bd8-241">Dynamic assemblies that will be loaded and executed by the new application domain can be placed there.</span></span>  
  
 <span data-ttu-id="95bd8-242">为<xref:System.AppDomainSetup.DynamicBase%2A>属性分配路径时, 会添加一个附加的子目录; 此子目录的名称是分配<xref:System.AppDomainSetup.ApplicationName%2A>给属性的值的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="95bd8-242">When you assign a path to the <xref:System.AppDomainSetup.DynamicBase%2A> property, an additional subdirectory is added; the name of this subdirectory is the hash code of the value assigned to the <xref:System.AppDomainSetup.ApplicationName%2A> property.</span></span> <span data-ttu-id="95bd8-243">因此, 随后由此属性返回的基目录始终不同于分配的值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-243">Thus, the base directory subsequently returned by this property is always different from the value assigned.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95bd8-244">为此属性赋值不会创建任何目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-244">Assigning a value to this property does not create any directories.</span></span> <span data-ttu-id="95bd8-245">目录必须由使用它们的代码创建或验证。</span><span class="sxs-lookup"><span data-stu-id="95bd8-245">The directories must be created or verified by the code that uses them.</span></span>  
  
 <span data-ttu-id="95bd8-246">动态目录是的<xref:System.AppDomainSetup.DynamicBase%2A>子目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-246">The dynamic directory is a subdirectory of <xref:System.AppDomainSetup.DynamicBase%2A>.</span></span> <span data-ttu-id="95bd8-247"><xref:System.AppDomainSetup.ApplicationName%2A>它的简单名称是由属性返回的值, 因此其格式为*原始路径*\\*哈希代码*\\*应用程序名称*。</span><span class="sxs-lookup"><span data-stu-id="95bd8-247">Its simple name is the value returned by the <xref:System.AppDomainSetup.ApplicationName%2A> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="95bd8-248">下面的示例演示如何使用<xref:System.AppDomainSetup.DynamicBase%2A>属性来设置加载动态程序集时应用程序域探测的路径。</span><span class="sxs-lookup"><span data-stu-id="95bd8-248">The following example demonstrates how to use the <xref:System.AppDomainSetup.DynamicBase%2A> property to set the path an application domain probes when loading dynamic assemblies.</span></span>  
  
 <span data-ttu-id="95bd8-249">该示例创建一个<xref:System.AppDomainSetup>对象, 并将<xref:System.AppDomainSetup.ApplicationName%2A>其属性设置为 "example" <xref:System.AppDomainSetup.DynamicBase%2A> , 并将其属性设置为 "C:\DynamicAssemblyDir"。</span><span class="sxs-lookup"><span data-stu-id="95bd8-249">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="95bd8-250">然后, 该示例显示<xref:System.AppDomainSetup.DynamicBase%2A>属性, 显示已将应用程序名称的哈希代码附加为最初分配的路径的子目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-250">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bd8-251">本示例中的基目录应位于示例应用程序的探测路径之外。</span><span class="sxs-lookup"><span data-stu-id="95bd8-251">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="95bd8-252">请确保在其他位置编译该示例。</span><span class="sxs-lookup"><span data-stu-id="95bd8-252">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="95bd8-253">每次运行该示例时, 删除基目录及其所有子目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-253">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="95bd8-254">该示例使用<xref:System.AppDomainSetup>对象创建一个新的应用程序域。</span><span class="sxs-lookup"><span data-stu-id="95bd8-254">The example creates a new application domain using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="95bd8-255">然后, 该示例创建动态目录 (如果它尚不存在)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-255">The example then creates the dynamic directory if it does not already exist.</span></span> <span data-ttu-id="95bd8-256">尽管该示例使用应用程序域的<xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType>属性来获取动态目录的名称, 但它可以通过连接原始路径、应用程序名称的哈希代码和应用程序名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-256">Although the example uses the application domain's <xref:System.AppDomain.DynamicDirectory%2A?displayProperty=nameWithType> property to get the name of the dynamic directory, it could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.</span></span>  
  
 <span data-ttu-id="95bd8-257">该示例包含一个`GenerateDynamicAssembly`方法, 该方法发出名`DynamicHelloWorld.dll`为的程序集, 并将其存储在新应用程序域的动态目录中。</span><span class="sxs-lookup"><span data-stu-id="95bd8-257">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="95bd8-258">动态程序集包含一个类型, `HelloWorld`该类型具有一个名为`HelloFromAD`的`Shared`静态方法 (Visual Basic 中的方法)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-258">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="95bd8-259">调用此方法将显示应用程序域的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-259">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="95bd8-260">类派生自<xref:System.MarshalByRefObject>, 因此该示例可以在新的应用程序域中创建类的实例并调用其`Test`方法。 `Example`</span><span class="sxs-lookup"><span data-stu-id="95bd8-260">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="95bd8-261">方法按其显示名称加载动态程序集, 并调用静态`HelloFromAD`方法。 `Test`</span><span class="sxs-lookup"><span data-stu-id="95bd8-261">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="95bd8-262">可以通过编写名为`DynamicHelloWorld.dll`的程序集的代码, 并在与此示例相同的目录中进行编译, 来显示在正常探测路径之后搜索动态目录。</span><span class="sxs-lookup"><span data-stu-id="95bd8-262">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="95bd8-263">程序集必须具有名为`HelloWorld`的静态`HelloFromAD`方法的类。</span><span class="sxs-lookup"><span data-stu-id="95bd8-263">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="95bd8-264">此方法不必与示例中的相同。它可以直接在控制台上显示字符串。</span><span class="sxs-lookup"><span data-stu-id="95bd8-264">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="95bd8-265">该程序集还必须有<xref:System.Reflection.AssemblyVersionAttribute>一个将其版本设置为1.0.0.0 的特性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-265">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="95bd8-266">运行此示例时, 将在搜索动态目录之前找到当前目录中编译的程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-266">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="95bd8-267">无法设置此属性，因为应用程序域上的应用程序名为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-267">This property cannot be set because the application name on the application domain is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="95bd8-268">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-268">for access to the path information.</span></span> <span data-ttu-id="95bd8-269">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="95bd8-269">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetConfigurationBytes">
      <MemberSignature Language="C#" Value="public byte[] GetConfigurationBytes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetConfigurationBytes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.GetConfigurationBytes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConfigurationBytes () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetConfigurationBytes();" />
      <MemberSignature Language="F#" Value="member this.GetConfigurationBytes : unit -&gt; byte[]" Usage="appDomainSetup.GetConfigurationBytes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="95bd8-270">返回由 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法设置的 XML 配置信息，这些信息优先于应用程序的 XML 配置信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-270">Returns the XML configuration information set by the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method, which overrides the application's XML configuration information.</span></span></summary>
        <returns><span data-ttu-id="95bd8-271">一个数组，其中包含由 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法设置的 XML 配置信息；如果未调用 <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> 方法，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-271">An array that contains the XML configuration information that was set by the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method, or <see langword="null" /> if the <see cref="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" /> method has not been called.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-272"><xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法提供了一种方法来重写创建新应用程序域的应用程序的配置信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-272">The <xref:System.AppDomainSetup.SetConfigurationBytes%2A> method provides a way to override the configuration information of an application that creates a new application domain.</span></span> <span data-ttu-id="95bd8-273">中`value`的配置文件信息覆盖应用程序的配置文件信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-273">The configuration file information in `value` overrides the configuration file information for the application.</span></span> <span data-ttu-id="95bd8-274">例如, 当 Example 应用程序创建新的应用程序域时, 它可以重写最初从 web.config 文件中获取的配置信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-274">For example, when the Example.exe application creates a new application domain, it can override the configuration information originally obtained from Example.exe.config file.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95bd8-275">配置文件信息的某些使用者不使用<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法所存储的信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-275">Some consumers of configuration file information do not use the information stored by the <xref:System.AppDomainSetup.SetConfigurationBytes%2A> method.</span></span> <span data-ttu-id="95bd8-276">运行时不强制执行此功能。</span><span class="sxs-lookup"><span data-stu-id="95bd8-276">The runtime does not enforce this.</span></span> <span data-ttu-id="95bd8-277">若要确保在新的应用程序域中覆盖所有配置文件信息, 请<xref:System.AppDomainSetup.ConfigurationFile%2A>使用属性来指定配置文件。</span><span class="sxs-lookup"><span data-stu-id="95bd8-277">To ensure that all configuration file information is overridden in a new application domain, use the <xref:System.AppDomainSetup.ConfigurationFile%2A> property to specify a configuration file.</span></span> <span data-ttu-id="95bd8-278"><xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法会影响程序集绑定。</span><span class="sxs-lookup"><span data-stu-id="95bd8-278">The <xref:System.AppDomainSetup.SetConfigurationBytes%2A> method does affect assembly binding.</span></span>  
  
 <span data-ttu-id="95bd8-279">中`value`的 xml 与普通配置文件中的 xml 相同, 不同之处在于它以<xref:System.Byte>数组形式存储。</span><span class="sxs-lookup"><span data-stu-id="95bd8-279">The XML in `value` is the same as the XML in a normal configuration file, except that it is stored as a <xref:System.Byte> array.</span></span>  
  
 <span data-ttu-id="95bd8-280">若要访问应用程序域的配置字节, 请使用<xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType>属性<xref:System.AppDomainSetup>获取应用程序<xref:System.AppDomainSetup.GetConfigurationBytes%2A>域的对象, 然后使用方法。</span><span class="sxs-lookup"><span data-stu-id="95bd8-280">To access the configuration bytes for an application domain, use the <xref:System.AppDomain.SetupInformation%2A?displayProperty=nameWithType> property to get the <xref:System.AppDomainSetup> object for the application domain, then use the <xref:System.AppDomainSetup.GetConfigurationBytes%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LicenseFile">
      <MemberSignature Language="C#" Value="public string LicenseFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LicenseFile" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LicenseFile" />
      <MemberSignature Language="VB.NET" Value="Public Property LicenseFile As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LicenseFile { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LicenseFile : string with get, set" Usage="System.AppDomainSetup.LicenseFile" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.LicenseFile</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-281">获取或设置与此域关联的许可证文件的位置。</span><span class="sxs-lookup"><span data-stu-id="95bd8-281">Gets or sets the location of the license file associated with this domain.</span></span></summary>
        <value><span data-ttu-id="95bd8-282">许可证文件的位置和名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-282">The location and name of the license file.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="95bd8-283">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-283">for access to the path information.</span></span> <span data-ttu-id="95bd8-284">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="95bd8-284">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoaderOptimization">
      <MemberSignature Language="C#" Value="public LoaderOptimization LoaderOptimization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.LoaderOptimization LoaderOptimization" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.LoaderOptimization" />
      <MemberSignature Language="VB.NET" Value="Public Property LoaderOptimization As LoaderOptimization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property LoaderOptimization LoaderOptimization { LoaderOptimization get(); void set(LoaderOptimization value); };" />
      <MemberSignature Language="F#" Value="member this.LoaderOptimization : LoaderOptimization with get, set" Usage="System.AppDomainSetup.LoaderOptimization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LoaderOptimization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-285">指定用于加载可执行文件的优化策略。</span><span class="sxs-lookup"><span data-stu-id="95bd8-285">Specifies the optimization policy used to load an executable.</span></span></summary>
        <value><span data-ttu-id="95bd8-286">与 <see cref="T:System.LoaderOptimizationAttribute" /> 配合使用的枚举常数。</span><span class="sxs-lookup"><span data-stu-id="95bd8-286">An enumerated constant that is used with the <see cref="T:System.LoaderOptimizationAttribute" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="95bd8-287">下面的示例创建一个动态程序集, 并将其保存到磁盘, 然后<xref:System.AppDomainSetup.LoaderOptimization%2A>使用属性设置用于将程序集加载到应用程序域的优化策略。</span><span class="sxs-lookup"><span data-stu-id="95bd8-287">The following example creates a dynamic assembly and saves it to disk, and then uses the <xref:System.AppDomainSetup.LoaderOptimization%2A> property to set the optimization policy used to load the assembly into an application domain.</span></span>  
  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PartialTrustVisibleAssemblies">
      <MemberSignature Language="C#" Value="public string[] PartialTrustVisibleAssemblies { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] PartialTrustVisibleAssemblies" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Property PartialTrustVisibleAssemblies As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ PartialTrustVisibleAssemblies { cli::array &lt;System::String ^&gt; ^ get(); void set(cli::array &lt;System::String ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PartialTrustVisibleAssemblies : string[] with get, set" Usage="System.AppDomainSetup.PartialTrustVisibleAssemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-288">获取或设置标以 <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> 标志的程序集的列表，这些程序集对沙箱应用程序域中的部分信任代码可见。</span><span class="sxs-lookup"><span data-stu-id="95bd8-288">Gets or sets a list of assemblies marked with the <see cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" /> flag that are made visible to partial-trust code running in a sandboxed application domain.</span></span></summary>
        <value><span data-ttu-id="95bd8-289">部分程序集名称的数组，其中每个部分名称都由简单程序集名称和公钥组成。</span><span class="sxs-lookup"><span data-stu-id="95bd8-289">An array of partial assembly names, where each partial name consists of the simple assembly name and the public key.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-290">从开始<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> <xref:System.Security.AllowPartiallyTrustedCallersAttribute> , 可以通过将 (APTCA) 属性的属性设置为来使其成为条件特性。 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</span><span class="sxs-lookup"><span data-stu-id="95bd8-290">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Security.AllowPartiallyTrustedCallersAttribute> (APTCA) attribute can be made conditional by setting its <xref:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel%2A> property to <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>.</span></span> <span data-ttu-id="95bd8-291">标记为的 APTCA 程序集<xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault>不能由部分受信任的代码使用, 除非宿主应用程序允许它。</span><span class="sxs-lookup"><span data-stu-id="95bd8-291">An APTCA assembly that is marked with <xref:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault> cannot be used by partially trusted code unless the host application allows it.</span></span>  
  
 <span data-ttu-id="95bd8-292">沙盒应用程序域的宿主允许应用程序域中的代码通过以下方式使用程序集: 具有条件 APTCA 特性的程序集: 创建一个包含每个程序集的简单名称和公钥的数组, 并将该数组分配给此属性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-292">The host of a sandboxed application domain allows code in the application domain to use assemblies with conditional APTCA attributes by creating an array that contains the simple name and public key of each assembly, and assigning the array to this property.</span></span> <span data-ttu-id="95bd8-293">例如, 数组元素可能如下所示:"MyAssembly, PublicKey =0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".</span><span class="sxs-lookup"><span data-stu-id="95bd8-293">For example, an element of the array might look like the following: "MyAssembly, PublicKey=0024000004800000940000000602000000240000525341310004000001000100db2ad5e5fedc67ea526ff72ad426ef68e08e241d296c499eedfec6648dcc62b1a12f72be5833a45bbec481b68415b08a5fbc9f9ef247b523dd72bbea65bb532784ddc5c704544bd2f1c2d46fdbe41e4f949e76f9947357b2d5cf8ca9f970701bbd6e8ab64ad31b20ad0be9b56dae4f6b83332b92a2a3b8ea2804c40efbc0b6b9".</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95bd8-294">如果你使用的是的子类<xref:System.AppDomainManager>, 并且定义它的程序集依赖于标记有条件 APTCA 特性的程序集, 则你必须将这些程序集包含在你传递<xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A>给的<xref:System.AppDomainSetup>属性的列表中。使用创建应用程序域。</span><span class="sxs-lookup"><span data-stu-id="95bd8-294">If you are using a subclass of <xref:System.AppDomainManager>, and the assembly that defines it depends on assemblies that are marked with the conditional APTCA attribute, you must include those assemblies in the list that you pass to the <xref:System.AppDomainSetup.PartialTrustVisibleAssemblies%2A> property of the <xref:System.AppDomainSetup> you use to create application domains.</span></span> <span data-ttu-id="95bd8-295">否则, 将禁用用条件 APTCA 特性标记的程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-295">Otherwise the assemblies that are marked with the conditional APTCA attribute will be disabled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="95bd8-296">调试在沙盒应用程序域中运行的应用程序时, 某些<xref:System.Security.SecurityException>消息可能会产生误导。</span><span class="sxs-lookup"><span data-stu-id="95bd8-296">When you are debugging an application that is running in a sandboxed application domain, some <xref:System.Security.SecurityException> messages can be misleading.</span></span> <span data-ttu-id="95bd8-297">例如, 消息可能表明, 其中一个完全受信任的程序集只有有限的权限, 而问题的真正原因在于, 超过沙盒应用程序域的授予集的安全要求已传播到沙盒应用程序域失败。</span><span class="sxs-lookup"><span data-stu-id="95bd8-297">For example, a message might state that one of your fully trusted assemblies has only limited permissions, when the real cause of the problem is that a security demand that exceeds the grant set of the sandboxed application domain has propagated to the boundary of the sandboxed application domain and failed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Security.AllowPartiallyTrustedCallersAttribute" />
        <altmember cref="P:System.Security.AllowPartiallyTrustedCallersAttribute.PartialTrustVisibilityLevel" />
        <altmember cref="F:System.Security.PartialTrustVisibilityLevel.NotVisibleByDefault" />
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPath">
      <MemberSignature Language="C#" Value="public string PrivateBinPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPath" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPath : string with get, set" Usage="System.AppDomainSetup.PrivateBinPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-298">获取或设置应用程序基目录下的目录列表，这些目录被探测以寻找其中的私有程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-298">Gets or sets the list of directories under the application base directory that are probed for private assemblies.</span></span></summary>
        <value><span data-ttu-id="95bd8-299">目录名称的列表，以用分号分隔。</span><span class="sxs-lookup"><span data-stu-id="95bd8-299">A list of directory names separated by semicolons.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-300">私有程序集部署在与应用程序相同的目录结构中。</span><span class="sxs-lookup"><span data-stu-id="95bd8-300">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="95bd8-301">如果为指定的<xref:System.AppDomainSetup.PrivateBinPath%2A>目录不在下<xref:System.AppDomainSetup.ApplicationBase%2A>, 则它们将被忽略。</span><span class="sxs-lookup"><span data-stu-id="95bd8-301">If the directories specified for <xref:System.AppDomainSetup.PrivateBinPath%2A> are not under <xref:System.AppDomainSetup.ApplicationBase%2A>, they are ignored.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrivateBinPathProbe">
      <MemberSignature Language="C#" Value="public string PrivateBinPathProbe { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PrivateBinPathProbe" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberSignature Language="VB.NET" Value="Public Property PrivateBinPathProbe As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PrivateBinPathProbe { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PrivateBinPathProbe : string with get, set" Usage="System.AppDomainSetup.PrivateBinPathProbe" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.PrivateBinPathProbe</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-302">获取或设置一个字符串值，用于在应用程序的搜索路径中包含 <see cref="P:System.AppDomainSetup.ApplicationBase" />，或者从搜索路径中排除该基路径而只在 <see cref="P:System.AppDomainSetup.PrivateBinPath" /> 中进行搜索。</span><span class="sxs-lookup"><span data-stu-id="95bd8-302">Gets or sets a string value that includes or excludes <see cref="P:System.AppDomainSetup.ApplicationBase" /> from the search path for the application, and searches only <see cref="P:System.AppDomainSetup.PrivateBinPath" />.</span></span></summary>
        <value><span data-ttu-id="95bd8-303">空引用（ Visual Basic 中的 <see langword="Nothing" />），包括搜索程序集时的应用程序基路径；要排除该路径的任何非空字符串值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-303">A null reference (<see langword="Nothing" /> in Visual Basic) to include the application base path when searching for assemblies; any non-null string value to exclude the path.</span></span> <span data-ttu-id="95bd8-304">默认值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-304">The default value is <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-305">将此属性设置为任何非 null 字符串值 (包括<xref:System.String.Empty?displayProperty=nameWithType> ("")), 以排除应用程序目录路径<xref:System.AppDomainSetup.ApplicationBase%2A> (即从应用程序的搜索路径获取), 并仅搜索中<xref:System.AppDomainSetup.PrivateBinPath%2A>的程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-305">Set this property to any non-null string value, including <xref:System.String.Empty?displayProperty=nameWithType> (""), to exclude the application directory path - that is, <xref:System.AppDomainSetup.ApplicationBase%2A> - from the search path for the application, and to search for assemblies only in <xref:System.AppDomainSetup.PrivateBinPath%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SandboxInterop">
      <MemberSignature Language="C#" Value="public bool SandboxInterop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SandboxInterop" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.SandboxInterop" />
      <MemberSignature Language="VB.NET" Value="Public Property SandboxInterop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SandboxInterop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SandboxInterop : bool with get, set" Usage="System.AppDomainSetup.SandboxInterop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-306">获取或设置一个值，该值指示是否在应用程序域中为互操作调用禁用接口缓存，从而对每个调用执行 <c>QueryInterface</c>。</span><span class="sxs-lookup"><span data-stu-id="95bd8-306">Gets or sets a value that indicates whether interface caching is disabled for interop calls in the application domain, so that a <c>QueryInterface</c> is performed on each call.</span></span></summary>
        <value><span data-ttu-id="95bd8-307">如果为使用当前 <see cref="T:System.AppDomainSetup" /> 对象创建的应用程序域中的互操作调用禁用接口缓存，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-307"><see langword="true" /> if interface caching is disabled for interop calls in application domains created with the current <see cref="T:System.AppDomainSetup" /> object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-308">禁用接口缓存会对互操作调用的性能产生显著影响。</span><span class="sxs-lookup"><span data-stu-id="95bd8-308">Disabling interface caching has a significant impact on the performance of interop calls.</span></span>  
  
 <span data-ttu-id="95bd8-309">此成员是在中引入[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]的。</span><span class="sxs-lookup"><span data-stu-id="95bd8-309">This member is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibilitySwitches">
      <MemberSignature Language="C#" Value="public void SetCompatibilitySwitches (System.Collections.Generic.IEnumerable&lt;string&gt; switches);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompatibilitySwitches(class System.Collections.Generic.IEnumerable`1&lt;string&gt; switches) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompatibilitySwitches (switches As IEnumerable(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompatibilitySwitches(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ switches);" />
      <MemberSignature Language="F#" Value="member this.SetCompatibilitySwitches : seq&lt;string&gt; -&gt; unit" Usage="appDomainSetup.SetCompatibilitySwitches switches" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switches" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="switches"><span data-ttu-id="95bd8-310">指定兼容性开关的字符串值的可枚举集或要擦除现有兼容性开关的 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-310">An enumerable set of string values that specify compatibility switches, or <see langword="null" /> to erase the existing compatibility switches.</span></span></param>
        <summary><span data-ttu-id="95bd8-311">设置指定的开关，从而使应用程序域针对指定问题与早期版本的 .NET Framework 兼容。</span><span class="sxs-lookup"><span data-stu-id="95bd8-311">Sets the specified switches, making the application domain compatible with previous versions of the .NET Framework for the specified issues.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-312">.NET Framework 的主要版本有时会引入以前版本的重大更改。</span><span class="sxs-lookup"><span data-stu-id="95bd8-312">Major versions of the .NET Framework sometimes introduce breaking changes from the previous version.</span></span> <span data-ttu-id="95bd8-313">例如, [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]从中引入了少量的重大更改。</span><span class="sxs-lookup"><span data-stu-id="95bd8-313">For example, the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] introduces a small number of breaking changes from the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span> <span data-ttu-id="95bd8-314"><xref:System.AppDomainSetup.SetCompatibilitySwitches%2A>使用方法可指定应为应用程序域回滚其中一个或多个重大更改, 以使该行为与 .NET Framework 的以前版本兼容。</span><span class="sxs-lookup"><span data-stu-id="95bd8-314">Use the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A> method to specify that one or more of these breaking changes should be rolled back for the application domain, to make the behavior compatible with the previous version of the .NET Framework.</span></span>  
  
 <span data-ttu-id="95bd8-315">每次调用此方法时, 它将替换现有的开关设置。</span><span class="sxs-lookup"><span data-stu-id="95bd8-315">Each time you call this method, it replaces the existing switch settings.</span></span> <span data-ttu-id="95bd8-316">若要清除设置, 请`null` `switches`为参数指定。</span><span class="sxs-lookup"><span data-stu-id="95bd8-316">To erase the settings, specify `null` for the `switches` parameter.</span></span>  
  
 <span data-ttu-id="95bd8-317">为提供的`switches`字符串值集可以是一个简单的字符串数组, 因为数组实现了<xref:System.Collections.IEnumerable>接口。</span><span class="sxs-lookup"><span data-stu-id="95bd8-317">The set of string values you provide for `switches` can be a simple string array, because arrays implement the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="95bd8-318">下表提供了可设置为还原 .NET Framework 早期版本的行为的兼容性开关的示例。</span><span class="sxs-lookup"><span data-stu-id="95bd8-318">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="95bd8-319">开关</span><span class="sxs-lookup"><span data-stu-id="95bd8-319">Switch</span></span>|<span data-ttu-id="95bd8-320">含义</span><span class="sxs-lookup"><span data-stu-id="95bd8-320">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="95bd8-321">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="95bd8-321">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="95bd8-322">在此应用程序域中启用了[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]的代码访问安全性 (CAS)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-322">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="95bd8-323">请[ &lt;参阅y&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-323">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="95bd8-324">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="95bd8-324">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="95bd8-325">在此应用程序域[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]中启用了的字符串排序默认值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-325">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="95bd8-326">成功还原旧的排序行为还要求 sort00001000.dll 动态链接库在本地系统上可用。</span><span class="sxs-lookup"><span data-stu-id="95bd8-326">Successfully restoring legacy sorting behavior also requires the sort00001000.dll dynamic link library to be available on the local system.</span></span> <span data-ttu-id="95bd8-327">请[ &lt;参阅CompatSortNLSVersion&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-327">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="95bd8-328">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="95bd8-328">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="95bd8-329">在此应用程序域[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]中启用和 Unicode 5.0 的字符串排序默认值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-329">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="95bd8-330">成功还原旧的排序行为还要求 sort00060101 动态链接库在本地系统上可用。</span><span class="sxs-lookup"><span data-stu-id="95bd8-330">Successfully restoring legacy sorting behavior also requires the sort00060101.dll dynamic link library to be available on the local system.</span></span>|  
|<span data-ttu-id="95bd8-331">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="95bd8-331">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="95bd8-332"><xref:System.TimeSpan>此应用程序域[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]中启用了的格式设置行为。</span><span class="sxs-lookup"><span data-stu-id="95bd8-332"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="95bd8-333">请[ &lt;参阅&gt; ](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) <xref:System.TimeSpan>主题中的 TimeSpan_LegacyFormatMode 元素和 "还原旧的 TimeSpan 格式" 部分。</span><span class="sxs-lookup"><span data-stu-id="95bd8-333">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="95bd8-334">"UseRandomizedStringHashAlgorithm"</span><span class="sxs-lookup"><span data-stu-id="95bd8-334">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="95bd8-335">运行时基于每个应用程序域计算字符串的哈希代码, 而不是使用单个哈希算法跨应用程序域生成一致的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="95bd8-335">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="95bd8-336">请[ &lt;参阅UseRandomizedStringHashAlgorithm&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-336">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
        <related type="Article" href="https://msdn.microsoft.com/library/07132b9c-4a72-4710-99d7-e702405e02d4"><span data-ttu-id="95bd8-337">&lt;Y&gt;元素</span><span class="sxs-lookup"><span data-stu-id="95bd8-337">&lt;NetFx40_LegacySecurityPolicy&gt; Element</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/782cc82e-83f7-404a-80b7-6d3061a8b6e3"><span data-ttu-id="95bd8-338">&lt;CompatSortNLSVersion&gt;元素</span><span class="sxs-lookup"><span data-stu-id="95bd8-338">&lt;CompatSortNLSVersion&gt; Element</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/865e7207-d050-4442-b574-57ea29d5e2d6"><span data-ttu-id="95bd8-339">&lt;TimeSpan_LegacyFormatMode&gt;元素</span><span class="sxs-lookup"><span data-stu-id="95bd8-339">&lt;TimeSpan_LegacyFormatMode&gt; Element</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630"><span data-ttu-id="95bd8-340">&lt;UseRandomizedStringHashAlgorithm&gt;元素</span><span class="sxs-lookup"><span data-stu-id="95bd8-340">&lt;UseRandomizedStringHashAlgorithm&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetConfigurationBytes">
      <MemberSignature Language="C#" Value="public void SetConfigurationBytes (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetConfigurationBytes(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetConfigurationBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetConfigurationBytes (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetConfigurationBytes(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetConfigurationBytes : byte[] -&gt; unit" Usage="appDomainSetup.SetConfigurationBytes value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="95bd8-341">一个数组，其中包含要用于应用程序域的 XML 配置信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-341">An array that contains the XML configuration information to be used for the application domain.</span></span></param>
        <summary><span data-ttu-id="95bd8-342">提供应用程序域的 XML 配置信息，并替换应用程序的 XML 配置信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-342">Provides XML configuration information for the application domain, replacing the application's XML configuration information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-343"><xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法提供了一种方法来替换创建新应用程序域的应用程序的配置信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-343">The <xref:System.AppDomainSetup.SetConfigurationBytes%2A> method provides a way to replace the configuration information of an application that creates a new application domain.</span></span> <span data-ttu-id="95bd8-344">中`value`的配置文件信息将替换应用程序的配置文件信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-344">The configuration file information in `value` replaces the configuration file information for the application.</span></span> <span data-ttu-id="95bd8-345">例如, 当 Example 应用程序创建新的应用程序域时, 它可以替换最初从 web.config 文件中获取的配置信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-345">For example, when the Example.exe application creates a new application domain, it can replace the configuration information originally obtained from the Example.exe.config file.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95bd8-346">配置文件信息的某些使用者不使用<xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法所存储的信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-346">Some consumers of configuration file information do not use the information stored by the <xref:System.AppDomainSetup.SetConfigurationBytes%2A> method.</span></span> <span data-ttu-id="95bd8-347">运行时不强制执行此功能。</span><span class="sxs-lookup"><span data-stu-id="95bd8-347">The runtime does not enforce this.</span></span> <span data-ttu-id="95bd8-348">若要确保在新的应用程序域中替换所有配置文件信息, 请<xref:System.AppDomainSetup.ConfigurationFile%2A>使用属性来指定配置文件。</span><span class="sxs-lookup"><span data-stu-id="95bd8-348">To ensure that all configuration file information is replaced in a new application domain, use the <xref:System.AppDomainSetup.ConfigurationFile%2A> property to specify a configuration file.</span></span> <span data-ttu-id="95bd8-349"><xref:System.AppDomainSetup.SetConfigurationBytes%2A>方法会影响程序集绑定。</span><span class="sxs-lookup"><span data-stu-id="95bd8-349">The <xref:System.AppDomainSetup.SetConfigurationBytes%2A> method does affect assembly binding.</span></span>  
  
 <span data-ttu-id="95bd8-350">中`value`的 xml 与普通配置文件中的 xml 相同, 不同之处在于它以<xref:System.Byte>数组形式存储。</span><span class="sxs-lookup"><span data-stu-id="95bd8-350">The XML in `value` is the same as the XML in a normal configuration file, except that it is stored as a <xref:System.Byte> array.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f04816ab-110d-4e28-9283-845d6d9a4a68"><span data-ttu-id="95bd8-351">运行时设置架构</span><span class="sxs-lookup"><span data-stu-id="95bd8-351">Runtime Settings Schema</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetNativeFunction">
      <MemberSignature Language="C#" Value="public void SetNativeFunction (string functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetNativeFunction(string functionName, int32 functionVersion, native int functionPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomainSetup.SetNativeFunction(System.String,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetNativeFunction (functionName As String, functionVersion As Integer, functionPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetNativeFunction(System::String ^ functionName, int functionVersion, IntPtr functionPointer);" />
      <MemberSignature Language="F#" Value="member this.SetNativeFunction : string * int * nativeint -&gt; unit" Usage="appDomainSetup.SetNativeFunction (functionName, functionVersion, functionPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="functionName" Type="System.String" Index="0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionVersion" Type="System.Int32" Index="1" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="functionPointer" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="functionName"><span data-ttu-id="95bd8-352">要重载的字符串比较函数的名称。</span><span class="sxs-lookup"><span data-stu-id="95bd8-352">The name of the string comparison function to override.</span></span></param>
        <param name="functionVersion"><span data-ttu-id="95bd8-353">函数版本。</span><span class="sxs-lookup"><span data-stu-id="95bd8-353">The function version.</span></span> <span data-ttu-id="95bd8-354">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]，必须为 1 或者 更大的数值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-354">For [!INCLUDE[net_v45](~/includes/net-v45-md.md)], its value must be 1 or greater.</span></span></param>
        <param name="functionPointer"><span data-ttu-id="95bd8-355">重写 <paramref name="functionName" /> 函数的指针。</span><span class="sxs-lookup"><span data-stu-id="95bd8-355">A pointer to the function that overrides <paramref name="functionName" />.</span></span></param>
        <summary><span data-ttu-id="95bd8-356">向通用语言运行时提供备用字符串比较功能实施。</span><span class="sxs-lookup"><span data-stu-id="95bd8-356">Provides the common language runtime with an alternate implementation of a string comparison function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-357">以下字符串比较和排序方法可由<xref:System.AppDomainSetup.SetNativeFunction%2A>方法重写:</span><span class="sxs-lookup"><span data-stu-id="95bd8-357">The following string comparison and sorting methods can be overridden by the <xref:System.AppDomainSetup.SetNativeFunction%2A> method:</span></span>  
  
-   `IsNLSDefinedString`  
  
-   `CompareStringEx`  
  
-   `LCMapStringEx`  
  
-   `FindNLSStringEx`  
  
-   `CompareStringOrdinal`  
  
-   `GetNLSVersion`  
  
 <span data-ttu-id="95bd8-358">有关这些函数的信息, 请参阅[国家语言支持功能](https://go.microsoft.com/fwlink/?LinkId=228134)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-358">For information about these functions, see [National Language Support Functions](https://go.microsoft.com/fwlink/?LinkId=228134).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="95bd8-359"><paramref name="functionName" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-359"><paramref name="functionName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="95bd8-360"><paramref name="functionVersion" /> 不是 1 或者更大的值。</span><span class="sxs-lookup"><span data-stu-id="95bd8-360"><paramref name="functionVersion" /> is not 1 or greater.</span></span>  
  
<span data-ttu-id="95bd8-361">或</span><span class="sxs-lookup"><span data-stu-id="95bd8-361">-or-</span></span> 
 <span data-ttu-id="95bd8-362"><paramref name="functionPointer" /> 为 <see cref="F:System.IntPtr.Zero" />。</span><span class="sxs-lookup"><span data-stu-id="95bd8-362"><paramref name="functionPointer" /> is <see cref="F:System.IntPtr.Zero" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="95bd8-363">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="95bd8-363">requires full trust for the immediate caller.</span></span> <span data-ttu-id="95bd8-364">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="95bd8-364">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyDirectories">
      <MemberSignature Language="C#" Value="public string ShadowCopyDirectories { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyDirectories" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyDirectories As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyDirectories { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyDirectories : string with get, set" Usage="System.AppDomainSetup.ShadowCopyDirectories" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyDirectories</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-365">获取或设置目录的名称，这些目录包含要影像复制的程序集。</span><span class="sxs-lookup"><span data-stu-id="95bd8-365">Gets or sets the names of the directories containing assemblies to be shadow copied.</span></span></summary>
        <value><span data-ttu-id="95bd8-366">目录名称的列表，以用分号分隔。</span><span class="sxs-lookup"><span data-stu-id="95bd8-366">A list of directory names separated by semicolons.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-367">启用卷影复制时, 默认情况下是通过探测找到的所有程序集的卷影副本。也就是说, 在<xref:System.AppDomainSetup.PrivateBinPath%2A>和<xref:System.AppDomainSetup.ApplicationBase%2A>属性指定的目录中。</span><span class="sxs-lookup"><span data-stu-id="95bd8-367">When shadow copying is enabled, the default is to shadow copy all assemblies found through probing; that is, in the directories specified by the <xref:System.AppDomainSetup.PrivateBinPath%2A> and <xref:System.AppDomainSetup.ApplicationBase%2A> properties.</span></span> <span data-ttu-id="95bd8-368">属性将卷影副本限制为<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>指定目录中的程序集。 <xref:System.AppDomainSetup.ShadowCopyDirectories%2A></span><span class="sxs-lookup"><span data-stu-id="95bd8-368">The <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property restricts the shadow copy to the assemblies in the directories specified by <xref:System.AppDomainSetup.ShadowCopyDirectories%2A>.</span></span>  
  
 <span data-ttu-id="95bd8-369">如果没有为<xref:System.AppDomainSetup.ShadowCopyDirectories%2A>属性分配字符串, 或者如果将此属性设置为`null`, 则<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>属性指定的目录中的所有程序集都将进行卷影复制。</span><span class="sxs-lookup"><span data-stu-id="95bd8-369">If you don't assign a string to the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property, or if you set this property to `null`, all assemblies in the directories specified by the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> properties are shadow copied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="95bd8-370">目录路径不能包含分号，因为分号是分隔符。</span><span class="sxs-lookup"><span data-stu-id="95bd8-370">Directory paths must not contain semicolons, because the semicolon is the delimiter character.</span></span> <span data-ttu-id="95bd8-371">分号没有转义符。</span><span class="sxs-lookup"><span data-stu-id="95bd8-371">There is no escape character for semicolons.</span></span>  
  
 <span data-ttu-id="95bd8-372">如果卷影复制生效, 则在加载程序集之前, 程序集文件将复制到另一个位置。</span><span class="sxs-lookup"><span data-stu-id="95bd8-372">When shadow copying is in effect, assembly files are copied to another location before the assemblies are loaded.</span></span> <span data-ttu-id="95bd8-373">原始程序集文件未锁定, 因此可进行更新。</span><span class="sxs-lookup"><span data-stu-id="95bd8-373">The original assembly file is not locked, so it can be updated.</span></span> <span data-ttu-id="95bd8-374">有关卷影复制的详细信息, 请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-374">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="95bd8-375">用于访问路径信息。</span><span class="sxs-lookup"><span data-stu-id="95bd8-375">for access to the path information.</span></span> <span data-ttu-id="95bd8-376">关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="95bd8-376">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="95bd8-377">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="95bd8-377">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public string ShadowCopyFiles { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Property ShadowCopyFiles As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ShadowCopyFiles { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : string with get, set" Usage="System.AppDomainSetup.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAppDomainSetup.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-378">获取或设置指示影像复制是打开还是关闭的字符串。</span><span class="sxs-lookup"><span data-stu-id="95bd8-378">Gets or sets a string that indicates whether shadow copying is turned on or off.</span></span></summary>
        <value><span data-ttu-id="95bd8-379">字符串值“true”指示打开了卷影复制；“false”则指示关闭了卷影复制。</span><span class="sxs-lookup"><span data-stu-id="95bd8-379">The string value "true" to indicate that shadow copying is turned on; or "false" to indicate that shadow copying is turned off.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-380">有关卷影复制的详细信息, 请参阅[卷影复制程序集](~/docs/framework/app-domains/shadow-copy-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="95bd8-380">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <altmember cref="P:System.AppDomainSetup.ShadowCopyDirectories" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="95bd8-381">卷影复制程序集</span><span class="sxs-lookup"><span data-stu-id="95bd8-381">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public string TargetFrameworkName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomainSetup.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetFrameworkName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.TargetFrameworkName : string with get, set" Usage="System.AppDomainSetup.TargetFrameworkName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="95bd8-382">获取或设置为应用程序域指定目标版本和 .NET Framework 配置文件的字符串，以可由 <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> 构造函数分析的格式。</span><span class="sxs-lookup"><span data-stu-id="95bd8-382">Gets or sets a string that specifies the target version and profile of the .NET Framework for the application domain, in a format that can be parsed by the <see cref="M:System.Runtime.Versioning.FrameworkName.#ctor(System.String)" /> constructor.</span></span></summary>
        <value><span data-ttu-id="95bd8-383">.NET Framework 的目标版本与配置文件。</span><span class="sxs-lookup"><span data-stu-id="95bd8-383">The target version and profile of the .NET Framework.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="95bd8-384">设置此属性, 告知当前正在运行的 .NET Framework 应用程序域将用于加载和运行已针对目标版本和配置文件编译的程序集的。</span><span class="sxs-lookup"><span data-stu-id="95bd8-384">Set this property to tell the currently running version of the .NET Framework that the application domain will be used to load and run assemblies that have been compiled for the target version and profile.</span></span> <span data-ttu-id="95bd8-385">如果当前运行的 .NET Framework 版本具有可影响使用目标版本编译的代码兼容性的可选行为, 则它可以根据需要启用或禁用这些行为以提高兼容性。</span><span class="sxs-lookup"><span data-stu-id="95bd8-385">If the currently running version of the .NET Framework has optional behaviors that affect the compatibility of code that was compiled with the target version, it can enable or disable those behaviors, as appropriate, to improve compatibility.</span></span> <span data-ttu-id="95bd8-386">当应用程序通过在单独的应用程序域中运行使用 .NET Framework 的多个版本编译的外接程序时, 这会很有用。</span><span class="sxs-lookup"><span data-stu-id="95bd8-386">This can be useful when an application supports add-ins compiled with multiple versions of the .NET Framework by running them in separate application domains.</span></span>  
  
 <span data-ttu-id="95bd8-387">对于客户端应用程序, <xref:System.AppDomainSetup.TargetFrameworkName%2A>属性的值<xref:System.Runtime.Versioning.TargetFrameworkAttribute>从属性中推断出来。</span><span class="sxs-lookup"><span data-stu-id="95bd8-387">For client applications, the value of the <xref:System.AppDomainSetup.TargetFrameworkName%2A> property is inferred from the <xref:System.Runtime.Versioning.TargetFrameworkAttribute> attribute.</span></span> <span data-ttu-id="95bd8-388">在[!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)]和更高版本中, 此属性基于项目的 "**目标框架**" 属性的设置自动添加到程序集中。</span><span class="sxs-lookup"><span data-stu-id="95bd8-388">In [!INCLUDE[vs_dev10_long](~/includes/vs-dev10-long-md.md)] and later, this attribute is added to the assembly automatically based on the setting of the project's **Target Framework** property.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
