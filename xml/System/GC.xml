<Type Name="GC" FullName="System.GC">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e1c18f82901a882b133deb9d96caaf88746649d3" /><Meta Name="ms.sourcegitcommit" Value="87817aa377ffe999787a084c8e8ca669080f1e6b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/19/2019" /><Meta Name="ms.locfileid" Value="68337254" /></Metadata><TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="ea2bb-101">控制系统垃圾回收器（一种自动回收未使用内存的服务）。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-102">垃圾回收器是公共语言运行时组件, 它控制托管内存的分配和释放。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="ea2bb-103">此类中的方法会影响在对象上执行垃圾回收的时间, 以及释放由对象分配的资源的时间。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="ea2bb-104">此类中的属性提供有关系统中可用的总内存量以及分配给对象的内存的总内存量的信息。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="ea2bb-105">垃圾回收器跟踪并回收托管内存中分配的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="ea2bb-106">垃圾回收器会定期执行垃圾回收, 以回收分配给没有有效引用的对象的内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="ea2bb-107">当使用可用可用内存无法满足内存请求时, 将自动进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="ea2bb-108">或者, 应用程序可以使用<xref:System.GC.Collect%2A>方法强制进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="ea2bb-109">垃圾回收包括以下步骤:</span><span class="sxs-lookup"><span data-stu-id="ea2bb-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="ea2bb-110">垃圾回收器搜索在托管代码中引用的托管对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="ea2bb-111">垃圾回收器尝试完成未引用的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="ea2bb-112">垃圾回收器释放未引用的对象并回收其内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="ea2bb-113">本主题包括以下部分：</span><span class="sxs-lookup"><span data-stu-id="ea2bb-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="ea2bb-114">[垃圾回收器和非托管资源](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="ea2bb-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="ea2bb-115">[对象老化和代](#generations) </span><span class="sxs-lookup"><span data-stu-id="ea2bb-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="ea2bb-116">禁止垃圾回收</span><span class="sxs-lookup"><span data-stu-id="ea2bb-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="ea2bb-117">垃圾回收器和非托管资源</span><span class="sxs-lookup"><span data-stu-id="ea2bb-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="ea2bb-118">在集合期间, 如果对象在托管代码中找到对对象的一个或多个引用, 则垃圾回收器不会释放对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="ea2bb-119">但是, 垃圾回收器不会从非托管代码识别对对象的引用, 并且可能会在非托管代码中独占使用对象, 除非明确禁止这样做。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="ea2bb-120"><xref:System.GC.KeepAlive%2A>方法提供了一种机制, 该机制可防止垃圾回收器收集仍在非托管代码中使用的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="ea2bb-121">除了托管内存分配外, 垃圾回收器的实现不会维护对象所持有的资源 (例如文件句柄或数据库连接) 的相关信息。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="ea2bb-122">当类型使用必须在回收类型的实例之前释放的非托管资源时, 该类型可以实现终结器。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="ea2bb-123">在大多数情况下, 通过重写<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法来实现终结器; 但是, 用编写C++ <xref:System.Object.Finalize%2A?displayProperty=nameWithType> C#或实现析构函数的类型, 编译器会转换为的重写。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ea2bb-124">在大多数情况下, 如果某个对象具有终结器, 垃圾回收器将在释放该对象之前调用它。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="ea2bb-125">但是, 在所有情况下, 都不需要垃圾回收器来调用终结器;例如, <xref:System.GC.SuppressFinalize%2A>方法显式阻止调用对象的终结器。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="ea2bb-126">此外, 垃圾回收器不需要使用特定线程来完成对象, 也不需要确保为彼此引用但可用于垃圾回收的对象调用终结器的顺序。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="ea2bb-127">在必须在特定时间释放资源的情况下, 类可以实现<xref:System.IDisposable>接口, 该接口包含执行资源管理和清理任务的<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="ea2bb-128">当类使用<xref:System.IDisposable.Dispose%2A>者调用方法清理对象时, 实现的类必须指定作为其类协定的一部分。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="ea2bb-129">默认情况下, 垃圾回收器不会调用<xref:System.IDisposable.Dispose%2A>方法; 但是, <xref:System.IDisposable.Dispose%2A>方法的实现<xref:System.GC>可以调用类中的方法来自定义垃圾回收器的终止行为。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="ea2bb-130">有关对象终止和释放模式的详细信息, 请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="ea2bb-131">对象老化和代</span><span class="sxs-lookup"><span data-stu-id="ea2bb-131">Object aging and generations</span></span>  
 <span data-ttu-id="ea2bb-132">公共语言运行时中的垃圾回收器支持使用代的对象老化。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="ea2bb-133">代是内存中对象的相对生存期的单位。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="ea2bb-134">对象的代数或 age 指示对象所属的代。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="ea2bb-135">最近创建的对象是较新的生成的一部分, 其生成号比之前在应用程序生命周期中创建的对象的生成号要低。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="ea2bb-136">最近一代中的对象位于第0代中。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="ea2bb-137">垃圾回收器的这种实现支持三代对象, 第0代、第1代和第2代。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="ea2bb-138">可以检索<xref:System.GC.MaxGeneration%2A>属性的值, 以确定系统支持的最大代数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="ea2bb-139">对象老化允许应用程序以一组特定的代进行垃圾回收, 而不需要垃圾回收器来评估所有代。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="ea2bb-140">包含参数的<xref:System.GC.Collect%2A>方法的重载允许您指定要进行垃圾回收的最早代。 `generation`</span><span class="sxs-lookup"><span data-stu-id="ea2bb-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="ea2bb-141">禁止垃圾回收</span><span class="sxs-lookup"><span data-stu-id="ea2bb-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="ea2bb-142">从开始, 垃圾回收器支持无 GC 区域延迟模式, 该模式可在关键路径执行期间使用, 在这种情况下, 垃圾回收可能会对应用的性能产生负面影响。 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ea2bb-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="ea2bb-143">无 GC 区域延迟模式要求您指定可在不干扰垃圾回收器的情况下分配的内存量。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="ea2bb-144">如果运行时可以分配该内存, 则运行时将不会在执行关键路径中的代码时执行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="ea2bb-145">可以通过调用的重载<xref:System.GC.TryStartNoGCRegion%2A>之一, 定义无 GC 区域的关键路径的开头。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="ea2bb-146">可以通过调用<xref:System.GC.EndNoGCRegion%2A>方法来指定其关键路径的末尾。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="ea2bb-147">不能嵌套对方法的<xref:System.GC.TryStartNoGCRegion%2A>调用, 并且应仅在运行时<xref:System.GC.EndNoGCRegion%2A>当前处于无 GC 区域延迟模式时调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="ea2bb-148">换句话说, 您不应调用<xref:System.GC.TryStartNoGCRegion%2A>多次 (在第一次调用方法后, 后续调用将不会成功), 并且您不应指望<xref:System.GC.EndNoGCRegion%2A>调用成功, <xref:System.GC.TryStartNoGCRegion%2A>因为首次调用 succeeded。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-149">下面的示例使用几个 GC 方法获取有关未使用的对象块的生成和内存信息, 并将其打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="ea2bb-150">然后收集未使用的对象, 并显示生成的内存总计。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md"><span data-ttu-id="ea2bb-151">垃圾回收</span><span class="sxs-lookup"><span data-stu-id="ea2bb-151">Garbage Collection</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="ea2bb-152">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="ea2bb-152">Fundamentals of Garbage Collection</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="ea2bb-153">已分配的非托管内存的增量。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-153">The incremental amount of unmanaged memory that has been allocated.</span></span></param>
        <summary><span data-ttu-id="ea2bb-154">通知运行时在安排垃圾回收时应考虑分配大量的非托管内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-155">在确定何时计划垃圾回收时, 运行时将考虑分配多少托管内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="ea2bb-156">如果某个小型托管对象分配了大量非托管内存, 则运行时将仅考虑托管内存, 从而低估计划垃圾回收的紧急性。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="ea2bb-157"><xref:System.GC.AddMemoryPressure%2A>方法将此额外压力通知给运行时系统内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="ea2bb-158">在最简单的用法模式下, 托管对象在构造函数中分配非托管内存, 并`Dispose`在`Finalize`或方法中释放它。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="ea2bb-159">在分配非托管内存后调用<xref:System.GC.RemoveMemoryPressure%2A> 方法,并在释放后调用方法。<xref:System.GC.AddMemoryPressure%2A></span><span class="sxs-lookup"><span data-stu-id="ea2bb-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="ea2bb-160">在更复杂的情况下, 如果非托管内存分配在托管对象的生存期内发生了重大更改, 则<xref:System.GC.AddMemoryPressure%2A>可以<xref:System.GC.RemoveMemoryPressure%2A>调用和方法将这些增量更改传递给运行时。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ea2bb-161">您必须确保完全删除所添加的压力。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="ea2bb-162">否则, 可能会对长时间运行的应用程序中系统的性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-163"><paramref name="bytesAllocated" /> 小于或等于 0。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-163"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="ea2bb-164">或</span><span class="sxs-lookup"><span data-stu-id="ea2bb-164">-or-</span></span> 
<span data-ttu-id="ea2bb-165">在 32 位的计算机上，<paramref name="bytesAllocated" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ea2bb-166">用于在操作垃圾回收优先级时调用非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="ea2bb-167">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="ea2bb-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-168">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-168">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-169">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-169">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ea2bb-170">取消注册垃圾回收通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-170">Cancels the registration of a garbage collection notification.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-171">此方法取消使用<xref:System.GC.RegisterForFullGCNotification%2A>方法注册的垃圾回收通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="ea2bb-172">在对<xref:System.GC.RegisterForFullGCNotification%2A>方法的后续调用中调整阈值参数值之前, 无需调用此方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-173">下面的示例取消垃圾回收的注册。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="ea2bb-174">此示例摘自为[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题提供的更大示例。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-175">此成员在启用并发垃圾回收时不可用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-175">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="ea2bb-176">若要了解如何禁用并发垃圾回收，请参阅 [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) 运行时设置。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ea2bb-177">表示完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-177">for full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-178">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-178">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-179">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-179">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-180">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-180">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="ea2bb-181">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="ea2bb-181">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ea2bb-182">强制进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-182">Forces garbage collection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ea2bb-183">强制对所有代进行即时垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-183">Forces an immediate garbage collection of all generations.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-184">使用此方法尝试回收所有无法访问的内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="ea2bb-185">它执行所有生成的阻止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="ea2bb-186">所有对象 (无论它们处于内存中的时长) 都视为集合;但是, 不会收集在托管代码中引用的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="ea2bb-187">使用此方法可强制系统尝试回收最大可用内存量。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="ea2bb-188">从开始<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> <xref:System.GC.Collect%2A> , 你可以通过在调用方法之前将属性设置为来压缩大型对象堆 (LOH), 如下面的示例所示。 [!INCLUDE[net_v451](~/includes/net-v451-md.md)]</span><span class="sxs-lookup"><span data-stu-id="ea2bb-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-189">下面的示例演示如何使用<xref:System.GC.Collect%2A>方法在所有内存代上执行集合。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="ea2bb-190">此代码会生成大量未使用的对象, 然后调用<xref:System.GC.Collect%2A>方法以从内存中清理它们。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="ea2bb-191">被动回收</span><span class="sxs-lookup"><span data-stu-id="ea2bb-191">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="ea2bb-192">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-192">The number of the oldest generation to be garbage collected.</span></span></param>
        <summary><span data-ttu-id="ea2bb-193">强制对 0 代到指定代进行即时垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-194">使用此方法尝试回收不可访问的内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="ea2bb-195">但是, 使用此方法并不保证回收指定代中所有无法访问的内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="ea2bb-196">如果实现了对象老化, 垃圾回收器不会收集版本号高于指定代的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="ea2bb-197">如果未实现对象老化, 垃圾回收器将在垃圾回收过程中考虑所有对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="ea2bb-198">使用属性可确定`generation`参数的最大有效值。 <xref:System.GC.MaxGeneration%2A></span><span class="sxs-lookup"><span data-stu-id="ea2bb-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="ea2bb-199">若要让垃圾回收器考虑所有对象, 而不管它们代有哪些, 请使用不带任何参数的此方法的版本。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="ea2bb-200">若要使垃圾回收器根据<xref:System.GCCollectionMode>设置回收对象, 请<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType>使用方法重载。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-201">下面的示例演示如何使用<xref:System.GC.Collect%2A>方法来执行单个内存层上的集合。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="ea2bb-202">此代码会生成大量未使用的对象, 然后调用<xref:System.GC.Collect%2A>方法以从内存中清理它们。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-203"><paramref name="generation" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-203"><paramref name="generation" /> is not valid.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="ea2bb-204">被动回收</span><span class="sxs-lookup"><span data-stu-id="ea2bb-204">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="ea2bb-205">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-205">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="ea2bb-206">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <summary><span data-ttu-id="ea2bb-207">强制在 <see cref="T:System.GCCollectionMode" /> 值所指定的时间对 0 代到指定代进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-208">`mode`使用参数可以指定垃圾回收应立即发生还是仅在回收对象的最佳时间时进行。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="ea2bb-209">使用此方法不能保证回收指定代中的所有无法访问的内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="ea2bb-210">若要在应用程序的关键期间调整垃圾回收的侵入性, 请设置<xref:System.Runtime.GCSettings.LatencyMode%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="ea2bb-211">垃圾回收器不会收集版本号高于`generation`参数指定的代数的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="ea2bb-212">使用属性可确定的`generation`最大有效值。 <xref:System.GC.MaxGeneration%2A></span><span class="sxs-lookup"><span data-stu-id="ea2bb-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="ea2bb-213">若要让垃圾回收器考虑所有对象, 而不管它们代有哪些, 请使用不带任何参数的此方法的版本。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="ea2bb-214">若要使垃圾回收器回收对象直至指定的对象生成, 请使用<xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="ea2bb-215">指定最大生成时, 将收集所有对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-216">下面的示例使用<xref:System.GCCollectionMode.Optimized>设置强制执行第2代对象的垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-217"><paramref name="generation" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-217"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="ea2bb-218">或</span><span class="sxs-lookup"><span data-stu-id="ea2bb-218">-or-</span></span> 
 <span data-ttu-id="ea2bb-219"><paramref name="mode" /> 不是 <see cref="T:System.GCCollectionMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-219"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149"><span data-ttu-id="ea2bb-220">被动回收</span><span class="sxs-lookup"><span data-stu-id="ea2bb-220">Induced Collections</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="ea2bb-221">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-221">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="ea2bb-222">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="ea2bb-223"><see langword="true" /> 执行阻碍性垃圾回收；<see langword="false" /> 在可能的情况下执行后台垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-223"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <summary><span data-ttu-id="ea2bb-224">在由 <see cref="T:System.GCCollectionMode" /> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收是否应该为阻碍性。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-225">下表总结了`mode`和`blocking`参数的交互:</span><span class="sxs-lookup"><span data-stu-id="ea2bb-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="ea2bb-226">`blocking` 为 `true`</span><span class="sxs-lookup"><span data-stu-id="ea2bb-226">`blocking` is `true`</span></span>|<span data-ttu-id="ea2bb-227">`blocking` 为 `false`</span><span class="sxs-lookup"><span data-stu-id="ea2bb-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="ea2bb-228"><xref:System.GCCollectionMode.Forced> 或 <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="ea2bb-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="ea2bb-229">尽快执行阻塞回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="ea2bb-230">如果后台回收正在进行, 并且`generation`为0或 1, 则该方法将<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>立即触发阻塞回收, 并在回收完成后返回。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="ea2bb-231">如果后台回收正在进行, 并且`generation`为 2, 则该方法将一直等待, 直到后台收集完成, 触发一个阻止第2代回收, 然后返回。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="ea2bb-232">尽快执行回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="ea2bb-233"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="ea2bb-234">如果后台回收正在进行，该方法将立即返回。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="ea2bb-235">可能会执行阻止式回收，具体视垃圾回收器的状态和 `generation` 参数而定。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="ea2bb-236">垃圾回收器会尽量提供最佳性能。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="ea2bb-237">根据垃圾回收器的状态，有时可执行回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="ea2bb-238"><xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> 方法请求执行后台回收，但这并没有保证；阻止式回收仍可执行，具体视环境而定。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="ea2bb-239">垃圾回收器会尽量提供最佳性能。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="ea2bb-240">如果后台回收正在进行，该方法将立即返回。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="ea2bb-241">如果对<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29>方法的调用执行完全阻止性垃圾回收, 还可以通过在调用<xref:System.GC.Collect%2A>方法之前<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>将属性设置为来<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>压缩大型对象堆。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-242"><paramref name="generation" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-242"><paramref name="generation" /> is not valid.</span></span>  
  
<span data-ttu-id="ea2bb-243">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ea2bb-243">-or-</span></span> 
 <span data-ttu-id="ea2bb-244"><paramref name="mode" /> 不是 <see cref="T:System.GCCollectionMode" /> 值之一。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-244"><paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="mode" Type="System.GCCollectionMode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="blocking" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="compacting" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="ea2bb-245">最后一代进行垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-245">The number of the oldest generation to be garbage collected.</span></span></param>
        <param name="mode"><span data-ttu-id="ea2bb-246">一个枚举值，指定垃圾回收是强制进行（<see cref="F:System.GCCollectionMode.Default" /> 或 <see cref="F:System.GCCollectionMode.Forced" />）还是优化 (<see cref="F:System.GCCollectionMode.Optimized" />)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span></span></param>
        <param name="blocking"><span data-ttu-id="ea2bb-247"><see langword="true" /> 执行阻碍性垃圾回收；<see langword="false" /> 在可能的情况下执行后台垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-247"><see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span></span></param>
        <param name="compacting"><span data-ttu-id="ea2bb-248"><see langword="true" /> 表示压缩小对象堆；<see langword="false" /> 表示仅进行清理。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-248"><see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span></span></param>
        <summary><span data-ttu-id="ea2bb-249">在由 <see cref="T:System.GCCollectionMode" /> 值指定的时间，强制对 0 代到指定代进行垃圾回收，另有数值指定回收应该为阻碍性还是压缩性。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-250">如果`blocking` 为`false`, 则 GC 决定是执行后台还是阻止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="ea2bb-251">如果`compacting` 为`true`, 则它将执行阻止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="ea2bb-252">如果`compacting` 为`true`, 则运行时将压缩小对象堆 (SOH)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="ea2bb-253">如果<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>将属性设置为<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>, 则不会压缩大型对象堆 (LOH)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ea2bb-254">请注意, 这包括所有阻碍性垃圾回收, 而不只是完全阻止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="ea2bb-255">可以调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法, 将托管堆减小到尽可能最小的大小, 如以下代码片段所示。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="ea2bb-256">为参数指定`true`可保证压缩、完全阻碍性垃圾回收。`compacting`</span><span class="sxs-lookup"><span data-stu-id="ea2bb-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="ea2bb-257">设置属性以<xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>确保 LOH 和 SOH 都已压缩。 <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="ea2bb-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generation"><span data-ttu-id="ea2bb-258">对象的代，将针对此代确定垃圾回收计数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-258">The generation of objects for which the garbage collection count is to be determined.</span></span></param>
        <summary><span data-ttu-id="ea2bb-259">返回已经对对象的指定代进行的垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-260">自启动进程以来已经对指定代进行的垃圾回收次数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-261">如果实现自己的资源管理, 则可能需要通过调用<xref:System.GC.Collect%2A>方法来定期强制进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="ea2bb-262">由于这是一种代价高昂的操作, 因此可以通过在最近发生垃圾回收时跳过调用来提高性能。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="ea2bb-263">在调用<xref:System.GC.CollectionCount%2A> <xref:System.GC.Collect%2A>后立即保存返回的值。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="ea2bb-264">下次需要调用<xref:System.GC.Collect%2A>时, 将<xref:System.GC.CollectionCount%2A>返回的当前值与保存的值进行比较。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="ea2bb-265">如果两个值相等, 则说明中间没有出现任何集合, 并且合理地调用<xref:System.GC.Collect%2A> 。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-266"><paramref name="generation" /> 小于 0。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-266"><paramref name="generation" /> is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ea2bb-267">结束无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-267">Ends the no GC region latency mode.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-268">如果垃圾回收器不处于无 GC 区域延迟模式, 则<xref:System.GC.EndNoGCRegion%2A>方法将引发。 <xref:System.InvalidOperationException></span><span class="sxs-lookup"><span data-stu-id="ea2bb-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="ea2bb-269">在以下任一情况下会发生此情况:</span><span class="sxs-lookup"><span data-stu-id="ea2bb-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="ea2bb-270">之前未调用方法。 <xref:System.GC.TryStartNoGCRegion%2A></span><span class="sxs-lookup"><span data-stu-id="ea2bb-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="ea2bb-271">对<xref:System.GC.TryStartNoGCRegion%2A>方法的调用返回`false`。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="ea2bb-272">对<xref:System.GC.TryStartNoGCRegion%2A>方法的调用引发了异常。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="ea2bb-273">可以通过使用如下所示的代码来防止发生异常:</span><span class="sxs-lookup"><span data-stu-id="ea2bb-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-274">垃圾回收器不处于无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-274">The garbage collector is not in no GC region latency mode.</span></span>  
  
<span data-ttu-id="ea2bb-275">或</span><span class="sxs-lookup"><span data-stu-id="ea2bb-275">-or-</span></span> 
<span data-ttu-id="ea2bb-276">无 GC 区域延迟模式已结束，可能是因为已引发垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span></span>  
  
<span data-ttu-id="ea2bb-277">- 或 -</span><span class="sxs-lookup"><span data-stu-id="ea2bb-277">-or-</span></span> 
<span data-ttu-id="ea2bb-278">内存分配超过了 <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> 方法调用中指定的量。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span></span></exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="ea2bb-279">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="ea2bb-279">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ea2bb-280">获取自当前线程的生存期开始以来分配给它的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-281">自当前线程的生存期开始以来分配给它的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="ea2bb-282">`GetAllocatedBytesForCurrentThread`方法返回在线程的生存期内在托管堆上分配的总字节数, 而不是在垃圾回收后的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="ea2bb-283">返回的值还不包括任何本机分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="ea2bb-284">此方法对于测量时间间隔或事件之间的内存分配差异的监视方案最为有用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-284">This method is most useful in monitoring scenarios for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGCMemoryInfo">
      <MemberSignature Language="C#" Value="public static GCMemoryInfo GetGCMemoryInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCMemoryInfo GetGCMemoryInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGCMemoryInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGCMemoryInfo () As GCMemoryInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCMemoryInfo GetGCMemoryInfo();" />
      <MemberSignature Language="F#" Value="static member GetGCMemoryInfo : unit -&gt; GCMemoryInfo" Usage="System.GC.GetGCMemoryInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.GCMemoryInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ea2bb-285">返回对象的当前代数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-285">Returns the current generation number of an object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ea2bb-286">检索其代信息的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-286">The object that generation information is retrieved for.</span></span></param>
        <summary><span data-ttu-id="ea2bb-287">返回指定对象的当前代数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-287">Returns the current generation number of the specified object.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-288"><paramref name="obj" /> 的当前代数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-288">The current generation number of <paramref name="obj" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-289">使用此方法来确定对象的使用期限, 然后将该信息与<xref:System.GC.Collect%2A>方法一起使用, 以强制垃圾回收器收集同一代中的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-289">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="ea2bb-290">例如, 如果有一组对象以组的形式创建, 且同时变为不可访问, 则可使用此方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-290">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-291">下面的示例演示如何使用<xref:System.GC.GetGeneration%2A>方法来确定对象的时间。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-291">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="ea2bb-292">然后, 该示例执行垃圾回收以清理内存, 并在控制台中比较 pre 和 post 收集的内存总计。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-292">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="wo"><span data-ttu-id="ea2bb-293">引用要确定其代数的目标对象的 <see cref="T:System.WeakReference" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-293">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span></span></param>
        <summary><span data-ttu-id="ea2bb-294">返回指定弱引用的目标的当前代数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-294">Returns the current generation number of the target of a specified weak reference.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-295"><paramref name="wo" /> 的目标的当前代数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-295">The current generation number of the target of <paramref name="wo" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ea2bb-296">下面的示例演示如何使用<xref:System.GC.GetGeneration%2A>方法来确定弱引用对象的生存期。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-296">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ea2bb-297">已经对 <paramref name="wo" /> 执行了垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-297">Garbage collection has already been performed on <paramref name="wo" />.</span></span></exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalAllocatedBytes">
      <MemberSignature Language="C#" Value="public static long GetTotalAllocatedBytes (bool precise = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalAllocatedBytes(bool precise) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalAllocatedBytes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalAllocatedBytes (Optional precise As Boolean = false) As Long" />
      <MemberSignature Language="F#" Value="static member GetTotalAllocatedBytes : bool -&gt; int64" Usage="System.GC.GetTotalAllocatedBytes precise" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="precise" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="precise"><span data-ttu-id="ea2bb-298">如果为 <see langword="true" />，则收集一个精确的数字；否则，收集近似计数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-298">If <see langword="true" />, gather a precise number; otherwise, gather an approximate count.</span></span> <span data-ttu-id="ea2bb-299">收集精确值会大大降低性能。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-299">Gathering a precise value entails a significant performance penalty.</span></span></param>
        <summary><span data-ttu-id="ea2bb-300">获取在进程生命周期内分配的字节计数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-300">Gets a count of the bytes allocated over the lifetime of the process.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-301">在进程生命周期内分配的总字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-301">The total number of bytes allocated over the lifetime of the process.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection"><span data-ttu-id="ea2bb-302">如果此方法可以在返回之前等待垃圾回收发生，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-302"><see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ea2bb-303">检索当前认为要分配的字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-303">Retrieves the number of bytes currently thought to be allocated.</span></span> <span data-ttu-id="ea2bb-304">一个参数，指示此方法是否可以等待较短间隔再返回，以便系统回收垃圾和终结对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-304">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-305">一个数字，它是托管内存中当前所分配字节数的可用的最佳近似值。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-305">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-306">如果参数为`true`, 则在系统收集垃圾和终结对象时, 此方法将等待较短的时间间隔。 `forceFullCollection`</span><span class="sxs-lookup"><span data-stu-id="ea2bb-306">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="ea2bb-307">间隔的持续时间是一个内部指定的限制, 由已完成的垃圾回收周期数和循环之间的内存恢复量决定。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-307">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="ea2bb-308">垃圾回收器不保证收集所有不可访问的内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-308">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-309">下面的示例演示如何使用<xref:System.GC.GetTotalMemory%2A>方法来获取和显示托管内存中当前分配的字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-309">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ea2bb-310">要引用的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-310">The object to reference.</span></span></param>
        <summary><span data-ttu-id="ea2bb-311">引用指定对象，使其从当前例程开始到调用此方法的那一刻为止均不符合进行垃圾回收的条件。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-311">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-312">此<xref:System.GC.KeepAlive%2A>方法的目的是确保存在对某个对象的引用, 而该对象存在于垃圾回收器过早回收的风险。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-312">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="ea2bb-313">这种情况的常见情况是, 在托管代码或数据中没有对该对象的引用, 但该对象仍在非托管代码 (如 Windows Api、非托管 Dll 或使用 COM 的方法) 中使用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-313">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Windows APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="ea2bb-314">此方法引用`obj`参数, 使该对象不符合从例程开始到调用此方法的点 (在执行顺序中) 的垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-314">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="ea2bb-315">在`obj`必须可用的指令范围的末尾 (而不是开始) 对此方法进行编码。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-315">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="ea2bb-316"><xref:System.GC.KeepAlive%2A>方法不执行任何操作, 并且不会对作为参数传入的对象的生存期进行扩展, 因此不会产生副作用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-316">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-317">下面的代码示例在其`Main`方法的开头创建一个对象, 在调用该<xref:System.GC.KeepAlive%2A>方法时, 该对象不会再次引用该对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-317">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="ea2bb-318">尽管调用了`Main` <xref:System.GC.Collect%2A>和<xref:System.GC.WaitForPendingFinalizers%2A>方法, 对象仍会在方法的30秒内持续。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-318">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ea2bb-319">获取系统当前支持的最大代数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-319">Gets the maximum number of generations that the system currently supports.</span></span></summary>
        <value><span data-ttu-id="ea2bb-320">从零到所支持的最大代数间的一个值。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-320">A value that ranges from zero to the maximum number of supported generations.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-321">对象的代数或 age 是对象生命周期的实现定义的相对度量值。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-321">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="ea2bb-322">最近创建的对象位于第0代中, 最旧的对象在代中的生成小于或等于<xref:System.GC.MaxGeneration%2A>属性返回的代。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-322">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="ea2bb-323">垃圾回收器假设较新的内存更有可能符合旧内存的垃圾回收的条件。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-323">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="ea2bb-324">因此, 垃圾回收器会在每次回收内存时调整代数, 提高其性能, 而<xref:System.GC.MaxGeneration%2A>属性值会随着时间的推移而增加。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-324">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="ea2bb-325">如果实现了对象老化, 则<xref:System.GC.MaxGeneration%2A>属性将返回系统使用的最大代数; 否则, 此属性将返回零。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-325">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-326">下面的示例演示如何使用 MaxGeneration 属性来显示当前正在使用的最大世代号。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-326">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="ea2bb-327">对于此实现, 由<see cref="P:System.GC.MaxGeneration" />属性返回的值保证在执行应用程序的生存期内保持不变。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-327">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span></span>  
  
<span data-ttu-id="ea2bb-328">使用属性可确定在<see cref="M:System.GC.Collect(System.Int32)" />调用采用生成参数的方法时可以指定的最大值。 <see cref="P:System.GC.MaxGeneration" /></span><span class="sxs-lookup"><span data-stu-id="ea2bb-328">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span></span></para></block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold"><span data-ttu-id="ea2bb-329">一个介于 1 和 99 之间的数字，指定根据在第 2 代中分配的对象，应何时引发通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-329">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span></span></param>
        <param name="largeObjectHeapThreshold"><span data-ttu-id="ea2bb-330">一个介于 1 和 99 之间的数字，指定根据大对象堆中分配的对象，应何时引发通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-330">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span></span></param>
        <summary><span data-ttu-id="ea2bb-331">指定当条件支持完整垃圾回收以及回收完成时，应引发垃圾回收通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-331">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-332">对于每个代, 垃圾回收器会将分配的阈值设置为该代。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-332">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="ea2bb-333">当分配的大小超过此阈值时, 将在该生成上触发垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-333">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="ea2bb-334">例如, 如果第2代的阈值为 20MB (这意味着20MB 置第1代回收, 并提升为第2代), 超过 20% 的第1代, 并提示第2代, 则将尝试下一次垃圾回收作为第2代回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-334">For example, if generation 2's threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="ea2bb-335">同样, 如果大对象堆 (LOH) 的阈值为 20MB, 而你的应用已分配超过20MB 的大型对象, 则下一次垃圾回收也将作为第2代回收进行, 因为 LOH 只收集在 gen2 垃圾回收中。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-335">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="ea2bb-336">`maxGenerationThreshold` 和`largeObjectHeapThreshold`阈值控制在进行完整垃圾回收之前通知您的进度。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-336">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="ea2bb-337">阈值越高, 通知与下一次完整垃圾回收之间可能发生的分配越多。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-337">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="ea2bb-338">如果你在某些情况下, 公共语言运行时的完整垃圾回收会对应用程序的性能产生负面影响, 则你可以要求在运行时要进行完整垃圾回收时收到通知, 并通过当条件仍有利时, 引入<xref:System.GC.Collect%2A>回收集合 (使用方法)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-338">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="ea2bb-339">除了自行更改垃圾回收计划之外, 在以下情况下, 完整的 GC 通知会很有用:</span><span class="sxs-lookup"><span data-stu-id="ea2bb-339">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="ea2bb-340">你需要监视完整垃圾回收的方法, 并在收到通知时, 减少实时数据大小 (例如, 通过释放一些缓存条目)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-340">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="ea2bb-341">因此, 垃圾回收发生时, 可以回收更多内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-341">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="ea2bb-342">你监视已完成的完整垃圾回收, 以便收集一些统计信息。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-342">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="ea2bb-343">例如, 你可能想要在 GC 完成时测量堆的大小, 以便了解实时数据的大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-343">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="ea2bb-344">(在完全 GC 后, 堆的大小最小。)</span><span class="sxs-lookup"><span data-stu-id="ea2bb-344">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="ea2bb-345">有关什么表示完整垃圾回收的详细信息, 请参阅[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-345">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="ea2bb-346">当你注册垃圾回收通知时, 你可以在完全垃圾回收接近和完成时收到通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-346">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="ea2bb-347">此模式类似于操作系统监视内存不足通知的方式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-347">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="ea2bb-348">指定`maxGenerationThreshold` 和`largeObjectHeapThreshold`参数时, 请遵循以下准则:</span><span class="sxs-lookup"><span data-stu-id="ea2bb-348">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="ea2bb-349">阈值越大, 通知与完整垃圾回收之间发生的分配就越多。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-349">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="ea2bb-350">较大的阈值为运行时检查接近的集合提供了更多机会。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-350">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="ea2bb-351">这会增加您收到通知的可能性。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-351">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="ea2bb-352">但是, 您不应将阈值设置得太高, 因为这样会导致在运行时引发下一个集合之前分配更多。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-352">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="ea2bb-353">使用高阈值的通知自行引发回收时, 回收的对象比运行时的下一个集合回收的对象更少。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-353">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="ea2bb-354">阈值越小, 通知与完整垃圾回收之间的分配越少。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-354">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-355">下面的示例演示如何注册垃圾回收通知并启动一个线程来监视垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-355">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="ea2bb-356">此代码示例是为[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-356">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-357"><paramref name="maxGenerationThreshold" /> 或 <paramref name="largeObjectHeapThreshold" /> 不在 1 和 99 之间。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-357"><paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ea2bb-358">表示完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-358">for full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-359">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-359">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-360">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-360">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-361">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-361">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="ea2bb-362">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="ea2bb-362">Garbage Collection Notifications</span></span></related>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-363">此成员在启用并发垃圾回收时不可用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-363">This member is not available when concurrent garbage collection is enabled.</span></span> <span data-ttu-id="ea2bb-364">若要了解如何禁用并发垃圾回收，请参阅 &lt;gcConcurrent&gt; 运行时设置。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-364">See the &lt;gcConcurrent&gt; runtime setting for information about how to disable concurrent garbage collection.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated"><span data-ttu-id="ea2bb-365">已释放的非托管内存量。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-365">The amount of unmanaged memory that has been released.</span></span></param>
        <summary><span data-ttu-id="ea2bb-366">通知运行时已释放非托管内存，在安排垃圾回收时不需要再考虑它。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-366">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-367">在确定何时计划垃圾回收时, 运行时将考虑分配多少托管内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-367">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="ea2bb-368">如果某个小型托管对象分配了大量非托管内存, 则运行时将仅考虑托管内存, 从而低估计划垃圾回收的紧急性。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-368">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="ea2bb-369">方法会向运行时通知系统内存的这一额外压力, <xref:System.GC.RemoveMemoryPressure%2A>方法会通知运行时已释放额外压力。 <xref:System.GC.AddMemoryPressure%2A></span><span class="sxs-lookup"><span data-stu-id="ea2bb-369">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="ea2bb-370">在最简单的用法模式下, 托管对象在构造函数中分配非托管内存, 并`Dispose`在`Finalize`或方法中释放它。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-370">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="ea2bb-371">在分配非托管内存后调用<xref:System.GC.RemoveMemoryPressure%2A> 方法,并在释放后调用方法。<xref:System.GC.AddMemoryPressure%2A></span><span class="sxs-lookup"><span data-stu-id="ea2bb-371">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="ea2bb-372">在更复杂的情况下, 如果非托管内存分配在托管对象的生存期内发生了重大更改, 则<xref:System.GC.AddMemoryPressure%2A>可以<xref:System.GC.RemoveMemoryPressure%2A>调用和方法将这些增量更改传递给运行时。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-372">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ea2bb-373">您必须确保完全删除所添加的压力。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-373">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="ea2bb-374">否则, 可能会对长时间运行的应用程序中系统的性能产生负面影响。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-374">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-375"><paramref name="bytesAllocated" /> 小于或等于 0。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-375"><paramref name="bytesAllocated" /> is less than or equal to 0.</span></span>  
  
<span data-ttu-id="ea2bb-376">或</span><span class="sxs-lookup"><span data-stu-id="ea2bb-376">-or-</span></span> 
<span data-ttu-id="ea2bb-377">在 32 位的计算机上，<paramref name="bytesAllocated" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-377">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ea2bb-378">用于在操作垃圾回收优先级时调用非托管代码的能力。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-378">for the ability to call unmanaged code when manipulating garbage-collection priority.</span></span> <span data-ttu-id="ea2bb-379">关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="ea2bb-379">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-380">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-380">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-381">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-381">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ea2bb-382">必须为其调用终结器的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-382">The object that a finalizer must be called for.</span></span></param>
        <summary><span data-ttu-id="ea2bb-383">请求系统调用指定对象的终结器，此前已为该对象调用 <see cref="M:System.GC.SuppressFinalize(System.Object)" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-383">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-384"><xref:System.GC.ReRegisterForFinalize%2A> 方法`obj`将参数添加到在垃圾回收器释放对象之前请求终止的对象的列表中。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-384">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="ea2bb-385">`obj`参数必须是此方法的调用方。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-385">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="ea2bb-386"><xref:System.GC.ReRegisterForFinalize%2A>调用方法并不保证垃圾回收器将调用对象的终结器。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-386">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="ea2bb-387">默认情况下, 实现终结器的所有对象都将添加到需要完成的对象列表中;但是, 对象可能已经完成了, 或者通过调用<xref:System.GC.SuppressFinalize%2A>方法禁用了终止。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-387">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="ea2bb-388">终结器可以使用此方法恢复自身或其引用的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-388">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-389">下面的示例演示如何使用 ReRegisterForFinalize 方法在垃圾回收后第二次完成一个对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-389">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ea2bb-390"><paramref name="obj" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-390"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="ea2bb-391">不得执行其终结器的对象。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-391">The object whose finalizer must not be executed.</span></span></param>
        <summary><span data-ttu-id="ea2bb-392">请求公共语言运行时不要调用指定对象的终结器。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-392">Requests that the common language runtime not call the finalizer for the specified object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-393">此方法在的对象标头`obj`中设置一个位, 在调用终结器时, 运行时将检查该位。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-393">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="ea2bb-394">由<xref:System.Object.Finalize%2A?displayProperty=nameWithType>方法表示的终结器用于在对对象进行垃圾回收之前释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-394">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="ea2bb-395">如果`obj`没有终结器, 则对<xref:System.GC.SuppressFinalize%2A>方法的调用不起作用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-395">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="ea2bb-396">实现<xref:System.IDisposable>接口的对象可以从对象的<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现中调用此方法, 以防止垃圾回收器在不<xref:System.Object.Finalize%2A?displayProperty=nameWithType>需要它的对象上调用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-396">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="ea2bb-397">通常, 这样做是为了防止终结器释放已由<xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType>实现释放的非托管资源。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-397">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-398">下面的示例演示如何使用资源类<xref:System.GC.SuppressFinalize%2A>中的方法来防止调用冗余垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-398">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="ea2bb-399">该示例使用[dispose 模式](~/docs/standard/garbage-collection/implementing-dispose.md)来释放托管资源 (即实现<xref:System.IDisposable>的对象) 和非托管资源。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-399">The example uses the [dispose pattern](~/docs/standard/garbage-collection/implementing-dispose.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ea2bb-400"><paramref name="obj" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-400"><paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb"><span data-ttu-id="ea2bb-401">释放模式</span><span class="sxs-lookup"><span data-stu-id="ea2bb-401">Dispose Pattern</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ea2bb-402">在关键路径执行期间尝试禁止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-402">Attempts to disallow garbage collection during the execution of a critical path.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ea2bb-403">不能嵌套对方法的<xref:System.GC.TryStartNoGCRegion%2A>调用, 并且应仅在运行时<xref:System.GC.EndNoGCRegion%2A>当前处于无 GC 区域延迟模式时调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-403">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="ea2bb-404">换句话说, 您不应调用<xref:System.GC.TryStartNoGCRegion%2A>多次 (在第一次调用方法后, 后续调用将不会成功), 并且您不应指望<xref:System.GC.EndNoGCRegion%2A>调用成功, <xref:System.GC.TryStartNoGCRegion%2A>因为首次调用 succeeded。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-404">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="ea2bb-405">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-405">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="ea2bb-406">它必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-406">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="ea2bb-407">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-407">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <summary><span data-ttu-id="ea2bb-408">如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-408">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-409">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-409"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-410">此<xref:System.GC.TryStartNoGCRegion%28System.Int64%29>方法尝试将垃圾回收器置于无 GC 区域延迟模式, 这在应用执行关键的代码区域时不允许垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-410">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="ea2bb-411">如果运行时无法最初分配所请求的内存量, 垃圾回收器将执行完全阻止性垃圾回收, 尝试释放更多内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-411">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="ea2bb-412">如果垃圾回收器能够分配所需的内存量 (在本例中为 2 \* `totalSize`个字节, 则它会尝试为小对象堆分配`totalSize`字节, `totalSize`为大型对象堆)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-412">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="ea2bb-413">`totalSize`必须足够大才能处理在关键路径中发生的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-413">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="ea2bb-414">这包括应用的分配以及运行时代表应用程序进行的分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-414">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ea2bb-415">不能嵌套对方法的<xref:System.GC.TryStartNoGCRegion%2A>调用, 并且应仅在运行时<xref:System.GC.EndNoGCRegion%2A>当前处于无 GC 区域延迟模式时调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-415">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="ea2bb-416">换句话说, 您不应调用<xref:System.GC.TryStartNoGCRegion%2A>多次 (在第一次调用方法后, 后续调用将不会成功), 并且您不应指望<xref:System.GC.EndNoGCRegion%2A>调用成功, <xref:System.GC.TryStartNoGCRegion%2A>因为首次调用 succeeded。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-416">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="ea2bb-417">可以通过调用<xref:System.GC.EndNoGCRegion%2A>方法退出无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-417">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-418"><paramref name="totalSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-418"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-419">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-419">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="ea2bb-420">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="ea2bb-420">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="ea2bb-421">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="ea2bb-421">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="ea2bb-422">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-422">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="ea2bb-423">它必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-423">It must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="ea2bb-424">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-424">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="ea2bb-425"><see langword="true" /> 表示如果垃圾回收器初始无法分配 <paramref name="totalSize" /> 字节，则忽略完整的阻碍性垃圾回收；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-425"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ea2bb-426">如果指定数量的内存可用，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-426">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-427">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-427"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-428">此<xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29>方法尝试将垃圾回收器置于无 GC 区域延迟模式, 这在应用执行关键的代码区域时不允许垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-428">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="ea2bb-429">如果运行时无法最初分配所请求的内存量, 并且`disallowFullBlockingGC`参数为`false`, 则垃圾回收器将在尝试释放更多内存时执行完全阻止性垃圾回收; 否则, 分配失败, 且方法返回`false`。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-429">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="ea2bb-430">如果垃圾回收器能够分配所需的内存量 (在这种情况下`totalSize` , 它会尝试为小对象堆和`totalSize`大型对象分配`totalSize` ), 则垃圾回收器不会输入 GC 区域延迟模式。堆)。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-430">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="ea2bb-431">`totalSize`必须足够大才能处理在关键路径中发生的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-431">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="ea2bb-432">这包括应用的分配以及运行时代表应用程序进行的分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-432">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="ea2bb-433">如果`disallowFullBlockingGC`没有`true`足够的内存可供初始使用时, 将设置为以防止完全阻止垃圾回收在负载平衡方案中最有用: 一个系统可以调用此方法, 并在返回, 并让负载均衡器将请求重定向到其他系统 ( `false`如果它返回)。 `true`</span><span class="sxs-lookup"><span data-stu-id="ea2bb-433">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="ea2bb-434">然后, 在通过调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法来处理请求时, 它可以执行完全阻止性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-434">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ea2bb-435">不能嵌套对方法的<xref:System.GC.TryStartNoGCRegion%2A>调用, 并且应仅在运行时<xref:System.GC.EndNoGCRegion%2A>当前处于无 GC 区域延迟模式时调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-435">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="ea2bb-436">换句话说, 您不应调用<xref:System.GC.TryStartNoGCRegion%2A>多次 (在第一次调用方法后, 后续调用将不会成功), 并且您不应指望<xref:System.GC.EndNoGCRegion%2A>调用成功, <xref:System.GC.TryStartNoGCRegion%2A>因为首次调用 succeeded。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-436">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="ea2bb-437">可以通过调用<xref:System.GC.EndNoGCRegion%2A>方法退出无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-437">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-438"><paramref name="totalSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-438"><paramref name="totalSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-439">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-439">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="ea2bb-440">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="ea2bb-440">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="ea2bb-441">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="ea2bb-441">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="ea2bb-442">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-442">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="ea2bb-443"><paramref name="totalSize" /> -<paramref name="lohSize" /> 必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-443"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="ea2bb-444">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-444">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="ea2bb-445"><paramref name="totalSize" /> 中用于大对象堆 (LOH) 分配的字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-445">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <summary><span data-ttu-id="ea2bb-446">如果指定数量的内存可用于大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-446">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-447">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-447"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-448">此<xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29>方法尝试将垃圾回收器置于无 GC 区域延迟模式, 这在应用执行关键的代码区域时不允许垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-448">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="ea2bb-449">如果运行时无法最初分配所请求的内存量, 垃圾回收器将执行完全阻止性垃圾回收, 尝试释放更多内存。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-449">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="ea2bb-450">如果垃圾回收器能够为 LOH 分配并为小对象堆 (SOH `lohSize` ) 分配, `totalSize`  -  `lohSize`则垃圾回收器不会输入 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-450">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="ea2bb-451">`lohSize`必须足够大, 以便处理 LOH 的关键路径中发生的所有内存分配, 并且`totalSize`  -  `lohSize`必须足够大才能处理 SOH 关键路径中发生的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-451">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="ea2bb-452">这包括应用的分配以及运行时代表应用程序进行的分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-452">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ea2bb-453">不能嵌套对方法的<xref:System.GC.TryStartNoGCRegion%2A>调用, 并且应仅在运行时<xref:System.GC.EndNoGCRegion%2A>当前处于无 GC 区域延迟模式时调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-453">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="ea2bb-454">换句话说, 您不应调用<xref:System.GC.TryStartNoGCRegion%2A>多次 (在第一次调用方法后, 后续调用将不会成功), 并且您不应指望<xref:System.GC.EndNoGCRegion%2A>调用成功, <xref:System.GC.TryStartNoGCRegion%2A>因为首次调用 succeeded。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-454">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="ea2bb-455">可以通过调用<xref:System.GC.EndNoGCRegion%2A>方法退出无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-455">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-456"><paramref name="totalSize" /> - <paramref name="lohSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-456"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-457">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-457">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="ea2bb-458">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="ea2bb-458">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="ea2bb-459">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="ea2bb-459">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="lohSize" Type="System.Int64" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="totalSize"><span data-ttu-id="ea2bb-460">在不会触发垃圾回收的情况下分配的内存量（以字节为单位）。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-460">The amount of memory in bytes to allocate without triggering a garbage collection.</span></span> <span data-ttu-id="ea2bb-461"><paramref name="totalSize" /> -<paramref name="lohSize" /> 必须小于或等于临时段的大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-461"><paramref name="totalSize" /> -<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span></span> <span data-ttu-id="ea2bb-462">有关暂时段大小的信息，请参阅[垃圾回收基础知识](~/docs/standard/garbage-collection/fundamentals.md)一文中“暂时代和暂时段”一节。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-462">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span></span></param>
        <param name="lohSize"><span data-ttu-id="ea2bb-463"><paramref name="totalSize" /> 中用于大对象堆 (LOH) 分配的字节数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-463">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span></span></param>
        <param name="disallowFullBlockingGC"><span data-ttu-id="ea2bb-464"><see langword="true" /> 表示如果垃圾回收器初始无法分配小对象堆 (SOH) 和 LOH 上的指定内存，则忽略完整的阻碍性垃圾回收；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-464"><see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ea2bb-465">如果指定数量的内存可用大对象堆和小对象堆，则在关键路径执行期间尝试禁止垃圾回收；并在初始没有足够内存可用的情况下，控制垃圾回收器是否进行完整的阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-465">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-466">如果运行时能够调配所需数量的内存，且垃圾回收器能够进入无 GC 区域延迟模式，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-466"><see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-467">此<xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29>方法尝试将垃圾回收器置于无 GC 区域延迟模式, 这在应用执行关键的代码区域时不允许垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-467">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="ea2bb-468">如果运行时无法最初分配所请求的内存量, 并且`disallowFullBlockingGC`参数为`false`, 则垃圾回收器将在尝试释放更多内存时执行完全阻止性垃圾回收; 否则, 分配失败, 且方法返回`false`。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-468">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="ea2bb-469">如果垃圾回收器能够为 LOH 分配并为小对象堆 (SOH `lohSize` ) 分配, `totalSize`  -  `lohSize`则垃圾回收器不会输入 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-469">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` - `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="ea2bb-470">`lohSize`必须足够大, 以便处理 LOH 的关键路径中发生的所有内存分配, 并且`totalSize`  -  `lohSize`必须足够大才能处理 SOH 关键路径中发生的所有内存分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-470">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` - `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="ea2bb-471">这包括应用的分配以及运行时代表应用程序进行的分配。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-471">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="ea2bb-472">如果`disallowFullBlockingGC`没有`true`足够的内存可供初始使用时, 将设置为以防止完全阻止垃圾回收在负载平衡方案中最有用: 一个系统可以调用此方法, 并在返回, 并让负载均衡器将请求重定向到其他系统 ( `false`如果它返回)。 `true`</span><span class="sxs-lookup"><span data-stu-id="ea2bb-472">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="ea2bb-473">然后, 在通过调用<xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29>方法来处理请求时, 它可以执行完全阻止性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-473">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="ea2bb-474">不能嵌套对方法的<xref:System.GC.TryStartNoGCRegion%2A>调用, 并且应仅在运行时<xref:System.GC.EndNoGCRegion%2A>当前处于无 GC 区域延迟模式时调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-474">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="ea2bb-475">换句话说, 您不应调用<xref:System.GC.TryStartNoGCRegion%2A>多次 (在第一次调用方法后, 后续调用将不会成功), 并且您不应指望<xref:System.GC.EndNoGCRegion%2A>调用成功, <xref:System.GC.TryStartNoGCRegion%2A>因为首次调用 succeeded。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-475">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="ea2bb-476">可以通过调用<xref:System.GC.EndNoGCRegion%2A>方法退出无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-476">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-477"><paramref name="totalSize" /> - <paramref name="lohSize" /> 超出了暂时段大小。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-477"><paramref name="totalSize" /> - <paramref name="lohSize" /> exceeds the ephemeral segment size.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-478">进程已进入无 GC 区域延迟模式。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-478">The process is already in no GC region latency mode.</span></span></exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2"><span data-ttu-id="ea2bb-479">垃圾回收的基础</span><span class="sxs-lookup"><span data-stu-id="ea2bb-479">Fundamentals of Garbage Collection</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81"><span data-ttu-id="ea2bb-480">滞后时间模式</span><span class="sxs-lookup"><span data-stu-id="ea2bb-480">Latency Modes</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ea2bb-481">返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-481">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ea2bb-482">返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-482">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-483">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-483">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-484">使用此方法返回的<xref:System.GC.RegisterForFullGCNotification%2A> 枚举来确定使用方法注册的当前垃圾回收通知的状态。<xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="ea2bb-484">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="ea2bb-485">你还可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法来确定完整垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-485">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="ea2bb-486">枚举返回<xref:System.GCNotificationStatus.Succeeded>时, 可以执行一些任务, 如阻止分配其他对象, 并<xref:System.GC.Collect%2A>使用方法自行引入集合。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-486">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="ea2bb-487">请注意, 通知不保证会发生完整的垃圾回收, 只有该条件达到了阈值, 才能进行完整垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-487">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="ea2bb-488">此方法无限期地等待获取垃圾回收通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-488">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="ea2bb-489">如果要为在无法获取通知时返回的方法指定超时时间, 请使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-489">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="ea2bb-490">如果在不指定超时的情况下调用此方法, 则如果等待的<xref:System.GC.CancelFullGCNotification%2A>时间比首选时间长, 则可以调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-490">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="ea2bb-491">你应在调用<xref:System.GC.WaitForFullGCComplete%2A>方法后遵循此方法, 以确保你已进行完整的垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-491">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="ea2bb-492">单独调用此方法会导致不确定的结果。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-492">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-493">下面的示例演示如何使用此方法来确定完全、阻止的垃圾回收是否接近。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-493">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="ea2bb-494">每当通知的状态为时<xref:System.GCNotificationStatus.Succeeded>, 将调用用户方法`OnFullGCApproachNotify`来执行操作以响应即将发生的集合。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-494">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="ea2bb-495">此代码示例是为[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-495">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ea2bb-496">表示完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-496">for full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-497">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-497">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-498">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-498">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-499">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-499">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="ea2bb-500">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="ea2bb-500">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="ea2bb-501">在获取通知状态前等待的时间长度。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-501">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="ea2bb-502">指定 -1 表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-502">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="ea2bb-503">在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时是否即将引发完整、阻碍性垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-503">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-504">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-504">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-505">使用此方法返回的<xref:System.GC.RegisterForFullGCNotification%2A> 枚举来确定使用方法注册的当前垃圾回收通知的状态。<xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="ea2bb-505">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="ea2bb-506">你还可以使用<xref:System.GC.WaitForFullGCComplete%2A>方法来确定完整垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-506">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="ea2bb-507">请注意, 无论何时获取垃圾回收通知状态, 此方法都会立即返回, 而与指定`millisecondsTimeout`的值无关。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-507">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="ea2bb-508">如果在超时之前`millisecondsTimeout`未获得垃圾回收通知状态, 此方法将返回。 <xref:System.GCNotificationStatus.NotApplicable></span><span class="sxs-lookup"><span data-stu-id="ea2bb-508">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="ea2bb-509">枚举返回<xref:System.GCNotificationStatus.Succeeded>时, 可以执行一些任务, 如阻止分配其他对象, 并<xref:System.GC.Collect%2A>使用方法自行引入集合。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-509">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="ea2bb-510">请注意, 通知不保证会发生完整的垃圾回收, 只有该条件达到了阈值, 才能进行完整垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-510">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="ea2bb-511">当你无法等待<xref:System.GC.CancelFullGCNotification%2A>超时期限结束时, 你可以调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-511">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="ea2bb-512">你应在调用<xref:System.GC.WaitForFullGCComplete%2A>方法后遵循此方法, 以确保你已进行完整的垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-512">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="ea2bb-513">单独调用此方法会导致不确定的结果。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-513">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ea2bb-514"><paramref name="millisecondsTimeout" /> 必须为非负数，或者小于等于 <see cref="F:System.Int32.MaxValue" /> 或 -1。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-514"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ea2bb-515">表示完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-515">for full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-516">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-516">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-517">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-517">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-518">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-518">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="ea2bb-519">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="ea2bb-519">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ea2bb-520">返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-520">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ea2bb-521">返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-521">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-522">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-522">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-523">使用此方法返回的<xref:System.GC.RegisterForFullGCNotification%2A> 枚举来确定使用方法注册的当前垃圾回收通知的状态。<xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="ea2bb-523">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="ea2bb-524">你还可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法来确定是否即将发生完整的垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-524">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="ea2bb-525">枚举返回<xref:System.GCNotificationStatus.Succeeded>时, 可以执行任务 (例如恢复工作) 并<xref:System.GC.CollectionCount%2A>使用属性获取集合计数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-525">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="ea2bb-526">此方法无限期地等待获取垃圾回收通知。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-526">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="ea2bb-527">如果要为在无法获取通知时返回的方法指定超时时间, 请使用<xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType>方法重载。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-527">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="ea2bb-528">如果在不指定超时的情况下调用此方法, 则如果等待的<xref:System.GC.CancelFullGCNotification%2A>时间比首选时间长, 则可以调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-528">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="ea2bb-529">此方法调用之前应调用<xref:System.GC.WaitForFullGCApproach%2A>方法, 以确保具有完全垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-529">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="ea2bb-530">单独调用此方法可能会产生不确定的结果。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-530">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-531">下面的示例演示如何使用此方法来确定完整垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-531">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="ea2bb-532">每当通知的状态为时<xref:System.GCNotificationStatus.Succeeded>, 都会调用用户方法`OnFullGCCompletedNotify`来执行操作, 以响应已完成的集合。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-532">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="ea2bb-533">此代码示例是为[垃圾回收通知](~/docs/standard/garbage-collection/notifications.md)主题提供的更大示例的一部分。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-533">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ea2bb-534">表示完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-534">for full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-535">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-535">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-536">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-536">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-537">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-537">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="ea2bb-538">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="ea2bb-538">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="ea2bb-539">在获取通知状态前等待的时间长度。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-539">The length of time to wait before a notification status can be obtained.</span></span> <span data-ttu-id="ea2bb-540">指定 -1 表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-540">Specify -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="ea2bb-541">在指定的超时期限内，返回已注册通知的状态，用于确定公共语言运行时引发的完整、阻碍性垃圾回收是否已完成。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-541">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span></span></summary>
        <returns><span data-ttu-id="ea2bb-542">已注册垃圾回收通知的状态。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-542">The status of the registered garbage collection notification.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-543">使用此方法返回的<xref:System.GC.RegisterForFullGCNotification%2A> 枚举来确定使用方法注册的当前垃圾回收通知的状态。<xref:System.GCNotificationStatus></span><span class="sxs-lookup"><span data-stu-id="ea2bb-543">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="ea2bb-544">你还可以使用<xref:System.GC.WaitForFullGCApproach%2A>方法来确定是否即将发生完整的垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-544">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="ea2bb-545">请注意, 无论何时获取垃圾回收通知状态, 此方法都会立即返回, 而与指定`millisecondsTimeout`的值无关。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-545">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="ea2bb-546">如果在超时之前`millisecondsTimeout`未获得垃圾回收通知状态, 此方法将返回。 <xref:System.GCNotificationStatus.NotApplicable></span><span class="sxs-lookup"><span data-stu-id="ea2bb-546">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="ea2bb-547">枚举返回<xref:System.GCNotificationStatus.Succeeded>时, 可以执行任务 (例如恢复工作) 并<xref:System.GC.CollectionCount%2A>使用属性获取集合计数。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-547">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="ea2bb-548">当你无法等待<xref:System.GC.CancelFullGCNotification%2A>超时期限结束时, 你可以调用方法。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-548">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="ea2bb-549">此方法调用之前应调用<xref:System.GC.WaitForFullGCApproach%2A>方法, 以确保具有完全垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-549">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="ea2bb-550">单独调用此方法可能会产生不确定的结果。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-550">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ea2bb-551"><paramref name="millisecondsTimeout" /> 必须为非负数，或者小于等于 <see cref="F:System.Int32.MaxValue" /> 或 -1。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-551"><paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand"><span data-ttu-id="ea2bb-552">表示完全信任直接调用方。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-552">for full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-553">此成员不能由部分信任的代码使用。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-553">This member cannot be used by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ea2bb-554">需要对直接调用方的完全信任。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-554">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ea2bb-555">部分受信任的或透明的代码不能使用此成员。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-555">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89"><span data-ttu-id="ea2bb-556">垃圾回收通知</span><span class="sxs-lookup"><span data-stu-id="ea2bb-556">Garbage Collection Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ea2bb-557">挂起当前线程，直到处理终结器队列的线程清空该队列为止。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-557">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ea2bb-558">当垃圾回收器发现可回收的对象时, 它会检查每个对象以确定对象的终止要求。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-558">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="ea2bb-559">如果对象实现终结器, 并且尚未通过调用<xref:System.GC.SuppressFinalize%2A>禁用完成, 则该对象将被置于标记为 "已准备好终止" 的对象列表中。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-559">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="ea2bb-560">垃圾回收器调用<xref:System.Object.Finalize%2A>此列表中的对象的方法, 并从列表中移除这些项。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-560">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="ea2bb-561">此方法会一直阻止, 直到所有终结器都已运行完毕。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-561">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="ea2bb-562">未指定运行终结器的线程, 因此无法保证此方法将终止。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-562">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="ea2bb-563">但是, 当<xref:System.GC.WaitForPendingFinalizers%2A>方法正在进行时, 此线程可能会被另一个线程中断。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-563">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="ea2bb-564">例如, 你可以启动等待一段时间的另一个线程, 并在此线程仍处于挂起状态时中断此线程。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-564">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ea2bb-565">下面的示例演示如何使用<xref:System.GC.WaitForPendingFinalizers%2A>方法挂起当前线程, 直到完成所有收集的对象的终止为止。</span><span class="sxs-lookup"><span data-stu-id="ea2bb-565">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
