<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="25c71127275f7f66a38c66d4f44927c80f0dbfa9" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69541139" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>当方法调用对于对象的当前状态无效时引发的异常。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.InvalidOperationException>如果调用方法失败是由无效参数以外的其他原因导致的, 则使用。 通常, 当对象的状态不支持方法调用时, 将引发此异常。 例如, <xref:System.InvalidOperationException>以下方法会引发异常:  
  
-   <xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType>如果在创建枚举器后修改集合的对象, 则为。 有关详细信息, 请参阅[循环访问集合](#Iterating)。  
  
-   <xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType>如果在执行方法调用前关闭资源集, 则为。  
  
-   <xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>如果要添加的对象将导致结构不正确的 XML 文档, 则为。  
  
-   尝试从非主线程或 UI 线程的线程操作 UI 的方法。  
  
> [!IMPORTANT]
>  由于在各种情况下可能会引发<xref:System.Exception.Message%2A> 异常,因此请务必阅读属性返回的异常消息。<xref:System.InvalidOperationException>  
  
 本节内容：  
  
 [InvalidOperationException 异常的一些常见原因](#Causes)   
 [从非 UI 线程更新 UI 线程](#UI)  
 [在循环访问集合时更改集合](#Iterating)  
 [对其对象无法进行比较的数组或集合进行排序](#Sorting)  
 [将为 null 的&gt; nullT转换为其基础类型&lt;](#Nullable)   
 [对空集合调用 system.exception 方法](#Empty)  
 [对没有一个元素的序列调用 SingleOrDefault 或可枚举的。](#Single)  
 [动态跨应用程序域字段访问](#Emit)  
[引发 InvalidOperationException 异常](#Throwing)  
[杂项信息](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a>InvalidOperationException 异常的一些常见原因  
 以下部分介绍了在<xref:System.InvalidOperationException>应用中引发异常的一些常见情况。 处理问题的方式取决于具体情况。 但大多数情况下, 异常是由开发人员错误导致的, <xref:System.InvalidOperationException>并且可能会预计和避免异常。  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a>从非 UI 线程更新 UI 线程  
 通常, 工作线程用于执行一些后台工作, 其中涉及收集要在应用程序的用户界面中显示的数据。 尽管如此. 大多数 .NET Framework 的 GUI (图形用户界面) 应用程序框架 (如 Windows 窗体和 Windows Presentation Foundation (WPF)) 只允许从创建和管理 UI 的线程 (主线程或 UI 线程) 访问 GUI 对象。 当你尝试从 ui 线程之外的其他线程访问 ui 元素时,将引发。<xref:System.InvalidOperationException>  下表显示了异常消息的文本。  
  
|应用类型|消息|  
|----------------------|-------------|  
|WPF 应用|**调用线程无法访问此对象, 因为另一个线程拥有该对象。**|  
|UWP 应用|**应用程序调用了为另一个线程封送的接口。**|  
|Windows 窗体应用|**跨线程操作无效:控件 "TextBox1" 从创建它的线程之外的其他线程访问。**|  
  
 .NET Framework 的 UI 框架实现了一个*调度*程序模式, 该模式包括一个方法, 用于检查 ui 线程上是否正在执行对 ui 线程成员的调用, 以及用于计划对 ui 线程的调用的其他方法:  
  
-   在 WPF 应用程序中, <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType>调用方法以确定方法是否正在非 UI 线程上运行。 如果方法`true`在 UI 线程上运行, `false`则返回; 否则返回。 调用<xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType>方法的重载之一来计划对 UI 线程的调用。  
  
-   在 UWP 应用中, 检查<xref:Windows.UI.Core.CoreDispatcher.HasThreadAccess?displayProperty=nameWithType>属性以确定某个方法是否正在非 UI 线程上运行。 <xref:Windows.UI.Core.CoreDispatcher.RunAsync%2A?displayProperty=nameWithType>调用方法以执行用于更新 UI 线程的委托。 
  
-   在 Windows 窗体应用中, 请<xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType>使用属性来确定某个方法是否正在非 UI 线程上运行。 调用<xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType>方法的重载之一来执行更新 UI 线程的委托。  
  
 下面的示例说明当<xref:System.InvalidOperationException>你尝试从创建它的线程以外的线程更新 UI 元素时引发的异常。  每个示例都需要创建两个控件:  
  
-   名为`textBox1`的文本框控件。  在 Windows 窗体应用程序中, 应将其<xref:System.Windows.Forms.TextBox.Multiline%2A>属性设置`true`为。  
  
-   名为`threadExampleBtn`的按钮控件。 该示例为按钮的`ThreadsExampleBtn_Click` `Click`事件提供了一个处理程序。  
  
 在每种情况下`threadExampleBtn_Click` , 事件处理程序`DoSomeWork`都会两次调用方法。 第一个调用同步运行并成功运行。 但第二次调用时, 由于它在线程池线程上以异步方式运行, 因此尝试从非 UI 线程更新 UI。 这会导致<xref:System.InvalidOperationException>异常。  
  
 WPF 和 UWP 应用  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 以下版本的`DoSomeWork`方法可消除 WPF 应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 以下版本的`DoSomeWork`方法消除了 UWP 应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 Windows 窗体应用  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 以下版本的`DoSomeWork`方法消除了 Windows 窗体应用中的异常。  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a>在循环访问集合时更改集合  
 Visual Basic `foreach`中的C#语句`For Each`或语句中的语句用于循环访问集合的成员, 并读取或修改其各个元素。 但是, 它不能用于添加或删除集合中的项。 执行此操作会<xref:System.InvalidOperationException>引发异常, 其中包含类似于 "**集合已修改;枚举操作可能无法执行。**"  
  
 下面的示例循环访问整数的集合, 尝试将每个整数的平方添加到集合中。 该示例<xref:System.InvalidOperationException>通过首次调用<xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType>方法引发。  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 可以通过以下两种方式之一消除异常: 具体取决于应用程序逻辑:  
  
-   如果在循环访问时必须将元素添加到集合中, 则可以使用`for`语句`foreach`而不是或`For Each`来循环访问元素。 下面的示例使用 for 语句将集合中的数字的平方添加到集合中。  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     请注意, 在循环访问集合之前, 必须先建立迭代数, 方法是在循环中使用计数器, 该循环会将从`Count` -1 到0的反向循环访问, 并通过将数组中元素的元素, 并使用它来确定循环的上限。 否则, 如果在每次迭代时向集合中添加了一个元素, 则会导致无限循环。  
  
-   如果在循环访问集合时不需要向集合添加元素, 则可以存储要添加到临时集合中的元素, 在循环访问完成后添加这些元素。  下面的示例使用此方法将集合中的数字的平方添加到临时集合, 然后将这些集合合并为单个数组对象。  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a>对其对象无法进行比较的数组或集合进行排序  
 一般用途的排序方法 ( <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>如方法<xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType>或方法) 通常要求至少一个<xref:System.IComparable%601>要<xref:System.IComparable>排序的对象实现或接口。 如果不是, 则无法对集合或数组进行排序, 并且该方法<xref:System.InvalidOperationException>将引发异常。 下面的示例定义了`Person`一个类, 将`Person`两个对象存储<xref:System.Collections.Generic.List%601>在一个泛型对象中, 并尝试对它们进行排序。 如示例的输出所示, 对<xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType>方法的调用将<xref:System.InvalidOperationException>引发。  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 可以通过以下三种方式之一消除异常:  
  
-   如果可以拥有要进行排序的类型 (即, 如果控制其源代码), 则可以修改它以实现<xref:System.IComparable%601> <xref:System.IComparable>或接口。 这要求您实现<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> <xref:System.IComparable.CompareTo%2A>或方法。 将接口实现添加到现有类型不是一项重大更改。  
  
     下面的示例使用此方法为<xref:System.IComparable%601> `Person`类提供一个实现。 你仍可以调用集合或数组的常规排序方法, 如示例中的输出所示, 该集合将成功排序。  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   如果您无法修改您尝试进行排序的类型的源代码, 则可以定义一个实现<xref:System.Collections.Generic.IComparer%601>接口的特殊用途的排序类。  可以调用`Sort` <xref:System.Collections.Generic.IComparer%601>包含参数的方法的重载。 如果要开发可基于多个条件对对象进行排序的专用排序类, 则此方法特别有用。  
  
     下面的示例通过开发用于对集合进行排序`PersonComparer` `Person`的自定义类来使用方法。  然后, 它将此类的一个实例传递<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType>给方法。  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   如果无法修改您尝试排序的类型的源代码, 则可以创建一个<xref:System.Comparison%601>委托来执行排序。 委托签名为  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     下面的示例通过定义`PersonComparison` <xref:System.Comparison%601>与委托签名匹配的方法来使用方法。  然后, 它将此委托传递<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType>给方法。  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a>将为 null\<的可为 null 的 T > 强制转换为其基础类型  
 如果尝试强制转换<xref:System.Nullable%601>为<xref:System.InvalidOperationException>其基础`null`类型的值, 则会引发异常并显示错误消息 "**可以为 null 的对象必须具有值。**  
  
 下面的示例在尝试<xref:System.InvalidOperationException>循环访问`Nullable(Of Integer)`包含值的数组时引发了异常。  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 若要防止发生此异常:  
  
-   使用属性来仅选择那些不`null`是的元素。 <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType>  
  
-   调用<xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType>重载之一, 为`null`值提供默认值。  
  
 下面的示例执行此<xref:System.InvalidOperationException>两个方法来避免异常。  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a>对空集合调用 system.exception 方法  
 <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType> 、<xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>、 、<xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>、、 、和<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>方法对序列执行操作并返回单个结果。 <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>   如果序列为空, 而其他<xref:System.InvalidOperationException>重载返回`null`, 则这些方法的某些重载会引发异常。 当<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>序列包含多个<xref:System.InvalidOperationException>元素时, 该方法也会引发异常。  
  
> [!NOTE]
>  引发<xref:System.InvalidOperationException>异常的大多数方法都是重载。 请确保了解所选重载的行为。  
  
 下表列出了由对某些<xref:System.InvalidOperationException> <xref:System.Linq.Enumerable?displayProperty=nameWithType>方法的调用引发的异常对象的异常消息。  
  
|方法|消息|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|**序列不包含任何元素**|  
|`First`|**序列不包含任何匹配元素**|  
|`Single` <br /> `SingleOrDefault`|**序列包含一个以上的匹配元素**|  
  
 消除或处理异常的方式取决于应用程序的假设和所调用的特定方法。  
  
-   如果在不检查空序列的情况下有意调用这些方法之一, 则假设序列不为空, 且空序列是意外的匹配项。 在这种情况下, 会适当捕获或重新引发异常。  
  
-   如果无法检查是否存在空序列, 则可以调用<xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType>重载的重载之一来确定序列是否包含任何元素。  
  
    > [!TIP]
    >  如果要处理的数据可能包含大量元素或生成序列的操作非常昂贵, 则在生成序列之前调用方法可以提高性能。<xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType>  
  
-   如果调用了<xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>方法 ( <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>如、或<xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>), 则<xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>可以替换返回默认值 (而不是序列的<xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>成员) 的替代方法, 如、或<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>。  
  
 这些示例提供更多详细信息。  
  
 下面的示例使用<xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>方法计算其值大于4的序列的平均值。 由于原始数组中没有值超过 4, 因此序列中不包含任何值, 并且该方法将引发<xref:System.InvalidOperationException>异常。  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 在调用处理序列的方法之前, <xref:System.Linq.Enumerable.Any%2A>可以通过调用方法来确定序列是否包含任何元素, 从而消除此异常, 如下面的示例所示。  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>方法返回序列中的第一项, 或序列中满足指定条件的第一个元素。 如果序列为空, 因此不包含第一个元素, 则会引发<xref:System.InvalidOperationException>异常。  
  
 在下面的示例中, <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType>方法<xref:System.InvalidOperationException>引发异常, 因为 dbQueryResults 数组不包含大于4的元素。  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 您可以调用<xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>方法, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>而不是返回指定值或默认值。 如果该方法未在序列中找到第一个元素, 则它将返回该数据类型的默认值。  `null`对于引用类型, 默认值为 0; 对于数值数据类型<xref:System.DateTime.MinValue?displayProperty=nameWithType> , 默认值为零; <xref:System.DateTime>对于类型, 则为。  
  
> [!NOTE]
>  解释该<xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>方法返回的值通常是很复杂的, 因为该类型的默认值可以是序列中的有效值。 在这种情况下, 在<xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>调用方法之前, 调用方法来确定序列是否具有有效的成员。  
  
 下面的示例调用<xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType>方法, 以防止在上一个示例中引发的<xref:System.InvalidOperationException>异常。  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a>对没有一个元素的序列调用 SingleOrDefault 或可枚举的。  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>方法返回序列中的唯一元素, 或序列中满足指定条件的唯一元素。    如果序列中没有元素, 或者如果有多个元素, 则该方法将引发<xref:System.InvalidOperationException>异常。  
  
 如果序列不包含<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>任何元素, 则可以使用方法返回默认值, 而不是引发异常。 但是, 当<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>序列包含多个<xref:System.InvalidOperationException>元素时, 该方法仍会引发异常。  
  
 下表列出了由对<xref:System.InvalidOperationException> <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>和<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>方法的调用引发的异常对象的异常消息。  
  
|方法|消息|  
|------------|-------------|  
|`Single`|**序列不包含任何匹配元素**|  
|`Single` <br /> `SingleOrDefault`|**序列包含一个以上的匹配元素**|  
  
 在下面的示例中, 对<xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>方法的调用将<xref:System.InvalidOperationException>引发异常, 因为序列没有大于4的元素。  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 下面的示例尝试通过<xref:System.InvalidOperationException> <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>调用方法来防止序列为空时引发的异常。 但是, 因为此序列返回多个值大于2的元素, 所以它还会引发<xref:System.InvalidOperationException>异常。  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>调用方法假设序列或满足指定条件的序列只包含一个元素。  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>假设序列包含零个或一个结果, 但没有其他结果。 如果此假设在您的部分中是有意的, 并且不满足这些条件, 则会重新引发或<xref:System.InvalidOperationException>捕获产生的结果。 否则, 或者, 如果您希望在某些频率下发生无效的条件, 则应考虑使用其他<xref:System.Linq.Enumerable>方法, <xref:System.Linq.Enumerable.FirstOrDefault%2A>例如或<xref:System.Linq.Enumerable.Where%2A>。  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a>动态跨应用程序域字段访问  
 如果<xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType>包含您尝试检索其地址的字段所在<xref:System.InvalidOperationException>的对象不在执行您的代码的应用程序域中, 则 Microsoft 中间语言 (MSIL) 指令会引发异常。 字段的地址只能从它所在的应用程序域进行访问。  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a>引发 InvalidOperationException 异常  
 仅当对象的<xref:System.InvalidOperationException>状态出于某种原因不支持特定方法调用时, 才应引发异常。 也就是说, 方法调用在某些环境或上下文中有效, 但在其他情况下无效。  
  
 如果方法调用失败是由无效参数引起的, 则<xref:System.ArgumentException>应改为引发或其派生<xref:System.ArgumentNullException>类<xref:System.ArgumentOutOfRangeException>之一或。  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a>杂项信息  
 <xref:System.InvalidOperationException>使用 COR_E_INVALIDOPERATION 值为0x80131509 的 HRESULT。  
  
 有关实例的初始属性值的列表<xref:System.InvalidOperationException>，请参阅<xref:System.InvalidOperationException.%23ctor%2A>构造函数。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md">处理和引发异常</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将<xref:System.Exception.Message%2A>新实例的属性初始化为系统提供的描述错误的消息, 例如 "无法执行请求的操作"。 此消息将当前系统区域性考虑在内。  
  
 下表显示 <xref:System.InvalidOperationException> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|本地化的错误消息字符串。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">描述错误的消息。</param>
        <summary>用指定的错误消息初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数`message`使用<xref:System.Exception.Message%2A?displayProperty=nameWithType>参数初始化新异常的属性。 `message` 的内容被设计为人可理解的形式。 此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。  
  
 下表显示 <xref:System.InvalidOperationException> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|空引用（在 Visual Basic 中为 `Nothing`）。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">承载序列化对象数据的对象。</param>
        <param name="context">关于来源和目标的上下文信息</param>
        <summary>用序列化数据初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数在反序列化过程中调用，以便重建通过流传输的异常对象。 有关详细信息，请参阅[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md">XML 和 SOAP 序列化</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">解释异常原因的错误消息。</param>
        <param name="innerException">导致当前异常的异常。 如果 <paramref name="innerException" /> 参数不是 null 引用（在 Visual Basic 中为 <see langword="Nothing" />），则在处理内部异常的 <see langword="catch" /> 块中引发当前异常。</param>
        <summary>使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 因前一个异常而直接引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。 <xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。  
  
 下表显示 <xref:System.InvalidOperationException> 的实例的初始属性值。  
  
|Property|“值”|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|内部异常引用。|  
|<xref:System.Exception.Message%2A>|错误消息字符串。|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md">处理和引发异常</related>
      </Docs>
    </Member>
  </Members>
</Type>
