<Type Name="InvalidOperationException" FullName="System.InvalidOperationException">
  <Metadata><Meta Name="ms.openlocfilehash" Value="25c71127275f7f66a38c66d4f44927c80f0dbfa9" /><Meta Name="ms.sourcegitcommit" Value="cb4d218ffd5a459a5f921fe1d945c682d1e09aca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/16/2019" /><Meta Name="ms.locfileid" Value="69541139" /></Metadata><TypeSignature Language="C#" Value="public class InvalidOperationException : SystemException" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit InvalidOperationException extends System.SystemException" />
  <TypeSignature Language="DocId" Value="T:System.InvalidOperationException" />
  <TypeSignature Language="VB.NET" Value="Public Class InvalidOperationException&#xA;Inherits SystemException" />
  <TypeSignature Language="C++ CLI" Value="public ref class InvalidOperationException : SystemException" />
  <TypeSignature Language="F#" Value="type InvalidOperationException = class&#xA;    inherit SystemException" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Exception</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.SystemException</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="8a148-101">当方法调用对于对象的当前状态无效时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-101">The exception that is thrown when a method call is invalid for the object's current state.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a148-102"><xref:System.InvalidOperationException>如果调用方法失败是由无效参数以外的其他原因导致的, 则使用。</span><span class="sxs-lookup"><span data-stu-id="8a148-102"><xref:System.InvalidOperationException> is used in cases when the failure to invoke a method is caused by reasons other than invalid arguments.</span></span> <span data-ttu-id="8a148-103">通常, 当对象的状态不支持方法调用时, 将引发此异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-103">Typically, it is thrown when the state of an object cannot support the method call.</span></span> <span data-ttu-id="8a148-104">例如, <xref:System.InvalidOperationException>以下方法会引发异常:</span><span class="sxs-lookup"><span data-stu-id="8a148-104">For example, an <xref:System.InvalidOperationException> exception is thrown by methods such as:</span></span>  
  
-   <span data-ttu-id="8a148-105"><xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType>如果在创建枚举器后修改集合的对象, 则为。</span><span class="sxs-lookup"><span data-stu-id="8a148-105"><xref:System.Collections.IEnumerator.MoveNext%2A?displayProperty=nameWithType> if objects of a collection are modified after the enumerator is created.</span></span> <span data-ttu-id="8a148-106">有关详细信息, 请参阅[循环访问集合](#Iterating)。</span><span class="sxs-lookup"><span data-stu-id="8a148-106">For more information, see [Changing a collection while iterating it](#Iterating).</span></span>  
  
-   <span data-ttu-id="8a148-107"><xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType>如果在执行方法调用前关闭资源集, 则为。</span><span class="sxs-lookup"><span data-stu-id="8a148-107"><xref:System.Resources.ResourceSet.GetString%2A?displayProperty=nameWithType> if the resource set is closed before the method call is made.</span></span>  
  
-   <span data-ttu-id="8a148-108"><xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>如果要添加的对象将导致结构不正确的 XML 文档, 则为。</span><span class="sxs-lookup"><span data-stu-id="8a148-108"><xref:System.Xml.Linq.XContainer.Add%2A?displayProperty=nameWithType>, if the object or objects to be added would result in an incorrectly structured XML document.</span></span>  
  
-   <span data-ttu-id="8a148-109">尝试从非主线程或 UI 线程的线程操作 UI 的方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-109">A method that attempts to manipulate the UI from a thread that is not the main or UI thread.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8a148-110">由于在各种情况下可能会引发<xref:System.Exception.Message%2A> 异常,因此请务必阅读属性返回的异常消息。<xref:System.InvalidOperationException></span><span class="sxs-lookup"><span data-stu-id="8a148-110">Because the <xref:System.InvalidOperationException> exception can be thrown in a wide variety of circumstances, it is important to read the exception message returned by the <xref:System.Exception.Message%2A> property.</span></span>  
  
 <span data-ttu-id="8a148-111">本节内容：</span><span class="sxs-lookup"><span data-stu-id="8a148-111">In this section:</span></span>  
  
 <span data-ttu-id="8a148-112">[InvalidOperationException 异常的一些常见原因](#Causes) </span><span class="sxs-lookup"><span data-stu-id="8a148-112">[Some common causes of InvalidOperationException exceptions](#Causes) </span></span>  
 [<span data-ttu-id="8a148-113">从非 UI 线程更新 UI 线程</span><span class="sxs-lookup"><span data-stu-id="8a148-113">Updating a UI thread from a non-UI thread</span></span>](#UI)  
 [<span data-ttu-id="8a148-114">在循环访问集合时更改集合</span><span class="sxs-lookup"><span data-stu-id="8a148-114">Changing a collection while iterating it</span></span>](#Iterating)  
 [<span data-ttu-id="8a148-115">对其对象无法进行比较的数组或集合进行排序</span><span class="sxs-lookup"><span data-stu-id="8a148-115">Sorting an array or collection whose objects cannot be compared</span></span>](#Sorting)  
 <span data-ttu-id="8a148-116">[将为 null 的&gt; nullT转换为其基础类型&lt;](#Nullable) </span><span class="sxs-lookup"><span data-stu-id="8a148-116">[Casting a Nullable&lt;T&gt; that is null to its underlying type](#Nullable) </span></span>  
 [<span data-ttu-id="8a148-117">对空集合调用 system.exception 方法</span><span class="sxs-lookup"><span data-stu-id="8a148-117">Calling a System.Linq.Enumerable method on an empty collection</span></span>](#Empty)  
 [<span data-ttu-id="8a148-118">对没有一个元素的序列调用 SingleOrDefault 或可枚举的。</span><span class="sxs-lookup"><span data-stu-id="8a148-118">Calling Enumerable.Single or Enumerable.SingleOrDefault on a sequence without one element</span></span>](#Single)  
 [<span data-ttu-id="8a148-119">动态跨应用程序域字段访问</span><span class="sxs-lookup"><span data-stu-id="8a148-119">Dynamic cross-application domain field access</span></span>](#Emit)  
[<span data-ttu-id="8a148-120">引发 InvalidOperationException 异常</span><span class="sxs-lookup"><span data-stu-id="8a148-120">Throwing an InvalidOperationException exception</span></span>](#Throwing)  
[<span data-ttu-id="8a148-121">杂项信息</span><span class="sxs-lookup"><span data-stu-id="8a148-121">Miscellaneous information</span></span>](#Misc)  
  
<a name="Causes"></a>   
## <a name="some-common-causes-of-invalidoperationexception-exceptions"></a><span data-ttu-id="8a148-122">InvalidOperationException 异常的一些常见原因</span><span class="sxs-lookup"><span data-stu-id="8a148-122">Some common causes of InvalidOperationException exceptions</span></span>  
 <span data-ttu-id="8a148-123">以下部分介绍了在<xref:System.InvalidOperationException>应用中引发异常的一些常见情况。</span><span class="sxs-lookup"><span data-stu-id="8a148-123">The following sections show how some common cases in which in <xref:System.InvalidOperationException> exception is thrown in an app.</span></span> <span data-ttu-id="8a148-124">处理问题的方式取决于具体情况。</span><span class="sxs-lookup"><span data-stu-id="8a148-124">How you handle the issue depends on the specific situation.</span></span> <span data-ttu-id="8a148-125">但大多数情况下, 异常是由开发人员错误导致的, <xref:System.InvalidOperationException>并且可能会预计和避免异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-125">Most commonly, however, the exception results from developer error, and the <xref:System.InvalidOperationException> exception can be anticipated and avoided.</span></span>  
  
<a name="UI"></a>   
### <a name="updating-a-ui-thread-from-a-non-ui-thread"></a><span data-ttu-id="8a148-126">从非 UI 线程更新 UI 线程</span><span class="sxs-lookup"><span data-stu-id="8a148-126">Updating a UI thread from a non-UI thread</span></span>  
 <span data-ttu-id="8a148-127">通常, 工作线程用于执行一些后台工作, 其中涉及收集要在应用程序的用户界面中显示的数据。</span><span class="sxs-lookup"><span data-stu-id="8a148-127">Often, worker threads are used to perform some background work that involves gathering data to be displayed in an application's user interface.</span></span> <span data-ttu-id="8a148-128">尽管如此.</span><span class="sxs-lookup"><span data-stu-id="8a148-128">However.</span></span> <span data-ttu-id="8a148-129">大多数 .NET Framework 的 GUI (图形用户界面) 应用程序框架 (如 Windows 窗体和 Windows Presentation Foundation (WPF)) 只允许从创建和管理 UI 的线程 (主线程或 UI 线程) 访问 GUI 对象。</span><span class="sxs-lookup"><span data-stu-id="8a148-129">most GUI (graphical user interface) application frameworks for the .NET Framework, such as Windows Forms and Windows Presentation Foundation (WPF),  let you access GUI objects only from the thread that creates and manages the UI (the Main or UI thread).</span></span> <span data-ttu-id="8a148-130">当你尝试从 ui 线程之外的其他线程访问 ui 元素时,将引发。<xref:System.InvalidOperationException></span><span class="sxs-lookup"><span data-stu-id="8a148-130">An <xref:System.InvalidOperationException> is thrown when you try to access a UI element from a thread other than the UI thread.</span></span>  <span data-ttu-id="8a148-131">下表显示了异常消息的文本。</span><span class="sxs-lookup"><span data-stu-id="8a148-131">The text of the exception message is shown in the following table.</span></span>  
  
|<span data-ttu-id="8a148-132">应用类型</span><span class="sxs-lookup"><span data-stu-id="8a148-132">Application Type</span></span>|<span data-ttu-id="8a148-133">消息</span><span class="sxs-lookup"><span data-stu-id="8a148-133">Message</span></span>|  
|----------------------|-------------|  
|<span data-ttu-id="8a148-134">WPF 应用</span><span class="sxs-lookup"><span data-stu-id="8a148-134">WPF app</span></span>|<span data-ttu-id="8a148-135">**调用线程无法访问此对象, 因为另一个线程拥有该对象。**</span><span class="sxs-lookup"><span data-stu-id="8a148-135">**The calling thread cannot access this object because a different thread owns it.**</span></span>|  
|<span data-ttu-id="8a148-136">UWP 应用</span><span class="sxs-lookup"><span data-stu-id="8a148-136">UWP app</span></span>|<span data-ttu-id="8a148-137">**应用程序调用了为另一个线程封送的接口。**</span><span class="sxs-lookup"><span data-stu-id="8a148-137">**The application called an interface that was marshaled for a different thread.**</span></span>|  
|<span data-ttu-id="8a148-138">Windows 窗体应用</span><span class="sxs-lookup"><span data-stu-id="8a148-138">Windows Forms app</span></span>|<span data-ttu-id="8a148-139">**跨线程操作无效:控件 "TextBox1" 从创建它的线程之外的其他线程访问。**</span><span class="sxs-lookup"><span data-stu-id="8a148-139">**Cross-thread operation not valid: Control 'TextBox1' accessed from a thread other than the thread it was created on.**</span></span>|  
  
 <span data-ttu-id="8a148-140">.NET Framework 的 UI 框架实现了一个*调度*程序模式, 该模式包括一个方法, 用于检查 ui 线程上是否正在执行对 ui 线程成员的调用, 以及用于计划对 ui 线程的调用的其他方法:</span><span class="sxs-lookup"><span data-stu-id="8a148-140">UI frameworks for the .NET Framework implement a *dispatcher* pattern that includes a method to check whether a call to a member of a UI element is being executed on the UI thread, and other methods to schedule the call on the UI thread:</span></span>  
  
-   <span data-ttu-id="8a148-141">在 WPF 应用程序中, <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType>调用方法以确定方法是否正在非 UI 线程上运行。</span><span class="sxs-lookup"><span data-stu-id="8a148-141">In WPF apps, call the <xref:System.Windows.Threading.Dispatcher.CheckAccess%2A?displayProperty=nameWithType> method to determine if a method is running on a non-UI thread.</span></span> <span data-ttu-id="8a148-142">如果方法`true`在 UI 线程上运行, `false`则返回; 否则返回。</span><span class="sxs-lookup"><span data-stu-id="8a148-142">It returns `true` if the method is running on the UI thread and `false` otherwise.</span></span> <span data-ttu-id="8a148-143">调用<xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType>方法的重载之一来计划对 UI 线程的调用。</span><span class="sxs-lookup"><span data-stu-id="8a148-143">Call one of the overloads of the <xref:System.Windows.Threading.Dispatcher.Invoke%2A?displayProperty=nameWithType> method to schedule the call on the UI thread.</span></span>  
  
-   <span data-ttu-id="8a148-144">在 UWP 应用中, 检查<xref:Windows.UI.Core.CoreDispatcher.HasThreadAccess?displayProperty=nameWithType>属性以确定某个方法是否正在非 UI 线程上运行。</span><span class="sxs-lookup"><span data-stu-id="8a148-144">In UWP apps, check the <xref:Windows.UI.Core.CoreDispatcher.HasThreadAccess?displayProperty=nameWithType> property to determine if a method is running on a non-UI thread.</span></span> <span data-ttu-id="8a148-145"><xref:Windows.UI.Core.CoreDispatcher.RunAsync%2A?displayProperty=nameWithType>调用方法以执行用于更新 UI 线程的委托。</span><span class="sxs-lookup"><span data-stu-id="8a148-145">Call the <xref:Windows.UI.Core.CoreDispatcher.RunAsync%2A?displayProperty=nameWithType> method to execute a delegate that updates the UI thread.</span></span> 
  
-   <span data-ttu-id="8a148-146">在 Windows 窗体应用中, 请<xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType>使用属性来确定某个方法是否正在非 UI 线程上运行。</span><span class="sxs-lookup"><span data-stu-id="8a148-146">In Windows Forms apps, use the <xref:System.Windows.Forms.Control.InvokeRequired%2A?displayProperty=nameWithType> property to determine if a method is running on a non-UI thread.</span></span> <span data-ttu-id="8a148-147">调用<xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType>方法的重载之一来执行更新 UI 线程的委托。</span><span class="sxs-lookup"><span data-stu-id="8a148-147">Call one of the overloads of the <xref:System.Windows.Forms.Control.Invoke%2A?displayProperty=nameWithType> method to execute a delegate that updates the UI thread.</span></span>  
  
 <span data-ttu-id="8a148-148">下面的示例说明当<xref:System.InvalidOperationException>你尝试从创建它的线程以外的线程更新 UI 元素时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-148">The following examples illustrate the <xref:System.InvalidOperationException> exception that is thrown when you attempt to update a UI element from a thread other than the thread that created it.</span></span>  <span data-ttu-id="8a148-149">每个示例都需要创建两个控件:</span><span class="sxs-lookup"><span data-stu-id="8a148-149">Each example requires that you create two controls:</span></span>  
  
-   <span data-ttu-id="8a148-150">名为`textBox1`的文本框控件。</span><span class="sxs-lookup"><span data-stu-id="8a148-150">A text box control named `textBox1`.</span></span>  <span data-ttu-id="8a148-151">在 Windows 窗体应用程序中, 应将其<xref:System.Windows.Forms.TextBox.Multiline%2A>属性设置`true`为。</span><span class="sxs-lookup"><span data-stu-id="8a148-151">In a Windows Forms app, you should set its <xref:System.Windows.Forms.TextBox.Multiline%2A> property to `true`.</span></span>  
  
-   <span data-ttu-id="8a148-152">名为`threadExampleBtn`的按钮控件。</span><span class="sxs-lookup"><span data-stu-id="8a148-152">A button  control named `threadExampleBtn`.</span></span> <span data-ttu-id="8a148-153">该示例为按钮的`ThreadsExampleBtn_Click` `Click`事件提供了一个处理程序。</span><span class="sxs-lookup"><span data-stu-id="8a148-153">The example provides a handler, `ThreadsExampleBtn_Click`, for the button's `Click` event.</span></span>  
  
 <span data-ttu-id="8a148-154">在每种情况下`threadExampleBtn_Click` , 事件处理程序`DoSomeWork`都会两次调用方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-154">In each case, the `threadExampleBtn_Click` event handler calls the `DoSomeWork` method twice.</span></span> <span data-ttu-id="8a148-155">第一个调用同步运行并成功运行。</span><span class="sxs-lookup"><span data-stu-id="8a148-155">The first call runs synchronously and succeeds.</span></span> <span data-ttu-id="8a148-156">但第二次调用时, 由于它在线程池线程上以异步方式运行, 因此尝试从非 UI 线程更新 UI。</span><span class="sxs-lookup"><span data-stu-id="8a148-156">But the second call, because it runs asynchronously on a thread pool thread, attempts to update the UI from a non-UI thread.</span></span> <span data-ttu-id="8a148-157">这会导致<xref:System.InvalidOperationException>异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-157">This results in a <xref:System.InvalidOperationException> exception.</span></span>  
  
 <span data-ttu-id="8a148-158">WPF 和 UWP 应用</span><span class="sxs-lookup"><span data-stu-id="8a148-158">WPF and UWP apps</span></span>  
 [!code-csharp[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/cs/MainWindow.xaml.cs#1)]
 [!code-vb[System.InvalidOperationException.Threading.WPF1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf1/vb/MainWindow.xaml.vb#1)]  
  
 <span data-ttu-id="8a148-159">以下版本的`DoSomeWork`方法可消除 WPF 应用中的异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-159">The following version of the `DoSomeWork` method eliminates the exception in a WPF app.</span></span>  
  
 [!code-csharp[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/cs/MainWindowDispatcher.xaml.cs#3)]
 [!code-vb[System.InvalidOperationException.Threading.WPF2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wpf2/vb/MainWindowDispatcher.xaml.vb#3)]  
  
 <span data-ttu-id="8a148-160">以下版本的`DoSomeWork`方法消除了 UWP 应用中的异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-160">The following version of the `DoSomeWork` method eliminates the exception in a UWP app.</span></span>  
  
 [!code-csharp[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/cs/MainPage.xaml.cs#4)]
 [!code-vb[System.InvalidOperationException.Threading.UWP#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception.threading.uwp/vb/MainPage.xaml.vb#4)]  
  
 <span data-ttu-id="8a148-161">Windows 窗体应用</span><span class="sxs-lookup"><span data-stu-id="8a148-161">Windows Forms apps</span></span>  
 [!code-csharp[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/cs/Form1.cs#2)]
 [!code-vb[System.InvalidOperationException.Threading.WF#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf/vb/Form1.vb#2)]  
  
 <span data-ttu-id="8a148-162">以下版本的`DoSomeWork`方法消除了 Windows 窗体应用中的异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-162">The following version of the `DoSomeWork` method eliminates the exception in a Windows Forms app.</span></span>  
  
 [!code-csharp[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/cs/Form1.cs#5)]
 [!code-vb[System.InvalidOperationException.Threading.WF2#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Invalidoperationexception.threading.wf2/vb/Form1.vb#5)]  
  
<a name="Iterating"></a>   
### <a name="changing-a-collection-while-iterating-it"></a><span data-ttu-id="8a148-163">在循环访问集合时更改集合</span><span class="sxs-lookup"><span data-stu-id="8a148-163">Changing a collection while iterating it</span></span>  
 <span data-ttu-id="8a148-164">Visual Basic `foreach`中的C#语句`For Each`或语句中的语句用于循环访问集合的成员, 并读取或修改其各个元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-164">The `foreach` statement in C# or `For Each` statement in Visual Basic is used to iterate the members of a collection and to read or modify its individual elements.</span></span> <span data-ttu-id="8a148-165">但是, 它不能用于添加或删除集合中的项。</span><span class="sxs-lookup"><span data-stu-id="8a148-165">However, it can't be used to add or remove items from the collection.</span></span> <span data-ttu-id="8a148-166">执行此操作会<xref:System.InvalidOperationException>引发异常, 其中包含类似于 "**集合已修改;枚举操作可能无法执行。**"</span><span class="sxs-lookup"><span data-stu-id="8a148-166">Doing this throws an  <xref:System.InvalidOperationException> exception with a message that is similar to, "**Collection was modified; enumeration operation may not execute.**"</span></span>  
  
 <span data-ttu-id="8a148-167">下面的示例循环访问整数的集合, 尝试将每个整数的平方添加到集合中。</span><span class="sxs-lookup"><span data-stu-id="8a148-167">The following example iterates a collection of integers attempts to add the square of each integer to the collection.</span></span> <span data-ttu-id="8a148-168">该示例<xref:System.InvalidOperationException>通过首次调用<xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType>方法引发。</span><span class="sxs-lookup"><span data-stu-id="8a148-168">The example throws an <xref:System.InvalidOperationException> with the first call to the <xref:System.Collections.Generic.List%601.Add%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating1.cs#1)]
 [!code-vb[System.InvalidOperationException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating1.vb#1)]  
  
 <span data-ttu-id="8a148-169">可以通过以下两种方式之一消除异常: 具体取决于应用程序逻辑:</span><span class="sxs-lookup"><span data-stu-id="8a148-169">You can eliminate the exception in one of two ways, depending on your application logic:</span></span>  
  
-   <span data-ttu-id="8a148-170">如果在循环访问时必须将元素添加到集合中, 则可以使用`for`语句`foreach`而不是或`For Each`来循环访问元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-170">If elements must be added to the collection while iterating it, you can iterate it by index using the `for` statement instead of `foreach` or `For Each`.</span></span> <span data-ttu-id="8a148-171">下面的示例使用 for 语句将集合中的数字的平方添加到集合中。</span><span class="sxs-lookup"><span data-stu-id="8a148-171">The following example uses the for statement to add the square of numbers in the collection to the collection.</span></span>  
  
     [!code-csharp[System.InvalidOperationException#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating2.cs#2)]
     [!code-vb[System.InvalidOperationException#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating2.vb#2)]  
  
     <span data-ttu-id="8a148-172">请注意, 在循环访问集合之前, 必须先建立迭代数, 方法是在循环中使用计数器, 该循环会将从`Count` -1 到0的反向循环访问, 并通过将数组中元素的元素, 并使用它来确定循环的上限。</span><span class="sxs-lookup"><span data-stu-id="8a148-172">Note that you must establish the number of iterations before iterating the collection either by using a counter inside the loop that will exit the loop appropriately, by iterating backward, from `Count` - 1 to 0, or, as the example does, by assigning the number of elements in the array to a variable and using it to establish the upper bound of the loop.</span></span> <span data-ttu-id="8a148-173">否则, 如果在每次迭代时向集合中添加了一个元素, 则会导致无限循环。</span><span class="sxs-lookup"><span data-stu-id="8a148-173">Otherwise, if an element is added to the collection on every iteration, an endless loop results.</span></span>  
  
-   <span data-ttu-id="8a148-174">如果在循环访问集合时不需要向集合添加元素, 则可以存储要添加到临时集合中的元素, 在循环访问完成后添加这些元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-174">If it is not necessary to add elements to the collection while iterating it, you can store the elements to be added in a temporary collection that you add when iterating the collection has finished.</span></span>  <span data-ttu-id="8a148-175">下面的示例使用此方法将集合中的数字的平方添加到临时集合, 然后将这些集合合并为单个数组对象。</span><span class="sxs-lookup"><span data-stu-id="8a148-175">The following example uses this approach to add the square of numbers in a collection to a temporary collection, and then to combine the collections into a single array object.</span></span>  
  
     [!code-csharp[System.InvalidOperationException#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Iterating3.cs#3)]
     [!code-vb[System.InvalidOperationException#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Iterating3.vb#3)]  
  
<a name="Sorting"></a>   
### <a name="sorting-an-array-or-collection-whose-objects-cannot-be-compared"></a><span data-ttu-id="8a148-176">对其对象无法进行比较的数组或集合进行排序</span><span class="sxs-lookup"><span data-stu-id="8a148-176">Sorting an array or collection whose objects cannot be compared</span></span>  
 <span data-ttu-id="8a148-177">一般用途的排序方法 ( <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType>如方法<xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType>或方法) 通常要求至少一个<xref:System.IComparable%601>要<xref:System.IComparable>排序的对象实现或接口。</span><span class="sxs-lookup"><span data-stu-id="8a148-177">General-purpose sorting methods, such as the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method or the <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> method, usually require that at least one of the objects to be sorted implement the <xref:System.IComparable%601> or the <xref:System.IComparable> interface.</span></span> <span data-ttu-id="8a148-178">如果不是, 则无法对集合或数组进行排序, 并且该方法<xref:System.InvalidOperationException>将引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-178">If not, the collection or array cannot be sorted, and the method throws an  <xref:System.InvalidOperationException> exception.</span></span> <span data-ttu-id="8a148-179">下面的示例定义了`Person`一个类, 将`Person`两个对象存储<xref:System.Collections.Generic.List%601>在一个泛型对象中, 并尝试对它们进行排序。</span><span class="sxs-lookup"><span data-stu-id="8a148-179">The following example defines a `Person` class, stores two `Person` objects in a generic <xref:System.Collections.Generic.List%601> object, and attempts to sort them.</span></span> <span data-ttu-id="8a148-180">如示例的输出所示, 对<xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType>方法的调用将<xref:System.InvalidOperationException>引发。</span><span class="sxs-lookup"><span data-stu-id="8a148-180">As the output from the example shows, the call to the <xref:System.Collections.Generic.List%601.Sort?displayProperty=nameWithType> method throws an <xref:System.InvalidOperationException>.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort1.cs#12)]
 [!code-vb[System.InvalidOperationException#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort1.vb#12)]  
  
 <span data-ttu-id="8a148-181">可以通过以下三种方式之一消除异常:</span><span class="sxs-lookup"><span data-stu-id="8a148-181">You can eliminate the exception in any of three ways:</span></span>  
  
-   <span data-ttu-id="8a148-182">如果可以拥有要进行排序的类型 (即, 如果控制其源代码), 则可以修改它以实现<xref:System.IComparable%601> <xref:System.IComparable>或接口。</span><span class="sxs-lookup"><span data-stu-id="8a148-182">If you can own the type that you are trying to sort (that is, if you control its source code), you can modify it to implement the <xref:System.IComparable%601> or the <xref:System.IComparable> interface.</span></span> <span data-ttu-id="8a148-183">这要求您实现<xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> <xref:System.IComparable.CompareTo%2A>或方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-183">This requires that you implement either the <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> or the <xref:System.IComparable.CompareTo%2A> method.</span></span> <span data-ttu-id="8a148-184">将接口实现添加到现有类型不是一项重大更改。</span><span class="sxs-lookup"><span data-stu-id="8a148-184">Adding an interface implementation to an existing type is not a breaking change.</span></span>  
  
     <span data-ttu-id="8a148-185">下面的示例使用此方法为<xref:System.IComparable%601> `Person`类提供一个实现。</span><span class="sxs-lookup"><span data-stu-id="8a148-185">The following example uses this approach to provide an <xref:System.IComparable%601> implementation  for the `Person` class.</span></span> <span data-ttu-id="8a148-186">你仍可以调用集合或数组的常规排序方法, 如示例中的输出所示, 该集合将成功排序。</span><span class="sxs-lookup"><span data-stu-id="8a148-186">You can still call the collection or array's general sorting method and, as the output from the example shows, the collection sorts successfully.</span></span>  
  
     [!code-csharp[System.InvalidOperationException#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort2.cs#13)]
     [!code-vb[System.InvalidOperationException#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort2.vb#13)]  
  
-   <span data-ttu-id="8a148-187">如果您无法修改您尝试进行排序的类型的源代码, 则可以定义一个实现<xref:System.Collections.Generic.IComparer%601>接口的特殊用途的排序类。</span><span class="sxs-lookup"><span data-stu-id="8a148-187">If you cannot modify the source code for the type you are trying to sort, you can define a special-purpose sorting class that implements the <xref:System.Collections.Generic.IComparer%601> interface.</span></span>  <span data-ttu-id="8a148-188">可以调用`Sort` <xref:System.Collections.Generic.IComparer%601>包含参数的方法的重载。</span><span class="sxs-lookup"><span data-stu-id="8a148-188">You can call an overload of the `Sort` method that includes an  <xref:System.Collections.Generic.IComparer%601> parameter.</span></span> <span data-ttu-id="8a148-189">如果要开发可基于多个条件对对象进行排序的专用排序类, 则此方法特别有用。</span><span class="sxs-lookup"><span data-stu-id="8a148-189">This approach is especially useful if you want to develop a specialized sorting class that can sort objects based on multiple criteria.</span></span>  
  
     <span data-ttu-id="8a148-190">下面的示例通过开发用于对集合进行排序`PersonComparer` `Person`的自定义类来使用方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-190">The following example uses the approach by developing a custom `PersonComparer` class that is used to sort `Person` collections.</span></span>  <span data-ttu-id="8a148-191">然后, 它将此类的一个实例传递<xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType>给方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-191">It then passes an instance of this class to the <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29?displayProperty=nameWithType> method.</span></span>  
  
     [!code-csharp[System.InvalidOperationException#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort3.cs#14)]
     [!code-vb[System.InvalidOperationException#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort3.vb#14)]  
  
-   <span data-ttu-id="8a148-192">如果无法修改您尝试排序的类型的源代码, 则可以创建一个<xref:System.Comparison%601>委托来执行排序。</span><span class="sxs-lookup"><span data-stu-id="8a148-192">If you cannot modify the source code for the type you are trying to sort, you can create a  <xref:System.Comparison%601> delegate to perform the sorting.</span></span> <span data-ttu-id="8a148-193">委托签名为</span><span class="sxs-lookup"><span data-stu-id="8a148-193">The delegate signature is</span></span>  
  
    ```vb  
    Function Comparison(Of T)(x As T, y As T) As Integer  
    ```  
  
    ```csharp  
    int Comparison<T>(T x, T y)  
    ```  
  
     <span data-ttu-id="8a148-194">下面的示例通过定义`PersonComparison` <xref:System.Comparison%601>与委托签名匹配的方法来使用方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-194">The following example uses the approach by defining a  `PersonComparison` method that matches the  <xref:System.Comparison%601> delegate signature.</span></span>  <span data-ttu-id="8a148-195">然后, 它将此委托传递<xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType>给方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-195">It then passes this delegate to the <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29?displayProperty=nameWithType> method.</span></span>  
  
     [!code-csharp[System.InvalidOperationException#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/List_Sort4.cs#15)]
     [!code-vb[System.InvalidOperationException#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/List_Sort4.vb#15)]  
  
<a name="Nullable"></a>   
### <a name="casting-a-nullablet-that-is-null-to-its-underlying-type"></a><span data-ttu-id="8a148-196">将为 null\<的可为 null 的 T > 强制转换为其基础类型</span><span class="sxs-lookup"><span data-stu-id="8a148-196">Casting a Nullable\<T> that is null to its underlying type</span></span>  
 <span data-ttu-id="8a148-197">如果尝试强制转换<xref:System.Nullable%601>为<xref:System.InvalidOperationException>其基础`null`类型的值, 则会引发异常并显示错误消息 "**可以为 null 的对象必须具有值。**</span><span class="sxs-lookup"><span data-stu-id="8a148-197">Attempting to cast a <xref:System.Nullable%601> value that is `null` to its underlying type throws an <xref:System.InvalidOperationException> exception  and displays the error message, "**Nullable object must have a value.**</span></span>  
  
 <span data-ttu-id="8a148-198">下面的示例在尝试<xref:System.InvalidOperationException>循环访问`Nullable(Of Integer)`包含值的数组时引发了异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-198">The following example throws an <xref:System.InvalidOperationException> exception  when it attempts to iterate an array that includes a `Nullable(Of Integer)` value.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable1.cs#4)]
 [!code-vb[System.InvalidOperationException#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable1.vb#4)]  
  
 <span data-ttu-id="8a148-199">若要防止发生此异常:</span><span class="sxs-lookup"><span data-stu-id="8a148-199">To prevent the exception:</span></span>  
  
-   <span data-ttu-id="8a148-200">使用属性来仅选择那些不`null`是的元素。 <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8a148-200">Use the <xref:System.Nullable%601.HasValue%2A?displayProperty=nameWithType> property to select only those elements that are not `null`.</span></span>  
  
-   <span data-ttu-id="8a148-201">调用<xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType>重载之一, 为`null`值提供默认值。</span><span class="sxs-lookup"><span data-stu-id="8a148-201">Call one of the <xref:System.Nullable%601.GetValueOrDefault%2A?displayProperty=nameWithType> overloads to provide a default value for a `null` value.</span></span>  
  
 <span data-ttu-id="8a148-202">下面的示例执行此<xref:System.InvalidOperationException>两个方法来避免异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-202">The following example does both to avoid the  <xref:System.InvalidOperationException> exception.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Nullable2.cs#5)]
 [!code-vb[System.InvalidOperationException#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Nullable2.vb#5)]  
  
<a name="Empty"></a>   
### <a name="calling-a-systemlinqenumerable-method-on-an-empty-collection"></a><span data-ttu-id="8a148-203">对空集合调用 system.exception 方法</span><span class="sxs-lookup"><span data-stu-id="8a148-203">Calling a System.Linq.Enumerable method on an empty collection</span></span>  
 <span data-ttu-id="8a148-204"><xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType> 、<xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>、 、<xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>、、 、和<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>方法对序列执行操作并返回单个结果。 <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8a148-204">The <xref:System.Linq.Enumerable.Aggregate%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Max%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Min%2A?displayProperty=nameWithType>,  <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, and <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> methods perform operations on a sequence and return a single result.</span></span>   <span data-ttu-id="8a148-205">如果序列为空, 而其他<xref:System.InvalidOperationException>重载返回`null`, 则这些方法的某些重载会引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-205">Some overloads of these methods throw an <xref:System.InvalidOperationException> exception when the sequence is empty, while other overloads return `null`.</span></span> <span data-ttu-id="8a148-206">当<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>序列包含多个<xref:System.InvalidOperationException>元素时, 该方法也会引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-206">The <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> method also throws an <xref:System.InvalidOperationException> exception when the sequence contains more than one element.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8a148-207">引发<xref:System.InvalidOperationException>异常的大多数方法都是重载。</span><span class="sxs-lookup"><span data-stu-id="8a148-207">Most of the methods that throw an <xref:System.InvalidOperationException> exception are overloads.</span></span> <span data-ttu-id="8a148-208">请确保了解所选重载的行为。</span><span class="sxs-lookup"><span data-stu-id="8a148-208">Be sure that you understand the behavior of the overload that you choose.</span></span>  
  
 <span data-ttu-id="8a148-209">下表列出了由对某些<xref:System.InvalidOperationException> <xref:System.Linq.Enumerable?displayProperty=nameWithType>方法的调用引发的异常对象的异常消息。</span><span class="sxs-lookup"><span data-stu-id="8a148-209">The following table lists the exception messages from the <xref:System.InvalidOperationException> exception objects thrown by calls to some <xref:System.Linq.Enumerable?displayProperty=nameWithType> methods.</span></span>  
  
|<span data-ttu-id="8a148-210">方法</span><span class="sxs-lookup"><span data-stu-id="8a148-210">Method</span></span>|<span data-ttu-id="8a148-211">消息</span><span class="sxs-lookup"><span data-stu-id="8a148-211">Message</span></span>|  
|------------|-------------|  
|`Aggregate` <br /> `Average` <br /> `Last` <br /> `Max` <br /> `Min`|<span data-ttu-id="8a148-212">**序列不包含任何元素**</span><span class="sxs-lookup"><span data-stu-id="8a148-212">**Sequence contains no elements**</span></span>|  
|`First`|<span data-ttu-id="8a148-213">**序列不包含任何匹配元素**</span><span class="sxs-lookup"><span data-stu-id="8a148-213">**Sequence contains no matching element**</span></span>|  
|`Single` <br /> `SingleOrDefault`|<span data-ttu-id="8a148-214">**序列包含一个以上的匹配元素**</span><span class="sxs-lookup"><span data-stu-id="8a148-214">**Sequence contains more than one matching element**</span></span>|  
  
 <span data-ttu-id="8a148-215">消除或处理异常的方式取决于应用程序的假设和所调用的特定方法。</span><span class="sxs-lookup"><span data-stu-id="8a148-215">How you eliminate or handle the exception depends on your application's assumptions and on the particular method you call.</span></span>  
  
-   <span data-ttu-id="8a148-216">如果在不检查空序列的情况下有意调用这些方法之一, 则假设序列不为空, 且空序列是意外的匹配项。</span><span class="sxs-lookup"><span data-stu-id="8a148-216">When you deliberately call one of these methods without checking for an empty sequence, you are assuming that the sequence is not empty, and that an empty sequence is an unexpected occurrence.</span></span> <span data-ttu-id="8a148-217">在这种情况下, 会适当捕获或重新引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-217">In this case, catching or rethrowing the exception is appropriate .</span></span>  
  
-   <span data-ttu-id="8a148-218">如果无法检查是否存在空序列, 则可以调用<xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType>重载的重载之一来确定序列是否包含任何元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-218">If your failure to check for an empty sequence was inadvertent, you can  call one of the overloads of the <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> overload to determine whether a sequence contains any elements.</span></span>  
  
    > [!TIP]
    >  <span data-ttu-id="8a148-219">如果要处理的数据可能包含大量元素或生成序列的操作非常昂贵, 则在生成序列之前调用方法可以提高性能。<xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="8a148-219">Calling the <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method before generating a sequence can improve performance if the data to be processed might contain a large number of elements or if operation that generates the sequence is expensive.</span></span>  
  
-   <span data-ttu-id="8a148-220">如果调用了<xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>方法 ( <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>如、或<xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>), 则<xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>可以替换返回默认值 (而不是序列的<xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>成员) 的替代方法, 如、或<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="8a148-220">If you've called a method such as <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.Last%2A?displayProperty=nameWithType>, or <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>, you can substitute an alternate method, such as <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>, <xref:System.Linq.Enumerable.LastOrDefault%2A?displayProperty=nameWithType>, or  <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>, that returns a default value instead of a member of the sequence.</span></span>  
  
 <span data-ttu-id="8a148-221">这些示例提供更多详细信息。</span><span class="sxs-lookup"><span data-stu-id="8a148-221">The examples provide additional detail.</span></span>  
  
 <span data-ttu-id="8a148-222">下面的示例使用<xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType>方法计算其值大于4的序列的平均值。</span><span class="sxs-lookup"><span data-stu-id="8a148-222">The following example uses the <xref:System.Linq.Enumerable.Average%2A?displayProperty=nameWithType> method to compute the average of a sequence whose values are greater than 4.</span></span> <span data-ttu-id="8a148-223">由于原始数组中没有值超过 4, 因此序列中不包含任何值, 并且该方法将引发<xref:System.InvalidOperationException>异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-223">Since no values from the original array exceed 4, no values are included in the sequence, and the method throws an <xref:System.InvalidOperationException> exception.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable1.cs#6)]
 [!code-vb[System.InvalidOperationException#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable1.vb#6)]  
  
 <span data-ttu-id="8a148-224">在调用处理序列的方法之前, <xref:System.Linq.Enumerable.Any%2A>可以通过调用方法来确定序列是否包含任何元素, 从而消除此异常, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="8a148-224">The exception can be eliminated by calling the <xref:System.Linq.Enumerable.Any%2A> method to determine whether the sequence contains any elements before calling the method that processes the sequence, as the following example shows.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable2.cs#7)]
 [!code-vb[System.InvalidOperationException#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable2.vb#7)]  
  
 <span data-ttu-id="8a148-225"><xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>方法返回序列中的第一项, 或序列中满足指定条件的第一个元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-225">The <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> method returns the first item in a sequence or the first element in a sequence that satisfies a specified condition.</span></span> <span data-ttu-id="8a148-226">如果序列为空, 因此不包含第一个元素, 则会引发<xref:System.InvalidOperationException>异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-226">If the sequence is empty and therefore does not have a first element, it throws an <xref:System.InvalidOperationException> exception.</span></span>  
  
 <span data-ttu-id="8a148-227">在下面的示例中, <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType>方法<xref:System.InvalidOperationException>引发异常, 因为 dbQueryResults 数组不包含大于4的元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-227">In the following example, the <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method throws an <xref:System.InvalidOperationException> exception because the dbQueryResults array doesn't contain an element greater than 4.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable3.cs#8)]
 [!code-vb[System.InvalidOperationException#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable3.vb#8)]  
  
 <span data-ttu-id="8a148-228">您可以调用<xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>方法, <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>而不是返回指定值或默认值。</span><span class="sxs-lookup"><span data-stu-id="8a148-228">You can call the <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> method instead of <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> to return a specified or default value.</span></span> <span data-ttu-id="8a148-229">如果该方法未在序列中找到第一个元素, 则它将返回该数据类型的默认值。</span><span class="sxs-lookup"><span data-stu-id="8a148-229">If the method does not find a first element in the sequence, it returns  the default value for that data type.</span></span>  <span data-ttu-id="8a148-230">`null`对于引用类型, 默认值为 0; 对于数值数据类型<xref:System.DateTime.MinValue?displayProperty=nameWithType> , 默认值为零; <xref:System.DateTime>对于类型, 则为。</span><span class="sxs-lookup"><span data-stu-id="8a148-230">The default value is `null` for a reference type, zero for a numeric data type, and <xref:System.DateTime.MinValue?displayProperty=nameWithType> for the <xref:System.DateTime> type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8a148-231">解释该<xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType>方法返回的值通常是很复杂的, 因为该类型的默认值可以是序列中的有效值。</span><span class="sxs-lookup"><span data-stu-id="8a148-231">Interpreting the value returned by the <xref:System.Linq.Enumerable.FirstOrDefault%2A?displayProperty=nameWithType> method is often complicated by the fact that the default value of the type can be a valid value in the sequence.</span></span> <span data-ttu-id="8a148-232">在这种情况下, 在<xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType>调用方法之前, 调用方法来确定序列是否具有有效的成员。</span><span class="sxs-lookup"><span data-stu-id="8a148-232">In this case, you an call the <xref:System.Linq.Enumerable.Any%2A?displayProperty=nameWithType> method to determine whether the sequence has valid members before calling the <xref:System.Linq.Enumerable.First%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8a148-233">下面的示例调用<xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType>方法, 以防止在上一个示例中引发的<xref:System.InvalidOperationException>异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-233">The following example calls the  <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29?displayProperty=nameWithType> method to prevent the <xref:System.InvalidOperationException> exception thrown in the previous example.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable4.cs#9)]
 [!code-vb[System.InvalidOperationException#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable4.vb#9)]  
  
<a name="Single"></a>   
### <a name="calling-enumerablesingle-or-enumerablesingleordefault-on-a-sequence-without-one-element"></a><span data-ttu-id="8a148-234">对没有一个元素的序列调用 SingleOrDefault 或可枚举的。</span><span class="sxs-lookup"><span data-stu-id="8a148-234">Calling Enumerable.Single or Enumerable.SingleOrDefault on a sequence without one element</span></span>  
 <span data-ttu-id="8a148-235"><xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>方法返回序列中的唯一元素, 或序列中满足指定条件的唯一元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-235">The <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> method returns the only element of a sequence, or the only element of a sequence that meets a specified condition.</span></span>    <span data-ttu-id="8a148-236">如果序列中没有元素, 或者如果有多个元素, 则该方法将引发<xref:System.InvalidOperationException>异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-236">If there are no elements in the sequence, or if there is more than one element , the method throws an <xref:System.InvalidOperationException> exception.</span></span>  
  
 <span data-ttu-id="8a148-237">如果序列不包含<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>任何元素, 则可以使用方法返回默认值, 而不是引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-237">You can use the <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> method to return a default value instead of throwing an exception when the sequence contains no elements.</span></span> <span data-ttu-id="8a148-238">但是, 当<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>序列包含多个<xref:System.InvalidOperationException>元素时, 该方法仍会引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-238">However, the <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> method still throws an <xref:System.InvalidOperationException> exception  when the sequence contains more than one element.</span></span>  
  
 <span data-ttu-id="8a148-239">下表列出了由对<xref:System.InvalidOperationException> <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>和<xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>方法的调用引发的异常对象的异常消息。</span><span class="sxs-lookup"><span data-stu-id="8a148-239">The following table lists the exception messages from the <xref:System.InvalidOperationException> exception objects thrown by calls to the <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> and <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> methods.</span></span>  
  
|<span data-ttu-id="8a148-240">方法</span><span class="sxs-lookup"><span data-stu-id="8a148-240">Method</span></span>|<span data-ttu-id="8a148-241">消息</span><span class="sxs-lookup"><span data-stu-id="8a148-241">Message</span></span>|  
|------------|-------------|  
|`Single`|<span data-ttu-id="8a148-242">**序列不包含任何匹配元素**</span><span class="sxs-lookup"><span data-stu-id="8a148-242">**Sequence contains no matching element**</span></span>|  
|`Single` <br /> `SingleOrDefault`|<span data-ttu-id="8a148-243">**序列包含一个以上的匹配元素**</span><span class="sxs-lookup"><span data-stu-id="8a148-243">**Sequence contains more than one matching element**</span></span>|  
  
 <span data-ttu-id="8a148-244">在下面的示例中, 对<xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>方法的调用将<xref:System.InvalidOperationException>引发异常, 因为序列没有大于4的元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-244">In the following example, the call to the <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> method throws an <xref:System.InvalidOperationException> exception because the sequence doesn't have an element greater than 4.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable5.cs#10)]
 [!code-vb[System.InvalidOperationException#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable5.vb#10)]  
  
 <span data-ttu-id="8a148-245">下面的示例尝试通过<xref:System.InvalidOperationException> <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>调用方法来防止序列为空时引发的异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-245">The following example attempts to prevent the <xref:System.InvalidOperationException> exception thrown when a sequence is empty by instead calling the <xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8a148-246">但是, 因为此序列返回多个值大于2的元素, 所以它还会引发<xref:System.InvalidOperationException>异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-246">However, because this sequence returns multiple elements whose value is greater than 2, it also throws an <xref:System.InvalidOperationException> exception.</span></span>  
  
 [!code-csharp[System.InvalidOperationException#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.invalidoperationexception/cs/Enumerable6.cs#11)]
 [!code-vb[System.InvalidOperationException#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.invalidoperationexception/vb/Enumerable6.vb#11)]  
  
 <span data-ttu-id="8a148-247"><xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType>调用方法假设序列或满足指定条件的序列只包含一个元素。</span><span class="sxs-lookup"><span data-stu-id="8a148-247">Calling the <xref:System.Linq.Enumerable.Single%2A?displayProperty=nameWithType> method assumes that either a sequence or the sequence that meets specified criteria contains only one element.</span></span>  <span data-ttu-id="8a148-248"><xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType>假设序列包含零个或一个结果, 但没有其他结果。</span><span class="sxs-lookup"><span data-stu-id="8a148-248"><xref:System.Linq.Enumerable.SingleOrDefault%2A?displayProperty=nameWithType> assumes a sequence with zero or one result, but no more.</span></span> <span data-ttu-id="8a148-249">如果此假设在您的部分中是有意的, 并且不满足这些条件, 则会重新引发或<xref:System.InvalidOperationException>捕获产生的结果。</span><span class="sxs-lookup"><span data-stu-id="8a148-249">If this assumption is a deliberate one on your part and these conditions are not met, rethrowing or catching the resulting <xref:System.InvalidOperationException> is appropriate.</span></span> <span data-ttu-id="8a148-250">否则, 或者, 如果您希望在某些频率下发生无效的条件, 则应考虑使用其他<xref:System.Linq.Enumerable>方法, <xref:System.Linq.Enumerable.FirstOrDefault%2A>例如或<xref:System.Linq.Enumerable.Where%2A>。</span><span class="sxs-lookup"><span data-stu-id="8a148-250">Otherwise, or if you expect that invalid conditions will occur with some frequency, you should consider using some other <xref:System.Linq.Enumerable> method, such as <xref:System.Linq.Enumerable.FirstOrDefault%2A> or <xref:System.Linq.Enumerable.Where%2A>.</span></span>  
  
<a name="Emit"></a>   
### <a name="dynamic-cross-application-domain-field-access"></a><span data-ttu-id="8a148-251">动态跨应用程序域字段访问</span><span class="sxs-lookup"><span data-stu-id="8a148-251">Dynamic cross-application domain field access</span></span>  
 <span data-ttu-id="8a148-252">如果<xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType>包含您尝试检索其地址的字段所在<xref:System.InvalidOperationException>的对象不在执行您的代码的应用程序域中, 则 Microsoft 中间语言 (MSIL) 指令会引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-252">The <xref:System.Reflection.Emit.OpCodes.Ldflda?displayProperty=nameWithType> Microsoft intermediate language (MSIL) instruction throws an <xref:System.InvalidOperationException> exception if the object containing the field whose address you are trying to retrieve is not within the application domain in which your code is executing.</span></span> <span data-ttu-id="8a148-253">字段的地址只能从它所在的应用程序域进行访问。</span><span class="sxs-lookup"><span data-stu-id="8a148-253">The address of a field can only be accessed from the application domain in which it resides.</span></span>  
  
<a name="Throwing"></a>   
## <a name="throwing-an-invalidoperationexception-exception"></a><span data-ttu-id="8a148-254">引发 InvalidOperationException 异常</span><span class="sxs-lookup"><span data-stu-id="8a148-254">Throwing an InvalidOperationException exception</span></span>  
 <span data-ttu-id="8a148-255">仅当对象的<xref:System.InvalidOperationException>状态出于某种原因不支持特定方法调用时, 才应引发异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-255">You should throw an <xref:System.InvalidOperationException> exception only when the state of your object for some reason does not support a particular method call.</span></span> <span data-ttu-id="8a148-256">也就是说, 方法调用在某些环境或上下文中有效, 但在其他情况下无效。</span><span class="sxs-lookup"><span data-stu-id="8a148-256">That is, the method call is valid in some circumstances or contexts, but is invalid in others.</span></span>  
  
 <span data-ttu-id="8a148-257">如果方法调用失败是由无效参数引起的, 则<xref:System.ArgumentException>应改为引发或其派生<xref:System.ArgumentNullException>类<xref:System.ArgumentOutOfRangeException>之一或。</span><span class="sxs-lookup"><span data-stu-id="8a148-257">If the method invocation failure is due to invalid arguments, then <xref:System.ArgumentException> or one of its derived classes, <xref:System.ArgumentNullException> or <xref:System.ArgumentOutOfRangeException>, should be thrown instead.</span></span>  
  
<a name="Misc"></a>   
## <a name="miscellaneous-information"></a><span data-ttu-id="8a148-258">杂项信息</span><span class="sxs-lookup"><span data-stu-id="8a148-258">Miscellaneous information</span></span>  
 <span data-ttu-id="8a148-259"><xref:System.InvalidOperationException>使用 COR_E_INVALIDOPERATION 值为0x80131509 的 HRESULT。</span><span class="sxs-lookup"><span data-stu-id="8a148-259"><xref:System.InvalidOperationException> uses the HRESULT COR_E_INVALIDOPERATION, which has the value 0x80131509.</span></span>  
  
 <span data-ttu-id="8a148-260">有关实例的初始属性值的列表<xref:System.InvalidOperationException>，请参阅<xref:System.InvalidOperationException.%23ctor%2A>构造函数。</span><span class="sxs-lookup"><span data-stu-id="8a148-260">For a list of initial property values for an instance of <xref:System.InvalidOperationException>, see the <xref:System.InvalidOperationException.%23ctor%2A> constructors.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Exception" />
    <altmember cref="T:System.Collections.IEnumerator" />
    <altmember cref="T:System.Resources.ResourceSet" />
    <related type="Article" href="~/docs/standard/exceptions/index.md"><span data-ttu-id="8a148-261">处理和引发异常</span><span class="sxs-lookup"><span data-stu-id="8a148-261">Handling and Throwing Exceptions</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="8a148-262">初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="8a148-262">Initializes a new instance of the <see cref="T:System.InvalidOperationException" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="8a148-263">初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="8a148-263">Initializes a new instance of the <see cref="T:System.InvalidOperationException" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a148-264">此构造函数将<xref:System.Exception.Message%2A>新实例的属性初始化为系统提供的描述错误的消息, 例如 "无法执行请求的操作"。</span><span class="sxs-lookup"><span data-stu-id="8a148-264">This constructor initializes the <xref:System.Exception.Message%2A> property of the new instance to a system-supplied message that describes the error, such as "The requested operation cannot be performed."</span></span> <span data-ttu-id="8a148-265">此消息将当前系统区域性考虑在内。</span><span class="sxs-lookup"><span data-stu-id="8a148-265">This message takes into account the current system culture.</span></span>  
  
 <span data-ttu-id="8a148-266">下表显示 <xref:System.InvalidOperationException> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="8a148-266">The following table shows the initial property values for an instance of <xref:System.InvalidOperationException>.</span></span>  
  
|<span data-ttu-id="8a148-267">Property</span><span class="sxs-lookup"><span data-stu-id="8a148-267">Property</span></span>|<span data-ttu-id="8a148-268">“值”</span><span class="sxs-lookup"><span data-stu-id="8a148-268">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="8a148-269">空引用（在 Visual Basic 中为 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="8a148-269">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="8a148-270">本地化的错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="8a148-270">The localized error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string -&gt; InvalidOperationException" Usage="new System.InvalidOperationException message" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="8a148-271">描述错误的消息。</span><span class="sxs-lookup"><span data-stu-id="8a148-271">The message that describes the error.</span></span></param>
        <summary><span data-ttu-id="8a148-272">用指定的错误消息初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="8a148-272">Initializes a new instance of the <see cref="T:System.InvalidOperationException" /> class with a specified error message.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a148-273">此构造函数`message`使用<xref:System.Exception.Message%2A?displayProperty=nameWithType>参数初始化新异常的属性。</span><span class="sxs-lookup"><span data-stu-id="8a148-273">This constructor initializes the <xref:System.Exception.Message%2A?displayProperty=nameWithType> property of the new exception using the `message` parameter.</span></span> <span data-ttu-id="8a148-274">`message` 的内容被设计为人可理解的形式。</span><span class="sxs-lookup"><span data-stu-id="8a148-274">The content of `message` is intended to be understood by humans.</span></span> <span data-ttu-id="8a148-275">此构造函数的调用方需要确保此字符串已针对当前系统区域性进行了本地化。</span><span class="sxs-lookup"><span data-stu-id="8a148-275">The caller of this constructor is required to ensure that this string has been localized for the current system culture.</span></span>  
  
 <span data-ttu-id="8a148-276">下表显示 <xref:System.InvalidOperationException> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="8a148-276">The following table shows the initial property values for an instance of <xref:System.InvalidOperationException>.</span></span>  
  
|<span data-ttu-id="8a148-277">Property</span><span class="sxs-lookup"><span data-stu-id="8a148-277">Property</span></span>|<span data-ttu-id="8a148-278">“值”</span><span class="sxs-lookup"><span data-stu-id="8a148-278">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="8a148-279">空引用（在 Visual Basic 中为 `Nothing`）。</span><span class="sxs-lookup"><span data-stu-id="8a148-279">A null reference (`Nothing` in Visual Basic).</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="8a148-280">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="8a148-280">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected InvalidOperationException (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; InvalidOperationException(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="8a148-281">承载序列化对象数据的对象。</span><span class="sxs-lookup"><span data-stu-id="8a148-281">The object that holds the serialized object data.</span></span></param>
        <param name="context"><span data-ttu-id="8a148-282">关于来源和目标的上下文信息</span><span class="sxs-lookup"><span data-stu-id="8a148-282">The contextual information about the source or destination.</span></span></param>
        <summary><span data-ttu-id="8a148-283">用序列化数据初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="8a148-283">Initializes a new instance of the <see cref="T:System.InvalidOperationException" /> class with serialized data.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a148-284">此构造函数在反序列化过程中调用，以便重建通过流传输的异常对象。</span><span class="sxs-lookup"><span data-stu-id="8a148-284">This constructor is called during deserialization to reconstitute the exception object transmitted over a stream.</span></span> <span data-ttu-id="8a148-285">有关详细信息，请参阅[XML 和 SOAP 序列化](~/docs/standard/serialization/xml-and-soap-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="8a148-285">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/serialization/xml-and-soap-serialization.md"><span data-ttu-id="8a148-286">XML 和 SOAP 序列化</span><span class="sxs-lookup"><span data-stu-id="8a148-286">XML and SOAP Serialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public InvalidOperationException (string message, Exception innerException);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string message, class System.Exception innerException) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.InvalidOperationException.#ctor(System.String,System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (message As String, innerException As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; InvalidOperationException(System::String ^ message, Exception ^ innerException);" />
      <MemberSignature Language="F#" Value="new InvalidOperationException : string * Exception -&gt; InvalidOperationException" Usage="new System.InvalidOperationException (message, innerException)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="innerException" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message"><span data-ttu-id="8a148-287">解释异常原因的错误消息。</span><span class="sxs-lookup"><span data-stu-id="8a148-287">The error message that explains the reason for the exception.</span></span></param>
        <param name="innerException"><span data-ttu-id="8a148-288">导致当前异常的异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-288">The exception that is the cause of the current exception.</span></span> <span data-ttu-id="8a148-289">如果 <paramref name="innerException" /> 参数不是 null 引用（在 Visual Basic 中为 <see langword="Nothing" />），则在处理内部异常的 <see langword="catch" /> 块中引发当前异常。</span><span class="sxs-lookup"><span data-stu-id="8a148-289">If the <paramref name="innerException" /> parameter is not a null reference (<see langword="Nothing" /> in Visual Basic), the current exception is raised in a <see langword="catch" /> block that handles the inner exception.</span></span></param>
        <summary><span data-ttu-id="8a148-290">使用指定的错误消息和对作为此异常原因的内部异常的引用来初始化 <see cref="T:System.InvalidOperationException" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="8a148-290">Initializes a new instance of the <see cref="T:System.InvalidOperationException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8a148-291">因前一个异常而直接引发的异常应在 <xref:System.Exception.InnerException%2A> 属性中包含对前一个异常的引用。</span><span class="sxs-lookup"><span data-stu-id="8a148-291">An exception that is thrown as a direct result of a previous exception should include a reference to the previous exception in the <xref:System.Exception.InnerException%2A> property.</span></span> <span data-ttu-id="8a148-292"><xref:System.Exception.InnerException%2A> 属性返回传递到构造函数中的相同值，或者如果 `Nothing` 属性不向构造函数提供内部异常值，则为空引用（在 Visual Basic 中为 <xref:System.Exception.InnerException%2A>）。</span><span class="sxs-lookup"><span data-stu-id="8a148-292">The <xref:System.Exception.InnerException%2A> property returns the same value that is passed into the constructor, or a null reference (`Nothing` in Visual Basic) if the <xref:System.Exception.InnerException%2A> property does not supply the inner exception value to the constructor.</span></span>  
  
 <span data-ttu-id="8a148-293">下表显示 <xref:System.InvalidOperationException> 的实例的初始属性值。</span><span class="sxs-lookup"><span data-stu-id="8a148-293">The following table shows the initial property values for an instance of <xref:System.InvalidOperationException>.</span></span>  
  
|<span data-ttu-id="8a148-294">Property</span><span class="sxs-lookup"><span data-stu-id="8a148-294">Property</span></span>|<span data-ttu-id="8a148-295">“值”</span><span class="sxs-lookup"><span data-stu-id="8a148-295">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Exception.InnerException%2A>|<span data-ttu-id="8a148-296">内部异常引用。</span><span class="sxs-lookup"><span data-stu-id="8a148-296">The inner exception reference.</span></span>|  
|<xref:System.Exception.Message%2A>|<span data-ttu-id="8a148-297">错误消息字符串。</span><span class="sxs-lookup"><span data-stu-id="8a148-297">The error message string.</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Exception" />
        <related type="Article" href="~/docs/standard/exceptions/index.md"><span data-ttu-id="8a148-298">处理和引发异常</span><span class="sxs-lookup"><span data-stu-id="8a148-298">Handling and Throwing Exceptions</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>
