<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6d3bee1721752f1378e182ae08c7080273500342" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69420925" /></Metadata><TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="1f410-101">指示可将枚举视为位域（即一组标志）。</span><span class="sxs-lookup"><span data-stu-id="1f410-101">Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="1f410-102">位域通常用于可能会组合在一起的元素列表, 而枚举常量通常用于互斥元素的列表。</span><span class="sxs-lookup"><span data-stu-id="1f410-102">Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</span></span> <span data-ttu-id="1f410-103">因此, 位域设计为与按位 "或" 运算组合以生成未命名的值, 而不是枚举的常量。</span><span class="sxs-lookup"><span data-stu-id="1f410-103">Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</span></span> <span data-ttu-id="1f410-104">与枚举常量相比, 语言的使用位域有所不同。</span><span class="sxs-lookup"><span data-stu-id="1f410-104">Languages vary in their use of bit fields compared to enumeration constants.</span></span>  
  
## <a name="attributes-of-the-flagsattribute"></a><span data-ttu-id="1f410-105">FlagsAttribute 的属性</span><span class="sxs-lookup"><span data-stu-id="1f410-105">Attributes of the FlagsAttribute</span></span>  
 <span data-ttu-id="1f410-106"><xref:System.AttributeUsageAttribute>应用于此类, 其<xref:System.AttributeUsageAttribute.Inherited%2A>属性指定。 `false`</span><span class="sxs-lookup"><span data-stu-id="1f410-106"><xref:System.AttributeUsageAttribute> is applied to this class, and its <xref:System.AttributeUsageAttribute.Inherited%2A> property specifies `false`.</span></span> <span data-ttu-id="1f410-107">此特性仅可应用于枚举。</span><span class="sxs-lookup"><span data-stu-id="1f410-107">This attribute can only be applied to enumerations.</span></span>  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a><span data-ttu-id="1f410-108">FlagsAttribute 和 Enum 的准则</span><span class="sxs-lookup"><span data-stu-id="1f410-108">Guidelines for FlagsAttribute and Enum</span></span>  
  
-   <span data-ttu-id="1f410-109">仅当对数值执行了按位运算 (and、OR、EXCLUSIVE 或) 时, 才将自定义属性用于枚举。<xref:System.FlagsAttribute></span><span class="sxs-lookup"><span data-stu-id="1f410-109">Use the <xref:System.FlagsAttribute> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</span></span>  
  
-   <span data-ttu-id="1f410-110">以2的幂 (即1、2、4、8等) 定义枚举常数。</span><span class="sxs-lookup"><span data-stu-id="1f410-110">Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</span></span> <span data-ttu-id="1f410-111">这意味着组合枚举常量中的各个标志不会重叠。</span><span class="sxs-lookup"><span data-stu-id="1f410-111">This means the individual flags in combined enumeration constants do not overlap.</span></span>  
  
-   <span data-ttu-id="1f410-112">请考虑为常用标记组合创建枚举常数。</span><span class="sxs-lookup"><span data-stu-id="1f410-112">Consider creating an enumerated constant for commonly used flag combinations.</span></span> <span data-ttu-id="1f410-113">例如, 如果你有一个枚举用于包含枚举常量`Read = 1`和`Write = 2`的文件 i/o 操作, 请考虑创建一个将`Read`和`Write`组合起来的枚举`ReadWrite = Read OR Write`常量随意.</span><span class="sxs-lookup"><span data-stu-id="1f410-113">For example, if you have an enumeration used for file I/O operations that contains the enumerated constants `Read = 1` and `Write = 2`, consider creating the enumerated constant `ReadWrite = Read OR Write`, which combines the `Read` and `Write` flags.</span></span> <span data-ttu-id="1f410-114">此外, 在某些情况下, 用于合并标志的按位 "或" 运算在某些情况下可能被视为高级概念, 而对于简单任务不是必需的。</span><span class="sxs-lookup"><span data-stu-id="1f410-114">In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</span></span>  
  
-   <span data-ttu-id="1f410-115">如果将一个负数定义为标志枚举常量, 则请小心, 因为许多标志位置可能设置为 1, 这可能会使代码混乱并鼓励编码错误。</span><span class="sxs-lookup"><span data-stu-id="1f410-115">Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</span></span>  
  
-   <span data-ttu-id="1f410-116">测试某个标志是否在数值中设置的一种简便方法是: 在数值和标志枚举常量之间执行按位 "与" 运算, 这会将数值中的所有位设置为零, 而不是对应于标志的值, 然后测试该操作的结果是否等于标志枚举常数。</span><span class="sxs-lookup"><span data-stu-id="1f410-116">A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</span></span>  
  
-   <span data-ttu-id="1f410-117">`None`用作值为零的标志枚举常量的名称。</span><span class="sxs-lookup"><span data-stu-id="1f410-117">Use `None` as the name of the flag enumerated constant whose value is zero.</span></span> <span data-ttu-id="1f410-118">不能使用按`None`位 "与" 运算中的枚举常量来测试标志, 因为结果始终为零。</span><span class="sxs-lookup"><span data-stu-id="1f410-118">You cannot use the `None` enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</span></span> <span data-ttu-id="1f410-119">不过, 您可以对数字值和`None`枚举常量执行逻辑 "非按位" 比较, 以确定是否设置了数值中的任何位。</span><span class="sxs-lookup"><span data-stu-id="1f410-119">However, you can perform a logical, not a bitwise, comparison between the numeric value and the `None` enumerated constant to determine whether any bits in the numeric value are set.</span></span>  
  
     <span data-ttu-id="1f410-120">如果创建的是值枚举而不是标志枚举, 则创建`None`枚举常数仍是有意义的。</span><span class="sxs-lookup"><span data-stu-id="1f410-120">If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a `None` enumerated constant.</span></span> <span data-ttu-id="1f410-121">这是因为, 默认情况下, 由公共语言运行时将用于枚举的内存初始化为零。</span><span class="sxs-lookup"><span data-stu-id="1f410-121">The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</span></span> <span data-ttu-id="1f410-122">因此, 如果未定义值为零的常量, 则在创建枚举时将包含非法值。</span><span class="sxs-lookup"><span data-stu-id="1f410-122">Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</span></span>  
  
     <span data-ttu-id="1f410-123">如果应用程序需要表示一个明显的默认情况, 请考虑使用值为零的枚举常数来表示默认值。</span><span class="sxs-lookup"><span data-stu-id="1f410-123">If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</span></span> <span data-ttu-id="1f410-124">如果没有默认的情况, 请考虑使用值为零的枚举常数, 表示不是由其他任何枚举常数表示的情况。</span><span class="sxs-lookup"><span data-stu-id="1f410-124">If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</span></span>  
  
-   <span data-ttu-id="1f410-125">不要定义仅用于镜像枚举自身状态的枚举值。</span><span class="sxs-lookup"><span data-stu-id="1f410-125">Do not define an enumeration value solely to mirror the state of the enumeration itself.</span></span> <span data-ttu-id="1f410-126">例如, 不要定义仅标记枚举结尾的枚举常数。</span><span class="sxs-lookup"><span data-stu-id="1f410-126">For example, do not define an enumerated constant that merely marks the end of the enumeration.</span></span> <span data-ttu-id="1f410-127">如果需要确定枚举的最后一个值, 请显式检查该值。</span><span class="sxs-lookup"><span data-stu-id="1f410-127">If you need to determine the last value of the enumeration, check for that value explicitly.</span></span> <span data-ttu-id="1f410-128">此外, 如果范围内的所有值都有效, 则可以对第一个和最后一个枚举常量执行范围检查。</span><span class="sxs-lookup"><span data-stu-id="1f410-128">In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</span></span>  
  
-   <span data-ttu-id="1f410-129">不要指定保留供将来使用的枚举常量。</span><span class="sxs-lookup"><span data-stu-id="1f410-129">Do not specify enumerated constants that are reserved for future use.</span></span>  
  
-   <span data-ttu-id="1f410-130">定义将枚举常量作为值的方法或属性时, 请考虑验证值。</span><span class="sxs-lookup"><span data-stu-id="1f410-130">When you define a method or property that takes an enumerated constant as a value, consider validating the value.</span></span> <span data-ttu-id="1f410-131">原因在于, 您可以将数值强制转换为枚举类型, 即使枚举中未定义该数值。</span><span class="sxs-lookup"><span data-stu-id="1f410-131">The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="1f410-132">下面的示例阐释了`FlagsAttribute`如何使用特性, 并显示对<xref:System.Enum>声明使用`FlagsAttribute`的<xref:System.Enum.ToString%2A>方法的影响。</span><span class="sxs-lookup"><span data-stu-id="1f410-132">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 <span data-ttu-id="1f410-133">下面的示例定义了两个与颜色相关`SingleHue`的`MultiHue`枚举: 和。</span><span class="sxs-lookup"><span data-stu-id="1f410-133">The following example defines two color-related enumerations, `SingleHue` and `MultiHue`.</span></span> <span data-ttu-id="1f410-134">后者具有`FlagsAttribute`属性; 前者不具有属性。</span><span class="sxs-lookup"><span data-stu-id="1f410-134">The latter has the `FlagsAttribute` attribute; the former does not.</span></span> <span data-ttu-id="1f410-135">此示例显示了在一个整数范围 (包括不表示枚举类型的基础值的整数) 转换为枚举类型及其显示的字符串表示形式时的行为差异。</span><span class="sxs-lookup"><span data-stu-id="1f410-135">The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</span></span>   <span data-ttu-id="1f410-136">例如, 请注意, 3 不能表示为`SingleHue`值, 因为3不是任何`SingleHue`成员的基础值, 而`FlagsAttribute`特性`MultiHue`使你可以将3表示为的`Black, Red`值。</span><span class="sxs-lookup"><span data-stu-id="1f410-136">For example, note that 3 cannot be represented as a `SingleHue` value because 3 is not the underlying value of any `SingleHue` member, whereas the `FlagsAttribute` attribute makes it possible to represent 3 as a `MultiHue` value of `Black, Red`.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="1f410-137">初始化 <see cref="T:System.FlagsAttribute" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="1f410-137">Initializes a new instance of the <see cref="T:System.FlagsAttribute" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="1f410-138">下面的示例定义了`PhoneService`一个枚举, 该枚举表示电话公司提供的通信形式。</span><span class="sxs-lookup"><span data-stu-id="1f410-138">The following example defines a `PhoneService` enumeration that represents forms of communication provided by a telephone company.</span></span> <span data-ttu-id="1f410-139">它初始化三个表示提供给三个不同家庭的服务的变量, 然后指示哪些家庭没有服务, 哪些家庭只包含手机服务, 哪些家庭具有手机和陆地线路服务。</span><span class="sxs-lookup"><span data-stu-id="1f410-139">It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</span></span> <span data-ttu-id="1f410-140">最后, 它隐式调用<xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType>方法以显示提供给每个家庭的服务的类型。</span><span class="sxs-lookup"><span data-stu-id="1f410-140">Finally, it implicitly calls the <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> method to display the types of service provided to each household.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 <span data-ttu-id="1f410-141">下面的示例阐释了`FlagsAttribute`如何使用特性, 并显示对<xref:System.Enum>声明使用`FlagsAttribute`的<xref:System.Enum.ToString%2A>方法的影响。</span><span class="sxs-lookup"><span data-stu-id="1f410-141">The following example illustrates the use of the `FlagsAttribute` attribute and shows the effect on the <xref:System.Enum.ToString%2A> method of using `FlagsAttribute` on an <xref:System.Enum> declaration.</span></span>  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
