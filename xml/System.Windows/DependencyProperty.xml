<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="80a9f01be53a2b998e0b5051f60d7a1d2994dddd" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68439807" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示可通过诸如样式、数据绑定、动画和继承等方法设置的属性。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty>支持中[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]的以下功能:  
  
-   可以在样式中设置属性。 有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
-   可以通过数据绑定设置属性。 有关数据绑定依赖项属性的详细信息, [请参阅如何:绑定两个控件](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)的属性。  
  
-   可以通过动态资源引用来设置属性。 有关详细信息，请参阅 [XAML 资源](~/docs/framework/wpf/advanced/xaml-resources.md)。  
  
-   属性可以从元素树中的父元素自动继承其值。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
-   可以对属性进行动画处理。 有关详细信息，请参阅 [动画概述](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)。  
  
-   属性的上一个值已更改并且属性值可以被强制时, 属性可报告。 有关详细信息，请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
-   属性将信息报告给[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], 例如更改属性值是否应要求布局系统 recompose 元素的视觉对象。  
  
-   属性在中[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]接收支持。  例如, 可以在 "**属性**" 窗口中编辑该属性。  
  
 若要了解有关依赖项属性的详细信息, 请参阅[依赖属性概述](~/docs/framework/wpf/advanced/dependency-properties-overview.md)。 如果希望自定义类型的属性支持上述列表中的功能, 则应创建一个依赖项属性。  若要了解如何创建自定义依赖项属性, 请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
 附加属性是一种属性, 该属性使任何对象都可以向定义附加属性的类型报告信息。 在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]中, 从<xref:System.Windows.DependencyObject>继承的任何类型都可以使用附加属性, 无论该类型是否继承自定义该属性的类型。 附加属性是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]语言的一项功能。  若要在中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]设置附加属性, 请使用*所有者*的。*propertyName*语法。 附加属性的一个示例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>属性。 如果要创建可用于所有<xref:System.Windows.DependencyObject>类型的属性, 则应创建附加属性。 若要了解有关附加属性的详细信息 (包括如何创建附加属性), 请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性用法  
  
```xaml 
<object property="dependencyPropertyName"/>  
```

或

```xaml
<object property="ownerType.dependencyPropertyName"/>  
```

或

```xaml
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 值  
 `dependencyPropertyName`  
 一个字符串, 指定<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>所需依赖属性的。 如果该属性不在默认的 XML 命名空间中, 则可以在其前面加上一个 XML 命名空间前缀 (有关详细信息, 请参阅[WPF xaml 的 Xaml 命名空间和命名空间映射](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md))。  
  
 `ownerType`.`dependencyPropertyName`  
 一个字符串, 该字符串指定依赖项属性的所有者类型、点 (.)、和<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>。 `ownerType`还可以以 XML 命名空间前缀开头。 此用法特别适用于晚期绑定样式和模板, 其中必须指定依赖属性的所有者来分析上下文, 因为`TargetType`尚不知道。 有关详细信息，请参阅[样式设置和模板化](~/docs/framework/wpf/controls/styling-and-templating.md)。  
  
 `attachedPropertyOwnerType` *的哈希代码。* `attachedPropertyName`  
 一个字符串, 指定附加属性的所有者、点 (.) 和附加属性名称。 `attachedPropertyOwnerType`还可以以 XML 命名空间前缀开头。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将另一种类型添加为已注册到一种类型的依赖属性的所有者。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">要作为此依赖属性所有者添加的类型。</param>
        <summary>将另一种类型添加为已注册的依赖属性的所有者。</summary>
        <returns>一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。 应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法, 属性系统可以在最初未注册特定依赖属性的类型上识别依赖属性。  
  
 通常, <xref:System.Windows.DependencyProperty.AddOwner%2A>用于向未通过托管类继承公开依赖属性的类添加依赖属性 (类继承将导致派生类继承包装属性, 因此将提供对依赖属性的常规成员表访问权限)。 <xref:System.Windows.DependencyProperty.AddOwner%2A>使属性系统能够识别最初未注册该依赖属性的类型的依赖项属性。  
  
 此签名不允许指定元数据。  使用此方法时, 会自动为新<xref:System.Windows.DependencyProperty>的及其所有者类型生成元数据。 自动生成的元数据是来自定义了此属性的所有基类型的合并元数据的结果。 如果没有可用的合并元数据, 则使用属性的默认元数据。 如果使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法注册属性, 则默认元数据与调用时<xref:System.Windows.DependencyProperty.RegisterAttached%2A>创建的元数据相同。 否则, 将<xref:System.Windows.PropertyMetadata>创建<xref:System.Windows.PropertyMetadata.DefaultValue%2A>对象, 并将属性设置为属性类型的默认值, 并且的<xref:System.Windows.PropertyMetadata>所有其他属性都设置为`null`。 如果要为已添加到提供的类型中的依赖属性版本提供元数据, 则使用签名。<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>  
  
 此方法的返回值通常用于通过存储依赖属性标识符来声明和公开依赖属性。 如果要针对依赖项属性调用属性系统[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] , 则标识符提供对依赖项属性的访问权限, 特别是在添加所有者类中。 应使用原始所有者和添加所有者的相同属性名称来指示类似的功能。 应使用<xref:System.Windows.DependencyProperty.AddOwner%2A>方法的<xref:System.Windows.DependencyProperty>返回值来定义依赖项属性标识符, 同时为使用<xref:System.Windows.DependencyProperty.AddOwner%2A>添加到类型的[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]依赖项属性声明属性包装。  
  
 在<xref:System.Windows.DependencyProperty.AddOwner%2A>创建在中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]声明的依赖项属性时, 将使用上面建议的方法。 例如, <xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定义`BorderBrush`具有类似功能的依赖属性。 <xref:System.Windows.Controls.Control>通过基于`BorderBrush`原始所有者<xref:System.Windows.DependencyProperty.AddOwner%2A> <xref:System.Windows.Controls.Border>及其注册<xref:System.Windows.Controls.Border.BorderBrushProperty>的依赖项属性标识符调用, 将其属性定义到属性系统。 然后, 将使用<xref:System.Windows.DependencyProperty> <xref:System.Windows.Controls.Control.BorderBrushProperty> `BorderBrush`返回值为添加的所有者的该属性建立一个新的静态字段 (), 并且还声明了一个属性包装。 <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">要作为此依赖属性所有者添加的类型。</param>
        <param name="typeMetadata">在依赖属性存在于所提供的类型上时对其进行限定的元数据。</param>
        <summary>将其他类型添加为已注册的依赖对象所有者，从而为依赖属性提供依赖属性元数据使其存在于提供的所有者类型上。</summary>
        <returns>一个引用，它指向可标识依赖属性的原始 <see cref="T:System.Windows.DependencyProperty" /> 标识符。 应通过将类添加为 <see langword="public static readonly" /> 字段来公开此标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法, 属性系统可以在最初未注册特定依赖属性的类型上识别依赖属性。  
  
 此方法的返回值用于声明并公开依赖属性, 尤其是它存在于添加所有者类中。 通常, 应使用原始所有者和添加所有者的相同属性名称来指示类似的功能。 为使用[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] <xref:System.Windows.DependencyProperty.AddOwner%2A>添加到类型中的依赖属性公开标识符, 以及新属性包装是一种很好的做法。  
  
 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]在中创建[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]声明时, 使用上述方法。<xref:System.Windows.DependencyProperty.AddOwner%2A> 例如, <xref:System.Windows.Controls.Border>和<xref:System.Windows.Controls.Control>定义`BorderBrush`具有类似功能的依赖属性。 <xref:System.Windows.Controls.Control>通过调用`BorderBrush` <xref:System.Windows.DependencyProperty.AddOwner%2A>原始所有者<xref:System.Windows.Controls.Border>及其注册<xref:System.Windows.Controls.Border.BorderBrushProperty>的依赖项属性标识符, 将其属性定义到属性系统。 然后, 将使用<xref:System.Windows.DependencyProperty> <xref:System.Windows.Controls.Control.BorderBrushProperty> `BorderBrush`返回值为添加的所有者的该属性建立静态字段 (), 同时还会声明属性包装。 <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 添加的所有者的依赖项属性标识符应用于等操作<xref:System.Windows.DependencyObject.GetValue%2A>。 但是, 如果在中指定了原始项 (而不是添加的所有者的) 依赖项属性标识符, 则涉及到的类型或实例的类型特定操作仍将返回预期结果, 即使在对<xref:System.Windows.DependencyObject.GetValue%2A> 或<xref:System.Windows.DependencyProperty.GetMetadata%2A>等方法的调用。 添加的所有者的元数据由<xref:System.Windows.DependencyProperty.AddOwner%2A>调用本身永久保留, 不必由 "添加所有者类标识符" 字段专门引用。 尽管如此, 为使用[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] <xref:System.Windows.DependencyProperty.AddOwner%2A>添加到类型中的依赖属性公开标识符, 以及新属性包装是一种很好的做法, 因为这样做会在[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]和之间创建差异[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]属性的表示形式。  
  
 提供的元数据与基所有者上存在的依赖属性的属性元数据合并在一起。 原始基本元数据中指定的所有特征都将保留。 只有那些在新的元数据中特别更改的特性才会重写基本元数据的特性。 如果在新的元<xref:System.Windows.PropertyMetadata.DefaultValue%2A>数据中指定了某些特征 (如), 则会将其替换。 其他类 (如<xref:System.Windows.PropertyChangedCallback>) 合并在一起。 最终, 合并行为取决于用于重写的属性元数据类型, 因此此处所述的行为适用于[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖属性使用的现有属性元数据类。 有关详细信息, 请参阅[依赖项属性元](~/docs/framework/wpf/advanced/dependency-property-metadata.md)数据和[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象的默认元数据。</summary>
        <value>依赖项对象的默认元数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认元数据是可用于该特定对象的属性元数据, 或者是一个派生类型的对象, 在该对象中, 不提供任何<xref:System.Windows.DependencyProperty.Register%2A>替代<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>元数据的显式或调用。  
  
 如果原始所有者将元数据应用于第<xref:System.Windows.DependencyProperty.Register%2A>一个建立依赖属性的调用, 则会将该元数据<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>作为返回。  
  
 如果未在原始<xref:System.Windows.DependencyProperty.Register%2A>调用中应用元数据, 则将从<xref:System.Windows.DependencyProperty.Register%2A>调用中生成默认元数据, 并将此<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>值作为返回。  
  
 使默认元数据与<xref:System.Windows.DependencyProperty>关联的主要目的是在任何<xref:System.Windows.DependencyObject>或派生的类型上提供此属性的默认值。  
  
 对于非附加属性, 该属性返回的元数据类型不能转换为类型的<xref:System.Windows.PropertyMetadata>派生类型, 即使该属性最初是使用派生的元数据类型注册的。 如果希望最初注册的元数据 (包括其最初可能派生的元数据<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>类型) 调用, 请改为将原始注册类型作为参数传递。  
  
 对于附加属性, 此属性返回的元数据的类型将与原始<xref:System.Windows.DependencyProperty.RegisterAttached%2A>注册方法中给定的类型匹配。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</summary>
        <returns>此 <see cref="T:System.Windows.DependencyProperty" /> 的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性系统使用其自己的唯一标识符<xref:System.Windows.DependencyProperty.GlobalIndex%2A>, 并且<xref:System.Windows.DependencyProperty.GetHashCode%2A>返回该属性的值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回与此依赖属性关联的的元数据（只要它对于特定的类型存在）。 它可以是在其中首次注册依赖属性的类型、随后将其添加到的类型，或在其中通过继承获取依赖属性而已专门重写元数据的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">要从中检索依赖属性元数据的特定类型。</param>
        <summary>返回此依赖属性的元数据，因为它存在于指定的现有类型上。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将类型或对象引用指定为使用类型是必需的, 因为元数据可能与原始注册<xref:System.Windows.DependencyProperty.AddOwner%2A>不同, 原因是更改了或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>调用, 这些调用会更改依赖属性的元数据, 因为它存在于类型上。  
  
   
  
## Examples  
 下面的示例基于依赖项属性的类型获取其元数据。 该类型是使用`typeof`运算符获取的。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">一个依赖对象，检查了其类型，以便确定元数据应来自依赖属性的哪个类型特定版本。</param>
        <summary>返回此依赖属性的元数据，因为它存在于指定的对象实例上。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定类型或对象引用是必需的, 因为任何给定依赖项属性的元数据可能会与原始注册不同, 原因是<xref:System.Windows.DependencyProperty.AddOwner%2A>对于<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , 或调用可以优化类别.  
  
 在请求基于实例的属性元数据时, 实际上只传递实例, 以便可以在内部计算其类型。 依赖属性元数据不因每个实例而异;它对于任何给定的类型属性组合始终是一致的。  
  
   
  
## Examples  
 下面的示例基于特定<xref:System.Windows.DependencyObject>实例获取依赖属性的元数据。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">一个特定对象，该对象记录需要其中的依赖属性元数据的依赖项对象类型。</param>
        <summary>为此依赖属性（当它位于指定的对象实例上时）返回元数据。</summary>
        <returns>属性元数据对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定类型或对象引用是必需的, 因为任何给定依赖项属性的元数据可能会与原始注册不同, 原因是<xref:System.Windows.DependencyProperty.AddOwner%2A>对于<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , 或调用可以优化类别.  
  
   
  
## Examples  
 下面的示例基于依赖项属性的来获取其<xref:System.Windows.DependencyObjectType>元数据。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取唯一标识依赖项对象的内部生成值。</summary>
        <value>唯一数字标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值是整数, 而不是全局唯一标识符 (GUID)。 通常, 使用此索引值并不是必需的, 并且不会对所有依赖属性的表进行索引访问。 依赖属性应改为引用其标识符字段。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>供内部使用, 以更快地访问使用<xref:System.Windows.DependencyProperty.GlobalIndex%2A>作为从零开始的数组索引的数据结构。 类似的用法可能具有用于设计器或工具的应用程序。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要检查的值。</param>
        <summary>确定指定的值对于该依赖项对象的类型是否可接受（与原依赖项对象注册中提供的属性类型相对照）。</summary>
        <returns>如果指定的值是已注册的属性类型或可接受的派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的`null`值是引用类型依赖属性或<xref:System.Nullable%601>依赖属性的有效类型, 并将在这些情况下返回`true` 。 如果依赖属性既不是引用也<xref:System.Nullable%601>不是类型, <xref:System.Windows.DependencyProperty.IsValidType%2A>则将返回`false` null 值而不是引发异常。  
  
   
  
## Examples  
 下面的示例在<xref:System.Windows.DependencyProperty.IsValidType%2A>调用<xref:System.Windows.DependencyObject.SetValue%2A>依赖属性之前使用作为检查。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">要检查的值。</param>
        <summary>确定所提供的值通过基本类型检查后是否被属性类型接受，以及它是否有可能在该类型的值的允许范围以内。</summary>
        <returns>如果值是可接受的，并且具有正确的类型或派生类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于依赖属性, 可以通过<xref:System.Windows.ValidateValueCallback>在依赖属性注册中提供的来指定该类型的值的允许范围。  
  
 此方法在<xref:System.Windows.DependencyProperty.IsValidType%2A>内部调用。 如果相关的依赖项属性没有<xref:System.Windows.ValidateValueCallback>, 则调用此方法实际上等效于调用。 <xref:System.Windows.DependencyProperty.IsValidType%2A> 如果依赖属性具有<xref:System.Windows.ValidateValueCallback>, 并且如果<xref:System.Windows.DependencyProperty.IsValidType%2A>返回`true`, 则返回的值将在回调中实现。  
  
 空值是引用类型依赖属性或<xref:System.Nullable%601>依赖属性的有效值, 并将在这些情况下返回。 `true` 如果依赖属性既不是引用也<xref:System.Nullable%601>不是类型, <xref:System.Windows.DependencyProperty.IsValidType%2A>则将返回`false` null 值而不是引发异常。  
  
   
  
## Examples  
 下面的示例在<xref:System.Windows.DependencyProperty.IsValidValue%2A>调用<xref:System.Windows.DependencyObject.SetValue%2A>依赖属性之前使用作为检查。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖属性的名称。</summary>
        <value>属性的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性获取在依赖项属性注册`name`过程中作为参数提供的名称。 此名称是不可变的, 并且`null`不能为或空字符串。 不允许在同一所有者类型上进行重复的名称注册, 并且当你尝试注册重复时, 将引发异常。  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A>依赖项属性的必须遵循与其依赖项属性标识符的名称相匹配的约定, 而不是后缀 "property"。 有关详细信息，请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)。  
  
   
  
## Examples  
 下面的示例查询依赖属性标识符的各种特征, 包括<xref:System.Windows.DependencyProperty.Name%2A>。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当此依赖属性位于指定类型的实例上时为其提供替换元数据（而不是在最初注册依赖属性时提供的元数据）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</param>
        <param name="typeMetadata">一种元数据，它将应用于重写类型上的依赖属性。</param>
        <summary>当此依赖属性位于指定类型的实例上时为其指定替换元数据，以在该依赖属性继承自基类型时重写该属性已存在的元数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应在属性系统使用依赖属性之前重写依赖属性元数据。 这相当于使用注册依赖属性的类创建特定实例的时间。 只应在将自身`forType`作为此方法的参数的类型的静态构造函数中执行调用, 或通过类似的实例化执行。 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 如果尝试在所有者类型的实例之后更改元数据, 则不会引发异常, 但会导致在属性系统中出现不一致的行为。  
  
 使用此方法建立特定派生类重写的元数据后, 后续尝试重写此同一派生类上的元数据会引发异常。  
  
 提供的元数据与基所有者上存在的依赖属性的属性元数据合并在一起。 原始基本元数据中指定的所有特征都将保留;只有那些在新的元数据中特别更改的特性才会重写基本元数据的特性。 如果在新的<xref:System.Windows.PropertyMetadata.DefaultValue%2A>元数据中指定了某些特性 (如), 则会将其替换。 其他类 (如<xref:System.Windows.PropertyChangedCallback>) 合并在一起。 最终, 合并行为取决于用于重写的属性元数据类型, 因此此处所述的行为适用于[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依赖属性使用的现有属性元数据类。 有关详细信息, 请参阅[依赖项属性元](~/docs/framework/wpf/advanced/dependency-property-metadata.md)数据和[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">尝试重写只读依赖属性的元数据（不能使用此签名完成该操作）。</exception>
        <exception cref="T:System.ArgumentException">已为依赖属性建立元数据，因为它存在于所提供的类型上。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">一种类型，在该类型上继承该依赖属性并将应用所提供的替换元数据。</param>
        <param name="typeMetadata">一种元数据，它将应用于重写类型上的依赖属性。</param>
        <param name="key">只读依赖属性的访问键。</param>
        <summary>当只读依赖属性位于指定类型的实例上时为其提供替换元数据，以便重写在最初注册依赖属性时提供的元数据。 你必须为只读依赖属性传递 <see cref="T:System.Windows.DependencyPropertyKey" />，以免引发异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此签名为只读依赖项属性标识符 (<xref:System.Windows.DependencyPropertyKey>) 方法提供基础实现。 如果重写读写依赖项属性的元数据, <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>请使用。  
  
 应在属性系统使用依赖属性之前重写依赖属性元数据。 这相当于为注册依赖属性的类创建特定对象的时间。 只应在将自身`forType`作为此方法的参数的类型的静态构造函数中执行调用, 或通过类似的实例化执行。 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 如果尝试在所有者类型的实例之后更改元数据, 则不会引发异常, 但会导致在属性系统中出现不一致的行为。  
  
 使用此方法建立特定派生类重写的元数据后, 后续尝试重写此同一派生类上的元数据会引发异常。  
  
 提供的元数据与基所有者上存在的依赖属性的属性元数据合并在一起。 原始基本元数据中指定的所有特征都将保留;只有那些在新的元数据中特别更改的特性才会重写基本元数据的特性。 如果在新的<xref:System.Windows.PropertyMetadata.DefaultValue%2A>元数据中指定了某些特性 (如), 则会将其替换。 其他类 (如<xref:System.Windows.PropertyChangedCallback>) 合并在一起。 合并行为取决于用于重写的属性元数据类型。 有关详细信息, 请参阅[依赖项属性元](~/docs/framework/wpf/advanced/dependency-property-metadata.md)数据和[框架属性元数据](~/docs/framework/wpf/advanced/framework-property-metadata.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取使用属性系统注册依赖属性或者将自己作为属性所有者添加的对象的类型。</summary>
        <value>注册属性或者将自己作为属性所有者添加的对象的类型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此值是在属性注册过程中提供的。 如果<xref:System.Windows.DependencyProperty>是<xref:System.Windows.DependencyProperty.AddOwner%2A>从调用生成的标识符, 则所有者将是原始注册类型, 或者是从调用生成的<xref:System.Windows.DependencyProperty>标识符添加自身作为所有者的类型。 <xref:System.Windows.DependencyProperty.Register%2A>  
  
 任何<xref:System.Windows.DependencyProperty.OwnerType%2A>给定<xref:System.Windows.DependencyProperty>的都是不可变的, 并且`null`不能为<xref:System.Windows.DependencyProperty>有效的。  
  
   
  
## Examples  
 下面的示例基于依赖项属性标识符`dp`获取所有者类型, 然后获取此同一标识符的所有者类型的元数据。 此操作实际上等效于获取<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。 `dp`  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象用于其值的类型。</summary>
        <value>属性值的 <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性通过`propertyType`参数报告由原始属性注册声明的属性值的类型。 与类似, 依赖属性的属性类型在注册后是不可变的。 <xref:System.Windows.DependencyProperty.Name%2A>  
  
   
  
## Examples  
 下面的示例查询依赖属性标识符的各种特征, 包括<xref:System.Windows.DependencyProperty.PropertyType%2A>。 从返回<xref:System.Windows.DependencyProperty.PropertyType%2A> <xref:System.Type>的中获取的类型名称字符串。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示由此 <see cref="T:System.Windows.DependencyProperty" /> 实例标识的依赖项对象是否为只读依赖项对象。</summary>
        <value>如果该依赖项对象为只读属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只读依赖属性是通过调用<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法 (而<xref:System.Windows.DependencyProperty.Register%2A>不是方法) 在属性系统中注册的。 附加属性还可以注册为只读属性;请<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>参阅。  
  
 只读依赖属性需要<xref:System.Windows.DependencyPropertyKey>标识符而不<xref:System.Windows.DependencyProperty>是标识符来执行元数据操作, 例如重写元数据或设置值。 如果通过<xref:System.Windows.DependencyProperty>对的<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>调用或公开标识符的另一个[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]标识符获取了标识符的集合, 请<xref:System.Windows.DependencyProperty.ReadOnly%2A>在尝试调用<xref:System.Windows.DependencyObject.SetValue%2A>或<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>使用之前检查值作为输入参数的依赖项属性标识符, 用于验证标识符所表示的依赖项属性是否不是只读的。 如果的<xref:System.Windows.DependencyProperty.ReadOnly%2A> <xref:System.Windows.DependencyProperty>值在依赖属性上, 则无法通过编程方式从元数据或标识符<xref:System.Windows.DependencyPropertyKey>获取对该依赖属性的标识符的引用; 标识符`true`必须可用作静态字段, 才能对只读依赖属性<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>进行调用。  
  
 在创建自定义依赖属性并将其注册为只读时, 应只为[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]包装器属性定义一个 get 访问器。 否则, 与支持依赖项属性的访问相比, 你的类将具有属性包装的混乱的对象模型。 有关详细信息, 请参阅[自定义依赖属性](~/docs/framework/wpf/advanced/custom-dependency-properties.md)或[只读依赖项属性](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)。  
  
   
  
## Examples  
 下面的示例从各种依赖属性字段获取默认的元数据和依赖属性标识符属性, 并使用该信息来填充表以实现 "元数据浏览器"。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册依赖属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。 名称必须在所有者类型的注册命名空间中是唯一的。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <summary>使用指定的属性名称、属性类型和所有者类型注册依赖属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、属性类型、所有者类型和属性元数据注册依赖属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性名称、属性类型、所有者类型、属性元数据和属性的值验证回叫来注册依赖属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
   
  
## Examples  
 下面的示例注册一个依赖项属性, 包括验证回调 (不显示回调定义; 有关回调定义的详细信息, 请参阅<xref:System.Windows.ValidateValueCallback>)。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在属性系统上注册附加属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <summary>使用指定的属性名称、属性类型和所有者类型注册附加属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加属性是由定义的[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]属性概念。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]实现附加属性作为依赖属性。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]由于附加属性是依赖属性, 因此它们可以应用元数据, 常规属性系统可以使用这些元数据来执行报表布局特征等操作。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
   
  
## Examples  
 下面的示例使用此<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名在抽象类上注册附加属性。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。 这可以包括默认值和其他特征。</param>
        <summary>使用指定的属性名、属性类型、所有者类型和属性元数据注册附加的属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加属性是由定义的[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]属性概念。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]实现附加属性作为依赖属性。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]由于附加属性是依赖属性, 因此它们可以应用元数据, 常规属性系统可以使用这些元数据来执行报表布局特征等操作。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 System.windows.dependencyproperty.registerattached 进行值继承依赖属性  
 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 使用<xref:System.Windows.DependencyProperty.Register%2A>代替来注册依赖属性的一个特定方案是支持属性值继承。 如果类定义了公开依赖属性的属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>包装访问器, 甚至不打算公开 Get * 和 Set * 静态方法以提供 true 附加的, 则应注册值继承依赖属性属性支持访问器。   尽管属性值继承可能看起来适用于非附加的依赖属性, 但通过运行时树中的某些元素边界的非附加属性的继承行为是不确定的。 将属性注册为 "附加" 会有效地将附加属性作为全局属性附加到属性系统, 并确保属性值继承在元素树中的所有边界上都有效。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册在元数据中<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>指定的属性。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。 这可以包括默认值和其他特征。</param>
        <param name="validateValueCallback">对回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和属性的值验证回调来注册附加属性。</summary>
        <returns>一个依赖属性标识符，应使用它来设置类中 <see langword="public static readonly" /> 字段的值。 稍后将此标识符用来引用依赖属性，从而实现以编程方式设置其值或获取元数据等操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附加属性是由定义的[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]属性概念。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]实现附加属性作为依赖属性。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]由于附加属性是依赖属性, 因此它们可以应用元数据, 常规属性系统可以使用这些元数据来执行报表布局特征等操作。 有关详细信息，请参阅[附加属性概述](~/docs/framework/wpf/advanced/attached-properties-overview.md)。  
  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 System.windows.dependencyproperty.registerattached 进行值继承依赖属性  
 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 使用<xref:System.Windows.DependencyProperty.Register%2A>代替来注册依赖属性的一个特定方案是支持属性值继承。 如果类定义了公开依赖属性的属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>包装访问器, 甚至不打算公开 Get * 和 Set * 静态方法以提供 true 附加的, 则应注册值继承依赖属性属性支持访问器。   尽管属性值继承可能看起来适用于非附加的依赖属性, 但通过运行时树中的某些元素边界的非附加属性的继承行为是不确定的。 将属性注册为 "附加" 会有效地将附加属性作为全局属性附加到属性系统, 并确保属性值继承在元素树中的所有边界上都有效。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册在元数据中<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>指定的属性。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
   
  
## Examples  
 下面的示例使用此<xref:System.Windows.DependencyProperty.RegisterAttached%2A>签名在抽象类上注册附加属性。 此附加属性是一个枚举类型属性, 注册将添加一个验证回调, 以验证提供的值是否为枚举的值。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册只读附加属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、所有者类型和属性元数据注册只读附加属性。</summary>
        <returns>一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回类型<xref:System.Windows.DependencyPropertyKey>, 而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回类型<xref:System.Windows.DependencyProperty>。 通常, 表示只读属性的键不会成为公共的, 因为键可用于通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>设置依赖属性值。 你的类设计将影响你的需求, 但通常建议仅将对某些代码部分的访问<xref:System.Windows.DependencyPropertyKey>权限和可见性限制为类或应用程序逻辑的一部分设置该依赖项属性。 还建议为只读依赖项属性公开依赖项属性标识符, 方法是将的<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>值公开`public static readonly`为类的字段。  
  
 只读附加属性是一种罕见方案, 因为附加属性的主要方案是在中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]使用它。 如果没有公共 setter, 则无法在语法中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]设置附加属性。  
  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 System.windows.dependencyproperty.registerattached 进行值继承依赖属性  
 将依赖属性注册为附加属性的一个特别方案是支持属性值继承。 如果类定义了公开依赖属性的属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>包装访问器, 甚至不打算公开 Get * 和 Set * 静态方法以提供 true 附加的, 则应注册值继承依赖属性属性支持访问器。   尽管属性值继承可能看起来适用于非附加的依赖属性, 但通过运行时树中的某些元素边界的非附加属性的继承行为是不确定的。 将属性注册为 "附加" 会有效地将附加属性作为全局属性附加到属性系统, 并确保属性值继承在元素树中的所有边界上都有效。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册在元数据中<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>指定的属性。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="defaultMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和验证回调来注册只读附加属性。</summary>
        <returns>一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回类型<xref:System.Windows.DependencyPropertyKey>, 而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回类型<xref:System.Windows.DependencyProperty>。 通常, 表示类型<xref:System.Windows.DependencyProperty>的键。 通常, 表示只读属性的键不会成为公共的, 因为键可用于通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>设置依赖属性值。 你的类设计将影响你的需求, 但通常建议仅将对某些代码部分的访问<xref:System.Windows.DependencyPropertyKey>权限和可见性限制为类或应用程序逻辑的一部分设置该依赖项属性。 还建议为只读依赖项属性公开依赖项属性标识符, 方法是将的<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>值公开`public static readonly`为类的字段。  
  
 只读附加属性是一种罕见方案, 因为附加属性的主要方案是在中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]使用它。 如果没有公共 setter, 则无法在语法中[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]设置附加属性。  
  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>使用 System.windows.dependencyproperty.registerattached 进行值继承依赖属性  
 将依赖属性注册为附加属性 (而不是) <xref:System.Windows.DependencyProperty.Register%2A>的一种特殊方案是支持属性值继承。 如果类定义了公开依赖属性的属性<xref:System.Windows.DependencyProperty.RegisterAttached%2A>包装访问器, 甚至不打算公开 Get * 和 Set * 静态方法以提供 true 附加的, 则应注册值继承依赖属性属性支持访问器。   尽管属性值继承可能看起来适用于非附加的依赖属性, 但通过运行时树中的某些元素边界的非附加属性的继承行为是不确定的。 将属性注册为 "附加" 会有效地将附加属性作为全局属性附加到属性系统, 并确保属性值继承在元素树中的所有边界上都有效。 始终使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>来注册在元数据中<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>指定的属性。 有关详细信息，请参阅[属性值继承](~/docs/framework/wpf/advanced/property-value-inheritance.md)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将依赖属性注册为只读依赖属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <summary>使用指定的属性名称、所有者类型和属性元数据注册只读依赖属性。</summary>
        <returns>一个依赖属性键，应使用它在类中设置静态只读字段的值，然后使用该字段的值引用依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回类型<xref:System.Windows.DependencyPropertyKey>, 而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回类型<xref:System.Windows.DependencyProperty>。 通常, 表示只读属性的键不会成为公共的, 因为键可用于通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>设置依赖属性值。 你的类设计将影响你的需求, 但通常建议仅将对某些代码部分的访问<xref:System.Windows.DependencyPropertyKey>权限和可见性限制为类或应用程序逻辑的一部分设置该依赖项属性。 还建议为只读依赖项属性公开依赖项属性标识符, 方法是将的<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>值公开`public static readonly`为类的字段。  
  
 只读依赖项属性是在现有[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]的和中的自定义方案中相当典型的方案, 因为其他[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能可能需要依赖属性, 即使该属性不是旨在由方可. 您可以使用只读依赖属性的值作为采用依赖属性的其他属性系统操作的基础, 例如以样式中的依赖属性为基础<xref:System.Windows.Trigger> 。  
  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
   
  
## Examples  
 下面的示例将`AquariumSize`依赖属性注册为只读。 该示例将`AquariumSizeKey`定义为一个内部键 (以便程序集中的其他类可以重写元数据), 并根据该`AquariumSizeProperty`密钥公开依赖项属性标识符。 此外, 为创建`AquariumSize`一个包装, 只使用一个 get 访问器。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">要注册的依赖属性的名称。</param>
        <param name="propertyType">属性的类型。</param>
        <param name="ownerType">正在注册依赖属性的所有者类型。</param>
        <param name="typeMetadata">依赖属性的属性元数据。</param>
        <param name="validateValueCallback">对用户创建的回调的引用，除了典型的类型验证之外，该引用还应执行依赖属性值的任何自定义验证。</param>
        <summary>使用指定的属性类型、所有者类型、属性元数据和验证回叫来注册只读依赖属性。</summary>
        <returns>一个依赖属性键，此键应用于设置你的类中静态只读字段的值，该值稍后被用于引用该依赖属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回类型<xref:System.Windows.DependencyPropertyKey>, 而<xref:System.Windows.DependencyProperty.RegisterAttached%2A>返回类型<xref:System.Windows.DependencyProperty>。 通常, 表示只读属性的键不会成为公共的, 因为键可用于通过调用<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>设置依赖属性值。 你的类设计将影响你的需求, 但通常建议仅将对某些代码部分的访问<xref:System.Windows.DependencyPropertyKey>权限和可见性限制为类或应用程序逻辑的一部分设置该依赖项属性。 还建议为只读依赖项属性公开依赖项属性标识符, 方法是将的<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>值公开`public static readonly`为类的字段。  
  
 只读依赖属性是一个相当典型的方案。 您可以使用只读依赖属性的值作为采用依赖属性的其他属性系统操作的基础, 例如以样式中的依赖属性为基础<xref:System.Windows.Trigger> 。  
  
 有关依赖属性注册的详细信息, 请<xref:System.Windows.DependencyProperty>参阅。  
  
 对只读依赖属性的验证可能不太重要。 为密钥指定的非公共访问级别减少了任意无效输入的可能性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回依赖属性的字符串表示形式。</summary>
        <returns>依赖属性的字符串表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此实现返回<xref:System.Windows.DependencyProperty.Name%2A>属性值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定由 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 属性系统使用的静态值而非 <see langword="null" />，以指示属性存在，但其值未经属性系统设置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue>是一个 sentinel 值, 用于[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]属性系统无法确定请求<xref:System.Windows.DependencyProperty>的值的方案。 <xref:System.Windows.DependencyProperty.UnsetValue>使用而不`null`是, 因为`null`可以是有效的属性值, 也可以是有效的 (并经常用到<xref:System.Windows.PropertyMetadata.DefaultValue%2A>)。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>永远不会从<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>中返回。 对<xref:System.Windows.DependencyObject>实例调用<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>依赖属性时, 以下情况之一适用:  
  
-   依赖属性具有在元数据中建立的默认值, 并且返回该值。 此值可能来自<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>。  
  
-   其他一些值由属性系统建立, 并且默认值不再相关。 有关详细信息，请参阅[依赖属性值优先级](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)。  
  
 特别不允许<xref:System.Windows.DependencyProperty.UnsetValue>设置的。<xref:System.Windows.PropertyMetadata.DefaultValue%2A>  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType>如果<xref:System.Windows.DependencyProperty.UnsetValue>尚未本地设置请求的属性, 则返回。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>当用作的返回值<xref:System.Windows.CoerceValueCallback>时, 具有特殊意义。 有关详细信息, 请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 如果要绑定到数据库, 请注意, 与<xref:System.Windows.DependencyProperty.UnsetValue>不等效于<xref:System.DBNull.Value>, 这与<xref:System.DBNull.Value>不等效于 true null 的方式相同。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取依赖项对象的值验证回调。</summary>
        <value>最初依赖项对象注册时为 <paramref name="validateValueCallback" /> 参数提供的该依赖项对象的值验证回调。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性将包含`null`任何没有注册验证回调的依赖项属性。  
  
 验证值回调必须以静态意义进行操作: 通过应用的<xref:System.Windows.ValidateValueCallback>验证无法确定所提供的值对于任何特定实例是否有效。 回调只能确定具有依赖项属性的所有对象是否应接受提供的值为有效的。 如果需要执行的验证依赖于在特定实例上了解其他依赖项属性的值, 请<xref:System.Windows.CoerceValueCallback>改用。 注册为依赖属性元数据的一部分, 而不是直接在依赖属性标识符中进行注册。<xref:System.Windows.CoerceValueCallback> 有关详细信息, 请参阅[依赖属性回调和验证](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>