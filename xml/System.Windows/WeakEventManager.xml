<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="080b5265a21bc5938d549e2c320e525fe044eb65" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69443648" /></Metadata><TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>为在“弱事件模式”中使用的事件管理器提供基类。 管理器为也使用该模式的事件（或回调）添加和移除侦听器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当事件源具有独立于事件侦听器的对象生存期时, 通常使用弱事件模式。 使用的中心事件调度功能<xref:System.Windows.WeakEventManager>允许对侦听器的处理程序进行垃圾回收, 即使源对象仍然存在也是如此。 相比之下, 使用`+=`运算符的定期事件挂接会导致可能断开连接的源持有对侦听器的引用。 这会阻止接收方及时进行垃圾回收。  
  
 源和侦听器之间的生存期关系应使用弱事件模式的一种常见情况是处理来自数据绑定的更新事件。  
  
 弱事件模式也可用于回调和常规事件。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>有关自定义<see cref="T:System.Windows.WeakEventManager" />的示例, 请参阅[弱事件模式](~/docs/framework/wpf/advanced/weak-event-patterns.md)。</para></block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>在基类值由派生类的构造函数用作初始值设定项时初始化基类值。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">在其中处理事件的对象。</param>
        <param name="args">一个包含要传递的事件的事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>将正在托管的事件传送到每个侦听器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从事件处理程序中调用<xref:System.Windows.WeakEventManager.StartListening%2A> <xref:System.Windows.WeakEventManager.StopListening%2A> 方法,这些事件处理程序由子类的和实现<xref:System.Windows.WeakEventManager.DeliverEvent%2A>添加或移除。  
  
 如果在类的<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> `AddListener`实现中调用方法, 则接收事件的侦听器列表将保留在基础集合中。 (`AddListener`不是接口或类协定的一部分。 `AddListener`是你的管理器类的方法的建议名称, 该<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>方法为事件调用并添加弱事件模式侦听器。)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>将侦听器添加到单个列表。 如果经理实现为每个事件维护多个侦听器列表, 请不要使用<xref:System.Windows.WeakEventManager.DeliverEvent%2A>或。 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> 相反, 你的实现应创建自己<xref:System.Windows.WeakEventManager.ListenerList>的实例`AddListener` , 应将侦听器添加到相应的列表, 并且应通过调用<xref:System.Windows.WeakEventManager.DeliverEventToList%2A>将事件传递到相应的侦听器列表。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">在其中处理事件的对象。</param>
        <param name="args">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <param name="list">提供的 <see cref="T:System.Windows.WeakEventManager.ListenerList" />。</param>
        <summary>将正在托管的事件传送到所提供列表中的每个侦听器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果您的管理器实现基于事件数据中捕获的信息维护单独的侦听器列表, 则此方法是必需的。 如果使用此高级技术, 则必须创建和维护单独的列表作为经理实现的一部分, 并且必须提供向特定列表添加侦听器的方法。 侦听原始事件的处理程序实现必须遵循用于区分列表的条件, 并且仅将事件传递到适当列表。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">要为其获取 <see cref="T:System.Windows.WeakEventManager" /> 的类型。</param>
        <summary>返回用于所提供类型的 <see cref="T:System.Windows.WeakEventManager" /> 实现。</summary>
        <returns>匹配的 <see cref="T:System.Windows.WeakEventManager" /> 实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A>实现使用其传递`managerType`的来调用此方法。 然后, <xref:System.Windows.WeakEventManager>将返回返回的, 以确定接收的事件以及要调用的私有类处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">所请求源的从零开始的索引。</param>
        <summary>获取或设置为指定的源存储的数据。</summary>
        <value>通过此源的管理器存储的数据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生类可以选择要存储在此索引器中的数据和类型。 通常<xref:System.Windows.WeakEventManager.ListenerList>, 此实现为, 它是对侦听器的弱引用的列表。 如果<xref:System.Windows.WeakEventManager.ListenerList>类型不能包含所需的信息, 则只需更改此类型。 如果是这样, 则必须重写<xref:System.Windows.WeakEventManager.Purge%2A>方法, 以便正确执行基础类型的所有清理操作。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回包含事件侦听器的新对象。</summary>
        <returns>包含事件侦听器的新对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">处理程序代理订阅的源对象。</param>
        <param name="handler">处理 <paramref name="source" /> 引发的事件的委托。</param>
        <summary>添加指定的委托为指定源的事件处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">要附加侦听器的源。</param>
        <param name="listener">侦听类（必须实现 <see cref="T:System.Windows.IWeakEventListener" />）。</param>
        <summary>将提供的侦听器添加到为托管事件所提供的源中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddListener` 在<xref:System.Windows.WeakEventManager>实现的管理器类方法中调用此方法。 `AddListener`是为管理器类定义的静态方法的建议名称, 以使其他类能够为弱事件模式添加侦听器。 `AddListener`应采用以下两个参数`source` : 侦听器附加到的, `listener`以及实例。 对于实现, 请对当前<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>管理器调用方法并传递相同的两个参数。 `AddListener`  
  
 如果侦听器列表之前为空, <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>则将在内部调用方法, 这将通过多态性调用特定<xref:System.Windows.WeakEventManager.StartListening%2A>的<xref:System.Windows.WeakEventManager.StartListening%2A>重写。  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>将侦听器添加到单个内部<xref:System.Windows.WeakEventManager.ListenerList> , `source`每个。 如果经理实现为每个事件源组合维护多个侦听器列表, 请不要使用<xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>。 相反, 你的实现应创建自己<xref:System.Windows.WeakEventManager.ListenerList>的实例`AddListener` , 应将侦听器添加到相应的列表, 并且应通过调用<xref:System.Windows.WeakEventManager.DeliverEventToList%2A>事件而不是将事件传递到相应的侦听器列表<xref:System.Windows.WeakEventManager.DeliverEvent%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="handler" Type="System.Delegate" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="source">要从中移除处理程序的源。</param>
        <param name="handler">要从 <paramref name="source" /> 移除的委托。</param>
        <summary>从指定的源中移除以前添加的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">要从中移除侦听器的源。</param>
        <param name="listener">侦听类（必须实现 <see cref="T:System.Windows.IWeakEventListener" />）。</param>
        <summary>从提供的源中移除以前添加的侦听器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `RemoveListener` 在<xref:System.Windows.WeakEventManager>实现的管理器类方法中调用此方法。 `RemoveListener`是为管理器类定义的静态方法的建议名称, 用于启用其他类来删除弱事件模式的侦听器。 `RemoveListener`应采用以下两个参数`source` : 删除侦听器的位置`listener`和类。 对于实现, 请对当前<xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>管理器调用方法并传递相同的两个参数。 `RemoveListener`  
  
 如果调用<xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>删除列表中的最后一个侦听器, <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>则将在内部<xref:System.Windows.WeakEventManager.StopListening%2A>调用方法, 这将通过多态性<xref:System.Windows.WeakEventManager.StopListening%2A>调用特定的重写。  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>从单个内部<xref:System.Windows.WeakEventManager.ListenerList>为每个`source`侦听器删除侦听器。 如果经理实现为每个事件源组合维护多个侦听器列表, 请不要使用<xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>。 相反, 你的实现应创建自己<xref:System.Windows.WeakEventManager.ListenerList>的实例`RemoveListener` , 应从相应的列表中移除侦听器, 并通过调用<xref:System.Windows.WeakEventManager.DeliverEventToList%2A>方法 (而不是<xref:System.Windows.WeakEventManager.DeliverEvent%2A>方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">要侦听的事件的源。</param>
        <param name="data">要检查的数据。 此对象应为 <see cref="T:System.Windows.WeakEventManager.ListenerList" /> 实现。</param>
        <param name="purgeAll">设置为 <see langword="true" /> 可停止侦听 <paramref name="source" />，并从 <paramref name="data" /> 中完全移除所有项。</param>
        <summary>从所提供源的数据列表中移除不活动的侦听器项。 如果某些项实际上已经从列表中移除，则返回 <see langword="true" />。</summary>
        <returns>如果某些项实际上已经移除，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法具有一个默认实现, 当数据<xref:System.Windows.WeakEventManager.ListenerList>为时, 将删除所有项。 <xref:System.Windows.WeakEventManager.Purge%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果的<see cref="P:System.Windows.WeakEventManager.Item(System.Object)" />基础类型是<see cref="T:System.Windows.WeakEventManager.ListenerList" />以外的类型, 或者包含以外的<see cref="T:System.Windows.WeakEventManager.ListenerList" />数据, 则必须重写<see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />方法。 重写应为替代类型项列表提供清除行为。 通常, 重写应提供行为而无需调用基实现。 如果特定<see cref="T:System.Windows.WeakEventManager.ListenerList" />仍需要清除, 请调用<see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />。</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在基础数据表上建立读取锁定，并返回 <see cref="T:System.IDisposable" />。</summary>
        <value>一个对象，可用于在数据表成员上建立锁定，然后通过 <see langword="using" /> 构造被相应释放。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类中, 对中<xref:System.Windows.WeakEventManager.Item%2A>包含的表的查询应始终出现在`using (ReadLock) { ... }`子句中, 但已在写入锁定内的查询除外。 如果你的`AddListener`类支持更复杂的实现, `source`而该实现需要超过和<xref:System.Windows.WeakEventManager.Item%2A>的`listener`更多数据, 则可能需要执行这些查询, 并使用集合存储额外的信息。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">要移除侦听器信息的源。</param>
        <summary>移除指定源的所有侦听器。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要求在优先级较低的线程上清除基础侦听器列表中未使用的项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用方法类似于在当前管理器<xref:System.Windows.WeakEventManager.Purge%2A>列表中调用方法, 在较低的`purgeAll`线程优先级时, 将参数设置为`false`。 <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">要为其设置新事件管理器的类型。</param>
        <param name="manager">新事件管理器。</param>
        <summary>为指定的管理器类型设置当前管理器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在实现<xref:System.Windows.WeakEventManager>上对`CurrentManager`属性的调用需要, 则调用方法以初始化管理器。<xref:System.Windows.WeakEventManager.SetCurrentManager%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">开始侦听的源。</param>
        <summary>在派生类中重写时，开始侦听被托管的事件。 第一次调用 <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> 方法后，只要处理了所提供源中的相关事件，管理器就应处于调用 <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> 或 <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> 的状态。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />重写应将处理程序添加到<paramref name="source" />提供的。 处理程序由管理器自行声明。 类处理程序不应为公共, 只应在响应被管理的事件时调用。 类处理程序应适当地<see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />调用方法<see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />或方法。</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">停止侦听的源。</param>
        <summary>在派生类中重写时，停止为被托管的事件侦听所提供的源。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" />实现应移除由<see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />方法添加的类处理程序。 删除侦听器不应清除侦听器列表。 相反, 它只应断开类处理程序的连接 (可能暂时会断开)。 其他方法可用于清除整个列表, 例如<see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> <paramref name="purgeAll" />参数设置为<see langword="true" />的方法。</para></block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在基础数据表上建立写入锁定，并返回 <see cref="T:System.IDisposable" />。</summary>
        <value>一个对象，可用于在数据表成员上建立锁定，然后通过 <see langword="using" /> 构造被相应释放。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在派生类中, 对基础数据表的所有修改应出现在`using (WriteLock) { ... }`子句中。 如果你的`AddListener`类支持更复杂的实现, `source`而这些实现需要超过和<xref:System.Windows.WeakEventManager.Item%2A>的`listener`更多数据, 则可能需要进行这些修改, 并使用集合存储额外的信息。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>
