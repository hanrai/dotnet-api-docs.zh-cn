<Type Name="Visual" FullName="System.Windows.Media.Visual">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5b527b32ee76f33673588093569045920a744596" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69446285" /></Metadata><TypeSignature Language="C#" Value="public abstract class Visual : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Visual extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Visual" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Visual&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Visual abstract : System::Windows::DependencyObject" />
  <TypeSignature Language="F#" Value="type Visual = class&#xA;    inherit DependencyObject&#xA;    interface DUCE.IResource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>为 WPF 中的呈现提供支持，其中包括命中测试、坐标转换和边界框计算。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 类是每个<xref:System.Windows.FrameworkElement>对象派生自的基本抽象。 <xref:System.Windows.Media.Visual> 它还用作在中[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]编写新控件的入口点, 在许多方面, 可被视为[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]应用程序模型中的窗口句柄 (HWND) 的等效项。  
  
 对象是核心[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]对象, 其主要角色是提供呈现支持。 <xref:System.Windows.Media.Visual> 用户界面控件 ( <xref:System.Windows.Controls.Button>例如和<xref:System.Windows.Controls.TextBox>) 从<xref:System.Windows.Media.Visual>类派生, 并使用<xref:System.Windows.Media.Visual>定义的属性来保存其呈现数据。 <xref:System.Windows.Media.Visual>对象提供对以下各项的支持:  
  
-   输出显示：呈现视觉对象的持久、序列化的绘图内容。  
  
-   转换：针对视觉对象执行转换。  
  
-   剪裁：为视觉对象提供剪裁区域支持。  
  
-   命中测试:确定指定的坐标 (点) 或几何图形是否包含在视觉对象的边界内。  
  
-   边框计算：确定视觉对象的边框。  
  
 从<xref:System.Windows.Media.Visual>结构上讲, 对象不支持其他应用程序开发要求/ [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]功能, 这些要求/功能不会立即与呈现相关, 如以下内容所示:  
  
-   事件处理  
  
-   布局  
  
-   样式  
  
-   数据绑定  
  
-   全球化  
  
 <xref:System.Windows.Media.Visual>作为可从中派生更多类的公共抽象类提供。 下图显示了在[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]体系结构中定义的现有视觉对象的层次结构。  
  
 ![从视觉对象派生的类的关系图](~/add/media/visualclass01.png "从视觉对象派生的类的关系图")  
视觉对象类层次结构  
  
 在某些情况下, 在<xref:System.Windows.Media.Visual>派生<xref:System.Windows.UIElement>类中, 定义为受保护的成员将公开为更易于访问的成员, 具有类似的名称。  
  
 有关详细信息，请参阅 [WPF 图形呈现概述](~/docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)。  
  
 <xref:System.Windows.Media.Visual>具有有限的级别数。 在 .NET Framework 的以前版本中, 此最大深度为255。 对于在可视化树中具有多个级别的某些布局而言, 此限制不够用。  
  
 在[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]中, 的最大深度<xref:System.Windows.Media.Visual>为 2047, 这可以实现更多的可视化树。 在大多数应用程序中, 堆栈空间不足, 无法遍历太多级别, 结果在布局<xref:System.StackOverflowException>期间是。 对于默认堆栈大小, 如果树深度大约为 800 (相当于大约190个嵌套<xref:System.Windows.Controls.TreeViewItem>对象), 则通常会引发此异常。  
  
 如果你的应用程序引发此异常, 并且你需要具有更深入的可视化树, 则可以增加应用程序的堆栈大小。 可以通过在编译时使用/STACK 选项或使用 EDITBIN 实用工具来增加堆栈的大小。 增大堆栈大小可能会影响应用程序的性能。 有关详细信息, 请参阅[Stack 分配](https://go.microsoft.com/fwlink/?LinkId=165510)和[EDITBIN 选项](https://go.microsoft.com/fwlink/?LinkId=165511)。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Media.VisualCollection" />
    <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Visual ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Visual();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>为从 <see cref="T:System.Windows.Media.Visual" /> 类派生的对象提供基本初始化。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddVisualChild">
      <MemberSignature Language="C#" Value="protected void AddVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AddVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.AddVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AddVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AddVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberSignature Language="F#" Value="member this.AddVisualChild : System.Windows.Media.Visual -&gt; unit" Usage="visual.AddVisualChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">要添加到父可视对象的子可视对象。</param>
        <summary>定义两个可视对象之间的父子关系。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.AddVisualChild%2A>方法设置两个可视对象之间的父子关系。 如果需要对可视子对象的基础存储实现进行更高级别的控制, 则必须使用此方法。 <xref:System.Windows.Media.VisualCollection>可用作存储子对象的默认实现。  
  
   
  
## Examples  
 下面的示例演示如何为视觉对象定义自定义存储要求。 该示例使用<xref:System.Windows.Media.Visual.AddVisualChild%2A>和<xref:System.Windows.Media.Visual.RemoveVisualChild%2A>方法来设置父视觉对象和`child`之间的父子关系。 为了正确枚举可视化树, 该示例提供<xref:System.Windows.Media.Visual.GetVisualChild%2A>方法和<xref:System.Windows.Media.Visual.VisualChildrenCount%2A>属性的重写实现。  
  
> [!NOTE]
>  尽管可以使用<xref:System.Windows.Media.VisualCollection>创建可视对象之间的父子关系, 但当只有一个子级链接到父对象时, 提供自己的自定义存储实现会更有效。  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <Member MemberName="FindCommonVisualAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject FindCommonVisualAncestor (System.Windows.DependencyObject otherVisual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject FindCommonVisualAncestor(class System.Windows.DependencyObject otherVisual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.FindCommonVisualAncestor(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindCommonVisualAncestor (otherVisual As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ FindCommonVisualAncestor(System::Windows::DependencyObject ^ otherVisual);" />
      <MemberSignature Language="F#" Value="member this.FindCommonVisualAncestor : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="visual.FindCommonVisualAncestor otherVisual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherVisual" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="otherVisual">一个 <see cref="T:System.Windows.DependencyObject" /> 类型的可视对象。</param>
        <summary>返回两个可视对象的公共上级。</summary>
        <returns>可视对象和 <paramref name="otherVisual" /> 的公共上级（如果存在的话）；否则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 二维和三维对象可以具有常见的视觉对象, 因此可以传递<xref:System.Windows.Media.Media3D.Visual3D>的。 `otherVisual`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberSignature Language="F#" Value="abstract member GetVisualChild : int -&gt; System.Windows.Media.Visual&#xA;override this.GetVisualChild : int -&gt; System.Windows.Media.Visual" Usage="visual.GetVisualChild index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><see cref="T:System.Windows.Media.VisualCollection" /> 中的可视对象的索引。</param>
        <summary>返回父级 <see cref="T:System.Windows.Media.Visual" /> 中的指定 <see cref="T:System.Windows.Media.VisualCollection" />。</summary>
        <returns><see cref="T:System.Windows.Media.VisualCollection" /> 中指定 <paramref name="index" /> 值处的子级。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, <xref:System.Windows.Media.Visual>没有任何子级。 因此, 默认实现始终引发<xref:System.ArgumentOutOfRangeException>。  
  
   
  
## Examples  
 下面的示例定义的<xref:System.Windows.Media.Visual.GetVisualChild%2A>重写实现。  
  
 [!code-csharp[DrawingVisualSample#102b](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102b)]
 [!code-vb[DrawingVisualSample#102b](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102b)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>从<see cref="T:System.Windows.Media.Visual" />派生的类必须重写此方法和<see cref="P:System.Windows.Media.Visual.VisualChildrenCount" />属性, 以便正确枚举可视化树。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定点或几何图形值是否在可视对象的边界内。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="abstract member HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult&#xA;override this.HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult" Usage="visual.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters"><see cref="T:System.Windows.Media.GeometryHitTestParameters" /> 对象，指定 <see cref="T:System.Windows.Media.Geometry" /> 针对命中测试。</param>
        <summary>确定可视对象的边界中是否存在几何图形值。</summary>
        <returns>表示命中测试结果的 <see cref="T:System.Windows.Media.GeometryHitTestResult" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以通过重<xref:System.Windows.Media.Visual.HitTestCore%2A>写方法来覆盖视觉对象的默认命中测试支持。 这意味着, 当你调用<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>方法时, 将调用的<xref:System.Windows.Media.Visual.HitTestCore%2A>重写实现。 当命中测试位于可视对象的边框内时, 将调用重写的方法, 即使该坐标在视觉对象的几何图形之外也是如此。  
  
   
  
## Examples  
 下面的示例演示如何重写 <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.GeometryHitTestParameters%29> 方法。 可能想要重写此方法的一个原因是在执行命中测试过程中提供附加功能。  
  
 [!code-csharp[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/GeometryHitTest.cs#hittestingoverviewsnippet13)]
 [!code-vb[HitTestingOverview#HitTestingOverviewSnippet13](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/geometryhittest.vb#hittestingoverviewsnippet13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="abstract member HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult&#xA;override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="visual.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters"><see cref="T:System.Windows.Media.PointHitTestParameters" /> 对象，指定 <see cref="T:System.Windows.Point" /> 针对命中测试。</param>
        <summary>确定点坐标值是否在可视对象的边界内。</summary>
        <returns>表示从命中测试中返回的 <see cref="T:System.Windows.Media.HitTestResult" /> 的 <see cref="T:System.Windows.Media.Visual" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以通过重<xref:System.Windows.Media.Visual.HitTestCore%2A>写方法来重写对视觉对象的默认命中测试支持。 这意味着, 当你调用<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>方法时, 将调用的<xref:System.Windows.Media.Visual.HitTestCore%2A>重写实现。 当命中测试位于可视对象的边框内时, 将调用重写的方法, 即使该坐标在视觉对象的几何图形之外也是如此。  
  
   
  
## Examples  
 下面的示例演示如何重写 <xref:System.Windows.Media.Visual.HitTestCore%28System.Windows.Media.PointHitTestParameters%29> 方法。 可能想要重写此方法的一个原因是在执行命中测试过程中提供附加功能。  
  
 [!code-csharp[HitTestingOverview#107](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#107)]
 [!code-vb[HitTestingOverview#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#107)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAncestorOf">
      <MemberSignature Language="C#" Value="public bool IsAncestorOf (System.Windows.DependencyObject descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAncestorOf(class System.Windows.DependencyObject descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsAncestorOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsAncestorOf (descendant As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAncestorOf(System::Windows::DependencyObject ^ descendant);" />
      <MemberSignature Language="F#" Value="member this.IsAncestorOf : System.Windows.DependencyObject -&gt; bool" Usage="visual.IsAncestorOf descendant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="descendant">一个 <see cref="T:System.Windows.DependencyObject" /> 类型的值。</param>
        <summary>确定可视对象是否为后代可视对象的上级。</summary>
        <returns>如果可视对象是 <paramref name="descendant" /> 的上级，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDescendantOf">
      <MemberSignature Language="C#" Value="public bool IsDescendantOf (System.Windows.DependencyObject ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDescendantOf(class System.Windows.DependencyObject ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.IsDescendantOf(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDescendantOf (ancestor As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDescendantOf(System::Windows::DependencyObject ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.IsDescendantOf : System.Windows.DependencyObject -&gt; bool" Usage="visual.IsDescendantOf ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="ancestor">一个 <see cref="T:System.Windows.DependencyObject" /> 类型的值。</param>
        <summary>确定可视对象是否为上级可视对象的后代。</summary>
        <returns>如果可视对象是 <paramref name="ancestor" /> 的后代，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit&#xA;override this.OnDpiChanged : System.Windows.DpiScale * System.Windows.DpiScale -&gt; unit" Usage="visual.OnDpiChanged (oldDpi, newDpi)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="oldDpi">上一 DPI 比例设置。</param>
        <param name="newDpi">新 DPI 比例设置。</param>
        <summary>呈现此视图时所使用的 DPI 发生变化时进行调用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualChildrenChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualChildrenChanged (System.Windows.DependencyObject visualAdded, System.Windows.DependencyObject visualRemoved);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualChildrenChanged(class System.Windows.DependencyObject visualAdded, class System.Windows.DependencyObject visualRemoved) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualChildrenChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualChildrenChanged (visualAdded As DependencyObject, visualRemoved As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualChildrenChanged(System::Windows::DependencyObject ^ visualAdded, System::Windows::DependencyObject ^ visualRemoved);" />
      <MemberSignature Language="F#" Value="abstract member OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit&#xA;override this.OnVisualChildrenChanged : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="visual.OnVisualChildrenChanged (visualAdded, visualRemoved)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visualAdded" Type="System.Windows.DependencyObject" />
        <Parameter Name="visualRemoved" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="visualAdded">已添加到集合中的 <see cref="T:System.Windows.Media.Visual" /></param>
        <param name="visualRemoved">已从集合中移除的 <see cref="T:System.Windows.Media.Visual" /></param>
        <summary>修改可视对象的 <see cref="T:System.Windows.Media.VisualCollection" /> 时调用。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="abstract member OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit&#xA;override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="visual.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">一个表示 <see cref="T:System.Windows.DependencyObject" /> 对象的上一个父级的 <see cref="T:System.Windows.Media.Visual" /> 类型值。 如果 <see cref="T:System.Windows.Media.Visual" /> 对象没有上一个父级，则参数的值为 <see langword="null" />。</param>
        <summary>当可视对象的父级更改时调用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从派生的<xref:System.Windows.Media.Visual>类可以选择重写此方法。  
  
 未提供可向实例报告此更改的 "VisualParentChanged" 事件。 因此, 你必须重写此方法以处理通知方案, 并提供通知的实例版本 (如果这是你的方案的一部分)。  
  
   
  
## Examples  
 下面的示例定义的<xref:System.Windows.Media.Visual.OnVisualParentChanged%2A>重写实现。  
  
 [!code-csharp[VisualSnippets#VisualSnippet10](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet10)]
 [!code-vb[VisualSnippets#VisualSnippet10](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Visual.VisualParent" />
      </Docs>
    </Member>
    <Member MemberName="PointFromScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointFromScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointFromScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointFromScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointFromScreen(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.PointFromScreen : System.Windows.Point -&gt; System.Windows.Point" Usage="visual.PointFromScreen point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">屏幕坐标中的 <see cref="T:System.Windows.Point" /> 值。</param>
        <summary>将屏幕坐标中的 <see cref="T:System.Windows.Point" /> 转换为表示 <see cref="T:System.Windows.Point" /> 的当前坐标系的 <see cref="T:System.Windows.Media.Visual" />。</summary>
        <returns>转换后的 <see cref="T:System.Windows.Point" /> 值表示 <see cref="T:System.Windows.Media.Visual" /> 的当前坐标系。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用方法将表示<xref:System.Windows.Media.Visual>的当前<xref:System.Windows.Point>坐标<xref:System.Windows.Point>系统的转换为屏幕坐标中的。 <xref:System.Windows.Media.Visual.PointToScreen%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Windows.Point PointToScreen (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point PointToScreen(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.PointToScreen(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point PointToScreen(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Windows.Point -&gt; System.Windows.Point" Usage="visual.PointToScreen point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">表示 <see cref="T:System.Windows.Point" /> 的当前坐标系的 <see cref="T:System.Windows.Media.Visual" /> 值。</param>
        <summary>将表示 <see cref="T:System.Windows.Point" /> 的当前坐标系的 <see cref="T:System.Windows.Media.Visual" /> 转换为屏幕坐标中的 <see cref="T:System.Windows.Point" />。</summary>
        <returns>屏幕坐标中转换后的 <see cref="T:System.Windows.Point" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用方法将屏幕<xref:System.Windows.Point>坐标中<xref:System.Windows.Point>的转换为表示的当前坐标系统<xref:System.Windows.Media.Visual>的。 <xref:System.Windows.Media.Visual.PointFromScreen%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveVisualChild">
      <MemberSignature Language="C#" Value="protected void RemoveVisualChild (System.Windows.Media.Visual child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RemoveVisualChild(class System.Windows.Media.Visual child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.RemoveVisualChild(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RemoveVisualChild (child As Visual)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RemoveVisualChild(System::Windows::Media::Visual ^ child);" />
      <MemberSignature Language="F#" Value="member this.RemoveVisualChild : System.Windows.Media.Visual -&gt; unit" Usage="visual.RemoveVisualChild child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="child">要从父可视对象中移除的子可视对象。</param>
        <summary>移除两个可视对象之间的父子关系。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.RemoveVisualChild%2A>方法移除两个视觉对象之间的父子关系。 如果需要对可视子对象<xref:System.Windows.Media.Visual.AddVisualChild%2A>的基础存储实现进行更高级别的控制, 则必须使用此方法以及方法。 <xref:System.Windows.Media.VisualCollection>可用作存储子对象的默认实现。  
  
   
  
## Examples  
 下面的示例演示如何为视觉对象定义自定义存储要求。 该示例使用<xref:System.Windows.Media.Visual.AddVisualChild%2A>和<xref:System.Windows.Media.Visual.RemoveVisualChild%2A>方法来设置父视觉对象和`child`之间的父子关系。 为了正确枚举可视化树, 该示例提供<xref:System.Windows.Media.Visual.GetVisualChild%2A>方法和<xref:System.Windows.Media.Visual.VisualChildrenCount%2A>属性的重写实现。  
  
> [!NOTE]
>  尽管可以使用<xref:System.Windows.Media.VisualCollection>创建可视对象之间的父子关系, 但当只有一个子级链接到父对象时, 提供自己的自定义存储实现会更有效。  
  
 [!code-csharp[AddVisualChild#AddVisualChild01](~/samples/snippets/csharp/VS_Snippets_Wpf/AddVisualChild/CSharp/Window1.xaml.cs#addvisualchild01)]
 [!code-vb[AddVisualChild#AddVisualChild01](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AddVisualChild/visualbasic/window1.xaml.vb#addvisualchild01)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.VisualCollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TransformToAncestor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个转换，该转换可用于将 <see cref="T:System.Windows.Media.Visual" /> 中的坐标转换为指定的可视对象上级。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor (System.Windows.Media.Media3D.Visual3D ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Media3D.GeneralTransform2DTo3D TransformToAncestor(class System.Windows.Media.Media3D.Visual3D ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Media3D.Visual3D)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual3D) As GeneralTransform2DTo3D" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Media3D::GeneralTransform2DTo3D ^ TransformToAncestor(System::Windows::Media::Media3D::Visual3D ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.TransformToAncestor : System.Windows.Media.Media3D.Visual3D -&gt; System.Windows.Media.Media3D.GeneralTransform2DTo3D" Usage="visual.TransformToAncestor ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Media3D.GeneralTransform2DTo3D</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Media3D.Visual3D" />
      </Parameters>
      <Docs>
        <param name="ancestor">要将坐标转换到的 <see cref="T:System.Windows.Media.Media3D.Visual3D" />。</param>
        <summary>返回一个转换，该转换可用于将 <see cref="T:System.Windows.Media.Visual" /> 中的坐标转换为可视对象的指定 <see cref="T:System.Windows.Media.Media3D.Visual3D" /> 上级。</summary>
        <returns>一个转换，该转换可用于将 <see cref="T:System.Windows.Media.Visual" /> 中的坐标转换为可视对象的指定 <see cref="T:System.Windows.Media.Media3D.Visual3D" /> 上级。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransformToAncestor">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToAncestor (System.Windows.Media.Visual ancestor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToAncestor(class System.Windows.Media.Visual ancestor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToAncestor(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToAncestor (ancestor As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToAncestor(System::Windows::Media::Visual ^ ancestor);" />
      <MemberSignature Language="F#" Value="member this.TransformToAncestor : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToAncestor ancestor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ancestor" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="ancestor">要将坐标转换到的 <see cref="T:System.Windows.Media.Visual" />。</param>
        <summary>返回一个转换，该转换可用于将 <see cref="T:System.Windows.Media.Visual" /> 中的坐标转换为可视对象的指定 <see cref="T:System.Windows.Media.Visual" /> 上级。</summary>
        <returns>一个 <see cref="T:System.Windows.Media.GeneralTransform" /> 类型的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 或者, 您可以使用<xref:System.Windows.Media.VisualTreeHelper.GetOffset%2A?displayProperty=nameWithType>方法检索相对于其父级的可视对象的偏移量。 偏移量值包含在返回<xref:System.Windows.Vector>值中。  
  
 [!code-csharp[VisualSnippets#VisualSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet2)]
 [!code-vb[VisualSnippets#VisualSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet2)]  
  
   
  
## Examples  
 以下标记示例演示<xref:System.Windows.Controls.TextBlock>了嵌套在两个<xref:System.Windows.Controls.StackPanel>对象中的。  
  
 [!code-xaml[VisualSnippets#VisualSnippet7](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window2.xaml#visualsnippet7)]  
  
 下面的代码示例演示如何使用<xref:System.Windows.Media.Visual.TransformToAncestor%2A>方法检索<xref:System.Windows.Controls.TextBlock>相对于所包含<xref:System.Windows.Window>的的偏移量。 偏移量值包含在返回<xref:System.Windows.Media.GeneralTransform>的中。  
  
 [!code-csharp[VisualSnippets#VisualSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet5)]
 [!code-vb[VisualSnippets#VisualSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet5)]  
  
 偏移量<xref:System.Windows.FrameworkElement.Margin%2A>将考虑包含<xref:System.Windows.Window>中的所有对象的值。 在这种情况<xref:System.Windows.Vector.X%2A>下, 为 28 <xref:System.Windows.Vector.Y%2A> , 而是28。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="ancestor" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="ancestor" /> 不是可视对象的上级。</exception>
        <exception cref="T:System.InvalidOperationException">这些可视对象不相关。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToDescendant">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToDescendant (System.Windows.Media.Visual descendant);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToDescendant(class System.Windows.Media.Visual descendant) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToDescendant(System.Windows.Media.Visual)" />
      <MemberSignature Language="VB.NET" Value="Public Function TransformToDescendant (descendant As Visual) As GeneralTransform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToDescendant(System::Windows::Media::Visual ^ descendant);" />
      <MemberSignature Language="F#" Value="member this.TransformToDescendant : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToDescendant descendant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descendant" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="descendant">要将坐标转换到的 <see cref="T:System.Windows.Media.Visual" />。</param>
        <summary>返回一个转换，该转换可用于将 <see cref="T:System.Windows.Media.Visual" /> 中的坐标转换为指定的可视对象后代。</summary>
        <returns>一个 <see cref="T:System.Windows.Media.GeneralTransform" /> 类型的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 以下标记示例显示了一个<xref:System.Windows.Controls.TextBlock>包含<xref:System.Windows.Controls.StackPanel>在对象中的。  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 下面的代码示例演示如何使用<xref:System.Windows.Media.Visual.TransformToDescendant%2A>方法检索<xref:System.Windows.Controls.StackPanel>相对于其子级<xref:System.Windows.Controls.TextBlock>的偏移量。 偏移量值包含在返回<xref:System.Windows.Media.GeneralTransform>值中。  
  
 [!code-csharp[VisualSnippets#VisualSnippet9](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet9)]
 [!code-vb[VisualSnippets#VisualSnippet9](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet9)]  
  
 偏移量会考虑所有对象<xref:System.Windows.FrameworkElement.Margin%2A>的值。 在此示例中<xref:System.Windows.Vector.X%2A> , 为-4, <xref:System.Windows.Vector.Y%2A>并且为-4。 偏移值是负值, 因为父对象相对于其子对象是负偏移。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="descendant" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">可视对象不是 <paramref name="descendant" /> 可视对象的上级。</exception>
        <exception cref="T:System.InvalidOperationException">这些可视对象不相关。</exception>
      </Docs>
    </Member>
    <Member MemberName="TransformToVisual">
      <MemberSignature Language="C#" Value="public System.Windows.Media.GeneralTransform TransformToVisual (System.Windows.Media.Visual visual);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.GeneralTransform TransformToVisual(class System.Windows.Media.Visual visual) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Visual.TransformToVisual(System.Windows.Media.Visual)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::GeneralTransform ^ TransformToVisual(System::Windows::Media::Visual ^ visual);" />
      <MemberSignature Language="F#" Value="member this.TransformToVisual : System.Windows.Media.Visual -&gt; System.Windows.Media.GeneralTransform" Usage="visual.TransformToVisual visual" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeneralTransform</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="visual" Type="System.Windows.Media.Visual" />
      </Parameters>
      <Docs>
        <param name="visual">要将坐标转换到的 <see cref="T:System.Windows.Media.Visual" />。</param>
        <summary>返回一个转换，该转换可用于将 <see cref="T:System.Windows.Media.Visual" /> 中的坐标转换为指定的可视对象。</summary>
        <returns>一个 <see cref="T:System.Windows.Media.GeneralTransform" /> 类型的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.TransformToAncestor%2A> 和<xref:System.Windows.Media.Visual.TransformToDescendant%2A>方法也可用于返回视觉对象的转换。  
  
   
  
## Examples  
 以下标记示例显示了一个<xref:System.Windows.Controls.TextBlock>包含<xref:System.Windows.Controls.StackPanel>在对象中的。  
  
 [!code-xaml[VisualSnippets#VisualSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml#visualsnippet4)]  
  
 下面的代码示例演示如何使用<xref:System.Windows.Media.Visual.TransformToVisual%2A>方法检索<xref:System.Windows.Controls.StackPanel>相对于其子级<xref:System.Windows.Controls.TextBlock>的偏移量。 偏移量值包含在返回<xref:System.Windows.Media.GeneralTransform>值中。  
  
 [!code-csharp[VisualSnippets#VisualSnippet8](~/samples/snippets/csharp/VS_Snippets_Wpf/VisualSnippets/CSharp/Window1.xaml.cs#visualsnippet8)]
 [!code-vb[VisualSnippets#VisualSnippet8](~/samples/snippets/visualbasic/VS_Snippets_Wpf/VisualSnippets/visualbasic/window1.xaml.vb#visualsnippet8)]  
  
 偏移量会考虑所有对象<xref:System.Windows.FrameworkElement.Margin%2A>的值。 在此示例中<xref:System.Windows.Vector.X%2A> , 为-4, <xref:System.Windows.Vector.Y%2A>并且为-4。 偏移值是负值, 因为父对象相对于其子对象是负偏移。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="visual" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">这些可视对象不相关。</exception>
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect VisualBitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffect ^ VisualBitmapEffect {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.Media.Visual.VisualBitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Effects.BitmapEffect" /> 的 <see cref="T:System.Windows.Media.Visual" /> 值。</summary>
        <value>此可视对象的位图效果。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput VisualBitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::BitmapEffectInput ^ VisualBitmapEffectInput {  protected public:&#xA;System::Windows::Media::Effects::BitmapEffectInput ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.Media.Visual.VisualBitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Effects.BitmapEffectInput" /> 的 <see cref="T:System.Windows.Media.Visual" /> 值。</summary>
        <value>此可视对象的位图效果输入值。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.UIElement.BitmapEffectInput" />
      </Docs>
    </Member>
    <Member MemberName="VisualBitmapScalingMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.BitmapScalingMode VisualBitmapScalingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualBitmapScalingMode As BitmapScalingMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::BitmapScalingMode VisualBitmapScalingMode {  protected public:&#xA;System::Windows::Media::BitmapScalingMode get(); protected:&#xA; void set(System::Windows::Media::BitmapScalingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualBitmapScalingMode : System.Windows.Media.BitmapScalingMode with get, set" Usage="System.Windows.Media.Visual.VisualBitmapScalingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.BitmapScalingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.BitmapScalingMode" /> 的 <see cref="T:System.Windows.Media.Visual" />。</summary>
        <value>的 <see cref="T:System.Windows.Media.BitmapScalingMode" /> 值 <see cref="T:System.Windows.Media.Visual" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualCacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode VisualCacheMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode VisualCacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualCacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualCacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::CacheMode ^ VisualCacheMode {  protected public:&#xA;System::Windows::Media::CacheMode ^ get(); protected:&#xA; void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualCacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.Media.Visual.VisualCacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Visual" /> 的缓存表示形式。</summary>
        <value><see cref="T:System.Windows.Media.CacheMode" />，用于容纳 <see cref="T:System.Windows.Media.Visual" /> 的缓存表示形式。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果需要提高呈现时间的内容的性能, 请设置属性。<xref:System.Windows.Media.Visual.VisualCacheMode%2A> 有关详细信息，请参阅 <xref:System.Windows.Media.BitmapCache>。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.CacheMode" />
        <altmember cref="P:System.Windows.Media.ContainerVisual.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected virtual int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualChildrenCount : int" Usage="System.Windows.Media.Visual.VisualChildrenCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Windows.Media.Visual" /> 的子元素数量。</summary>
        <value>子元素的数量。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, <xref:System.Windows.Media.Visual>没有任何子级。 因此, 默认实现始终返回0。  
  
   
  
## Examples  
 下面的示例定义的<xref:System.Windows.Media.Visual.VisualChildrenCount%2A>重写实现。  
  
 [!code-csharp[DrawingVisualSample#102a](~/samples/snippets/csharp/VS_Snippets_Wpf/DrawingVisualSample/CSharp/Window1.xaml.cs#102a)]
 [!code-vb[DrawingVisualSample#102a](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DrawingVisualSample/visualbasic/window1.xaml.vb#102a)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>从<see cref="T:System.Windows.Media.Visual" />派生的类必须重写此属性和<see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" />方法, 以便正确枚举可视化树。</para></block>
      </Docs>
    </Member>
    <Member MemberName="VisualClearTypeHint">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.ClearTypeHint VisualClearTypeHint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.ClearTypeHint VisualClearTypeHint" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualClearTypeHint As ClearTypeHint" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::ClearTypeHint VisualClearTypeHint { System::Windows::Media::ClearTypeHint get(); void set(System::Windows::Media::ClearTypeHint value); };" />
      <MemberSignature Language="F#" Value="member this.VisualClearTypeHint : System.Windows.Media.ClearTypeHint with get, set" Usage="System.Windows.Media.Visual.VisualClearTypeHint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ClearTypeHint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.ClearTypeHint" />，它确定在 <see cref="T:System.Windows.Media.Visual" /> 中呈现 ClearType 的方式。</summary>
        <value><see cref="T:System.Windows.Media.ClearTypeHint" /> 的 <see cref="T:System.Windows.Media.Visual" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualClip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry VisualClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry VisualClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualClip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Geometry ^ VisualClip {  protected public:&#xA;System::Windows::Media::Geometry ^ get(); protected:&#xA; void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualClip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.Media.Visual.VisualClip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Visual" /> 的剪辑区域作为 <see cref="T:System.Windows.Media.Geometry" /> 值。</summary>
        <value>作为 <see cref="T:System.Windows.Media.Geometry" /> 类型的可视对象的剪辑区域值。</value>
        <remarks>To be added.</remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/ms746710(v=vs.90)">如何：创建剪辑区域</related>
      </Docs>
    </Member>
    <Member MemberName="VisualEdgeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.EdgeMode VisualEdgeMode { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.EdgeMode VisualEdgeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEdgeMode As EdgeMode" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::EdgeMode VisualEdgeMode {  protected public:&#xA;System::Windows::Media::EdgeMode get(); protected:&#xA; void set(System::Windows::Media::EdgeMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualEdgeMode : System.Windows.Media.EdgeMode with get, set" Usage="System.Windows.Media.Visual.VisualEdgeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.EdgeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Visual" /> 的边缘模式作为 <see cref="T:System.Windows.Media.EdgeMode" /> 值。</summary>
        <value>可视对象的 <see cref="T:System.Windows.Media.EdgeMode" /> 值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect VisualEffect { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect VisualEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualEffect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Effects::Effect ^ VisualEffect {  protected public:&#xA;System::Windows::Media::Effects::Effect ^ get(); protected:&#xA; void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualEffect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.Media.Visual.VisualEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置要应用于 <see cref="T:System.Windows.Media.Visual" /> 的位图效果。</summary>
        <value>一个表示位图效果的 <see cref="T:System.Windows.Media.Effects.Effect" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="VisualOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Vector VisualOffset { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Vector VisualOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOffset As Vector" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Vector VisualOffset {  protected public:&#xA;System::Windows::Vector get(); protected:&#xA; void set(System::Windows::Vector value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOffset : System.Windows.Vector with get, set" Usage="System.Windows.Media.Visual.VisualOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Vector</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置可视对象的偏移量值。</summary>
        <value>一个指定偏移量值的 <see cref="T:System.Windows.Vector" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacity">
      <MemberSignature Language="C#" Value="public double VisualOpacity { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VisualOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacity" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:  property double VisualOpacity {  protected public:&#xA;double get(); protected:&#xA; void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOpacity : double with get, set" Usage="System.Windows.Media.Visual.VisualOpacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Visual" /> 的不透明度。</summary>
        <value>可视对象的不透明度值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 的不透明度<xref:System.Windows.Media.Visual>值表示为介于0和1之间的值。 如果值为 0, 则指示元素是完全透明的, 而值1表示元素完全不透明。 如果值为 0.5, 则表示元素为 50% 不透明。 小于0的值将被视为 0;大于1的值将被视为1。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualOpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush VisualOpacityMask { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush VisualOpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualOpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Brush ^ VisualOpacityMask {  protected public:&#xA;System::Windows::Media::Brush ^ get(); protected:&#xA; void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualOpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.Media.Visual.VisualOpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Brush" /> 值，该值表示 <see cref="T:System.Windows.Media.Visual" /> 的不透明蒙板。</summary>
        <value>一个表示可视对象的不透明蒙板值的 <see cref="T:System.Windows.Media.Brush" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不透明蒙板是<xref:System.Windows.Media.Brush>一个, 它应用于此视觉对象的呈现内容的任何 alpha 通道蒙板。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualParent">
      <MemberSignature Language="C#" Value="protected System.Windows.DependencyObject VisualParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject VisualParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualParent" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property VisualParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::DependencyObject ^ VisualParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.VisualParent : System.Windows.DependencyObject" Usage="System.Windows.Media.Visual.VisualParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取可视对象的可视化树父级。</summary>
        <value><see cref="T:System.Windows.Media.Visual" /> 父级。</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkContentElement.Parent" />
        <altmember cref="T:System.Windows.Media.VisualTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="VisualScrollableAreaClip">
      <MemberSignature Language="C#" Value="public Nullable&lt;System.Windows.Rect&gt; VisualScrollableAreaClip { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;valuetype System.Windows.Rect&gt; VisualScrollableAreaClip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualScrollableAreaClip As Nullable(Of Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:  property Nullable&lt;System::Windows::Rect&gt; VisualScrollableAreaClip {  protected public:&#xA;Nullable&lt;System::Windows::Rect&gt; get(); protected:&#xA; void set(Nullable&lt;System::Windows::Rect&gt; value); };" />
      <MemberSignature Language="F#" Value="member this.VisualScrollableAreaClip : Nullable&lt;System.Windows.Rect&gt; with get, set" Usage="System.Windows.Media.Visual.VisualScrollableAreaClip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Windows.Rect&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Visual" /> 的剪辑的可滚动区域。</summary>
        <value>一个表示可滚动的剪辑区域的 <see cref="T:System.Windows.Rect" />，如果未分配剪辑区域，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A>将属性设置为在软件中呈现时启用加速滚动。 这对于远程呈现方案非常有用, 例如, 通过远程桌面运行或在虚拟机中运行。 在将滚动其子级的父元素上设置此属性。 在呈现<xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A>硬件加速时, 设置属性不起作用。  
  
 <xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A>属性启用特定的高级方案。 以下列表显示了使用<xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A>属性时的注意事项。  
  
-   滚动区域的背景必须是不透明的, 否则将发生滚动项目。  
  
-   仅<xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A>当 WPF 在软件中呈现时, 属性才会加速滚动。 例如, 当应用程序通过远程桌面运行或在虚拟机中本地运行时, 会发生这种情况。  
  
-   在硬件中呈现时, 滚动行为不变。 若要防止滚动行为的差异, 应保持<xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A>对硬件和软件启用属性。  
  
-   旋转和倾斜变换禁用加速滚动。 缩放转换和滚动区域上方的水平或垂直翻译工作正常, 不会禁用滚动加速。  
  
-   更改子树或触发可滚动区域的部分以通过动画进行重绘会按预期方式运行, 但会丧失重绘区域加速滚动的优点。 在滚动发生的相同帧中使滚动区域失效的任何动画消除了此优化的优点。  
  
-   该<xref:System.Windows.Media.Visual.VisualScrollableAreaClip%2A>矩形向内对齐到像素。 因此, 滚动矩形的已对齐大小始终小于或等于您设置的大小。  
  
-   靠下的偏移量。 这意味着, 上一个对齐的偏移量和当前对齐的偏移量的差始终为整数的像素数。  
  
-   命中测试最多可以关闭一个像素。  
  
-   应启用布局舍入, 因为它可以确保可滚动区域的边缘和边界窗口客户端区域将对齐到像素边界, 从而使对齐正确。  
  
-   滚动加速在分层窗口上不起作用。 这意味着 windows 中 AllowTransparency = = true, windowstyle = = none, 等等。  
  
-   滚动加速过程中不会发生滚动加速。  
  
-   当窗口跨越两台监视器时, 滚动加速不起作用。  
  
-   滚动加速在滚动元素的父链中存在中间呈现目标时不起作用。 以下列表显示了其中一些中间呈现目标。  
  
    -   具  
  
    -   效果  
  
    -   DrawingBrushes  
  
    -   VisualBrushes  
  
    -   OpacityMasks  
  
    -   不透明度  
  
-   每个帧只能发生一次加速滚动。 可以有多个加速滚动区域, 但其中只有一个可以在框架中执行加速滚动。 滚动的区域是不确定的。  
  
-   滚动加速支持滚动区域上方的内容 (在 z 顺序中), 但不滚动其他内容。 系统将计算所有必要的脏区域并完成加速滚动, 但会通过线路发送多个附加的位图, 将无意中滚动的部分移回其在屏幕上的正确位置。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextHintingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextHintingMode VisualTextHintingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextHintingMode VisualTextHintingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextHintingMode As TextHintingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextHintingMode VisualTextHintingMode { System::Windows::Media::TextHintingMode get(); void set(System::Windows::Media::TextHintingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTextHintingMode : System.Windows.Media.TextHintingMode with get, set" Usage="System.Windows.Media.Visual.VisualTextHintingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextHintingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Visual" /> 的 <see cref="T:System.Windows.Media.TextHintingMode" />。</summary>
        <value>应用于 <see cref="T:System.Windows.Media.Visual" /> 的 <see cref="T:System.Windows.Media.TextHintingMode" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTextRenderingMode">
      <MemberSignature Language="C#" Value="protected internal System.Windows.Media.TextRenderingMode VisualTextRenderingMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Media.TextRenderingMode VisualTextRenderingMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property VisualTextRenderingMode As TextRenderingMode" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::Media::TextRenderingMode VisualTextRenderingMode { System::Windows::Media::TextRenderingMode get(); void set(System::Windows::Media::TextRenderingMode value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTextRenderingMode : System.Windows.Media.TextRenderingMode with get, set" Usage="System.Windows.Media.Visual.VisualTextRenderingMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.TextRenderingMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Visual" /> 的 <see cref="T:System.Windows.Media.TextRenderingMode" />。</summary>
        <value>应用于 <see cref="T:System.Windows.Media.Visual" /> 的 <see cref="T:System.Windows.Media.TextRenderingMode" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform VisualTransform { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform VisualTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::Transform ^ VisualTransform {  protected public:&#xA;System::Windows::Media::Transform ^ get(); protected:&#xA; void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.Media.Visual.VisualTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 <see cref="T:System.Windows.Media.Transform" /> 的 <see cref="T:System.Windows.Media.Visual" /> 值。</summary>
        <value>可视对象的转换值。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualXSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualXSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualXSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualXSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualXSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualXSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.Visual.VisualXSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 X 坐标（垂直）准线集合。</summary>
        <value>可视对象的 X 坐标准线集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 像素对齐是内容布局固定到的过程, 以便在特定于设备的像素上呈现对象边缘。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 图形系统使用与设备无关的单元来使分辨率和设备独立。 每个与设备无关的像素都会随着系统的 [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] 设置自动进行缩放。 这为 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 应用程序提供了不同 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] 设置的适当缩放，并使应用程序自动感知 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]。  
  
 但是, 这[!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]种独立性可能会因为抗锯齿而产生不规则边缘渲染。 当边缘的位置落在设备像素中间而不是设备像素之间时, 可能会出现这些项目, 这些项目通常被视为模糊或 "软" 边缘。 若要解决此问题[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , 可为可视化树中的对象边缘提供一种 "对齐" 到设备像素的方式, 从而消除抗锯齿产生的软边缘。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetXSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
    <Member MemberName="VisualYSnappingGuidelines">
      <MemberSignature Language="C#" Value="public System.Windows.Media.DoubleCollection VisualYSnappingGuidelines { protected internal get; protected set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.DoubleCollection VisualYSnappingGuidelines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberSignature Language="VB.NET" Value="Public Property VisualYSnappingGuidelines As DoubleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:  property System::Windows::Media::DoubleCollection ^ VisualYSnappingGuidelines {  protected public:&#xA;System::Windows::Media::DoubleCollection ^ get(); protected:&#xA; void set(System::Windows::Media::DoubleCollection ^ value); };" />
      <MemberSignature Language="F#" Value="member this.VisualYSnappingGuidelines : System.Windows.Media.DoubleCollection with get, set" Usage="System.Windows.Media.Visual.VisualYSnappingGuidelines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.DoubleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置 Y 坐标（水平）准线集合。</summary>
        <value>可视对象的 Y 坐标准线集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 像素对齐是内容布局固定到的过程, 以便在特定于设备的像素上呈现对象边缘。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 图形系统使用与设备无关的单元来使分辨率和设备独立。 每个与设备无关的像素都会随着系统的 [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] 设置自动进行缩放。 这为 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 应用程序提供了不同 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)] 设置的适当缩放，并使应用程序自动感知 [!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]。  
  
 但是, 这[!INCLUDE[TLA2#tla_dpi](~/includes/tla2sharptla-dpi-md.md)]种独立性可能会因为抗锯齿而产生不规则边缘渲染。 当边缘的位置落在设备像素中间而不是设备像素之间时, 可能会出现这些项目 (通常看起来是模糊或 "软" 边缘)。 若要解决此问题[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , 可为可视化树中的对象边缘提供一种 "对齐" 到设备像素的方式, 从而消除抗锯齿产生的软边缘。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.VisualTreeHelper.GetYSnappingGuidelines(System.Windows.Media.Visual)" />
      </Docs>
    </Member>
  </Members>
</Type>
