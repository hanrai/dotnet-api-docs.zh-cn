<Type Name="Task" FullName="System.Threading.Tasks.Task">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c200bb14e9b286622509ade5fbfb3ca3adb9b4db" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69099116" /></Metadata><TypeSignature Language="C#" Value="public class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task extends System.Object implements class System.IAsyncResult, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task" />
  <TypeSignature Language="VB.NET" Value="Public Class Task&#xA;Implements IAsyncResult, IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Task : IAsyncResult, IDisposable" />
  <TypeSignature Language="F#" Value="type Task = class&#xA;    interface IAsyncResult&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IAsyncResult</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_TaskDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="0ddf6-101">表示一个异步操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-101">Represents an asynchronous operation.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
   
## Remarks  
 <span data-ttu-id="0ddf6-102"><xref:System.Threading.Tasks.Task>类表示不返回值并且通常以异步方式执行的单个操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-102">The <xref:System.Threading.Tasks.Task> class represents a single operation that does not return a value and that usually executes asynchronously.</span></span> <span data-ttu-id="0ddf6-103"><xref:System.Threading.Tasks.Task>对象是在 .NET Framework 4 中首次引入的[基于任务的异步模式](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md)的中心组件之一。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-103"><xref:System.Threading.Tasks.Task> objects are one of the central components of the  [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) first introduced in the .NET Framework 4.</span></span> <span data-ttu-id="0ddf6-104">由于<xref:System.Threading.Tasks.Task>对象执行的工作通常在线程池线程上异步执行, 而不是在主应用程序线程上同步执行, 因此你<xref:System.Threading.Tasks.Task.Status%2A>可以使用属性<xref:System.Threading.Tasks.Task.IsCanceled%2A>, 以及、 <xref:System.Threading.Tasks.Task.IsCompleted%2A>和<xref:System.Threading.Tasks.Task.IsFaulted%2A>属性, 用于确定任务的状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-104">Because the work performed by a <xref:System.Threading.Tasks.Task> object typically executes asynchronously on a thread pool thread rather than synchronously on the main application thread, you can use the <xref:System.Threading.Tasks.Task.Status%2A> property, as well as the <xref:System.Threading.Tasks.Task.IsCanceled%2A>, <xref:System.Threading.Tasks.Task.IsCompleted%2A>, and <xref:System.Threading.Tasks.Task.IsFaulted%2A> properties, to determine the   state of a task.</span></span> <span data-ttu-id="0ddf6-105">通常, lambda 表达式用于指定任务要执行的工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-105">Most commonly, a lambda expression is used to specify the work that the task is to perform.</span></span>  
  
 <span data-ttu-id="0ddf6-106">对于返回值的操作, 请使用<xref:System.Threading.Tasks.Task%601>类。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-106">For operations that return values, you use the <xref:System.Threading.Tasks.Task%601> class.</span></span>  
  
 <span data-ttu-id="0ddf6-107">本节内容：</span><span class="sxs-lookup"><span data-stu-id="0ddf6-107">In this section:</span></span>  
  
 <span data-ttu-id="0ddf6-108">[任务实例化示例](#Instant) </span><span class="sxs-lookup"><span data-stu-id="0ddf6-108">[Task instantiation examples](#Instant) </span></span>  
 <span data-ttu-id="0ddf6-109">[创建和执行任务](#Creating) </span><span class="sxs-lookup"><span data-stu-id="0ddf6-109">[Creating and executing a task](#Creating) </span></span>  
 <span data-ttu-id="0ddf6-110">[分离任务创建和执行](#Separating) </span><span class="sxs-lookup"><span data-stu-id="0ddf6-110">[Separating task creation and execution](#Separating) </span></span>  
 <span data-ttu-id="0ddf6-111">[正在等待一个或多个任务完成](#WaitingForOne) </span><span class="sxs-lookup"><span data-stu-id="0ddf6-111">[Waiting for one or more tasks to complete](#WaitingForOne) </span></span>  
 <span data-ttu-id="0ddf6-112">[任务和区域性](#Culture) </span><span class="sxs-lookup"><span data-stu-id="0ddf6-112">[Tasks and culture](#Culture) </span></span>  
 [<span data-ttu-id="0ddf6-113">对于调试器开发人员</span><span class="sxs-lookup"><span data-stu-id="0ddf6-113">For debugger developers</span></span>](#Debugger)  

 <a name="Instant"></a>     
## <a name="task-instantiation"></a><span data-ttu-id="0ddf6-114">任务实例化</span><span class="sxs-lookup"><span data-stu-id="0ddf6-114">Task instantiation</span></span>  
 <span data-ttu-id="0ddf6-115">下面的示例创建并执行四个任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-115">The following example creates and executes four tasks.</span></span> <span data-ttu-id="0ddf6-116">三个任务执行<xref:System.Action%601>名为`action`的委托, 该委托接受类型<xref:System.Object>的参数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-116">Three tasks execute an <xref:System.Action%601> delegate named `action`, which accepts an argument of type <xref:System.Object>.</span></span> <span data-ttu-id="0ddf6-117">第四个任务执行在对任务创建<xref:System.Action>方法的调用中以内联方式定义的 lambda 表达式 (委托)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-117">A fourth task executes a lambda expression (an <xref:System.Action> delegate) that is defined inline in the call to the task creation method.</span></span> <span data-ttu-id="0ddf6-118">每个任务实例化并以不同的方式运行:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-118">Each task is instantiated and run in a different way:</span></span>  
  
-   <span data-ttu-id="0ddf6-119">任务`t1`是通过调用任务类构造函数来实例化的, 但只有在<xref:System.Threading.Tasks.Task.Start>任务`t2`启动之后才会通过调用其方法来启动。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-119">Task `t1` is instantiated by calling a Task class constructor, but is started by calling its <xref:System.Threading.Tasks.Task.Start> method only after task `t2` has started.</span></span>  
  
-   <span data-ttu-id="0ddf6-120">`t2` 通过<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>调用方法, 在单个方法调用中实例化和启动任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-120">Task `t2` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="0ddf6-121">`t3` 通过<xref:System.Threading.Tasks.Task.Run%28System.Action%29>调用方法, 在单个方法调用中实例化和启动任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-121">Task `t3` is instantiated and started in a single method call by calling the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
-   <span data-ttu-id="0ddf6-122">`t4` 通过<xref:System.Threading.Tasks.Task.RunSynchronously>调用方法, 在主线程上同步执行任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-122">Task `t4` is executed synchronously on the main thread by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method.</span></span>  
  
 <span data-ttu-id="0ddf6-123">由于任务`t4`以同步方式执行, 因此它在主应用程序线程上执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-123">Because task `t4` executes synchronously, it executes on the main application thread.</span></span> <span data-ttu-id="0ddf6-124">其余任务通常在一个或多个线程池线程上异步执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-124">The remaining tasks execute asynchronously typically on one or more thread pool threads.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew.cs#01)]
 [!code-vb[System.Threading.Tasks.Task#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew.vb#01)] 
    
<a name="Creating"></a>   
## <a name="creating-and-executing-a-task"></a><span data-ttu-id="0ddf6-125">创建和执行任务</span><span class="sxs-lookup"><span data-stu-id="0ddf6-125">Creating and executing a task</span></span>  
 <span data-ttu-id="0ddf6-126"><xref:System.Threading.Tasks.Task>可以通过多种方式创建实例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-126"><xref:System.Threading.Tasks.Task> instances may be created in a variety of ways.</span></span> <span data-ttu-id="0ddf6-127">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)], 最常见的方法是调用静态<xref:System.Threading.Tasks.Task.Run%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-127">The most common approach, which is available starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], is to call the static <xref:System.Threading.Tasks.Task.Run%2A> method.</span></span> <span data-ttu-id="0ddf6-128"><xref:System.Threading.Tasks.Task.Run%2A>方法提供了一种简单的方法来使用默认值启动任务, 而无需其他参数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-128">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a simple way to start a task using default values and without requiring additional parameters.</span></span> <span data-ttu-id="0ddf6-129">下面的示例使用<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法来启动任务, 该任务将循环, 并显示循环迭代次数:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-129">The following example uses the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to start a task that loops and then displays the number of loop iterations:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/run1.vb#6)]  
  
 <span data-ttu-id="0ddf6-130">用于启动中[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]的任务的一种替代方法和最常见的方法是静态<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-130">An alternative, and the most common method to start a task in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], is the static <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-131"><xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> 属性<xref:System.Threading.Tasks.TaskFactory>返回对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-131">The <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType> property returns a <xref:System.Threading.Tasks.TaskFactory> object.</span></span> <span data-ttu-id="0ddf6-132"><xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法的重载使你可以指定要传递给任务创建选项和任务计划程序的参数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-132">Overloads of the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method let you specify parameters to pass to the task creation options and a task scheduler.</span></span> <span data-ttu-id="0ddf6-133">下面的示例使用<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法来启动任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-133">The following example uses the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method to start a task.</span></span> <span data-ttu-id="0ddf6-134">它在功能上等效于上一示例中的代码。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-134">It is functionally equivalent to the code in the previous example.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/startnew1.vb#7)]  
  
 <span data-ttu-id="0ddf6-135">有关更完整的示例, 请参阅[基于任务的异步编程](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-135">For more complete examples, see [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md).</span></span>  
  
<a name="Separating"></a>   
## <a name="separating-task-creation-and-execution"></a><span data-ttu-id="0ddf6-136">分离任务创建和执行</span><span class="sxs-lookup"><span data-stu-id="0ddf6-136">Separating task creation and execution</span></span>  
 <span data-ttu-id="0ddf6-137"><xref:System.Threading.Tasks.Task>类还提供了初始化任务的构造函数, 但未计划执行该任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-137">The <xref:System.Threading.Tasks.Task> class also provides constructors that initialize the task but that do not schedule it for execution.</span></span> <span data-ttu-id="0ddf6-138">出于性能原因, <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法是用于创建和计划计算任务的首选机制, 但对于必须分隔创建和计划的情况, 可以使用构造函数, 然后调用<xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType>用于计划任务稍后执行的方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-138">For performance reasons, the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method is the preferred mechanism for creating and scheduling computational tasks, but for scenarios where creation and scheduling must be separated, you can use the constructors and then call the <xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType> method to schedule the task for execution at a later time.</span></span>  
  
<a name="WaitingForOne"></a>   
## <a name="waiting-for-one-or-more-tasks-to-complete"></a><span data-ttu-id="0ddf6-139">正在等待一个或多个任务完成</span><span class="sxs-lookup"><span data-stu-id="0ddf6-139">Waiting for one or more tasks to complete</span></span>  
 <span data-ttu-id="0ddf6-140">因为任务通常在线程池线程上以异步方式运行, 所以, 创建和启动任务的线程会在实例化任务后立即继续执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-140">Because tasks typically run asynchronously on a thread pool thread, the thread that creates and starts the task continues execution as soon as the task has been instantiated.</span></span> <span data-ttu-id="0ddf6-141">在某些情况下, 当调用线程是主应用程序线程时, 应用程序可能会在任何任务实际开始执行之前终止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-141">In some cases, when the calling thread is the main application thread, the app may terminate before any the task actually begins execution.</span></span> <span data-ttu-id="0ddf6-142">在其他情况下, 应用程序的逻辑可能要求调用线程在一个或多个任务完成执行时继续执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-142">In others,   your application's logic may require that the calling thread continue execution only when one or more tasks has completed execution.</span></span> <span data-ttu-id="0ddf6-143">可以通过调用`Wait`方法来等待一个或多个任务完成, 从而同步调用线程的执行以及它启动的异步任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-143">You can synchronize the execution of the calling thread and the asynchronous tasks it launches by calling a `Wait` method to wait for one or more tasks to complete.</span></span>  
  
 <span data-ttu-id="0ddf6-144">若要等待单个任务完成, 可以调用其<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-144">To wait for a single task to complete, you can call its <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-145">对<xref:System.Threading.Tasks.Task.Wait%2A>方法的调用会阻止调用线程, 直到单类实例执行完毕。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-145">A call to the  <xref:System.Threading.Tasks.Task.Wait%2A> method blocks the calling thread until the single class instance has completed execution.</span></span>  
  
 <span data-ttu-id="0ddf6-146">下面的示例调用无参数<xref:System.Threading.Tasks.Task.Wait>方法以无条件等待, 直到任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-146">The following example calls the parameterless <xref:System.Threading.Tasks.Task.Wait> method to wait unconditionally until a task completes.</span></span> <span data-ttu-id="0ddf6-147">任务通过调用<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法来模拟两秒钟的工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-147">The task simulates work by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to sleep for two seconds.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait1.cs#8)]
 [!code-vb[System.Threading.Tasks.Task#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait1.vb#8)]  
  
 <span data-ttu-id="0ddf6-148">还可以有条件地等待任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-148">You can also conditionally wait for a task to complete.</span></span> <span data-ttu-id="0ddf6-149"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> 和<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>方法会阻止调用线程, 直到任务完成或超时间隔 (以先达到者为准) 为止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-149">The <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> and <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> methods block the calling thread until the task finishes or a timeout interval elapses, whichever comes first.</span></span> <span data-ttu-id="0ddf6-150">由于下面的示例将启动一个睡眠时间为两秒的任务, 但定义了一秒的超时值, 因此调用线程将会阻塞, 直到超时过期以及任务已完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-150">Since the following example launches a task that sleeps for two seconds but defines a one-second timeout value, the calling thread blocks until the timeout expires and before the task has completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/Wait2.cs#9)]
 [!code-vb[System.Threading.Tasks.Task#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/Wait2.vb#9)]  
  
 <span data-ttu-id="0ddf6-151">还可以通过调用<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>和<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法来提供取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-151">You can also supply a cancellation token by calling the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> and  <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> methods.</span></span> <span data-ttu-id="0ddf6-152">如果<xref:System.Threading.CancellationToken.IsCancellationRequested%2A>在执行`true` `true` 方法<xref:System.Threading.Tasks.Task.Wait%2A>时, 标记的属性为或, 则该方法将引发<xref:System.OperationCanceledException>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-152">If the  token's <xref:System.Threading.CancellationToken.IsCancellationRequested%2A> property is `true` or becomes `true` while the <xref:System.Threading.Tasks.Task.Wait%2A> method is executing, the method throws an <xref:System.OperationCanceledException>.</span></span>  
  
 <span data-ttu-id="0ddf6-153">在某些情况下, 可能需要等待一系列正在执行的任务的第一项完成, 但不要在意任务是哪个。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-153">In some cases, you may want to wait for the first of a series of executing tasks to complete, but don't care which task it is.</span></span>  <span data-ttu-id="0ddf6-154">为此, 可以调用<xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType>方法的重载之一。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-154">For this purpose, you can call one of the overloads of the <xref:System.Threading.Tasks.Task.WaitAny%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="0ddf6-155">下面的示例创建三个任务, 每个任务休眠一段时间间隔, 由随机数生成器决定。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-155">The following example creates three tasks, each of which sleeps for an interval determine by a random number generator.</span></span> <span data-ttu-id="0ddf6-156"><xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29>方法等待第一个任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-156">The <xref:System.Threading.Tasks.Task.WaitAny%28System.Threading.Tasks.Task%5B%5D%29> method waits for the first task to complete.</span></span> <span data-ttu-id="0ddf6-157">然后, 该示例显示所有三个任务的状态信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-157">The example then displays information about the status of all three tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WhenAny1.cs#10)]
 [!code-vb[System.Threading.Tasks.Task#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAny1.vb#10)]  
  
 <span data-ttu-id="0ddf6-158">还可以通过调用<xref:System.Threading.Tasks.Task.WaitAll%2A>方法来等待一系列任务全部完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-158">You can also wait for all of a series of tasks to complete by calling the <xref:System.Threading.Tasks.Task.WaitAll%2A> method.</span></span> <span data-ttu-id="0ddf6-159">下面的示例创建了十个任务, 等待所有十个任务完成, 然后显示其状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-159">The following example creates ten tasks, waits for all ten to complete, and then displays their status.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll1.cs#11)]
 [!code-vb[System.Threading.Tasks.Task#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll1.vb#11)]  
  
 <span data-ttu-id="0ddf6-160">请注意, 当你等待一个或多个任务完成时, 正在运行的任务中引发的任何异常都会在调用`Wait`方法的线程上传播, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-160">Note that when you wait for one or more tasks to complete, any exceptions thrown in the running tasks are propagated on the thread that calls the `Wait` method, as the following example shows.</span></span> <span data-ttu-id="0ddf6-161">它启动12个任务, 其中三个任务都正常完成, 三个任务引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-161">It launches 12 tasks, three of which complete normally and three of which throw an exception.</span></span> <span data-ttu-id="0ddf6-162">其余六个任务在开始之前会被取消, 三个任务在执行时取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-162">Of the remaining six tasks, three are cancelled before they start, and three are cancelled while they are executing.</span></span> <span data-ttu-id="0ddf6-163">异常在<xref:System.Threading.Tasks.Task.WaitAll%2A>方法调用中引发并`try` / `catch`由块处理。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-163">Exceptions are thrown in the <xref:System.Threading.Tasks.Task.WaitAll%2A> method call and are handled by a `try`/`catch` block.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/WaitAll2.cs#12)]
 [!code-vb[System.Threading.Tasks.Task#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/WaitAll2.vb#12)]  
  
 <span data-ttu-id="0ddf6-164">有关基于任务的异步操作中的异常处理的详细信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-164">For more information on exception handling in task-based asynchronous operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
<a name="Culture"></a>   
## <a name="tasks-and-culture"></a><span data-ttu-id="0ddf6-165">任务和区域性</span><span class="sxs-lookup"><span data-stu-id="0ddf6-165">Tasks and culture</span></span>  
 <span data-ttu-id="0ddf6-166">从面向的[!INCLUDE[net_v46](~/includes/net-v46-md.md)]桌面应用程序开始, 创建和调用任务的线程的区域性将成为线程上下文的一部分。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-166">Starting with desktop apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the thread that creates and invokes a task becomes part of the thread's context.</span></span> <span data-ttu-id="0ddf6-167">也就是说, 无论执行任务的线程的当前区域性如何, 任务的当前区域性都是调用线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-167">That is, regardless of the current culture of the thread on which the task executes, the current culture of the task is the culture of the calling thread.</span></span> <span data-ttu-id="0ddf6-168">对于面向之前[!INCLUDE[net_v46](~/includes/net-v46-md.md)]的 .NET Framework 版本的应用, 任务的区域性是执行任务的线程的区域性。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-168">For apps that target versions of the .NET Framework prior to the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the culture of the task is the culture of the thread on which the task executes.</span></span> <span data-ttu-id="0ddf6-169">有关详细信息, 请参阅<xref:System.Globalization.CultureInfo>主题中的 "区域性和基于任务的异步操作" 一节。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-169">For more information, see the "Culture and task-based asynchronous operations" section in the <xref:System.Globalization.CultureInfo> topic.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ddf6-170">应用商店应用按照设置和获取默认区域性的 Windows 运行时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-170">Store apps follow the Windows Runtime in setting and getting the default culture.</span></span>  
  
<a name="Debugger"></a>   
## <a name="for-debugger-developers"></a><span data-ttu-id="0ddf6-171">对于调试器开发人员</span><span class="sxs-lookup"><span data-stu-id="0ddf6-171">For debugger developers</span></span>  
 <span data-ttu-id="0ddf6-172">对于实现自定义调试器的开发人员而言, 任务的多个内部和私有成员可能会很有用 (它们可能会因发布而变化)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-172">For developers implementing custom debuggers, several internal and private members of task may be useful (these may change from release to release).</span></span> <span data-ttu-id="0ddf6-173">该`m_taskId`字段充当<xref:System.Threading.Tasks.Task.Id%2A>属性的后备存储, 但是直接从调试器访问此字段可能比通过属性`s_taskIdCounter`的 getter 方法访问相同的值更有效 (计数器为用于检索任务的下一个可用 ID)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-173">The `m_taskId` field serves as the backing store for the <xref:System.Threading.Tasks.Task.Id%2A> property, however accessing this field directly from a debugger may be more efficient than accessing the same value through the property's getter method (the `s_taskIdCounter` counter is used to retrieve the next available ID for a task).</span></span> <span data-ttu-id="0ddf6-174">同样, `m_stateFlags`字段存储有关任务当前生命周期阶段的信息, 也可以<xref:System.Threading.Tasks.Task.Status%2A>通过属性访问信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-174">Similarly, the `m_stateFlags` field stores information about the current lifecycle stage of the task, information also accessible through the <xref:System.Threading.Tasks.Task.Status%2A> property.</span></span> <span data-ttu-id="0ddf6-175">字段存储对任务的委托的引用, `m_stateObject`而字段存储开发人员传递给任务的异步状态。 `m_action`</span><span class="sxs-lookup"><span data-stu-id="0ddf6-175">The `m_action` field stores a reference to the task's delegate, and the `m_stateObject` field stores the async state passed to the task by the developer.</span></span> <span data-ttu-id="0ddf6-176">最后, 对于分析堆栈帧的调试器, 该`InternalWait`方法为在任务进入等待操作时提供可能的标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-176">Finally, for debuggers that parse stack frames, the `InternalWait` method serves a potential marker for when a task is entering a wait operation.</span></span>   
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="0ddf6-177">除之外<see cref="T:System.Threading.Tasks.Task" />的所有成员都是线程安全的, 可同时从多个线程使用。 <see cref="M:System.Threading.Tasks.Task.Dispose" /></span><span class="sxs-lookup"><span data-stu-id="0ddf6-177">All members of <see cref="T:System.Threading.Tasks.Task" />, except for <see cref="M:System.Threading.Tasks.Task.Dispose" />, are thread-safe and may be used from multiple threads concurrently.</span></span></threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task`1" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md"><span data-ttu-id="0ddf6-178">任务并行库 (TPL)</span><span class="sxs-lookup"><span data-stu-id="0ddf6-178">Task Parallel Library (TPL)</span></span></related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md"><span data-ttu-id="0ddf6-179">基于任务的异步编程</span><span class="sxs-lookup"><span data-stu-id="0ddf6-179">Task-based Asynchronous Programming</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="0ddf6-180">与 .NET Framework 并行编程的示例</span><span class="sxs-lookup"><span data-stu-id="0ddf6-180">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-181">初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-181">Initializes a new <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task action" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-182">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-182">The delegate that represents the code to execute in the task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-183">使用指定的操作初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-183">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-184">此构造函数只应在需要分离任务的创建和启动的高级方案中使用。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-184">This constructor should only be used in advanced scenarios where it is required that the creation and starting of the task is separated.</span></span>  
  
 <span data-ttu-id="0ddf6-185">不是调用此构造函数, 而是通过调用静态<xref:System.Threading.Tasks.Task> <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>方法来实例化对象并启动任务的最常见方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-185">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%29?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0ddf6-186">如果只是为了让 API 的使用者有权等待某些内容而不需要执行任何操作的任务<xref:System.Threading.Tasks.TaskCompletionSource%601> , 则应使用。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-186">If a task with no action is needed just for the consumer of an API to have something to await, a <xref:System.Threading.Tasks.TaskCompletionSource%601> should be used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-187">下面的示例使用<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>构造函数创建检索指定目录中的文件名的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-187">The following example uses the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to create tasks that retrieve the filenames in specified directories.</span></span> <span data-ttu-id="0ddf6-188">所有任务将文件名写入单个<xref:System.Collections.Concurrent.ConcurrentBag%601>对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-188">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="0ddf6-189">然后, 该示例调用<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>方法以确保所有任务都已完成, 然后显示写入<xref:System.Collections.Concurrent.ConcurrentBag%601>对象的文件名称总数的计数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-189">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/ctor1.vb#1)]  
  
 <span data-ttu-id="0ddf6-190">下面的示例是相同的, 只不过它使用<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法实例化并在单个操作中运行任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-190">The following example is identical, except that it used the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method to instantiate and run the task in a single operation.</span></span> <span data-ttu-id="0ddf6-191">方法返回<xref:System.Threading.Tasks.Task>表示任务的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-191">The method returns the <xref:System.Threading.Tasks.Task> object that represents the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-192"><paramref name="action" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-192">The <paramref name="action" /> argument is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.Task.Run(System.Action)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-193">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-193">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-194">新任务将观察的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-194">The <see cref="T:System.Threading.CancellationToken" /> that the new  task will observe.</span></span></param>
        <summary><span data-ttu-id="0ddf6-195">使用指定的操作和 <see cref="T:System.Threading.Tasks.Task" /> 初始化新的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-195">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and <see cref="T:System.Threading.CancellationToken" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-196">不是调用此构造函数, 实例化<xref:System.Threading.Tasks.Task>对象和启动任务的最常见方法是调用静态<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>和<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-196">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> and <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="0ddf6-197">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-197">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="0ddf6-198">有关详细信息, 请参阅[托管线程中](~/docs/standard/threading/cancellation-in-managed-threads.md)的[任务并行 (任务并行库)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)和取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-198">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-199">下面的示例调用<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29>构造函数来创建一个用于循环访问 C:\Windows\System32 目录中的文件的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-199">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%2CSystem.Threading.CancellationToken%29> constructor to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="0ddf6-200">Lambda 表达式调用<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法, 将有关每个文件的<xref:System.Collections.Generic.List%601>信息添加到对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-200">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="0ddf6-201"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>循环调用的每个分离的嵌套任务会检查取消标记的状态, 如果请求取消, 则<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>调用方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-201">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-202">当调用线程调用<xref:System.OperationCanceledException> `catch` <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 方法<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>时, 方法将引发在块中处理的异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-202">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="0ddf6-203">然后<xref:System.Threading.Tasks.Task.Start%2A>调用方法以启动任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-203">The <xref:System.Threading.Tasks.Task.Start%2A> method is then called to start the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-204">提供的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-204">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-205"><paramref name="action" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-205">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-206">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-206">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="0ddf6-207">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-207">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="0ddf6-208">使用指定的操作和创建选项初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-208">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-209">要实例化<xref:System.Threading.Tasks.Task>对象并启动任务, 最常见的方法是调用静态<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>方法, 而不是调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-209">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-210">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-210">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-211"><paramref name="action" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-211">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-212"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-212">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-213">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-213">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-214">一个表示由该操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-214">An object representing data to be used by the action.</span></span></param>
        <summary><span data-ttu-id="0ddf6-215">使用指定的操作和状态初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-215">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-216">要实例化<xref:System.Threading.Tasks.Task>对象并启动任务, 最常见的方法是调用静态<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType>方法, 而不是调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-216">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-217">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-217">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-218">下面的示例定义了一个由6个字母构成的单词的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-218">The following example defines an array of 6-letter words.</span></span> <span data-ttu-id="0ddf6-219"><xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> 然后<xref:System.Action%601> , 每个单词都作为参数传递给构造函数, 该构造函数的委托将单词中的字符进行编码, 然后显示原始单词及其已打乱的版本。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-219">Each word is then passed as an argument to the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%7BSystem.Object%7D%2CSystem.Object%29> constructor, whose <xref:System.Action%601> delegate scrambles the characters in the word, then displays the original word and its scrambled version.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/startnew3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.ctor#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/startnew3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-220"><paramref name="action" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-220">The <paramref name="action" /> argument is null.</span></span></exception>
        <altmember cref="M:System.Threading.Tasks.TaskFactory.StartNew(System.Action{System.Object},System.Object)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action ^ action, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-221">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-221">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-222">新任务将观察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-222">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="0ddf6-223">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-223">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="0ddf6-224">使用指定的操作和创建选项初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-224">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action and creation options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-225">要实例化<xref:System.Threading.Tasks.Task>对象并启动任务, 最常见的方法是调用静态<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>方法, 而不是调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-225">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-226">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-226">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 <span data-ttu-id="0ddf6-227">有关详细信息, 请参阅[任务并行 (任务并行库)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)和[任务取消](~/docs/standard/parallel-programming/task-cancellation.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-227">For more information, see [Task Parallelism (Task Parallel Library)](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Task Cancellation](~/docs/standard/parallel-programming/task-cancellation.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-228">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-228">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-229"><paramref name="action" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-229">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-230"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-230">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-231">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-231">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-232">一个表示由该操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-232">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-233">新任务将观察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-233">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <summary><span data-ttu-id="0ddf6-234">使用指定的操作、状态和选项初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-234">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-235">要实例化<xref:System.Threading.Tasks.Task>对象并启动任务, 最常见的方法是调用静态<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法, 而不是调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-235">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-236">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-236">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-237">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-237">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-238"><paramref name="action" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-238">The <paramref name="action" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (action As Action(Of Object), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-239">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-239">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-240">一个表示由该操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-240">An object representing data to be used by the action.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="0ddf6-241">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-241">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="0ddf6-242">使用指定的操作、状态和选项初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-242">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-243">要实例化<xref:System.Threading.Tasks.Task>对象并启动任务, 最常见的方法是调用静态<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>方法, 而不是调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-243">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-244">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-244">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-245"><paramref name="action" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-245">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-246"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-246">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Action&lt;object&gt; action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Action`1&lt;object&gt; action, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.#ctor(System.Action{System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Action&lt;System::Object ^&gt; ^ action, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task : Action&lt;obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task" Usage="new System.Threading.Tasks.Task (action, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-247">表示要在任务中执行的代码的委托。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-247">The delegate that represents the code to execute in the task.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-248">一个表示由该操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-248">An object representing data to be used by the action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-249">新任务将观察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-249">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that the new task will observe.</span></span></param>
        <param name="creationOptions"><span data-ttu-id="0ddf6-250">用于自定义任务的行为的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-250">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to customize the task's behavior.</span></span></param>
        <summary><span data-ttu-id="0ddf6-251">使用指定的操作、状态和选项初始化新的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-251">Initializes a new <see cref="T:System.Threading.Tasks.Task" /> with the specified action, state, and options.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-252">要实例化<xref:System.Threading.Tasks.Task>对象并启动任务, 最常见的方法是调用静态<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>方法, 而不是调用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-252">Rather than calling this constructor, the most common way to instantiate a <xref:System.Threading.Tasks.Task> object and launch a task is by calling the static <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%7BSystem.Object%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-253">此构造函数提供的唯一优点是它允许将对象实例化与任务调用分离。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-253">The only advantage offered by this constructor is that it allows object instantiation to be separated from task invocation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-254">创建了 <paramref name="cancellationToken" /> 的 <see cref="T:System.Threading.CancellationTokenSource" /> 已经被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-254">The <see cref="T:System.Threading.CancellationTokenSource" /> that created <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-255"><paramref name="action" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-255">The <paramref name="action" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-256"><paramref name="creationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-256">The <paramref name="creationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskCreationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AsyncState">
      <MemberSignature Language="C#" Value="public object AsyncState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object AsyncState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.AsyncState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AsyncState As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ AsyncState { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AsyncState : obj" Usage="System.Threading.Tasks.Task.AsyncState" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncState</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-257">获取在创建 <see cref="T:System.Threading.Tasks.Task" /> 时提供的状态对象，如果未提供，则为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-257">Gets the state object supplied when the <see cref="T:System.Threading.Tasks.Task" /> was created, or null if none was supplied.</span></span></summary>
        <value><span data-ttu-id="0ddf6-258">一个 <see cref="T:System.Object" />，表示在创建任务时传递给该任务的状态数据。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-258">An <see cref="T:System.Object" /> that represents the state data that was passed in to the task when it was created.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-259">将对象强制转换回原始类型以检索其数据。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-259">Cast the object back to the original type to retrieve its data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompletedTask">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task CompletedTask { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.Task CompletedTask" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CompletedTask" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedTask As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::Task ^ CompletedTask { System::Threading::Tasks::Task ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedTask : System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.CompletedTask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-260">获取一个已成功完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-260">Gets a task that has already completed successfully.</span></span></summary>
        <value><span data-ttu-id="0ddf6-261">已成功完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-261">The successfully completed task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-262">此属性将返回其<xref:System.Threading.Tasks.Task.Status%2A>属性设置为<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-262">This property returns a task whose <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="0ddf6-263">若要创建返回值并运行到完成的任务, 请调用<xref:System.Threading.Tasks.Task.FromResult%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-263">To create task that returns a value and runs to completion, call the <xref:System.Threading.Tasks.Task.FromResult%2A> method.</span></span>  
  
 <span data-ttu-id="0ddf6-264">检索此属性值的重复尝试不一定总是返回同一个实例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-264">Repeated attempts to retrieve this property value may not always return the same instance.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="member this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext"><span data-ttu-id="0ddf6-265">尝试将延续任务封送回原始上下文，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-265"><see langword="true" /> to attempt to marshal the continuation back to the original context captured; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="0ddf6-266">配置用于等待此 <see cref="T:System.Threading.Tasks.Task" />的 awaiter。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-266">Configures an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-267">用于的等待此任务的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-267">An object used to await this task.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-268">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-268">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-269">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-269">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-270">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-270">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="0ddf6-271">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-271">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-272">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-272">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-273">返回<xref:System.Threading.Tasks.Task>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-273">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-274">下面的示例定义了一个任务, 该任务使用100随机日期和时间值填充数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-274">The following example defines a task that populates an array with 100 random date and time values.</span></span> <span data-ttu-id="0ddf6-275">它使用<xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29>方法来选择完全填充数组后的最早和最晚日期值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-275">It uses the <xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%7D%29> method to select the earliest and the latest date values once the array is fully populated.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/cs/continuewith1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.continuewith/vb/continuewith1.vb#1)]  
  
 <span data-ttu-id="0ddf6-276">由于控制台应用程序可能会在延续任务执行前终止, <xref:System.Threading.Tasks.Task.Wait>因此调用方法以确保延续在示例结束之前完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-276">Because a console application may terminate before the continuation task executes, the <xref:System.Threading.Tasks.Task.Wait> method is called to ensure that the continuation finishes executing before the example ends.</span></span>  
  
 <span data-ttu-id="0ddf6-277">有关其他示例, 请参阅[使用延续任务链接任务](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-277">For an additional example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-278"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-278">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-279">在任务完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-279">An action to run when the task completes.</span></span> <span data-ttu-id="0ddf6-280">运行时，委托作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-280">When run, the delegate is passed the completed task and a caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-281">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-281">An object representing data to be used by the continuation action.</span></span></param>
        <summary><span data-ttu-id="0ddf6-282">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时接收调用方提供的状态信息并执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-282">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-283">一个新的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-283">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-284">返回<xref:System.Threading.Tasks.Task>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而出错, 或由于取消而提前退出。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-284">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting early due to cancellation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-285"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-285">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-286">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-286">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-287">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-287">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-288">将指派给新的延续任务的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-288">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-289">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时可接收取消标记并以异步方式执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-289">Creates a continuation that receives a cancellation token and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-290">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-290">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-291">返回<xref:System.Threading.Tasks.Task>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-291">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-292">创建了该标记的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-292">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-293"><paramref name="continuationAction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-293">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-294">根据在 <paramref name="continuationOptions" /> 中指定的条件运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-294">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="0ddf6-295">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-295">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-296">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-296">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-297">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-297">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="0ddf6-298">创建一个在目标任务完成时按照指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-298">Creates a continuation that executes when the target task completes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-299">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-299">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-300">直到当前<xref:System.Threading.Tasks.Task>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-300">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="0ddf6-301">如果未满足通过`continuationOptions`参数指定的继续条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-301">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-302">下面的示例演示如何<xref:System.Threading.Tasks.TaskContinuationOptions>使用来指定延续任务在前面的任务完成时应同步运行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-302">The following example demonstrates using <xref:System.Threading.Tasks.TaskContinuationOptions> to specify that a continuation task should run synchronously when the antecedent task completes.</span></span> <span data-ttu-id="0ddf6-303">(如果指定的任务已在调用时间<xref:System.Threading.Tasks.Task.ContinueWith%2A>之后完成, 则同步延续将在调用<xref:System.Threading.Tasks.Task.ContinueWith%2A>的线程上运行。)</span><span class="sxs-lookup"><span data-stu-id="0ddf6-303">(If the specified task has already completed by the time <xref:System.Threading.Tasks.Task.ContinueWith%2A> is called, the synchronous continuation will run on the thread calling <xref:System.Threading.Tasks.Task.ContinueWith%2A>.)</span></span>  
  
```csharp  
  
public class TaskCounter  
{  
   private volatile int _count;  
  
   public void Track(Task t)  
   {  
      if (t == null) throw new ArgumentNullException("t");  
      Interlocked.Increment(ref _count);  
      t.ContinueWith(ct => Interlocked.Decrement(ref _count), TaskContinuationOptions.ExecuteSynchronously);  
   }  
  
   public int NumberOfActiveTasks { get { return _count; } }  
}  
  
```  
  
```vb  
  
Public Class TaskCounter  
   Private _count as Integer  
  
   Public Sub Track(ByVal t as Task)  
      If t is Nothing Then Throw New ArgumentNullException("t")  
      Interlocked.Increment(_count)  
      t.ContinueWith(Sub(ct)  
                        Interlocked.Decrement(_count)  
                     End Sub,  
                     TaskContinuationOptions.ExecuteSynchronously)  
   End Sub  
  
   Public ReadOnly Property NumberOfActiveTasks As Integer  
      Get  
         Return _count  
      End Get  
   End Property  
End Class  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-304"><paramref name="continuationAction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-304">The <paramref name="continuationAction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-305"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-305">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-306">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-306">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-307">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-307">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-308">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-308">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-309">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-309">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-310">延续任务使用指定计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-310">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-311">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-311">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-312">返回<xref:System.Threading.Tasks.Task>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-312">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-313">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-313">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-314"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-314">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="0ddf6-315">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-315">-or-</span></span> 
<span data-ttu-id="0ddf6-316"><paramref name="scheduler" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-316">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-317">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-317">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-318">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如参数）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-318">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-319">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-319">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-320">将指派给新的延续任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-320">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-321">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时接收调用方提供的状态信息和取消标记，并以异步方式执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-321">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-322">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-322">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-323">返回<xref:System.Threading.Tasks.Task>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-323">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-324"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-324">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-325">提供的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-325">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-326">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-326">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-327">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-327">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-328">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-328">An object representing data to be used by the continuation action.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-329">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-329">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-330">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-330">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="0ddf6-331">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时接收调用方提供的状态信息并执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-331">Creates a continuation that receives caller-supplied state information and executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-332">延续任务根据一组指定的条件执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-332">The continuation executes based on a set of specified conditions.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-333">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-333">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-334">直到当前<xref:System.Threading.Tasks.Task>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-334">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="0ddf6-335">如果未满足通过`continuationOptions`参数指定的继续条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-335">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-336"><paramref name="continuationAction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-336">The <paramref name="continuationAction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-337"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-337">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task, Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-338">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-338">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="0ddf6-339">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-339">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-340">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-340">An object representing data to be used by the continuation action.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-341">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-341">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-342">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时接收调用方提供的状态信息并以异步方式执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-342">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-343">延续任务使用指定计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-343">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-344">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-344">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-345">返回<xref:System.Threading.Tasks.Task>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-345">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-346"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-346">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-347">根据在 <paramref name="continuationOptions" /> 中指定的条件运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-347">An action to run according to the specified <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="0ddf6-348">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-348">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-349">将指派给新的延续任务的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-349">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-350">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-350">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-351">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-351">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-352">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-352">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-353">创建一个在目标任务完成时按照指定的 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-353">Creates a continuation that executes when the target task competes according to the specified <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span> <span data-ttu-id="0ddf6-354">延续任务会收到一个取消标记，并使用指定的计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-354">The continuation receives a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-355">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-355">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-356">直到当前<xref:System.Threading.Tasks.Task>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-356">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="0ddf6-357">如果未满足通过`continuationOptions`参数指定的条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-357">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-358">下面是使用 System.threading.tasks.task.continuewith 在后台和用户界面线程上运行工作的示例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-358">The following is an example of using ContinueWith to run work both in the background and on the user interface threads.</span></span>  
  
```csharp  
  
private void Button1_Click(object sender, EventArgs e)  
{  
   var backgroundScheduler = TaskScheduler.Default;  
   var uiScheduler = TaskScheduler.FromCurrentSynchronizationContext();  
   Task.Factory.StartNew(delegate { DoBackgroundComputation(); },  
                         backgroundScheduler).  
   ContinueWith(delegate { UpdateUI(); }, uiScheduler).  
                ContinueWith(delegate { DoAnotherBackgroundComputation(); },  
                             backgroundScheduler).  
                ContinueWith(delegate { UpdateUIAgain(); }, uiScheduler);  
}  
  
```  
  
```vb  
  
Private Sub Button1_Click(ByVal sender As System.Object,   
                          ByVal e As System.EventArgs) Handles Button1.Click  
   Dim backgroundScheduler = TaskScheduler.Default  
   Dim uiScheduler = TaskScheduler.FromCurrentSynchronizationContext()  
  
   Task.Factory.StartNew(Sub()  
                           DoBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUI()  
                         End Sub, uiScheduler).ContinueWith(Sub(t)  
                            DoAnotherBackgroundComputation()  
                         End Sub, backgroundScheduler).ContinueWith(Sub(t)  
                            UpdateUIAgain()  
                         End Sub, uiScheduler)  
End Sub  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-359">创建了该标记的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-359">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-360"><paramref name="continuationAction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-360">The <paramref name="continuationAction" /> argument is null.</span></span>  
  
<span data-ttu-id="0ddf6-361">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-361">-or-</span></span> 
<span data-ttu-id="0ddf6-362"><paramref name="scheduler" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-362">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-363"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-363">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Action&lt;System.Threading.Tasks.Task, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task,System.Object&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="continuationAction"><span data-ttu-id="0ddf6-364">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-364">An action to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-365">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-365">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-366">一个表示由该延续操作使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-366">An object representing data to be used by the continuation action.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-367">将指派给新的延续任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-367">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-368">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-368">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-369">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-369">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-370">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-370">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-371">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时接收调用方提供的状态信息和取消标记并执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-371">Creates a continuation that receives caller-supplied state information and a cancellation token and that executes when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-372">延续任务根据一组指定的条件执行，并使用指定的计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-372">The continuation executes based on a set of specified conditions and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-373">一个新的延续 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-373">A new continuation <see cref="T:System.Threading.Tasks.Task" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-374">直到当前<xref:System.Threading.Tasks.Task>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-374">The returned <xref:System.Threading.Tasks.Task> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="0ddf6-375">如果未满足通过`continuationOptions`参数指定的条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-375">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-376"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-376">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-377"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-377">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-378">提供的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-378">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-379">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-379">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-380">在 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-380">A function to run when the <see cref="T:System.Threading.Tasks.Task`1" /> completes.</span></span> <span data-ttu-id="0ddf6-381">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-381">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <summary><span data-ttu-id="0ddf6-382">创建一个在目标 <see cref="T:System.Threading.Tasks.Task`1" /> 完成时异步执行并返回一个值的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-382">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task`1" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-383">一个新的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-383">A new continuation task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-384">返回<xref:System.Threading.Tasks.Task%601>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-384">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-385">下面的示例演示如何使用 System.threading.tasks.task.continuewith 方法:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-385">The following example shows how to use the ContinueWith method:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationsimple.cs#03)]
 [!code-vb[System.Threading.Tasks.Task#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationsimple.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-386">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-386">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-387"><paramref name="continuationFunction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-387">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-388">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-388">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-389">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-389">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-390">运行时，将传递委托，如完成的任务一样，调用方提供的状态对象（如参数）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-390">When run, the delegate will be passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-391">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-391">An object representing data to be used by the continuation function.</span></span></param>
        <summary><span data-ttu-id="0ddf6-392">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成并返回一个值时接收调用方提供的状态信息并以异步方式执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-392">Creates a continuation that receives caller-supplied state information and executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-393">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-393">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-394">返回<xref:System.Threading.Tasks.Task%601>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-394">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-395"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-395">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-396">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-396">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-397">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-397">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-398">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-398">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-399">将指派给新的延续任务的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-399">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-400">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时异步执行并返回一个值的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-400">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="0ddf6-401">延续任务收到取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-401">The continuation receives a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-402">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-402">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-403">返回<xref:System.Threading.Tasks.Task%601>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-403">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-404">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-404">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="0ddf6-405">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-405">-or-</span></span> 
<span data-ttu-id="0ddf6-406">创建了该标记的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-406">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-407"><paramref name="continuationFunction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-407">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-408">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-408">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-409">根据 <paramref name="continuationOptions" /> 中指定的条件运行函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-409">A function to run according to the condition specified in <paramref name="continuationOptions" />.</span></span> <span data-ttu-id="0ddf6-410">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-410">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-411">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-411">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-412">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-412">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="0ddf6-413">创建一个按照指定延续任务选项执行并返回一个值的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-413">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-414">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-414">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-415">直到当前<xref:System.Threading.Tasks.Task%601>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-415">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="0ddf6-416">如果未满足通过`continuationOptions`参数指定的继续条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-416">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-417">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-417">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-418"><paramref name="continuationFunction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-418">The <paramref name="continuationFunction" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-419"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-419">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, TResult), scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-420">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-420">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-421">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-421">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-422">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-422">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-423">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-423">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-424">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时异步执行并返回一个值的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-424">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="0ddf6-425">延续任务使用指定计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-425">The continuation uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-426">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-426">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-427">返回<xref:System.Threading.Tasks.Task%601>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-427">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed, whether it completes due to running to completion successfully, faulting due to an unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-428">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-428">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-429"><paramref name="continuationFunction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-429">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="0ddf6-430">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-430">-or-</span></span> 
<span data-ttu-id="0ddf6-431"><paramref name="scheduler" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-431">The <paramref name="scheduler" /> argument is null.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-432">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-432">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-433">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-433">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-434">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-434">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-435">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-435">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-436">将指派给新的延续任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-436">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-437">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时异步执行并返回一个值的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-437">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="0ddf6-438">延续任务接收调用方提供的状态信息和取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-438">The continuation receives caller-supplied state information and a cancellation token.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-439">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-439">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-440">返回<xref:System.Threading.Tasks.Task%601>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-440">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-441"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-441">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-442">提供的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-442">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-443">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-443">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-444">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-444">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-445">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-445">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-446">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-446">An object representing data to be used by the continuation function.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-447">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-447">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-448">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-448">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <summary><span data-ttu-id="0ddf6-449">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时根据指定的任务延续选项执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-449">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-450">延续任务接收调用方提供的状态信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-450">The continuation receives caller-supplied state information.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-451">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-451">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-452">直到当前<xref:System.Threading.Tasks.Task%601>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-452">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="0ddf6-453">如果未满足通过`continuationOptions`参数指定的继续条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-453">If the continuation criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-454"><paramref name="continuationFunction" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-454">The <paramref name="continuationFunction" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-455"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-455">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TResult) (continuationFunction As Func(Of Task, Object, TResult), state As Object, scheduler As TaskScheduler) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-456">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-456">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-457">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-457">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span>  <span data-ttu-id="0ddf6-458">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-458">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-459">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-459">An object representing data to be used by the continuation function.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-460">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-460">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-461">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成时异步执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-461">Creates a continuation that executes asynchronously when the target <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-462">延续任务接收调用方提供的状态信息，并使用指定的计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-462">The continuation receives caller-supplied state information and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-463">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-463">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-464">返回<xref:System.Threading.Tasks.Task%601>的将不会计划执行, 直到当前任务已完成, 该任务是否已完成, 因为该任务已成功完成、是否由于未经处理的异常而发生故障, 或由于被取消而发生错误。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-464">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed, whether it completes due to running to completion successfully, faulting due to an  unhandled exception, or exiting out early due to being canceled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-465"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-465">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,TResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task, !!TResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, TResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, 'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-466">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-466">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-467">根据指定 <c>continuationOptions.</c> 运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-467">A function to run according to the specified <c>continuationOptions.</c></span></span> <span data-ttu-id="0ddf6-468">在运行时，委托将作为一个自变量传递给完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-468">When run, the delegate will be passed the completed task as an argument.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-469">将指派给新的延续任务的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-469">The <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-470">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-470">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-471">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-471">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-472">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-472">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-473">创建一个按照指定延续任务选项执行并返回一个值的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-473">Creates a continuation that executes according to the specified continuation options and returns a value.</span></span> <span data-ttu-id="0ddf6-474">延续任务被传入一个取消标记，并使用指定的计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-474">The continuation is passed a cancellation token and uses a specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-475">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-475">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-476">直到当前<xref:System.Threading.Tasks.Task%601>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-476">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has completed.</span></span> <span data-ttu-id="0ddf6-477">如果未满足通过`continuationOptions`参数指定的条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-477">If the criteria specified through the `continuationOptions` parameter are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-478">下面的示例演示如何将 System.threading.tasks.task.continuewith 方法与延续选项一起使用:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-478">The following example shows how to use the ContinueWith method with continuation options:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/continuationoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Task#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/continuationoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-479">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-479">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span>  
  
<span data-ttu-id="0ddf6-480">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-480">-or-</span></span> 
<span data-ttu-id="0ddf6-481">创建了该标记的 <see cref="T:System.Threading.CancellationTokenSource" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-481">The <see cref="T:System.Threading.CancellationTokenSource" /> that created the token has already been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-482"><paramref name="continuationFunction" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-482">The <paramref name="continuationFunction" /> argument is null.</span></span>  
  
<span data-ttu-id="0ddf6-483">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-483">-or-</span></span> 
<span data-ttu-id="0ddf6-484"><paramref name="scheduler" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-484">The <paramref name="scheduler" /> argument is null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-485"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-485">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TResult&gt; ContinueWith&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task,object,TResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TResult&gt; ContinueWith&lt;TResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task, object, !!TResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.ContinueWith``1(System.Func{System.Threading.Tasks.Task,System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; System::Threading::Tasks::Task&lt;TResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task ^, System::Object ^, TResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.ContinueWith : Func&lt;System.Threading.Tasks.Task, obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task,System.Object,TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-486">延续任务生成的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-486">The type of the result produced by the continuation.</span></span></typeparam>
        <param name="continuationFunction"><span data-ttu-id="0ddf6-487">在 <see cref="T:System.Threading.Tasks.Task" /> 完成时要运行的函数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-487">A function to run when the <see cref="T:System.Threading.Tasks.Task" /> completes.</span></span> <span data-ttu-id="0ddf6-488">运行时，委托将作为一个自变量传递给完成的任务和调用方提供的状态对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-488">When run, the delegate will be  passed the completed task and the caller-supplied state object as arguments.</span></span></param>
        <param name="state"><span data-ttu-id="0ddf6-489">一个表示由该延续功能使用的数据的对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-489">An object representing data to be used by the continuation function.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-490">将指派给新的延续任务的 <see cref="T:System.Threading.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-490">The <see cref="T:System.Threading.CancellationToken" /> that will be assigned to the new continuation task.</span></span></param>
        <param name="continuationOptions"><span data-ttu-id="0ddf6-491">用于设置计划延续任务的时间以及延续任务的工作方式的选项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-491">Options for when the continuation is scheduled and how it behaves.</span></span> <span data-ttu-id="0ddf6-492">这包括条件（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />）和执行选项（如 <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-492">This includes criteria, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" />, as well as execution options, such as <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" />.</span></span></param>
        <param name="scheduler"><span data-ttu-id="0ddf6-493">要与延续任务关联并用于其执行过程的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-493">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> to associate with the continuation task and to use for its  execution.</span></span></param>
        <summary><span data-ttu-id="0ddf6-494">创建一个在目标 <see cref="T:System.Threading.Tasks.Task" /> 完成并返回一个值时根据指定的任务延续选项执行的延续任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-494">Creates a continuation that executes based on the specified task continuation options when the target <see cref="T:System.Threading.Tasks.Task" /> completes and returns a value.</span></span> <span data-ttu-id="0ddf6-495">延续任务接收调用方提供的状态信息和取消标记，并使用指定的计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-495">The continuation receives caller-supplied state information and a cancellation token and uses the specified scheduler.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-496">一个新的延续 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-496">A new continuation <see cref="T:System.Threading.Tasks.Task`1" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-497">直到当前<xref:System.Threading.Tasks.Task%601>任务完成后, 才会安排返回的执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-497">The returned <xref:System.Threading.Tasks.Task%601> will not be scheduled for execution until the current task has  completed.</span></span> <span data-ttu-id="0ddf6-498">如果未满足通过`continuationOptions`参数指定的条件, 则将取消延续任务, 而不是计划。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-498">If the criteria specified through the `continuationOptions` parameter  are not met, the continuation task will be canceled instead of scheduled.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-499"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-499">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-500"><paramref name="continuationOptions" /> 参数为 <see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> 指定无效值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-500">The <paramref name="continuationOptions" /> argument specifies an invalid value for <see cref="T:System.Threading.Tasks.TaskContinuationOptions" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-501">提供的 <see cref="T:System.Threading.CancellationToken" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-501">The provided <see cref="T:System.Threading.CancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreationOptions">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskCreationOptions CreationOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskCreationOptions CreationOptions" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CreationOptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CreationOptions As TaskCreationOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskCreationOptions CreationOptions { System::Threading::Tasks::TaskCreationOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.CreationOptions : System.Threading.Tasks.TaskCreationOptions" Usage="System.Threading.Tasks.Task.CreationOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskCreationOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-502">获取用于创建此任务的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-502">Gets the <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></summary>
        <value><span data-ttu-id="0ddf6-503">用于创建此任务的 <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-503">The <see cref="T:System.Threading.Tasks.TaskCreationOptions" /> used to create this task.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentId">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; CurrentId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Nullable`1&lt;int32&gt; CurrentId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.CurrentId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentId As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Nullable&lt;int&gt; CurrentId { Nullable&lt;int&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentId : Nullable&lt;int&gt;" Usage="System.Threading.Tasks.Task.CurrentId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-504">返回当前正在执行 <see cref="T:System.Threading.Tasks.Task" /> 的 ID。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-504">Returns the ID of the currently executing <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <value><span data-ttu-id="0ddf6-505">系统分配给当前正在执行的任务的一个整数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-505">An integer that was assigned by the system to the currently-executing task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-506"><xref:System.Threading.Tasks.Task.CurrentId%2A>是一个`static` (`Shared`在 Visual Basic) 属性, 用于从任务正在执行的代码中获取当前正在执行的任务的标识符。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-506"><xref:System.Threading.Tasks.Task.CurrentId%2A> is a `static` (`Shared` in Visual Basic) property that is used to get the identifier of the currently executing task from the code that the task is executing.</span></span> <span data-ttu-id="0ddf6-507">它不同于<xref:System.Threading.Tasks.Task.Id%2A>属性, 后者返回特定<xref:System.Threading.Tasks.Task>实例的标识符。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-507">It differs from the <xref:System.Threading.Tasks.Task.Id%2A> property, which returns the identifier of a particular <xref:System.Threading.Tasks.Task> instance.</span></span> <span data-ttu-id="0ddf6-508">如果尝试从执行任务的<xref:System.Threading.Tasks.Task.CurrentId%2A>代码之外检索值, 则属性将返回。 `null`</span><span class="sxs-lookup"><span data-stu-id="0ddf6-508">If you attempt to retrieve the <xref:System.Threading.Tasks.Task.CurrentId%2A> value from outside the code that a task is executing, the property returns `null`.</span></span>  
  
 <span data-ttu-id="0ddf6-509">请注意, 尽管冲突非常罕见, 但不保证任务标识符是唯一的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-509">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.Id" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delay">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-510">创建将在时间延迟后完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-510">Creates a task that will complete after a time delay.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (millisecondsDelay As Integer) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay);" />
      <MemberSignature Language="F#" Value="static member Delay : int -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay millisecondsDelay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="0ddf6-511">在完成返回的任务前要等待的毫秒数；如果无限期等待，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-511">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-512">创建一个在指定的毫秒数后完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-512">Creates a task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-513">表示时间延迟的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-513">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-514"><xref:System.Threading.Tasks.Task.Delay%2A>方法通常用于在指定的时间间隔内延迟任务的全部或部分操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-514">The <xref:System.Threading.Tasks.Task.Delay%2A> method is typically used to delay the operation of all or part of a task for a specified time interval.</span></span> <span data-ttu-id="0ddf6-515">最常见的情况是, 会引入时间延迟:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-515">Most commonly, the time delay is introduced:</span></span>  
  
-   <span data-ttu-id="0ddf6-516">在任务开始时, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-516">At the beginning of the task, as the following example shows.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#5)]
     [!code-vb[System.Threading.Tasks.Task.Delay#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#5)]  
  
-   <span data-ttu-id="0ddf6-517">在任务执行期间的某个时间段。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-517">Sometime while the task is executing.</span></span> <span data-ttu-id="0ddf6-518">在这种情况下, 对<xref:System.Threading.Tasks.Task.Delay%2A>方法的调用作为任务内的子任务执行, 如下面的示例所示。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-518">In this case, the call to the <xref:System.Threading.Tasks.Task.Delay%2A> method executes as a child task within a task, as the following example shows.</span></span> <span data-ttu-id="0ddf6-519">请注意, 调用<xref:System.Threading.Tasks.Task.Delay%2A>方法的任务是异步执行的, 父任务必须等待它完成, 方法是`await`使用关键字。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-519">Note that since the task that calls the <xref:System.Threading.Tasks.Task.Delay%2A> method executes asynchronously, the parent task must wait for it to complete by using the `await` keyword.</span></span>  
  
     [!code-csharp[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay5.cs#7)]
     [!code-vb[System.Threading.Tasks.Task.Delay#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay5.vb#7)]  
  
 <span data-ttu-id="0ddf6-520">在指定的时间延迟后, 任务在<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状态下完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-520">After the specified time delay, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="0ddf6-521">此方法取决于系统时钟。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-521">This method depends on the system clock.</span></span> <span data-ttu-id="0ddf6-522">这意味着, 如果`millisecondsDelay`参数小于系统时钟的分辨率 (在 Windows 系统上约为15毫秒), 则时间延迟约等于系统时钟的分辨率。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-522">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-523">下面的示例演示<xref:System.Threading.Tasks.Task.Delay%2A>方法的简单用法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-523">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Delay#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-524"><paramref name="millisecondsDelay" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-524">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Delay (delay As TimeSpan) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay delay" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="0ddf6-525">在完成返回的任务前等待的时间跨度；如果无限期等待，则为 <see langword="TimeSpan.FromMilliseconds(-1)" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-525">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-526">创建一个在指定的时间间隔后完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-526">Creates a task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-527">表示时间延迟的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-527">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-528">在指定的时间延迟后, 任务将以<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状态完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-528">After the specified time delay, the task is completed in <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="0ddf6-529">有关使用方案和其他示例, 请参阅<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>重载的文档。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-529">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="0ddf6-530">此方法取决于系统时钟。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-530">This method depends on the system clock.</span></span> <span data-ttu-id="0ddf6-531">这意味着, 如果`delay`参数小于系统时钟的分辨率 (在 Windows 系统上约为15毫秒), 则时间延迟约等于系统时钟的分辨率。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-531">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-532">下面的示例演示<xref:System.Threading.Tasks.Task.Delay%2A>方法的简单用法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-532">The following example shows a simple use of the <xref:System.Threading.Tasks.Task.Delay%2A> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Delay#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-533"><paramref name="delay" /> 表示除 <see langword="TimeSpan.FromMilliseconds(-1)" /> 以外的负时间间隔。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-533"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMilliseconds(-1)" />.</span></span>  
  
<span data-ttu-id="0ddf6-534">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-534">-or-</span></span> 
<span data-ttu-id="0ddf6-535"><paramref name="delay" /> 参数的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 属性大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-535">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (int millisecondsDelay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(int32 millisecondsDelay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(int millisecondsDelay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : int * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (millisecondsDelay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsDelay" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="millisecondsDelay"><span data-ttu-id="0ddf6-536">在完成返回的任务前要等待的毫秒数；如果无限期等待，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-536">The number of milliseconds to wait before completing the returned task, or -1 to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-537">等待任务完成期间要观察的取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-537">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-538">创建一个在指定的毫秒数后完成的可取消任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-538">Creates a cancellable task that completes after a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-539">表示时间延迟的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-539">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-540">如果在指定的时间延迟之前向取消标记发出信号, <xref:System.Threading.Tasks.TaskCanceledException>则会生成异常结果, 并且任务<xref:System.Threading.Tasks.TaskStatus.Canceled>在状态中完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-540">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="0ddf6-541">否则, 在指定的时间延迟结束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>后, 任务将以状态完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-541">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="0ddf6-542">有关使用方案和其他示例, 请参阅<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>重载的文档。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-542">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="0ddf6-543">此方法取决于系统时钟。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-543">This method depends on the system clock.</span></span> <span data-ttu-id="0ddf6-544">这意味着, 如果`millisecondsDelay`参数小于系统时钟的分辨率 (在 Windows 系统上约为15毫秒), 则时间延迟约等于系统时钟的分辨率。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-544">This means that the time delay will approximately equal the resolution of the system clock if the `millisecondsDelay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-545">下面的示例启动一个任务, 该任务包括对<xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29>方法的调用, 且延迟为一秒。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-545">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%2CSystem.Threading.CancellationToken%29> method with a one second delay.</span></span> <span data-ttu-id="0ddf6-546">在延迟间隔结束之前, 会取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-546">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="0ddf6-547">该示例的输出显示, 引发了<xref:System.Threading.Tasks.TaskCanceledException> , 并将<xref:System.Threading.Tasks.Task.Status%2A> tasks 的属性设置为<xref:System.Threading.Tasks.TaskStatus.Canceled>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-547">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Delay#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-548"><paramref name="millisecondsDelay" /> 参数小于 -1。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-548">The <paramref name="millisecondsDelay" /> argument is less than -1.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="0ddf6-549">该任务已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-549">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-550">提供的 <paramref name="cancellationToken" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-550">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Delay (TimeSpan delay, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Delay(valuetype System.TimeSpan delay, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Delay(TimeSpan delay, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Delay : TimeSpan * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Delay (delay, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delay" Type="System.TimeSpan" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="delay"><span data-ttu-id="0ddf6-551">在完成返回的任务前等待的时间跨度；如果无限期等待，则为 <see langword="TimeSpan.FromMilliseconds(-1)" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-551">The time span to wait before completing the returned task, or <see langword="TimeSpan.FromMilliseconds(-1)" /> to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-552">等待任务完成期间要观察的取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-552">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-553">创建一个在指定的时间间隔后完成的可取消任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-553">Creates a cancellable task that completes after a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-554">表示时间延迟的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-554">A task that represents the time delay.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-555">如果在指定的时间延迟之前向取消标记发出信号, <xref:System.Threading.Tasks.TaskCanceledException>则会生成异常结果, 并且任务<xref:System.Threading.Tasks.TaskStatus.Canceled>在状态中完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-555">If the cancellation token is signaled before the specified time delay, a <xref:System.Threading.Tasks.TaskCanceledException> exception results, and the task is completed in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  <span data-ttu-id="0ddf6-556">否则, 在指定的时间延迟结束<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>后, 任务将以状态完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-556">Otherwise, the task is completed in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state once the specified time delay has elapsed.</span></span>  
  
 <span data-ttu-id="0ddf6-557">有关使用方案和其他示例, 请参阅<xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>重载的文档。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-557">For usage scenarios and additional examples, see the documentation for the <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> overload.</span></span>  
  
 <span data-ttu-id="0ddf6-558">此方法取决于系统时钟。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-558">This method depends on the system clock.</span></span> <span data-ttu-id="0ddf6-559">这意味着, 如果`delay`参数小于系统时钟的分辨率 (在 Windows 系统上约为15毫秒), 则时间延迟约等于系统时钟的分辨率。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-559">This means that the time delay will approximately equal the resolution of the system clock if the `delay` argument is less than the resolution of the system clock, which is approximately 15 milliseconds on Windows systems.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-560">下面的示例启动一个任务, 其中包括对<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法的调用, 但延迟为1.5 秒。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-560">The following example launches a task that includes a call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method with a 1.5 second delay.</span></span> <span data-ttu-id="0ddf6-561">在延迟间隔结束之前, 会取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-561">Before the delay interval elapses, the token is cancelled.</span></span> <span data-ttu-id="0ddf6-562">该示例的输出显示, 引发了<xref:System.Threading.Tasks.TaskCanceledException> , 并将<xref:System.Threading.Tasks.Task.Status%2A> tasks 的属性设置为<xref:System.Threading.Tasks.TaskStatus.Canceled>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-562">The output from the example shows that, as a result, a <xref:System.Threading.Tasks.TaskCanceledException> is thrown, and the tasks' <xref:System.Threading.Tasks.Task.Status%2A> property is set to <xref:System.Threading.Tasks.TaskStatus.Canceled>.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.delay/cs/delay4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Delay#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.delay/vb/delay4.vb#4)]  
  
 <span data-ttu-id="0ddf6-563">请注意, 此示例包含潜在的争用条件: 在取消标记时, 它依赖于异步执行延迟的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-563">Note that this example includes a potential race condition: it depends on the task asynchronously executing the delay when the token is cancelled.</span></span> <span data-ttu-id="0ddf6-564">尽管对<xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>方法的调用中, 1.5 秒的延迟会使该假设成为可能, 但是, 在取消标记之前, <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29>对方法的调用可能会返回。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-564">Although the 1.5 second delay from the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method makes that assumption likely, it is nevertheless possible that the call to the <xref:System.Threading.Tasks.Task.Delay%28System.TimeSpan%2CSystem.Threading.CancellationToken%29> method could return before the token is cancelled.</span></span> <span data-ttu-id="0ddf6-565">在这种情况下, 该示例生成以下输出:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-565">In that case, the example produces the following output:</span></span>  
  
```  
Task t Status: RanToCompletion, Result: 42  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-566"><paramref name="delay" /> 表示除 <see langword="TimeSpan.FromMilliseconds(-1)" /> 以外的负时间间隔。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-566"><paramref name="delay" /> represents a negative time interval other than <see langword="TimeSpan.FromMilliseconds(-1)" />.</span></span>  
  
<span data-ttu-id="0ddf6-567">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-567">-or-</span></span> 
<span data-ttu-id="0ddf6-568"><paramref name="delay" /> 参数的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 属性大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-568">The <paramref name="delay" /> argument's <see cref="P:System.TimeSpan.TotalMilliseconds" /> property is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="0ddf6-569">该任务已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-569">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-570">提供的 <paramref name="cancellationToken" /> 已被释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-570">The provided <paramref name="cancellationToken" /> has already been disposed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-571">释放 <see cref="T:System.Threading.Tasks.Task" /> 类的当前实例所使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-571">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="task.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ddf6-572">释放 <see cref="T:System.Threading.Tasks.Task" /> 类的当前实例所使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-572">Releases all resources used by the current instance of the <see cref="T:System.Threading.Tasks.Task" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-573">类实现接口, <xref:System.IDisposable>因为在内部它使用也实现<xref:System.IDisposable>的资源。 <xref:System.Threading.Tasks.Task></span><span class="sxs-lookup"><span data-stu-id="0ddf6-573">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="0ddf6-574">但是, 如果你的[!INCLUDE[net_v45](~/includes/net-v45-md.md)]应用面向或更高版本, 则无需调用<xref:System.Threading.Tasks.Task.Dispose%2A> , 除非性能或可伸缩性测试表明, 根据你的使用模式, 应用的性能将通过释放任务来改善。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-574">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="0ddf6-575">有关详细信息, 请参阅并行编程和 .NET 博客中的 "[我是否需要处置任务？](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) "。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-575">For more information, see [Do I need to dispose of Tasks?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ddf6-576">任务的最终状态不是一下值之一：<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 或 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-576">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="task.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="0ddf6-577">一个布尔值，该值指示是否由于调用 <see cref="M:System.Threading.Tasks.Task.Dispose" /> 的原因而调用此方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-577">A Boolean value that indicates whether this method is being called due to a call to <see cref="M:System.Threading.Tasks.Task.Dispose" />.</span></span></param>
        <summary><span data-ttu-id="0ddf6-578">释放 <see cref="T:System.Threading.Tasks.Task" />，同时释放其所有非托管资源。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-578">Disposes the <see cref="T:System.Threading.Tasks.Task" />, releasing all of its unmanaged resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-579">类实现接口, <xref:System.IDisposable>因为在内部它使用也实现<xref:System.IDisposable>的资源。 <xref:System.Threading.Tasks.Task></span><span class="sxs-lookup"><span data-stu-id="0ddf6-579">The <xref:System.Threading.Tasks.Task> class implements the <xref:System.IDisposable> interface because internally it uses resources that also implement <xref:System.IDisposable>.</span></span> <span data-ttu-id="0ddf6-580">但是, 如果你的[!INCLUDE[net_v45](~/includes/net-v45-md.md)]应用面向或更高版本, 则无需调用<xref:System.Threading.Tasks.Task.Dispose%2A> , 除非性能或可伸缩性测试表明, 根据你的使用模式, 应用的性能将通过释放任务来改善。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-580">However, particularly if your app targets the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] or later, there is no need to call <xref:System.Threading.Tasks.Task.Dispose%2A> unless performance or scalability testing indicates that, based on your usage patterns, your app's performance would be improved by disposing of tasks.</span></span> <span data-ttu-id="0ddf6-581">有关详细信息, 请参阅并行编程和 .NET 博客中的 "[我是否需要处置任务？](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) "。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-581">For more information, see [Do I need to dispose of Tasks?](https://devblogs.microsoft.com/pfxteam/do-i-need-to-dispose-of-tasks/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ddf6-582">任务的最终状态不是一下值之一：<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />、<see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> 或 <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-582">The task is not in one of the final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />.</span></span></exception>
        <threadsafe><span data-ttu-id="0ddf6-583">与<see cref="T:System.Threading.Tasks.Task" />该类的大多数成员不同, 此方法不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-583">Unlike most of the members of the <see cref="T:System.Threading.Tasks.Task" /> class, this method is not thread-safe.</span></span></threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Exception">
      <MemberSignature Language="C#" Value="public AggregateException Exception { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AggregateException Exception" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Exception" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exception As AggregateException" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AggregateException ^ Exception { AggregateException ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Exception : AggregateException" Usage="System.Threading.Tasks.Task.Exception" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AggregateException</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-584">获取导致 <see cref="T:System.AggregateException" /> 提前结束的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-584">Gets the <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span> <span data-ttu-id="0ddf6-585">如果 <see cref="T:System.Threading.Tasks.Task" /> 成功完成或尚未引发任何异常，这将返回 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-585">If the <see cref="T:System.Threading.Tasks.Task" /> completed successfully or has not yet thrown any exceptions, this will return <see langword="null" />.</span></span></summary>
        <value><span data-ttu-id="0ddf6-586">导致 <see cref="T:System.AggregateException" /> 提前结束的 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-586">The <see cref="T:System.AggregateException" /> that caused the <see cref="T:System.Threading.Tasks.Task" /> to end prematurely.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-587">引发未经处理的异常的任务存储生成的异常, 并将其<xref:System.AggregateException>传播到<xref:System.Threading.Tasks.Task.Wait%2A>中的调用<xref:System.Threading.Tasks.Task.Exception%2A>或访问属性的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-587">Tasks that throw unhandled exceptions store the resulting exception and propagate it wrapped in a <xref:System.AggregateException> in calls to <xref:System.Threading.Tasks.Task.Wait%2A> or in accesses to the <xref:System.Threading.Tasks.Task.Exception%2A> property.</span></span> <span data-ttu-id="0ddf6-588">在对任务实例进行垃圾回收时未观察到的任何异常都将在终结器线程上传播。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-588">Any exceptions not observed by the time the task instance is garbage collected will be propagated on the finalizer thread.</span></span> <span data-ttu-id="0ddf6-589">有关详细信息和示例, 请参阅[异常处理 (任务并行库)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-589">For more information and an example, see [Exception Handling (Task Parallel Library)](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory ^ Factory { System::Threading::Tasks::TaskFactory ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory" Usage="System.Threading.Tasks.Task.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-590">提供对用于创建和配置 <see cref="T:System.Threading.Tasks.Task" /> 和 <see cref="T:System.Threading.Tasks.Task`1" /> 实例的工厂方法的访问。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-590">Provides access to factory methods for creating and configuring <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> instances.</span></span></summary>
        <value><span data-ttu-id="0ddf6-591">一个工厂对象，可创建多种 <see cref="T:System.Threading.Tasks.Task" /> 和 <see cref="T:System.Threading.Tasks.Task`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-591">A factory object that can create a variety of <see cref="T:System.Threading.Tasks.Task" /> and <see cref="T:System.Threading.Tasks.Task`1" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-592">此属性返回<xref:System.Threading.Tasks.TaskFactory>类的默认实例, 该实例与通过调用无参数<xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType>构造函数创建的实例相同。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-592">This property returns a default instance of the <xref:System.Threading.Tasks.TaskFactory> class that is identical to the one created by calling the parameterless <xref:System.Threading.Tasks.TaskFactory.%23ctor?displayProperty=nameWithType> constructor.</span></span> <span data-ttu-id="0ddf6-593">它具有以下属性值:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-593">It has the following property values:</span></span>  
  
|<span data-ttu-id="0ddf6-594">Property</span><span class="sxs-lookup"><span data-stu-id="0ddf6-594">Property</span></span>|<span data-ttu-id="0ddf6-595">值</span><span class="sxs-lookup"><span data-stu-id="0ddf6-595">Value</span></span>|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory.Scheduler%2A?displayProperty=nameWithType>|<span data-ttu-id="0ddf6-596">`null`, 或<xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ddf6-596">`null`, or <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType></span></span>|  
  
 <span data-ttu-id="0ddf6-597">此属性的最常见用途是在一次调用<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法时创建并启动一个新任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-597">The most common use of this property is to create and start a new task in a single call to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ddf6-598">从开始[!INCLUDE[net_v45](~/includes/net-v45-md.md)] <xref:System.Threading.Tasks.Task> , 方法提供了使用默认配置值创建对象的最简单方法。 <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="0ddf6-598">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> method provides the easiest way to create a <xref:System.Threading.Tasks.Task> object with default configuration values.</span></span>  
  
 <span data-ttu-id="0ddf6-599">下面的示例使用静态<xref:System.Threading.Tasks.Task.Factory%2A>属性对<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法进行两次调用。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-599">The following example uses the static <xref:System.Threading.Tasks.Task.Factory%2A> property to make two calls to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-600">第一种方式是使用用户的 MyDocuments 目录中的文件名称填充数组, 而第二次使用用户的 MyDocuments 目录的子目录名称填充数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-600">The first populates an array with the names of files in the user's MyDocuments directory, while the second populates an array with the names of subdirectories of the user's MyDocuments directory.</span></span> <span data-ttu-id="0ddf6-601">然后, 它调用<xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType>方法, 该方法在前两个任务完成执行后显示两个数组中的文件和目录的数量信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-601">It then calls the <xref:System.Threading.Tasks.TaskFactory.ContinueWhenAll%28System.Threading.Tasks.Task%5B%5D%2CSystem.Action%7BSystem.Threading.Tasks.Task%5B%5D%7D%29?displayProperty=nameWithType> method, which displays information about the number of files and directories in the two arrays after the first two tasks have completed execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.factory/cs/factory1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Factory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.factory/vb/factory1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.Tasks.TaskFactory" />
      </Docs>
    </Member>
    <Member MemberName="FromCanceled">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromCanceled (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromCanceled(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-602">完成任务的取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-602">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-603">创建 <see cref="T:System.Threading.Tasks.Task" />，它因指定的取消标记进行的取消操作而完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-603">Creates a <see cref="T:System.Threading.Tasks.Task" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-604">取消的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-604">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-605">尚未对 <paramref name="cancellationToken" /> 请求取消；其 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 属性为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-605">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromCanceled&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromCanceled&lt;TResult&gt; (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromCanceled&lt;TResult&gt;(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromCanceled``1(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromCanceled(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member FromCanceled : System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromCanceled cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-606">任务返回的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-606">The type of the result returned by the task.</span></span></typeparam>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-607">完成任务的取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-607">The cancellation token with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-608">创建 <see cref="T:System.Threading.Tasks.Task`1" />，它因指定的取消标记进行的取消操作而完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-608">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed due to cancellation with a specified cancellation token.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-609">取消的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-609">The canceled task.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-610">尚未对 <paramref name="cancellationToken" /> 请求取消；其 <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> 属性为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-610">Cancellation has not been requested for <paramref name="cancellationToken" />; its <see cref="P:System.Threading.CancellationToken.IsCancellationRequested" /> property is <see langword="false" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="FromException">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task FromException (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task FromException(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="0ddf6-611">完成任务的异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-611">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-612">创建 <see cref="T:System.Threading.Tasks.Task" />，它在完成后出现指定的异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-612">Creates a <see cref="T:System.Threading.Tasks.Task" /> that has completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-613">出错的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-613">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-614">此方法创建一个<xref:System.Threading.Tasks.Task>对象, <xref:System.Threading.Tasks.Task.Status%2A>该对象<xref:System.Threading.Tasks.TaskStatus.Faulted>的属性<xref:System.Threading.Tasks.Task.Exception%2A>为, `exception`其属性包含。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-614">This method creates a <xref:System.Threading.Tasks.Task> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="0ddf6-615">当你立即知道任务执行的工作在执行更长的代码路径之前将引发异常时, 通常使用方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-615">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="0ddf6-616">有关示例, 请参见<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>重载。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-616">For an example, see the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> overload.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromException&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromException&lt;TResult&gt; (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromException&lt;TResult&gt;(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromException``1(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromException(Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FromException : Exception -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromException exception" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-617">任务返回的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-617">The type of the result returned by the task.</span></span></typeparam>
        <param name="exception"><span data-ttu-id="0ddf6-618">完成任务的异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-618">The exception with which to complete the task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-619">创建 <see cref="T:System.Threading.Tasks.Task`1" />，它在完成后出现指定的异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-619">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed with a specified exception.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-620">出错的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-620">The faulted task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-621">此方法创建一个<xref:System.Threading.Tasks.Task%601>对象, <xref:System.Threading.Tasks.Task.Status%2A>该对象<xref:System.Threading.Tasks.TaskStatus.Faulted>的属性<xref:System.Threading.Tasks.Task.Exception%2A>为, `exception`其属性包含。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-621">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.Faulted> and whose <xref:System.Threading.Tasks.Task.Exception%2A> property contains `exception`.</span></span> <span data-ttu-id="0ddf6-622">当你立即知道任务执行的工作在执行更长的代码路径之前将引发异常时, 通常使用方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-622">The method is commonly used when you immediately know that the work that a task performs will throw an exception before executing a longer code path.</span></span> <span data-ttu-id="0ddf6-623">说明如示例所示。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-623">The example provides an illustration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-624">下面的示例是一个命令行实用工具, 该实用工具计算每个目录中的文件中其名称作为命令行参数传递的字节数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-624">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="0ddf6-625">该示例只调用<xref:System.IO.FileInfo> <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> 方法来创建出错的任务(如果有),而不是执行实例化对象并为目录中的每个文件检索其属性值<xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29>的代码路径。子目录不存在。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-625">Rather than executing a longer code path that instantiates a <xref:System.IO.FileInfo> object and retrieves the value of its <xref:System.IO.FileInfo.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromException%60%601%28System.Exception%29> method to create a faulted task if a particular subdirectory does not exist.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromResult&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; FromResult&lt;TResult&gt; (TResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; FromResult&lt;TResult&gt;(!!TResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.FromResult``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromResult(Of TResult) (result As TResult) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ FromResult(TResult result);" />
      <MemberSignature Language="F#" Value="static member FromResult : 'Result -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.FromResult result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="result" Type="TResult" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-626">任务返回的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-626">The type of the result returned by the task.</span></span></typeparam>
        <param name="result"><span data-ttu-id="0ddf6-627">存储入已完成任务的结果。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-627">The result to store into the completed task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-628">创建指定结果的、成功完成的 <see cref="T:System.Threading.Tasks.Task`1" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-628">Creates a <see cref="T:System.Threading.Tasks.Task`1" /> that's completed successfully with the specified result.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-629">已成功完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-629">The successfully completed task.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-630">此方法创建一个<xref:System.Threading.Tasks.Task%601>对象, <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>该对象`result`的属性<xref:System.Threading.Tasks.Task.Status%2A>为, <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>其属性为。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-630">This method creates a <xref:System.Threading.Tasks.Task%601> object whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is `result` and whose <xref:System.Threading.Tasks.Task.Status%2A> property is <xref:System.Threading.Tasks.TaskStatus.RanToCompletion>.</span></span> <span data-ttu-id="0ddf6-631">当立即知道任务的返回值而不执行更长的代码路径时, 通常使用方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-631">The method is commonly used when the return value of a task is immediately known without executing a longer code path.</span></span> <span data-ttu-id="0ddf6-632">说明如示例所示。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-632">The example provides an illustration.</span></span>  
  
 <span data-ttu-id="0ddf6-633">若要创建不返回值的任务对象, 请从<xref:System.Threading.Tasks.Task.CompletedTask%2A>属性中检索任务对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-633">To create a Task object that does not return a value, retrieve the Task object from the <xref:System.Threading.Tasks.Task.CompletedTask%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-634">下面的示例是一个命令行实用工具, 该实用工具计算每个目录中的文件中其名称作为命令行参数传递的字节数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-634">The following example is a command-line utility that calculates the number of bytes in the files in each directory whose name is passed as a command-line argument.</span></span> <span data-ttu-id="0ddf6-635">该示例<xref:System.IO.FileStream>只调用<xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>方法来创建一个任务, 该代码路径实例化对象并检索该目录中每个文件的属性值, 而不是执行更长的代码路径。 <xref:System.Threading.Tasks.Task.FromResult%2A>如果目录中没有任何文件, 则属性为零 (0)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-635">Rather than executing a longer code path that instantiates a <xref:System.IO.FileStream> object and retrieves the value of its <xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType> property for each file in the directory, the example simply calls the <xref:System.Threading.Tasks.Task.FromResult%2A> method to create a task whose <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property is zero (0) if a directory has no files.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CompletedTask" />
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter GetAwaiter();" />
      <MemberSignature Language="F#" Value="member this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ddf6-636">获取用于等待此 <see cref="T:System.Threading.Tasks.Task" /> 的等待者。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-636">Gets an awaiter used to await this <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-637">一个 awaiter 实例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-637">An awaiter instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-638">此方法适用于编译器, 而不是在应用程序代码中使用。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-638">This method is intended for compiler use rather than for use in application code.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.Task.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-639">获取此 <see cref="T:System.Threading.Tasks.Task" /> 实例的 ID。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-639">Gets an ID for this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></summary>
        <value><span data-ttu-id="0ddf6-640">系统分配到此 <see cref="T:System.Threading.Tasks.Task" /> 实例的标识符。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-640">The identifier that is assigned by the system to this <see cref="T:System.Threading.Tasks.Task" /> instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-641">任务 Id 按需分配, 不一定表示任务实例的创建顺序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-641">Task IDs are assigned on-demand and do not necessarily represent the order in which task instances are created.</span></span> <span data-ttu-id="0ddf6-642">请注意, 尽管冲突非常罕见, 但不保证任务标识符是唯一的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-642">Note that although collisions are very rare, task identifiers are not guaranteed to be unique.</span></span>  
  
 <span data-ttu-id="0ddf6-643">若要从任务正在执行的代码内获取当前正在执行的任务的任务 ID, 请<xref:System.Threading.Tasks.Task.CurrentId%2A>使用属性。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-643">To get the task ID of the currently executing task from within code that task is executing, use the <xref:System.Threading.Tasks.Task.CurrentId%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Threading.Tasks.Task.CurrentId" />
      </Docs>
    </Member>
    <Member MemberName="IsCanceled">
      <MemberSignature Language="C#" Value="public bool IsCanceled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCanceled" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCanceled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCanceled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCanceled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCanceled : bool" Usage="System.Threading.Tasks.Task.IsCanceled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-644">获取此 <see cref="T:System.Threading.Tasks.Task" /> 实例是否由于被取消的原因而已完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-644">Gets whether this <see cref="T:System.Threading.Tasks.Task" /> instance has completed execution due to being canceled.</span></span></summary>
        <value><span data-ttu-id="0ddf6-645">如果任务由于被取消而完成，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-645"><see langword="true" /> if the task has completed due to being canceled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-646">在以下任何条件下<xref:System.Threading.Tasks.TaskStatus.Canceled> ,都将在状态中完成:<xref:System.Threading.Tasks.Task></span><span class="sxs-lookup"><span data-stu-id="0ddf6-646">A <xref:System.Threading.Tasks.Task> will complete in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="0ddf6-647">在<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A>任务开始执行之前, 已将其标记为取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-647">Its <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> was marked for cancellation before the task started executing,</span></span>  
  
-   <span data-ttu-id="0ddf6-648">该任务通过引发具有<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> <xref:System.OperationCanceledException>相同<xref:System.Threading.CancellationToken>的的发出的, 确认了取消请求。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-648">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by throwing an <xref:System.OperationCanceledException> that bears the same <xref:System.Threading.CancellationToken>.</span></span>  
  
-   <span data-ttu-id="0ddf6-649">该任务通过<xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A>调用上<xref:System.Threading.CancellationToken>的方法, 确认了对它已发出信号的取消请求。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-649">The task acknowledged the cancellation request on its already signaled <xref:System.Threading.Tasks.TaskFactory.CancellationToken%2A> by calling the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A> method on the <xref:System.Threading.CancellationToken>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0ddf6-650">检索<xref:System.Threading.Tasks.Task.IsCanceled%2A>属性的值不会阻止调用线程, 直到任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-650">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCanceled%2A> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompleted">
      <MemberSignature Language="C#" Value="public bool IsCompleted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompleted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompleted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompleted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompleted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompleted : bool" Usage="System.Threading.Tasks.Task.IsCompleted" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.IsCompleted</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-651">获取一个值，它表示是否已完成任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-651">Gets a value that indicates whether the task has completed.</span></span></summary>
        <value><span data-ttu-id="0ddf6-652"><see langword="true" />如果任务已完成 (即, 任务处于以下三个最终状态之一<see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />:、 <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />或<see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />), <see langword="false" />则为; 否则为。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-652"><see langword="true" /> if the task has completed (that is, the task is in one of the three final states: <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion" />, <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />, or <see cref="F:System.Threading.Tasks.TaskStatus.Canceled" />); otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="0ddf6-653">检索<xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType>属性的值不会阻止调用线程, 直到任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-653">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsCompleted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCompletedSuccessfully">
      <MemberSignature Language="C#" Value="public bool IsCompletedSuccessfully { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCompletedSuccessfully" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCompletedSuccessfully As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCompletedSuccessfully { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCompletedSuccessfully : bool" Usage="System.Threading.Tasks.Task.IsCompletedSuccessfully" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFaulted">
      <MemberSignature Language="C#" Value="public bool IsFaulted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFaulted" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.IsFaulted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFaulted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFaulted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFaulted : bool" Usage="System.Threading.Tasks.Task.IsFaulted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-654">获取 <see cref="T:System.Threading.Tasks.Task" /> 是否由于未经处理异常的原因而完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-654">Gets whether the <see cref="T:System.Threading.Tasks.Task" /> completed due to an unhandled exception.</span></span></summary>
        <value><span data-ttu-id="0ddf6-655">如果任务引发了未经处理的异常，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-655"><see langword="true" /> if the task has thrown an unhandled exception; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-656">如果<xref:System.Threading.Tasks.Task.IsFaulted%2A> <xref:System.Threading.Tasks.Task.Status%2A>为`true`, 则该<xref:System.Threading.Tasks.Task.Exception%2A>任务的等于,其属性将为非null。<xref:System.Threading.Tasks.TaskStatus.Faulted></span><span class="sxs-lookup"><span data-stu-id="0ddf6-656">If <xref:System.Threading.Tasks.Task.IsFaulted%2A> is `true`, the task's <xref:System.Threading.Tasks.Task.Status%2A> is equal to <xref:System.Threading.Tasks.TaskStatus.Faulted>, and its <xref:System.Threading.Tasks.Task.Exception%2A> property will be non-null.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="0ddf6-657">检索<xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType>属性的值不会阻止调用线程, 直到任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-657">Retrieving the value of the <xref:System.Threading.Tasks.Task.IsFaulted%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-658">将在线程池上运行的指定工作排队，并返回该工作的任务或 <see cref="T:System.Threading.Tasks.Task`1" /> 句柄。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-658">Queues the specified work to run on the ThreadPool and returns a task or <see cref="T:System.Threading.Tasks.Task`1" /> handle for that work.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-659"><xref:System.Threading.Tasks.Task.Run%2A>方法提供了一组重载, 使您可以轻松地使用默认值启动任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-659">The <xref:System.Threading.Tasks.Task.Run%2A> method provides a set of overloads that make it easy to start a task by using default values.</span></span> <span data-ttu-id="0ddf6-660">它是<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>重载的轻型替代项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-660">It is a lightweight alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> overloads.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action);" />
      <MemberSignature Language="F#" Value="static member Run : Action -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run action" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-661">以异步方式执行的工作量。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-661">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="0ddf6-662">将在线程池上运行的指定工作排队，并返回代表该工作的 <see cref="T:System.Threading.Tasks.Task" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-662">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-663">表示在线程池执行的队列的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-663">A task that represents the work queued to execute in the ThreadPool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-664">方法允许您在单个方法调用中创建和执行任务, 这是<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>方法的更简单的替代方法。 <xref:System.Threading.Tasks.Task.Run%2A></span><span class="sxs-lookup"><span data-stu-id="0ddf6-664">The <xref:System.Threading.Tasks.Task.Run%2A> method allows you to create and execute a task in a single method call and is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="0ddf6-665">它使用以下默认值创建任务:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-665">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="0ddf6-666">其取消标记为<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-666">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="0ddf6-667">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>属性值为<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-667">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="0ddf6-668">它使用默认的任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-668">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="0ddf6-669">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-669">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-670">下面的示例定义了`ShowThreadInfo`一个方法, 该<xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType>方法显示当前线程的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-670">The following example defines a `ShowThreadInfo` method  that displays the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> of the current thread.</span></span> <span data-ttu-id="0ddf6-671">它直接从应用程序线程调用, 并从传递<xref:System.Action> <xref:System.Threading.Tasks.Task.Run%28System.Action%29>给方法的委托调用。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-671">It is called directly from the application thread, and is called from the <xref:System.Action> delegate passed to the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run11.cs#11)]
 [!code-vb[System.Threading.Tasks.Task.Run#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run11.vb#11)]  
  
 <span data-ttu-id="0ddf6-672">下面的示例与上一个示例类似, 不同之处在于它使用 lambda 表达式来定义任务要执行的代码。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-672">The following example is similar to the previous one, except that it uses a lambda expression to define the code that the task is to execute.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run6.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Run#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run6.vb#3)]  
  
 <span data-ttu-id="0ddf6-673">示例显示异步任务在与主应用程序线程不同的线程上执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-673">The examples show that the asynchronous task executes on a different thread than the main application thread.</span></span>  
  
 <span data-ttu-id="0ddf6-674">对<xref:System.Threading.Tasks.Task.Wait%2A>方法的调用确保任务完成并在应用程序结束之前显示其输出。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-674">The call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that the task completes and displays its output before the application ends.</span></span> <span data-ttu-id="0ddf6-675">否则, 该`Main`方法可能会在任务完成前完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-675">Otherwise, it is possible that the `Main` method will complete before the task finishes.</span></span>  
  
 <span data-ttu-id="0ddf6-676">下面的示例演示<xref:System.Threading.Tasks.Task.Run%28System.Action%29>方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-676">The following example illustrates the <xref:System.Threading.Tasks.Task.Run%28System.Action%29> method.</span></span> <span data-ttu-id="0ddf6-677">它定义目录名称的数组, 并启动单独的任务以检索每个目录中的文件名。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-677">It defines an array of directory names and starts a separate task to retrieve the file names in each directory.</span></span> <span data-ttu-id="0ddf6-678">所有任务将文件名写入单个<xref:System.Collections.Concurrent.ConcurrentBag%601>对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-678">All tasks write the file names to a single <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span> <span data-ttu-id="0ddf6-679">然后, 该示例调用<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>方法以确保所有任务都已完成, 然后显示写入<xref:System.Collections.Concurrent.ConcurrentBag%601>对象的文件名称总数的计数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-679">The example then calls the <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method to ensure that all tasks have completed, and then displays a count of the total number of file names written to the <xref:System.Collections.Concurrent.ConcurrentBag%601> object.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run2.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Run#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-680"><paramref name="action" /> 参数是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-680">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-681">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-681">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run (function As Func(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="0ddf6-682">以异步方式执行的工作量。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-682">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="0ddf6-683">将在线程池上运行的指定工作排队，并返回 <paramref name="function" /> 所返回的任务的代理项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-683">Queues the specified work to run on the thread pool and returns a proxy for the  task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-684">表示由 <paramref name="function" /> 返回的任务的代理的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-684">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-685">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-685">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-686"><paramref name="function" /> 参数是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-686">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-687">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-687">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Action action, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Action action, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Action,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Action ^ action, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Action * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (action, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action"><span data-ttu-id="0ddf6-688">以异步方式执行的工作量。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-688">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-689">可用于取消工作的取消标记</span><span class="sxs-lookup"><span data-stu-id="0ddf6-689">A cancellation token that can be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="0ddf6-690">将在线程池上运行的指定工作排队，并返回代表该工作的 <see cref="T:System.Threading.Tasks.Task" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-690">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task" /> object that represents that work.</span></span> <span data-ttu-id="0ddf6-691">可使用取消标记来取消工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-691">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-692">一个任务，它表示在线程池中排队执行的工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-692">A task that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-693">如果在任务开始执行之前请求取消, 则不执行该任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-693">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="0ddf6-694">而是设置为<xref:System.Threading.Tasks.TaskStatus.Canceled>状态, 并<xref:System.Threading.Tasks.TaskCanceledException>引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-694">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="0ddf6-695">方法是<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>方法的更简单的替代方法。 <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29></span><span class="sxs-lookup"><span data-stu-id="0ddf6-695">The <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-696">它使用以下默认值创建任务:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-696">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="0ddf6-697">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>属性值为<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-697">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="0ddf6-698">它使用默认的任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-698">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="0ddf6-699">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-699">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-700">下面的示例调用<xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29>方法, 以创建一个循环访问 C:\Windows\System32 目录中的文件的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-700">The following example calls the <xref:System.Threading.Tasks.Task.Run%28System.Action%2CSystem.Threading.CancellationToken%29> method to create a task that iterates the files in the C:\Windows\System32 directory.</span></span> <span data-ttu-id="0ddf6-701">Lambda 表达式调用<xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>方法, 将有关每个文件的<xref:System.Collections.Generic.List%601>信息添加到对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-701">The lambda expression calls the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to add information about each  file to a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="0ddf6-702"><xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>循环调用的每个分离的嵌套任务会检查取消标记的状态, 如果请求取消, 则<xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType>调用方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-702">Each detached nested task invoked by the <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> loop checks the state of the cancellation token and, if cancellation is requested, calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-703">当调用线程调用<xref:System.OperationCanceledException> `catch` <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> 方法<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>时, 方法将引发在块中处理的异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-703">The <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method throws an <xref:System.OperationCanceledException> exception that is handled in a `catch` block when the calling thread calls the <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Run#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-704"><paramref name="action" /> 参数是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-704">The <paramref name="action" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="0ddf6-705">该任务已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-705">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-706">与 <paramref name="cancellationToken" /> 关联的 <see cref="T:System.Threading.CancellationTokenSource" /> 已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-706">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-707">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-707">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task Run (Func&lt;System.Threading.Tasks.Task&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task Run(class System.Func`1&lt;class System.Threading.Tasks.Task&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ Run(Func&lt;System::Threading::Tasks::Task ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="function"><span data-ttu-id="0ddf6-708">以异步方式执行的工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-708">The work to execute asynchronously.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-709">应用于取消工作的取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-709">A cancellation token that should be used to cancel the work.</span></span></param>
        <summary><span data-ttu-id="0ddf6-710">将在线程池上运行的指定工作排队，并返回 <paramref name="function" /> 所返回的任务的代理项。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-710">Queues the specified work to run on the thread pool and returns a proxy for the task returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-711">表示由 <paramref name="function" /> 返回的任务的代理的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-711">A task that represents a proxy for the task returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-712">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-712">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-713"><paramref name="function" /> 参数是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-713">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="0ddf6-714">该任务已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-714">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-715">与 <paramref name="cancellationToken" /> 关联的 <see cref="T:System.Threading.CancellationTokenSource" /> 已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-715">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="0ddf6-716">任务取消</span><span class="sxs-lookup"><span data-stu-id="0ddf6-716">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-717">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-717">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of Task(Of TResult))) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-718">代理任务返回的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-718">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="0ddf6-719">以异步方式执行的工作量。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-719">The work to execute asynchronously</span></span></param>
        <summary><span data-ttu-id="0ddf6-720">将指定的工作排成队列在线程池上运行，并返回由 <paramref name="function" /> 返回的 <see langword="Task(TResult)" /> 的代理。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-720">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-721">表示由 <see langword="Task(TResult)" /> 返回的 <see langword="Task(TResult)" /> 的代理的 <paramref name="function" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-721">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-722">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-722">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-723"><paramref name="function" /> 参数是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-723">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-724">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-724">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Run(Of TResult) (function As Func(Of TResult)) As Task(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run function" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-725">任务的返回类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-725">The return type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="0ddf6-726">以异步方式执行的工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-726">The work to execute asynchronously.</span></span></param>
        <summary><span data-ttu-id="0ddf6-727">将在线程池上运行的指定工作排队，并返回代表该工作的 <see cref="T:System.Threading.Tasks.Task`1" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-727">Queues the specified work to run on the thread pool and returns a <see cref="T:System.Threading.Tasks.Task`1" /> object that represents that work.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-728">表示在线程池中排队执行的工作的任务对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-728">A task object that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-729">方法是<xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType>方法的更简单的替代方法。 <xref:System.Threading.Tasks.Task.Run%2A></span><span class="sxs-lookup"><span data-stu-id="0ddf6-729">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%28System.Action%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="0ddf6-730">它使用以下默认值创建任务:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-730">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="0ddf6-731">其取消标记为<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-731">Its cancellation token is <xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="0ddf6-732">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>属性值为<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-732">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="0ddf6-733">它使用默认的任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-733">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="0ddf6-734">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-734">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-735">下面的示例对表示已发布书籍的文本文件中的单词的近似数目进行计数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-735">The following example counts the approximate number of words in text files that represent published books.</span></span> <span data-ttu-id="0ddf6-736">每个任务都负责打开文件, 异步读取其全部内容, 并使用正则表达式计算单词计数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-736">Each task is responsible for opening a file, reading its entire contents asynchronously, and calculating the word count by using a regular expression.</span></span> <span data-ttu-id="0ddf6-737">调用<xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29>方法以确保所有任务都已完成, 然后在控制台中显示每本书的字数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-737">The <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29> method is called to ensure that all tasks have completed before  displaying the word count of each book to the console.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.Run#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/run3.vb#2)]  
  
 <span data-ttu-id="0ddf6-738">正则表达式`\p{P}*\s+`匹配后跟一个或多个空白字符的零个、一个或多个标点符号字符。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-738">The regular expression `\p{P}*\s+` matches zero, one, or more punctuation characters followed by one or more white-space characters.</span></span> <span data-ttu-id="0ddf6-739">它假定匹配项总数等于大致单词计数。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-739">It assumes that the total number of matches equals the approximate word count.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-740"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-740">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-741">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-741">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-742">代理任务返回的结果的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-742">The type of the result returned by the proxy task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="0ddf6-743">以异步方式执行的工作量。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-743">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-744">应用以取消工作的取消标记</span><span class="sxs-lookup"><span data-stu-id="0ddf6-744">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="0ddf6-745">将指定的工作排成队列在线程池上运行，并返回由 <paramref name="function" /> 返回的 <see langword="Task(TResult)" /> 的代理。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-745">Queues the specified work to run on the thread pool and returns a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-746">表示由 <see langword="Task(TResult)" /> 返回的 <see langword="Task(TResult)" /> 的代理的 <paramref name="function" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-746">A <see langword="Task(TResult)" /> that represents a proxy for the <see langword="Task(TResult)" /> returned by <paramref name="function" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-747">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-747">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-748"><paramref name="function" /> 参数是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-748">The <paramref name="function" /> parameter was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="0ddf6-749">该任务已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-749">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-750">与 <paramref name="cancellationToken" /> 关联的 <see cref="T:System.Threading.CancellationTokenSource" /> 已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-750">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="0ddf6-751">任务取消</span><span class="sxs-lookup"><span data-stu-id="0ddf6-751">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-752">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-752">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Run&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult&gt; Run&lt;TResult&gt; (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult&gt; Run&lt;TResult&gt;(class System.Func`1&lt;!!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Run``1(System.Func{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;TResult&gt; ^ Run(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member Run : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="System.Threading.Tasks.Task.Run (function, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-753">任务的结果类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-753">The result type of the task.</span></span></typeparam>
        <param name="function"><span data-ttu-id="0ddf6-754">以异步方式执行的工作量。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-754">The work to execute asynchronously</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-755">应用以取消工作的取消标记</span><span class="sxs-lookup"><span data-stu-id="0ddf6-755">A cancellation token that should be used to cancel the work</span></span></param>
        <summary><span data-ttu-id="0ddf6-756">将在线程池上运行的指定工作排队，并返回代表该工作的 <see langword="Task(TResult)" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-756">Queues the specified work to run on the thread pool and returns a <see langword="Task(TResult)" /> object that represents that work.</span></span> <span data-ttu-id="0ddf6-757">可使用取消标记来取消工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-757">A cancellation token allows the work to be cancelled.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-758">一个 <see langword="Task(TResult)" />，它表示在线程池中排队等待执行的工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-758">A <see langword="Task(TResult)" /> that represents the work queued to execute in the thread pool.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-759">如果在任务开始执行之前请求取消, 则不执行该任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-759">If cancellation is requested before the task begins execution, the task does not execute.</span></span> <span data-ttu-id="0ddf6-760">而是设置为<xref:System.Threading.Tasks.TaskStatus.Canceled>状态, 并<xref:System.Threading.Tasks.TaskCanceledException>引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-760">Instead it is set to the <xref:System.Threading.Tasks.TaskStatus.Canceled> state and throws a <xref:System.Threading.Tasks.TaskCanceledException> exception.</span></span>  
  
 <span data-ttu-id="0ddf6-761">方法是<xref:System.Threading.Tasks.TaskFactory.StartNew%2A>方法的更简单的替代方法。 <xref:System.Threading.Tasks.Task.Run%2A></span><span class="sxs-lookup"><span data-stu-id="0ddf6-761">The <xref:System.Threading.Tasks.Task.Run%2A> method is a simpler alternative to the <xref:System.Threading.Tasks.TaskFactory.StartNew%2A> method.</span></span> <span data-ttu-id="0ddf6-762">它使用以下默认值创建任务:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-762">It creates a task with the following default values:</span></span>  
  
-   <span data-ttu-id="0ddf6-763">其<xref:System.Threading.Tasks.Task.CreationOptions%2A>属性值为<xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-763">Its <xref:System.Threading.Tasks.Task.CreationOptions%2A> property value is <xref:System.Threading.Tasks.TaskCreationOptions.DenyChildAttach?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="0ddf6-764">它使用默认的任务计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-764">It uses the default task scheduler.</span></span>  
  
 <span data-ttu-id="0ddf6-765">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-765">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-766">下面的示例创建了20个任务, 这些任务将循环, 直到计数器的值递增为2000000。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-766">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="0ddf6-767">当前10个任务达到2000000时, 取消标记将被取消, 并且任何其计数器未达到2000000的任务都将被取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-767">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="0ddf6-768">该示例显示可能的输出。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-768">The example shows possible output.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 <span data-ttu-id="0ddf6-769">该示例将循环<xref:System.AggregateException.InnerExceptions%2A>访问所有任务来确定哪些任务已成功完成且已取消, 而不是使用属性检查异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-769">Instead of using the <xref:System.AggregateException.InnerExceptions%2A> property to   examine exceptions, the example iterates all tasks to determine which have completed successfully and which have been cancelled.</span></span> <span data-ttu-id="0ddf6-770">对于已完成的, 它会显示任务返回的值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-770">For those that have completed, it displays the value returned by the task.</span></span>  
  
 <span data-ttu-id="0ddf6-771">由于取消是协作性的, 因此每个任务都可以决定如何响应取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-771">Because cancellation is cooperative, each task can decide how to respond to cancellation.</span></span> <span data-ttu-id="0ddf6-772">下面的示例与第一个示例类似, 不同之处在于, 在取消标记后, 任务返回已完成的迭代数, 而不是引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-772">The following example is like the first, except that, once the token is cancelled, tasks return the number of iterations they've completed rather than throw an exception.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run28.cs#28)]
 [!code-vb[System.Threading.Tasks.Task.Run#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run28.vb#28)]  
  
 <span data-ttu-id="0ddf6-773">该示例仍必须处理<xref:System.AggregateException>异常, 因为请求取消时未启动的任何任务仍会引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-773">The example still must handle the <xref:System.AggregateException> exception,   since any tasks that have not started when cancellation is requested still throw an exception.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-774"><paramref name="function" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-774">The <paramref name="function" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskCanceledException"><span data-ttu-id="0ddf6-775">该任务已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-775">The task has been canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-776">与 <paramref name="cancellationToken" /> 关联的 <see cref="T:System.Threading.CancellationTokenSource" /> 已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-776">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with <paramref name="cancellationToken" /> was disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-cancellation.md"><span data-ttu-id="0ddf6-777">任务取消</span><span class="sxs-lookup"><span data-stu-id="0ddf6-777">Task Cancellation</span></span></related>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-778">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-778">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="RunSynchronously">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-779">对当前的 <see cref="T:System.Threading.Tasks.Task" /> 同步运行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-779">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously();" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : unit -&gt; unit" Usage="task.RunSynchronously " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ddf6-780">对当前的 <see cref="T:System.Threading.Tasks.Task" /> 同步运行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-780">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-781">通常, 任务在线程池线程上以异步方式执行, 并且不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-781">Ordinarily, tasks are executed asynchronously on a thread pool thread and do not block the calling thread.</span></span> <span data-ttu-id="0ddf6-782">通过调用<xref:System.Threading.Tasks.Task.RunSynchronously>方法执行的任务与当前<xref:System.Threading.Tasks.TaskScheduler>关联, 并在调用线程上运行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-782">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously> method are associated with the current <xref:System.Threading.Tasks.TaskScheduler> and are run on the calling thread.</span></span> <span data-ttu-id="0ddf6-783">如果目标计划程序不支持在调用线程上运行此任务, 则将在计划程序上计划任务的执行, 并且调用线程将被阻止, 直到任务完成执行为止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-783">If the target scheduler does not support running this task on the calling thread, the task will be scheduled for execution on the scheduler, and the calling thread will block until the task has completed execution.</span></span> <span data-ttu-id="0ddf6-784">即使任务以同步方式运行, 调用线程仍应调用<xref:System.Threading.Tasks.Task.Wait%2A>来处理任务可能引发的任何异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-784">Even though the task runs synchronously, the calling thread should still call <xref:System.Threading.Tasks.Task.Wait%2A> to handle any exceptions that the task might throw.</span></span>  <span data-ttu-id="0ddf6-785">有关异常处理的详细信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-785">For more information on exception handling, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 <span data-ttu-id="0ddf6-786">通过调用<xref:System.Threading.Tasks.Task.RunSynchronously%2A>方法执行的任务通过<xref:System.Threading.Tasks.Task>调用或<xref:System.Threading.Tasks.Task%601>类构造函数进行实例化。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-786">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="0ddf6-787">要同步运行的任务必须处于<xref:System.Threading.Tasks.TaskStatus.Created>状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-787">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="0ddf6-788">任务只能启动并运行一次。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-788">A task may be started and run only once.</span></span> <span data-ttu-id="0ddf6-789">如果尝试再次计划任务, 将导致异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-789">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-790">下面的示例通过调用<xref:System.Threading.Tasks.Task.RunSynchronously%2A>方法来比较执行的任务, 并异步执行一个任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-790">The following example compares a task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method with one executed asynchronously.</span></span> <span data-ttu-id="0ddf6-791">在这两种情况下, 任务执行相同的 lambda 表达式, 用于显示任务 ID 以及运行任务的线程的 ID。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-791">In both cases, the tasks execute identical lambda expressions that display the task ID and the ID of the thread on which the task is running.</span></span> <span data-ttu-id="0ddf6-792">该任务计算1到1000000之间的整数之和。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-792">The task calculates the sum of the integers between 1 and 1,000,000.</span></span> <span data-ttu-id="0ddf6-793">如示例的输出所示, 通过调用<xref:System.Threading.Tasks.Task.RunSynchronously%2A>方法执行的任务在应用程序线程上运行, 而异步任务则不运行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-793">As the output from the example shows, the task executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method runs on the application thread, while the asynchronous task does not.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/cs/runsynchronously1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.RunSynchronously#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.runsynchronously/vb/runsynchronously1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-794">已释放了 <see cref="T:System.Threading.Tasks.Task" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-794">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ddf6-795"><see cref="T:System.Threading.Tasks.Task" /> 并非要启动的有效状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-795">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="0ddf6-796">它可能已启动、执行或取消，或者它可能是以不支持直接计划的方式创建的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-796">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-797">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-797">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RunSynchronously">
      <MemberSignature Language="C#" Value="public void RunSynchronously (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RunSynchronously(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.RunSynchronously(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RunSynchronously (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RunSynchronously(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.RunSynchronously : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.RunSynchronously scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="0ddf6-798">尝试对其以内联方式运行此任务的计划程序。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-798">The scheduler on which to attempt to run this task inline.</span></span></param>
        <summary><span data-ttu-id="0ddf6-799">对提供的 <see cref="T:System.Threading.Tasks.Task" /> 同步运行 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-799">Runs the <see cref="T:System.Threading.Tasks.Task" /> synchronously on the <see cref="T:System.Threading.Tasks.TaskScheduler" /> provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-800">通过调用<xref:System.Threading.Tasks.Task.RunSynchronously%2A>方法执行的任务通过<xref:System.Threading.Tasks.Task>调用或<xref:System.Threading.Tasks.Task%601>类构造函数进行实例化。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-800">Tasks executed by calling the <xref:System.Threading.Tasks.Task.RunSynchronously%2A> method are instantiated by calling a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> class constructor.</span></span> <span data-ttu-id="0ddf6-801">要同步运行的任务必须处于<xref:System.Threading.Tasks.TaskStatus.Created>状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-801">The task to be run synchronously must be in the <xref:System.Threading.Tasks.TaskStatus.Created> state.</span></span> <span data-ttu-id="0ddf6-802">任务只能启动并运行一次。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-802">A task may be started and run only once.</span></span> <span data-ttu-id="0ddf6-803">如果尝试再次计划任务, 将导致异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-803">Any attempts to schedule a task a second time results in an exception.</span></span>  
  
 <span data-ttu-id="0ddf6-804">如果目标计划程序不支持在当前线程上运行此任务, 则将在计划程序上计划任务的执行, 并且在任务完成执行之前, 当前线程将被阻止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-804">If the target scheduler does not support running this task on the current thread, the task will be scheduled for execution on the scheduler, and the current thread will block until the task has completed execution.</span></span> <span data-ttu-id="0ddf6-805">因此, 调用线程不需要调用方法 (如<xref:System.Threading.Tasks.Task.Wait%2A> ) 以确保任务已完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-805">Because of this, the calling thread does not need to call a method such as <xref:System.Threading.Tasks.Task.Wait%2A> to ensure that the task has completed execution.</span></span> <span data-ttu-id="0ddf6-806">有关任务操作的异常处理的详细信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-806">For more information on exception handling for task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-807">已释放了 <see cref="T:System.Threading.Tasks.Task" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-807">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-808"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-808">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ddf6-809"><see cref="T:System.Threading.Tasks.Task" /> 并非要启动的有效状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-809">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="0ddf6-810">它可能已启动、执行或取消，或者它可能是以不支持直接计划的方式创建的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-810">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-811">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-811">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-812">启动 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-812">Starts the <see cref="T:System.Threading.Tasks.Task" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="task.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ddf6-813">启动 <see cref="T:System.Threading.Tasks.Task" />，并将它安排到当前的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 中执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-813">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the current <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-814">任务只能启动并运行一次。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-814">A task may be started and run only once.</span></span> <span data-ttu-id="0ddf6-815">如果尝试再次计划任务, 将导致异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-815">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="0ddf6-816">用于执行已通过调用其中一个<xref:System.Threading.Tasks.Task>构造函数创建的任务。 <xref:System.Threading.Tasks.Task.Start%2A></span><span class="sxs-lookup"><span data-stu-id="0ddf6-816">The <xref:System.Threading.Tasks.Task.Start%2A> is used to execute a task that has been created by calling one of the <xref:System.Threading.Tasks.Task> constructors.</span></span> <span data-ttu-id="0ddf6-817">通常情况下, 在需要将任务的创建从其执行中分离出来 (例如, 在有条件地执行您创建的任务时) 时, 可以执行此操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-817">Typically, you do this when you need to separate the task's creation from its execution, such as when you conditionally execute tasks that you've created.</span></span> <span data-ttu-id="0ddf6-818">对于不需要将任务实例化与执行分离的更常见情况, 我们建议调用<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>或<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>方法的重载。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-818">For the more common case in which you don't need to separate  task instantiation from execution, we recommend that you call an overload of the <xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType> or <xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="0ddf6-819">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-819">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-820">下面的示例调用<xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29>构造函数来实例化一个新<xref:System.Threading.Tasks.Task>的对象, 该对象显示其任务 id 和托管线程 ID, 然后执行一个循环。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-820">The following example calls the <xref:System.Threading.Tasks.Task.%23ctor%28System.Action%29> constructor to instantiate a new <xref:System.Threading.Tasks.Task> object that displays its task ID and managed thread ID and then executes a loop.</span></span> <span data-ttu-id="0ddf6-821">然后, 它会<xref:System.Threading.Tasks.Task.Start%2A>调用方法来执行任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-821">It then calls the <xref:System.Threading.Tasks.Task.Start%2A> method to execute the task.</span></span>  <span data-ttu-id="0ddf6-822">由于这是一个控制台应用程序, 因此调用<xref:System.Threading.Tasks.Task.Wait%2A>方法是为了防止应用程序在任务完成执行之前终止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-822">Since this is a console app, the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method is necessary to prevent the app from terminating before the task finishes execution.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.start/cs/Start1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.start/vb/Start1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-823">已释放了 <see cref="T:System.Threading.Tasks.Task" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-823">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ddf6-824"><see cref="T:System.Threading.Tasks.Task" /> 并非要启动的有效状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-824">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="0ddf6-825">它可能已启动、执行或取消，或者它可能是以不支持直接计划的方式创建的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-825">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-826">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-826">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Start(System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (scheduler As TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="member this.Start : System.Threading.Tasks.TaskScheduler -&gt; unit" Usage="task.Start scheduler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="scheduler"><span data-ttu-id="0ddf6-827">要与之关联并执行此任务的 <see cref="T:System.Threading.Tasks.TaskScheduler" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-827">The <see cref="T:System.Threading.Tasks.TaskScheduler" /> with which to associate and execute this task.</span></span></param>
        <summary><span data-ttu-id="0ddf6-828">启动 <see cref="T:System.Threading.Tasks.Task" />，并将它安排到指定的 <see cref="T:System.Threading.Tasks.TaskScheduler" /> 中执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-828">Starts the <see cref="T:System.Threading.Tasks.Task" />, scheduling it for execution to the specified <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-829">一个任务只能启动并运行一次。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-829">A task may only be started and run only once.</span></span> <span data-ttu-id="0ddf6-830">如果尝试再次计划任务, 将导致异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-830">Any attempts to schedule a task a second time will result in an exception.</span></span>  
  
 <span data-ttu-id="0ddf6-831">有关处理任务操作引发的异常的信息, 请参阅[异常处理](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-831">For information on handling exceptions thrown by task operations, see [Exception Handling](~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-832"><paramref name="scheduler" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-832">The <paramref name="scheduler" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="0ddf6-833"><see cref="T:System.Threading.Tasks.Task" /> 并非要启动的有效状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-833">The <see cref="T:System.Threading.Tasks.Task" /> is not in a valid state to be started.</span></span> <span data-ttu-id="0ddf6-834">它可能已启动、执行或取消，或者它可能是以不支持直接计划的方式创建的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-834">It may have already been started, executed, or canceled, or it may have been created in a manner that doesn't support direct scheduling.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-835">已释放了 <see cref="T:System.Threading.Tasks.Task" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-835">The <see cref="T:System.Threading.Tasks.Task" /> instance has been disposed.</span></span></exception>
        <exception cref="T:System.Threading.Tasks.TaskSchedulerException"><span data-ttu-id="0ddf6-836">计划程序无法将此任务排入队列。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-836">The scheduler was unable to queue this task.</span></span></exception>
        <related type="Article" href="~/docs/standard/parallel-programming/exception-handling-task-parallel-library.md"><span data-ttu-id="0ddf6-837">异常处理（任务并行库）</span><span class="sxs-lookup"><span data-stu-id="0ddf6-837">Exception Handling (Task Parallel Library)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.TaskStatus Status { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.Tasks.TaskStatus Status" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.Status" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Status As TaskStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::TaskStatus Status { System::Threading::Tasks::TaskStatus get(); };" />
      <MemberSignature Language="F#" Value="member this.Status : System.Threading.Tasks.TaskStatus" Usage="System.Threading.Tasks.Task.Status" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskStatus</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-838">获取此任务的 <see cref="T:System.Threading.Tasks.TaskStatus" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-838">Gets the <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task.</span></span></summary>
        <value><span data-ttu-id="0ddf6-839">此任务实例的当前 <see cref="T:System.Threading.Tasks.TaskStatus" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-839">The current <see cref="T:System.Threading.Tasks.TaskStatus" /> of this task instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-840">检索<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>属性的值不会阻止调用线程, 直到任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-840">Retrieving the value of the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property does not block the calling thread until the task has completed.</span></span>  
  
 <span data-ttu-id="0ddf6-841">有关详细信息和示例, 请参阅[使用延续任务链接任务](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)和[如何:取消任务及其子级](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-841">For more information and an example, see [Chaining Tasks by Using Continuation Tasks](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md) and [How to: Cancel a Task and Its Children](~/docs/standard/parallel-programming/how-to-cancel-a-task-and-its-children.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-842">下面的示例创建了20个任务, 这些任务将循环, 直到计数器的值递增为2000000。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-842">The following example creates 20 tasks that will loop until a counter is incremented to a value of 2 million.</span></span> <span data-ttu-id="0ddf6-843">当前10个任务达到2000000时, 取消标记将被取消, 并且任何其计数器未达到2000000的任务都将被取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-843">When the first 10 tasks reach 2 million, the cancellation token is cancelled, and any tasks whose counters have not reached 2 million are cancelled.</span></span> <span data-ttu-id="0ddf6-844">然后, 该示例检查<xref:System.Threading.Tasks.Task.Status%2A>每个任务的属性, 以指示该任务是否已成功完成或已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-844">The example then examines the <xref:System.Threading.Tasks.Task.Status%2A> property of each task to indicate whether it completed successfully or was cancelled.</span></span> <span data-ttu-id="0ddf6-845">对于已完成的, 它会显示任务返回的值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-845">For those that completed, it displays the value returned by the task.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Run#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.run/cs/Run7.cs#7)]
 [!code-vb[System.Threading.Tasks.Task.Run#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.run/vb/Run7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.AsyncWaitHandle">
      <MemberSignature Language="C#" Value="System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.WaitHandle System.IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#AsyncWaitHandle" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property AsyncWaitHandle As WaitHandle Implements IAsyncResult.AsyncWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="property System::Threading::WaitHandle ^ System::IAsyncResult::AsyncWaitHandle { System::Threading::WaitHandle ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.AsyncWaitHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.AsyncWaitHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-846">获取可用于等待任务完成的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-846">Gets a <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></summary>
        <value><span data-ttu-id="0ddf6-847">可用于等待任务完成的 <see cref="T:System.Threading.WaitHandle" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-847">A <see cref="T:System.Threading.WaitHandle" /> that can be used to wait for the task to complete.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-848">使用提供<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>的等待功能优于使用<xref:System.IAsyncResult.AsyncWaitHandle%2A>来实现类似功能。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-848">Using the wait functionality provided by <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> is preferable to using <xref:System.IAsyncResult.AsyncWaitHandle%2A> for similar functionality.</span></span> <span data-ttu-id="0ddf6-849">有关详细信息, 请参阅[基于任务的异步编程](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)中的 "等待任务" 部分, 并将[TPL 与其他异步模式结合使用](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md)。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-849">For more information, see the "Waiting on Tasks" section in [Task-based Asynchronous Programming](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md) and [Using TPL with Other Asynchronous Patterns](~/docs/standard/parallel-programming/using-tpl-with-other-asynchronous-patterns.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-850">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-850">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IAsyncResult.CompletedSynchronously">
      <MemberSignature Language="C#" Value="bool System.IAsyncResult.CompletedSynchronously { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task.System#IAsyncResult#CompletedSynchronously" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property CompletedSynchronously As Boolean Implements IAsyncResult.CompletedSynchronously" />
      <MemberSignature Language="C++ CLI" Value="property bool System::IAsyncResult::CompletedSynchronously { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.IAsyncResult.CompletedSynchronously" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.IAsyncResult.CompletedSynchronously</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0ddf6-851">获取操作是否已同步完成的指示。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-851">Gets an indication of whether the operation completed synchronously.</span></span></summary>
        <value><span data-ttu-id="0ddf6-852">如果操作同步完成，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-852"><see langword="true" /> if the operation completed synchronously; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-853">等待 <see cref="T:System.Threading.Tasks.Task" /> 完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-853">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait" />
      <MemberSignature Language="VB.NET" Value="Public Sub Wait ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait();" />
      <MemberSignature Language="F#" Value="member this.Wait : unit -&gt; unit" Usage="task.Wait " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ddf6-854">等待 <see cref="T:System.Threading.Tasks.Task" /> 完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-854">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-855"><xref:System.Threading.Tasks.Task.Wait%2A>同步方法, 这会导致调用线程等待, 直到当前任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-855"><xref:System.Threading.Tasks.Task.Wait%2A> is a synchronization method that causes the calling thread to wait until the current task has completed.</span></span> <span data-ttu-id="0ddf6-856">如果当前任务尚未开始执行, 则 Wait 方法尝试从计划程序中删除任务并在当前线程上以内联方式执行该任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-856">If the current task has not started execution, the Wait method attempts to remove the task from the scheduler and execute it inline on the current thread.</span></span> <span data-ttu-id="0ddf6-857">如果无法执行此操作, 或者当前任务已开始执行, 则它会阻止调用线程, 直到任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-857">If it is unable to do that, or if the current task has already started execution, it blocks the calling thread until the task completes.</span></span> <span data-ttu-id="0ddf6-858">有关详细信息, 请参阅 "通过 .NET 并行编程" 博客中的["任务" 和 "内联"](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) 。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-858">For more information, see [Task.Wait and "Inlining"](https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/) in the Parallel Programming with .NET blog.</span></span>   
  
## Examples  
 <span data-ttu-id="0ddf6-859">下面的示例启动了一个任务, 该任务生成0到100之间的1000000随机整数, 并计算其平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-859">The following example starts a task that generates one million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="0ddf6-860">该示例使用<xref:System.Threading.Tasks.Task.Wait%2A>方法来确保该任务在应用程序终止前完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-860">The example uses the <xref:System.Threading.Tasks.Task.Wait%2A> method to ensure that the task completes before the application terminates.</span></span> <span data-ttu-id="0ddf6-861">否则, 因为这是一个控制台应用程序, 则在任务可以计算并显示平均值之前, 此示例将终止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-861">Otherwise, because this is a console application, the example would terminate before the task can compute and display the mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.Wait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-862">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-862">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-863">已取消任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-863">The task was canceled.</span></span> <span data-ttu-id="0ddf6-864"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-864">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="0ddf6-865">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-865">-or-</span></span> 
<span data-ttu-id="0ddf6-866">执行任务期间引发了一个异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-866">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="0ddf6-867"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含一个或多个异常的相关信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-867">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
        <related type="ExternalDocumentation" href="https://devblogs.microsoft.com/pfxteam/task-wait-and-inlining/"><span data-ttu-id="0ddf6-868">Wait 和 "内联"</span><span class="sxs-lookup"><span data-stu-id="0ddf6-868">Task.Wait and "Inlining"</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : int -&gt; bool" Usage="task.Wait millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="0ddf6-869">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-869">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-870">等待 <see cref="T:System.Threading.Tasks.Task" /> 在指定的毫秒数内完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-870">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-871">如果在分配的时间内 <see langword="true" /> 完成执行，则为 <see cref="T:System.Threading.Tasks.Task" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-871"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-872"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>是一种同步方法, 该方法使调用线程等待当前任务实例完成, 直到发生以下情况之一:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-872"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0ddf6-873">任务成功完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-873">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="0ddf6-874">任务本身被取消或引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-874">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="0ddf6-875">在这种情况下, 您<xref:System.AggregateException>将处理异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-875">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="0ddf6-876"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>属性包含有关异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-876">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="0ddf6-877">所定义`millisecondsTimeout`的间隔。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-877">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="0ddf6-878">在这种情况下, 当前线程将继续执行, 并且`false`该方法将返回。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-878">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-879">下面的示例启动了一个任务, 该任务生成0到100之间的5000000随机整数, 并计算其平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-879">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="0ddf6-880">该示例使用<xref:System.Threading.Tasks.Task.Wait%28System.Int32%29>方法等待应用程序在150毫秒内完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-880">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="0ddf6-881">如果应用程序正常完成, 任务会显示其生成的随机数字的总和和平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-881">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="0ddf6-882">如果超时间隔已过, 则该示例在消息终止之前显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-882">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait5.cs#5)]
 [!code-vb[System.Threading.Tasks.Task.Wait#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-883">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-883">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-884"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-884"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-885">已取消任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-885">The task was canceled.</span></span> <span data-ttu-id="0ddf6-886"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-886">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="0ddf6-887">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-887">-or-</span></span> 
<span data-ttu-id="0ddf6-888">执行任务期间引发了一个异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-888">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="0ddf6-889"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含一个或多个异常的相关信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-889">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public void Wait (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Wait(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Wait(System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : System.Threading.CancellationToken -&gt; unit" Usage="task.Wait cancellationToken" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-890">等待任务完成期间要观察的取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-890">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-891">等待 <see cref="T:System.Threading.Tasks.Task" /> 完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-891">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="0ddf6-892">如果在任务完成之前取消标记已取消，等待将终止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-892">The wait terminates if a cancellation token is canceled before the task completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-893"><xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>方法创建可取消的等待; 也就是说, 它会导致当前线程等待, 直到发生以下情况之一:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-893">The <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method creates a cancelable wait; that is, it causes the current thread to wait until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0ddf6-894">任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-894">The task completes.</span></span>  
  
-   <span data-ttu-id="0ddf6-895">取消标记被取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-895">The cancellation token is canceled.</span></span> <span data-ttu-id="0ddf6-896">在这种情况下, 对<xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29>方法的调用将<xref:System.OperationCanceledException>引发。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-896">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ddf6-897">`cancellationToken`取消取消标记不会对正在运行的任务产生任何影响, 除非它还传递了取消标记并准备处理取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-897">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="0ddf6-898">`cancellationToken`将对象传递到此方法只是允许取消等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-898">Passing the `cancellationToken` object to this method simply allows the wait to be canceled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-899">下面的示例演示如何使用取消标记来取消等待任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-899">The following example illustrates the simple use of a cancellation token to cancel waiting for a task's completion.</span></span> <span data-ttu-id="0ddf6-900">启动任务后, 调用<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>方法以取消标记源的任何取消标记, 然后延迟五秒。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-900">A task is launched, calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel any of the token source's cancellation tokens, and then delays for five seconds.</span></span> <span data-ttu-id="0ddf6-901">请注意, 尚未向任务本身传递取消标记, 因而不可取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-901">Note that the task itself has not been passed the cancellation token and is not cancelable.</span></span> <span data-ttu-id="0ddf6-902">应用程序线程调用任务的<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>方法来等待任务完成, 但一旦取消标记<xref:System.OperationCanceledException>并引发, 就会取消等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-902">The application thread calls the task's <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> method to wait for the task to complete, but the wait is canceled once the cancellation token is cancelled and an <xref:System.OperationCanceledException> is thrown.</span></span> <span data-ttu-id="0ddf6-903">异常处理程序将报告异常, 并休眠六秒钟。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-903">The exception handler reports the exception and then sleeps for six seconds.</span></span> <span data-ttu-id="0ddf6-904">如示例的输出所示, 该延迟使任务在<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状态中完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-904">As the output from the example shows, that delay allows the task to complete in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.Wait#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="0ddf6-905">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-905">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-906">已释放该任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-906">The task has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-907">已取消任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-907">The task was canceled.</span></span> <span data-ttu-id="0ddf6-908"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-908">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="0ddf6-909">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-909">-or-</span></span> 
<span data-ttu-id="0ddf6-910">执行任务期间引发了一个异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-910">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="0ddf6-911"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含一个或多个异常的相关信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-911">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wait (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Wait : TimeSpan -&gt; bool" Usage="task.Wait timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="0ddf6-912">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-912">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-913">等待 <see cref="T:System.Threading.Tasks.Task" /> 在指定的时间间隔内完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-913">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-914">如果在分配的时间内 <see langword="true" /> 完成执行，则为 <see cref="T:System.Threading.Tasks.Task" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-914"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-915"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>是一种同步方法, 该方法使调用线程等待当前任务实例完成, 直到发生以下情况之一:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-915"><xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0ddf6-916">任务成功完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-916">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="0ddf6-917">任务本身被取消或引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-917">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="0ddf6-918">在这种情况下, 您<xref:System.AggregateException>将处理异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-918">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="0ddf6-919"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>属性包含有关异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-919">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="0ddf6-920">所定义`timeout`的间隔。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-920">The interval defined by `timeout` elapses.</span></span> <span data-ttu-id="0ddf6-921">在这种情况下, 当前线程将继续执行, 并且`false`该方法将返回。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-921">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-922">下面的示例启动了一个任务, 该任务生成0到100之间的5000000随机整数, 并计算其平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-922">The following example starts a task that generates five million random integers between 0 and 100 and computes their mean.</span></span> <span data-ttu-id="0ddf6-923">该示例使用<xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29>方法等待应用程序在150毫秒内完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-923">The example uses the <xref:System.Threading.Tasks.Task.Wait%28System.TimeSpan%29> method to wait for the application to complete within 150 milliseconds.</span></span> <span data-ttu-id="0ddf6-924">如果应用程序正常完成, 任务会显示其生成的随机数字的总和和平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-924">If the application completes normally, the task displays the sum and mean of the random numbers that it has generated.</span></span> <span data-ttu-id="0ddf6-925">如果超时间隔已过, 则该示例在消息终止之前显示一条消息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-925">If the timeout interval has elapsed, the example displays a message before it terminates.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/Wait6.cs#6)]
 [!code-vb[System.Threading.Tasks.Task.Wait#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/Wait6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-926">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-926">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-927"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-927"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ddf6-928">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-928">-or-</span></span> 
 <span data-ttu-id="0ddf6-929"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-929"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-930">已取消任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-930">The task was canceled.</span></span> <span data-ttu-id="0ddf6-931"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-931">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="0ddf6-932">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-932">-or-</span></span> 
<span data-ttu-id="0ddf6-933">执行任务期间引发了一个异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-933">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="0ddf6-934"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含一个或多个异常的相关信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-934">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public bool Wait (int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Wait(int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Wait(System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Wait(int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="member this.Wait : int * System.Threading.CancellationToken -&gt; bool" Usage="task.Wait (millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="0ddf6-935">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-935">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-936">等待任务完成期间要观察的取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-936">A cancellation token to observe while waiting for the task to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-937">等待 <see cref="T:System.Threading.Tasks.Task" /> 完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-937">Waits for the <see cref="T:System.Threading.Tasks.Task" /> to complete execution.</span></span> <span data-ttu-id="0ddf6-938">如果在任务完成之前超时间隔结束或取消标记已取消，等待将终止。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-938">The wait terminates if a timeout interval elapses or a cancellation token is canceled before the task completes.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-939">如果在分配的时间内 <see langword="true" /> 完成执行，则为 <see cref="T:System.Threading.Tasks.Task" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-939"><see langword="true" /> if the <see cref="T:System.Threading.Tasks.Task" /> completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-940"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>是一种同步方法, 该方法使调用线程等待当前任务实例完成, 直到发生以下情况之一:</span><span class="sxs-lookup"><span data-stu-id="0ddf6-940"><xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> is a synchronization method that causes the calling thread to wait for the current task instance to complete until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="0ddf6-941">任务成功完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-941">The task completes successfully.</span></span>  
  
-   <span data-ttu-id="0ddf6-942">任务本身被取消或引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-942">The task itself is canceled or throws an exception.</span></span> <span data-ttu-id="0ddf6-943">在这种情况下, 您<xref:System.AggregateException>将处理异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-943">In this case, you handle an <xref:System.AggregateException> exception.</span></span> <span data-ttu-id="0ddf6-944"><xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType>属性包含有关异常的详细信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-944">The <xref:System.AggregateException.InnerExceptions%2A?displayProperty=nameWithType> property contains details about the exception or exceptions.</span></span>  
  
-   <span data-ttu-id="0ddf6-945">`cancellationToken`取消标记被取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-945">The `cancellationToken` cancellation token is canceled.</span></span> <span data-ttu-id="0ddf6-946">在这种情况下, 对<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法的调用将<xref:System.OperationCanceledException>引发。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-946">In this case, the call to the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method throws an <xref:System.OperationCanceledException>.</span></span>  
  
-   <span data-ttu-id="0ddf6-947">所定义`millisecondsTimeout`的间隔。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-947">The interval defined by `millisecondsTimeout` elapses.</span></span> <span data-ttu-id="0ddf6-948">在这种情况下, 当前线程将继续执行, 并且`false`该方法将返回。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-948">In this case, the current thread resumes execution and the method returns `false`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ddf6-949">`cancellationToken`取消取消标记不会对正在运行的任务产生任何影响, 除非它还传递了取消标记并准备处理取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-949">Canceling the `cancellationToken` cancellation token has no effect on the running task unless it has also been passed the cancellation token and is prepared to handle cancellation.</span></span> <span data-ttu-id="0ddf6-950">`cancellationToken`将对象传递给此方法只允许根据某些条件取消等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-950">Passing the `cancellationToken` object to this method simply allows the wait to be canceled based on some condition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-951">下面的示例调用<xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29>方法, 以提供可结束任务完成等待的超时值和取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-951">The following example calls the <xref:System.Threading.Tasks.Task.Wait%28System.Int32%2CSystem.Threading.CancellationToken%29> method to provide both a timeout value and a cancellation token that can end the wait for a task's completion.</span></span> <span data-ttu-id="0ddf6-952">此时将启动一个新线程并执行`CancelToken`方法, 该方法将暂停, 然后<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>调用方法以取消取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-952">A new thread is started and executes the `CancelToken` method, which pauses and then calls the <xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType> method to cancel the cancellation tokens.</span></span> <span data-ttu-id="0ddf6-953">然后, 将启动任务并延迟5秒。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-953">A task is then launched and delays for 5 seconds.</span></span> <span data-ttu-id="0ddf6-954">然后<xref:System.Threading.Tasks.Task.Wait%2A>调用方法来等待任务完成, 并同时提供一个简短的超时值和一个取消标记。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-954">The <xref:System.Threading.Tasks.Task.Wait%2A> method is then called to wait for the task's completion and is provided both a brief timeout value and a cancellation token.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.wait/cs/wait4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.Wait#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.wait/vb/wait4.vb#4)]  
  
 <span data-ttu-id="0ddf6-955">请注意, 该示例的精确输出取决于是否由于取消标记而取消等待, 或由于超时间隔已用。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-955">Note that the precise output from the example depends on whether the wait was canceled because of the cancellation token or because the timeout interval elapsed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="0ddf6-956">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-956">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-957">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-957">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-958"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-958"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-959">已取消任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-959">The task was canceled.</span></span> <span data-ttu-id="0ddf6-960"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含 <see cref="T:System.Threading.Tasks.TaskCanceledException" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-960">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains a <see cref="T:System.Threading.Tasks.TaskCanceledException" /> object.</span></span>  
  
<span data-ttu-id="0ddf6-961">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-961">-or-</span></span> 
<span data-ttu-id="0ddf6-962">执行任务期间引发了一个异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-962">An exception was thrown during the execution of the task.</span></span> <span data-ttu-id="0ddf6-963"><see cref="P:System.AggregateException.InnerExceptions" /> 集合包含一个或多个异常的相关信息。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-963">The <see cref="P:System.AggregateException.InnerExceptions" /> collection contains information about the exception or exceptions.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-964">等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 对象完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-964">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitAll (ParamArray tasks As Task())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-965">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-965">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="0ddf6-966">等待提供的所有 <see cref="T:System.Threading.Tasks.Task" /> 对象完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-966">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0ddf6-967">下面的示例启动了10个任务, 其中每个任务都作为状态对象传递了一个索引。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-967">The following example starts 10 tasks, each of which is passed an index as a state object.</span></span> <span data-ttu-id="0ddf6-968">索引为2到5的任务引发异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-968">Tasks with an index from two to five throw exceptions.</span></span> <span data-ttu-id="0ddf6-969">对<xref:System.Threading.Tasks.Task.WaitAll%2A>方法的调用会包装<xref:System.AggregateException>对象中的所有异常, 并将其传播到调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-969">The call to the <xref:System.Threading.Tasks.Task.WaitAll%2A> method wraps all exceptions in an <xref:System.AggregateException> object and propagates it to the calling thread.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task/cs/waitall.cs#02)]
 [!code-vb[System.Threading.Tasks.Task#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task/vb/waitall.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-970"><paramref name="tasks" /> 中的一个或多个 <see cref="T:System.Threading.Tasks.Task" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-970">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-971"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-971">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-972"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-972">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-973">至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-973">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="0ddf6-974">如果任务取消，则 <see cref="T:System.AggregateException" /> 异常在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" /> 异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-974">If a task was canceled, the <see cref="T:System.AggregateException" /> exception contains an <see cref="T:System.OperationCanceledException" /> exception in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="0ddf6-975">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-975">-or-</span></span> 
<span data-ttu-id="0ddf6-976">在至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例的执行过程中引发了异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-976">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-977">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-977">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ddf6-978">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-978">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-979">等待所有提供的 <see cref="T:System.Threading.Tasks.Task" /> 在指定的毫秒数内完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-979">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-980">如果在分配的时间内所有 <see langword="true" /> 实例都已完成执行，则为 <see cref="T:System.Threading.Tasks.Task" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-980"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-981"><paramref name="tasks" /> 中的一个或多个 <see cref="T:System.Threading.Tasks.Task" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-981">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-982"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-982">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-983">至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-983">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="0ddf6-984">如果任务已取消，则 <see cref="T:System.AggregateException" /> 在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-984">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="0ddf6-985">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-985">-or-</span></span> 
<span data-ttu-id="0ddf6-986">在至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例的执行过程中引发了异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-986">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-987"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-987"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-988"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-988">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static void WaitAll (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; unit" Usage="System.Threading.Tasks.Task.WaitAll (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-989">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-989">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-990">等待任务完成期间要观察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-990">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-991">等待提供的所有 <see cref="T:System.Threading.Tasks.Task" /> 对象完成执行过程（除非取消等待）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-991">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-992">`cancellationToken`参数用于取消等待操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-992">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="0ddf6-993">取消任务是一种不同的操作, 并由<xref:System.AggregateException>发出信号, 如上所述。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-993">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> as noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="0ddf6-994">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-994">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-995"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-995">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-996">至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-996">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="0ddf6-997">如果任务已取消，则 <see cref="T:System.AggregateException" /> 在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-997">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="0ddf6-998">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-998">-or-</span></span> 
<span data-ttu-id="0ddf6-999">在至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例的执行过程中引发了异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-999">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1000"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1000">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1001"><paramref name="tasks" /> 中的一个或多个 <see cref="T:System.Threading.Tasks.Task" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1001">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAll (tasks As Task(), timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * TimeSpan -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1002">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1002">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="0ddf6-1003">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1003">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1004">等待所有提供的可取消 <see cref="T:System.Threading.Tasks.Task" /> 对象在指定的时间间隔内完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1004">Waits for all of the provided cancellable <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1005">如果在分配的时间内所有 <see langword="true" /> 实例都已完成执行，则为 <see cref="T:System.Threading.Tasks.Task" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1005"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1006"><paramref name="tasks" /> 中的一个或多个 <see cref="T:System.Threading.Tasks.Task" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1006">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1007"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1007">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-1008">至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1008">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="0ddf6-1009">如果任务已取消，则 <see cref="T:System.AggregateException" /> 在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1009">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="0ddf6-1010">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1010">-or-</span></span> 
<span data-ttu-id="0ddf6-1011">在至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例的执行过程中引发了异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1011">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-1012"><paramref name="timeout" /> 为 -1 毫秒以外的负数，表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1012"><paramref name="timeout" /> is a negative number other than -1 milliseconds, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ddf6-1013">- 或 -</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1013">-or-</span></span> 
 <span data-ttu-id="0ddf6-1014"><paramref name="timeout" /> 大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1014"><paramref name="timeout" /> is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1015"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1015">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAll(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool WaitAll(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAll : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; bool" Usage="System.Threading.Tasks.Task.WaitAll (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1016">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1016">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ddf6-1017">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1017">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-1018">等待任务完成期间要观察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1018">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for the tasks to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1019">等待提供的所有 <see cref="T:System.Threading.Tasks.Task" /> 对象在指定的毫秒数内完成执行，或等到取消等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1019">Waits for all of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1020">如果在分配的时间内所有 <see langword="true" /> 实例都已完成执行，则为 <see cref="T:System.Threading.Tasks.Task" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1020"><see langword="true" /> if all of the <see cref="T:System.Threading.Tasks.Task" /> instances completed execution within the allotted time; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1021">`cancellationToken`参数用于取消等待操作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1021">The `cancellationToken` argument is used to cancel the wait operation.</span></span> <span data-ttu-id="0ddf6-1022">取消任务是一种不同的操作, 并按上面所述<xref:System.AggregateException>的方式发出通知。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1022">Cancellation of the tasks is a distinct operation, and is signaled by the <xref:System.AggregateException> noted above.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1023"><paramref name="tasks" /> 中的一个或多个 <see cref="T:System.Threading.Tasks.Task" /> 对象已释放。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1023">One or more of the <see cref="T:System.Threading.Tasks.Task" /> objects in <paramref name="tasks" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1024"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1024">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="0ddf6-1025">至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例已取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1025">At least one of the <see cref="T:System.Threading.Tasks.Task" /> instances was canceled.</span></span> <span data-ttu-id="0ddf6-1026">如果任务已取消，则 <see cref="T:System.AggregateException" /> 在其 <see cref="P:System.AggregateException.InnerExceptions" /> 集合中包含 <see cref="T:System.OperationCanceledException" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1026">If a task was canceled, the <see cref="T:System.AggregateException" /> contains an <see cref="T:System.OperationCanceledException" /> in its <see cref="P:System.AggregateException.InnerExceptions" /> collection.</span></span>  
  
<span data-ttu-id="0ddf6-1027">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1027">-or-</span></span> 
<span data-ttu-id="0ddf6-1028">在至少一个 <see cref="T:System.Threading.Tasks.Task" /> 实例的执行过程中引发了异常。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1028">An exception was thrown during the execution of at least one of the <see cref="T:System.Threading.Tasks.Task" /> instances.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-1029"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1029"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1030"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1030">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="0ddf6-1031">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1031">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-1032">等待提供的任一 <see cref="T:System.Threading.Tasks.Task" /> 对象完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1032">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (ParamArray tasks As Task()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1033">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1033">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1034">等待提供的任一 <see cref="T:System.Threading.Tasks.Task" /> 对象完成执行过程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1034">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1035"><paramref name="tasks" /> 数组中已完成的 <see cref="T:System.Threading.Tasks.Task" /> 对象的所有。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1035">The index of the completed <see cref="T:System.Threading.Tasks.Task" /> object in the <paramref name="tasks" /> array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0ddf6-1036">下面的示例启动五个任务, 每个任务都休眠至少50毫秒或最大1050毫秒。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1036">The following example launches five tasks, each of which sleeps for a minimum of 50 milliseconds or a maximum of 1,050 milliseconds.</span></span> <span data-ttu-id="0ddf6-1037">然后<xref:System.Threading.Tasks.Task.WaitAny%2A> , 该方法等待任何任务完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1037">The <xref:System.Threading.Tasks.Task.WaitAny%2A> method then waits for any of the tasks to complete.</span></span> <span data-ttu-id="0ddf6-1038">该示例显示结束等待的任务的任务 ID 以及所有任务的当前状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1038">The example displays the task ID of the task that ended the wait, as well as the current status of all the tasks.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/cs/WaitAny1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WaitAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Tasks.Task.WaitAny/vb/WaitAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1039">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1039">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1040"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1040">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1041"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1041">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), millisecondsTimeout As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1042">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1042">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ddf6-1043">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1043">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1044">等待任何提供的 <see cref="T:System.Threading.Tasks.Task" /> 对象在指定的毫秒数内完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1044">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1045">已完成的任务在 <paramref name="tasks" /> 数组参数中的索引，如果发生超时，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1045">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1046">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1046">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1047"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1047">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-1048"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1048"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1049"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1049">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1050">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1050">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-1051">等待任务完成期间要观察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1051">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1052">等待提供的任何 <see cref="T:System.Threading.Tasks.Task" /> 对象完成执行过程（除非取消等待）。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1052">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution unless the wait is cancelled.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1053">已完成的任务在 <paramref name="tasks" /> 数组参数中的索引。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1053">The index of the completed task in the <paramref name="tasks" /> array argument.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1054">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1054">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1055"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1055">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1056"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1056">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="0ddf6-1057">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1057">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitAny (tasks As Task(), timeout As TimeSpan) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * TimeSpan -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1058">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1058">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="timeout"><span data-ttu-id="0ddf6-1059">表示等待毫秒数的 <see cref="T:System.TimeSpan" />，或表示 -1 毫秒（无限期等待）的 <see cref="T:System.TimeSpan" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1059">A <see cref="T:System.TimeSpan" /> that represents the number of milliseconds to wait, or a <see cref="T:System.TimeSpan" /> that represents -1 milliseconds to wait indefinitely.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1060">等待任何提供的 <see cref="T:System.Threading.Tasks.Task" /> 对象在指定的时间间隔内完成执行。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1060">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified time interval.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1061">已完成的任务在 <paramref name="tasks" /> 数组参数中的索引，如果发生超时，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1061">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1062">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1062">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1063"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1063">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-1064"><paramref name="timeout" /> 参数的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 属性是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1064">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is a negative number other than -1, which represents an infinite time-out.</span></span> 
<span data-ttu-id="0ddf6-1065">或</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1065">-or-</span></span> 
<span data-ttu-id="0ddf6-1066"><paramref name="timeout" /> 参数的 <see cref="P:System.TimeSpan.TotalMilliseconds" /> 属性大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1066">The <see cref="P:System.TimeSpan.TotalMilliseconds" /> property of the <paramref name="timeout" /> argument is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1067"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1067">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.Tasks.Task[] tasks, int32 millisecondsTimeout, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WaitAny(System.Threading.Tasks.Task[],System.Int32,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int WaitAny(cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks, int millisecondsTimeout, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="static member WaitAny : System.Threading.Tasks.Task[] * int * System.Threading.CancellationToken -&gt; int" Usage="System.Threading.Tasks.Task.WaitAny (tasks, millisecondsTimeout, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1068">要等待的 <see cref="T:System.Threading.Tasks.Task" /> 实例的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1068">An array of <see cref="T:System.Threading.Tasks.Task" /> instances on which to wait.</span></span></param>
        <param name="millisecondsTimeout"><span data-ttu-id="0ddf6-1069">等待的毫秒数，或为 <see cref="F:System.Threading.Timeout.Infinite" /> (-1)，表示无限期等待。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1069">The number of milliseconds to wait, or <see cref="F:System.Threading.Timeout.Infinite" /> (-1) to wait indefinitely.</span></span></param>
        <param name="cancellationToken"><span data-ttu-id="0ddf6-1070">等待任务完成期间要观察的 <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1070">A <see cref="P:System.Threading.Tasks.TaskFactory.CancellationToken" /> to observe while waiting for a task to complete.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1071">等待提供的任何 <see cref="T:System.Threading.Tasks.Task" /> 对象在指定的毫秒数内完成执行，或等到取消标记取消。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1071">Waits for any of the provided <see cref="T:System.Threading.Tasks.Task" /> objects to complete execution within a specified number of milliseconds or until a cancellation token is cancelled.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1072">已完成的任务在 <paramref name="tasks" /> 数组参数中的索引，如果发生超时，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1072">The index of the completed task in the <paramref name="tasks" /> array argument, or -1 if the timeout occurred.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="0ddf6-1073">已释放了 <see cref="T:System.Threading.Tasks.Task" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1073">The <see cref="T:System.Threading.Tasks.Task" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1074"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1074">The <paramref name="tasks" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="0ddf6-1075"><paramref name="millisecondsTimeout" /> 是一个非 -1 的负数，而 -1 表示无限期超时。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1075"><paramref name="millisecondsTimeout" /> is a negative number other than -1, which represents an infinite time-out.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1076"><paramref name="tasks" /> 参数包含一个 null 元素。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1076">The <paramref name="tasks" /> argument contains a null element.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="0ddf6-1077">已取消 <paramref name="cancellationToken" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1077">The <paramref name="cancellationToken" /> was canceled.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAll">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-1078">所有提供的任务已完成时，创建将完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1078">Creates a task that will complete when all of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (tasks As IEnumerable(Of Task)) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1079">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1079">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1080">创建一个任务，该任务将在可枚举集合中的所有 <see cref="T:System.Threading.Tasks.Task" /> 对象都已完成时完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1080">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1081">表示所有提供的任务的完成情况的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1081">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1082">如果对一组<xref:System.Threading.Tasks.Task.WhenAll%2A>任务的状态或<xref:System.Threading.Tasks.Task>任务组引发的异常感兴趣, 则通常会调用返回对象的方法的重载。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1082">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ddf6-1083">对<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>方法的调用不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1083">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="0ddf6-1084">如果任何提供的任务在出错状态下完成, 则返回的任务也将在<xref:System.Threading.Tasks.TaskStatus.Faulted>状态中完成, 在此状态下, 其异常将包含每个提供的任务的一组已包装异常的聚合。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1084">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state,  where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="0ddf6-1085">如果任何提供的任务都出现故障, 但至少其中一项已取消, 则返回的任务将以<xref:System.Threading.Tasks.TaskStatus.Canceled>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1085">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="0ddf6-1086">如果所有任务均出错并且任务都未被取消, 则生成的任务将以<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1086">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="0ddf6-1087">如果提供的数组/可枚举不包含任何任务, 则返回的任务将在<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>返回到调用方之前立即转换为状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1087">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-1088">下面的示例创建一组用于对数组中的 Url 进行 ping 操作的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1088">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="0ddf6-1089">任务存储在传递`List<Task>` <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>给方法的集合中。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1089">The tasks are stored in a `List<Task>` collection that is passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="0ddf6-1090">在对<xref:System.Threading.Tasks.Task.Wait%2A>方法的调用确保所有线程都完成后, 该示例将<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>检查属性以确定是否有任何任务出错。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1090">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll4.cs#4)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1091"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1091">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1092"><paramref name="tasks" /> 收集包含 <see langword="null" /> 任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1092">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WhenAll (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WhenAll(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll (ParamArray tasks As Task()) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1093">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1093">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1094">创建一个任务，该任务将在数组中的所有 <see cref="T:System.Threading.Tasks.Task" /> 对象都已完成时完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1094">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1095">表示所有提供的任务的完成情况的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1095">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1096">如果对一组<xref:System.Threading.Tasks.Task.WhenAll%2A>任务的状态或<xref:System.Threading.Tasks.Task>任务组引发的异常感兴趣, 则通常会调用返回对象的方法的重载。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1096">The overloads of the <xref:System.Threading.Tasks.Task.WhenAll%2A> method that return a <xref:System.Threading.Tasks.Task> object are typically called when you are interested in the status of a set of tasks or in the exceptions thrown by a set of tasks.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0ddf6-1097">对<xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29>方法的调用不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1097">The call to <xref:System.Threading.Tasks.Task.WhenAll%28System.Threading.Tasks.Task%5B%5D%29> method does not block the calling thread.</span></span>  
  
 <span data-ttu-id="0ddf6-1098">如果任何提供的任务在出错状态下完成, 则返回的任务也将在<xref:System.Threading.Tasks.TaskStatus.Faulted>状态中完成, 在此状态下, 其异常将包含每个提供的任务的一组已包装异常的聚合。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1098">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="0ddf6-1099">如果任何提供的任务都出现故障, 但至少其中一项已取消, 则返回的任务将以<xref:System.Threading.Tasks.TaskStatus.Canceled>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1099">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="0ddf6-1100">如果所有任务均出错并且任务都未被取消, 则生成的任务将以<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1100">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  
  
 <span data-ttu-id="0ddf6-1101">如果提供的数组/可枚举不包含任何任务, 则返回的任务将在<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>返回到调用方之前立即转换为状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1101">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-1102">下面的示例创建一组用于对数组中的 Url 进行 ping 操作的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1102">The following example creates a set of tasks that ping the URLs in an array.</span></span> <span data-ttu-id="0ddf6-1103">任务存储在转换为数组`List<Task>`并传递<xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29>给方法的集合中。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1103">The tasks are stored in a `List<Task>` collection that is converted to an array and passed to the <xref:System.Threading.Tasks.Task.WhenAll%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7D%29> method.</span></span> <span data-ttu-id="0ddf6-1104">在对<xref:System.Threading.Tasks.Task.Wait%2A>方法的调用确保所有线程都完成后, 该示例将<xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType>检查属性以确定是否有任何任务出错。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1104">After the call to the <xref:System.Threading.Tasks.Task.Wait%2A> method ensures that all threads have completed, the example examines the <xref:System.Threading.Tasks.Task.Status%2A?displayProperty=nameWithType> property to determine whether any tasks have faulted.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/WhenAll3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/WhenAll3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1105"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1105">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1106"><paramref name="tasks" /> 数组包含 <see langword="null" /> 任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1106">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-1107">已完成任务的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1107">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="0ddf6-1108">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1108">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1109">创建一个任务，该任务将在可枚举集合中的所有 <see cref="T:System.Threading.Tasks.Task`1" /> 对象都已完成时完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1109">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an enumerable collection have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1110">表示所有提供的任务的完成情况的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1110">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1111">对<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29>方法的调用不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1111">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Collections.Generic.IEnumerable%7BSystem.Threading.Tasks.Task%7B%60%600%7D%7D%29> method does not block the calling thread.</span></span> <span data-ttu-id="0ddf6-1112">但是, 对返回<xref:System.Threading.Tasks.Task%601.Result%2A>的属性的调用会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1112">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="0ddf6-1113">如果任何提供的任务在出错状态下完成, 则返回的任务也将在<xref:System.Threading.Tasks.TaskStatus.Faulted>状态中完成, 在此状态下, 其异常将包含每个提供的任务的一组已包装异常的聚合。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1113">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="0ddf6-1114">如果任何提供的任务都出现故障, 但至少其中一项已取消, 则返回的任务将以<xref:System.Threading.Tasks.TaskStatus.Canceled>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1114">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="0ddf6-1115">如果所有任务均出错并且任务都未被取消, 则生成的任务将以<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1115">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="0ddf6-1116">返回<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>的任务的属性将设置为一个数组, 其中包含所提供任务的所有结果, 其顺序与提供的任务的顺序相同 (例如, 如果输入任务数组包含 t1, t2, t3, 输出任务的<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>属性将返回一个`TResult[]` 。`arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1116">The <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output task's <xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType> property will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="0ddf6-1117">如果参数不包含任何任务, 则返回的任务将在返回到<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>调用方之前立即转换为状态。 `tasks`</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1117">If the `tasks` argument contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span> <span data-ttu-id="0ddf6-1118">返回`TResult[]`的将是0个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1118">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-1119">下面的示例创建了十个任务, 每个任务都实例化一个随机数生成器, 该生成器可在1到1000之间创建1000随机数, 并计算其平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1119">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="0ddf6-1120"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>方法用于延迟随机数生成器的实例化, 使其不是使用相同的种子值创建的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1120">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="0ddf6-1121">然后, 对<xref:System.Threading.Tasks.Task.WhenAll%2A>方法的调用将返回<xref:System.Int64>一个数组, 其中包含每个任务计算的平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1121">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="0ddf6-1122">然后, 将使用它们来计算整体平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1122">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall1.vb#1)]  
  
 <span data-ttu-id="0ddf6-1123">在这种情况下, 十个单独的任务存储<xref:System.Collections.Generic.List%601>在一个对象中。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1123">In this case, the ten individual tasks are stored in a <xref:System.Collections.Generic.List%601> object.</span></span> <span data-ttu-id="0ddf6-1124"><xref:System.Collections.Generic.List%601> 实现 <xref:System.Collections.Generic.IEnumerable%601> 接口。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1124"><xref:System.Collections.Generic.List%601> implements the <xref:System.Collections.Generic.IEnumerable%601> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1125"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1125">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1126"><paramref name="tasks" /> 收集包含 <see langword="null" /> 任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1126">The <paramref name="tasks" /> collection contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAll&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;TResult[]&gt; WhenAll&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;!!TResult[]&gt; WhenAll&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAll``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAll(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of TResult())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;cli::array &lt;TResult&gt; ^&gt; ^ WhenAll(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAll : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;'Result[]&gt;" Usage="System.Threading.Tasks.Task.WhenAll tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TResult[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-1127">已完成任务的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1127">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="0ddf6-1128">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1128">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1129">创建一个任务，该任务将在数组中的所有 <see cref="T:System.Threading.Tasks.Task`1" /> 对象都已完成时完成。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1129">Creates a task that will complete when all of the <see cref="T:System.Threading.Tasks.Task`1" /> objects in an array have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1130">表示所有提供的任务的完成情况的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1130">A task that represents the completion of all of the supplied tasks.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1131">对<xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29>方法的调用不会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1131">The call to <xref:System.Threading.Tasks.Task.WhenAll%60%601%28System.Threading.Tasks.Task%7B%60%600%7D%5B%5D%29> method does not block the calling thread.</span></span> <span data-ttu-id="0ddf6-1132">但是, 对返回<xref:System.Threading.Tasks.Task%601.Result%2A>的属性的调用会阻止调用线程。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1132">However, a call to the returned <xref:System.Threading.Tasks.Task%601.Result%2A> property does block the calling thread.</span></span>  
  
 <span data-ttu-id="0ddf6-1133">如果任何提供的任务在出错状态下完成, 则返回的任务也将在<xref:System.Threading.Tasks.TaskStatus.Faulted>状态中完成, 在此状态下, 其异常将包含每个提供的任务的一组已包装异常的聚合。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1133">If any of the supplied tasks completes in a faulted state, the returned task will also complete in a <xref:System.Threading.Tasks.TaskStatus.Faulted> state, where its exceptions will contain the aggregation of the set of unwrapped exceptions from each of the supplied tasks.</span></span>  
  
 <span data-ttu-id="0ddf6-1134">如果任何提供的任务都出现故障, 但至少其中一项已取消, 则返回的任务将以<xref:System.Threading.Tasks.TaskStatus.Canceled>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1134">If none of the supplied tasks faulted but at least one of them was canceled, the returned task will end in the <xref:System.Threading.Tasks.TaskStatus.Canceled> state.</span></span>  
  
 <span data-ttu-id="0ddf6-1135">如果所有任务均出错并且任务都未被取消, 则生成的任务将以<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1135">If none of the tasks faulted and none of the tasks were canceled, the resulting task will end in the <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state.</span></span>  <span data-ttu-id="0ddf6-1136">返回任务的将设置为一个数组, 其中包含所提供任务的所有结果, 这些结果的顺序与提供的任务的顺序相同 (例如, 如果输入任务数组包含 t1, t2, t3, 输出任务的<xref:System.Threading.Tasks.Task%601.Result%2A>将返回`TResult[]` <xref:System.Threading.Tasks.Task%601.Result%2A>where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1136">The <xref:System.Threading.Tasks.Task%601.Result%2A> of the returned task will be set to an array containing all of the results of the supplied tasks in the same order as they were provided (e.g. if the input tasks array contained t1, t2, t3, the output   task's <xref:System.Threading.Tasks.Task%601.Result%2A> will return an `TResult[]` where `arr[0] == t1.Result, arr[1] == t2.Result, and arr[2] == t3.Result)`.</span></span>  
  
 <span data-ttu-id="0ddf6-1137">如果提供的数组/可枚举不包含任何任务, 则返回的任务将在<xref:System.Threading.Tasks.TaskStatus.RanToCompletion>返回到调用方之前立即转换为状态。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1137">If the supplied array/enumerable contains no tasks, the returned task will immediately transition to a <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state before it's returned to the caller.</span></span>  <span data-ttu-id="0ddf6-1138">返回`TResult[]`的将是0个元素的数组。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1138">The returned `TResult[]` will be an array of 0 elements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0ddf6-1139">下面的示例创建了十个任务, 每个任务都实例化一个随机数生成器, 该生成器可在1到1000之间创建1000随机数, 并计算其平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1139">The following example creates ten tasks, each of which instantiates a random number generator that creates 1,000 random numbers between 1 and 1,000 and computes their mean.</span></span> <span data-ttu-id="0ddf6-1140">在这种情况下, 十个单独的任务存储`Task<Int64>`在一个数组中。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1140">In this case, the ten individual tasks are stored in a `Task<Int64>` array.</span></span>  <span data-ttu-id="0ddf6-1141"><xref:System.Threading.Tasks.Task.Delay%28System.Int32%29>方法用于延迟随机数生成器的实例化, 使其不是使用相同的种子值创建的。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1141">The <xref:System.Threading.Tasks.Task.Delay%28System.Int32%29> method is used to delay instantiation of the random number generators so that they are not created with identical seed values.</span></span> <span data-ttu-id="0ddf6-1142">然后, 对<xref:System.Threading.Tasks.Task.WhenAll%2A>方法的调用将返回<xref:System.Int64>一个数组, 其中包含每个任务计算的平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1142">The call to the <xref:System.Threading.Tasks.Task.WhenAll%2A> method then returns an <xref:System.Int64> array that contains the mean computed by each task.</span></span> <span data-ttu-id="0ddf6-1143">然后, 将使用它们来计算整体平均值。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1143">These are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/cs/whenall2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.WhenAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.whenall/vb/whenall2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1144"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1144">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1145"><paramref name="tasks" /> 数组包含 <see langword="null" /> 任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1145">The <paramref name="tasks" /> array contained a <see langword="null" /> task.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="WhenAny">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0ddf6-1146">任何提供的任务已完成时，创建将完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1146">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (tasks As IEnumerable(Of Task)) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1147">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1147">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1148">任何提供的任务已完成时，创建将完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1148">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1149">表示提供的任务之一已完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1149">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="0ddf6-1150">返回任务的结果是完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1150">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1151">当任何提供的任务完成时, 将完成返回的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1151">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="0ddf6-1152">返回的任务将始终以`RanToCompletion`状态结束, 并将其结果集设置为要完成的第一个任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1152">The returned task will always end in the `RanToCompletion` state  with its Result set to the first task to complete.</span></span>  <span data-ttu-id="0ddf6-1153">即使完成的第一个任务以`Canceled`或`Faulted`状态结束, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1153">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1154"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1154">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1155"><paramref name="tasks" /> 数组包含了 null 任务，或为空。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1155">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt; WhenAny (params System.Threading.Tasks.Task[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task&gt; WhenAny(class System.Threading.Tasks.Task[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny(System.Threading.Tasks.Task[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny (ParamArray tasks As Task()) As Task(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="tasks"><span data-ttu-id="0ddf6-1156">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1156">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1157">任何提供的任务已完成时，创建将完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1157">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1158">表示提供的任务之一已完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1158">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="0ddf6-1159">返回任务的结果是完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1159">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1160">当任何提供的任务完成时, 将完成返回的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1160">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="0ddf6-1161">返回的任务将始终以其`RanToCompletion` `Result`设置为要完成的第一个任务的状态结束。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1161">The returned task will always end in the `RanToCompletion` state   with its `Result` set to the first task to complete.</span></span>  <span data-ttu-id="0ddf6-1162">即使完成的第一个任务以`Canceled`或`Faulted`状态结束, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1162">This is true even if the first task to complete ended in the `Canceled` or `Faulted` state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1163"><paramref name="tasks" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1163">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1164"><paramref name="tasks" /> 数组包含了 null 任务，或为空。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1164">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (tasks As IEnumerable(Of Task(Of TResult))) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : seq&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-1165">已完成任务的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1165">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="0ddf6-1166">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1166">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1167">任何提供的任务已完成时，创建将完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1167">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1168">表示提供的任务之一已完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1168">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="0ddf6-1169">返回任务的结果是完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1169">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1170">当任何提供的任务完成时, 将完成返回的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1170">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="0ddf6-1171">返回的任务将始终以 RanToCompletion 状态结束, 并将其结果集设置为要完成的第一个任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1171">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="0ddf6-1172">即使完成的第一个任务以 "已取消" 或 "出错" 状态结束, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1172">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1173"><paramref name="tasks" /> 参数为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1173">The <paramref name="tasks" /> argument was <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1174"><paramref name="tasks" /> 数组包含了 null 任务，或为空。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1174">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="WhenAny&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; WhenAny&lt;TResult&gt; (params System.Threading.Tasks.Task&lt;TResult&gt;[] tasks);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;class System.Threading.Tasks.Task`1&lt;!!TResult&gt;&gt; WhenAny&lt;TResult&gt;(class System.Threading.Tasks.Task`1&lt;!!TResult&gt;[] tasks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.WhenAny``1(System.Threading.Tasks.Task{``0}[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WhenAny(Of TResult) (ParamArray tasks As Task(Of TResult)()) As Task(Of Task(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TResult&gt;&#xA; static System::Threading::Tasks::Task&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ WhenAny(... cli::array &lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ tasks);" />
      <MemberSignature Language="F#" Value="static member WhenAny : System.Threading.Tasks.Task&lt;'Result&gt;[] -&gt; System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt;" Usage="System.Threading.Tasks.Task.WhenAny tasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tasks" Type="System.Threading.Tasks.Task&lt;TResult&gt;[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TResult"><span data-ttu-id="0ddf6-1175">已完成任务的类型。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1175">The type of the completed task.</span></span></typeparam>
        <param name="tasks"><span data-ttu-id="0ddf6-1176">等待完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1176">The tasks to wait on for completion.</span></span></param>
        <summary><span data-ttu-id="0ddf6-1177">任何提供的任务已完成时，创建将完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1177">Creates a task that will complete when any of the supplied tasks have completed.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1178">表示提供的任务之一已完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1178">A task that represents the completion of one of the supplied tasks.</span></span>  <span data-ttu-id="0ddf6-1179">返回任务的结果是完成的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1179">The return task's Result is the task that completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1180">当任何提供的任务完成时, 将完成返回的任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1180">The returned task will complete when any of the supplied tasks has completed.</span></span>  <span data-ttu-id="0ddf6-1181">返回的任务将始终以 RanToCompletion 状态结束, 并将其结果集设置为要完成的第一个任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1181">The returned task will always end in the RanToCompletion state with its Result set to the first task to complete.</span></span> <span data-ttu-id="0ddf6-1182">即使完成的第一个任务以 "已取消" 或 "出错" 状态结束, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1182">This is true even if the first task to complete ended in the Canceled or Faulted state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="0ddf6-1183"><paramref name="tasks" /> 参数为 null。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1183">The <paramref name="tasks" /> argument was null.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="0ddf6-1184"><paramref name="tasks" /> 数组包含了 null 任务，或为空。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1184">The <paramref name="tasks" /> array contained a null task, or was empty.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static System.Runtime.CompilerServices.YieldAwaitable Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.CompilerServices.YieldAwaitable Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As YieldAwaitable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::CompilerServices::YieldAwaitable Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; System.Runtime.CompilerServices.YieldAwaitable" Usage="System.Threading.Tasks.Task.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.YieldAwaitable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="0ddf6-1185">创建异步产生当前上下文的等待任务。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1185">Creates an awaitable task that asynchronously yields back to the current context when awaited.</span></span></summary>
        <returns><span data-ttu-id="0ddf6-1186">等待时，上下文将异步转换回等待时的当前上下文。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1186">A context that, when awaited, will asynchronously transition back into the current context at the time of the await.</span></span> <span data-ttu-id="0ddf6-1187">如果当前 <see cref="T:System.Threading.SynchronizationContext" /> 不为 null，则将其视为当前上下文。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1187">If the current <see cref="T:System.Threading.SynchronizationContext" /> is non-null, it is treated as the current context.</span></span> <span data-ttu-id="0ddf6-1188">否则，与当前执行任务关联的任务计划程序将视为当前上下文。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1188">Otherwise, the task scheduler that is associated with the currently executing task is treated as the current context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0ddf6-1189">可以在异步`await Task.Yield();`方法中使用来强制异步完成方法。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1189">You can use `await Task.Yield();` in an asynchronous method to force the method to complete asynchronously.</span></span> <span data-ttu-id="0ddf6-1190">如果存在当前的同步上下文 (<xref:System.Threading.SynchronizationContext>对象), 则这会将该方法的其余执行内容发布回该上下文。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1190">If there is a current synchronization context (<xref:System.Threading.SynchronizationContext> object), this will post the remainder of the method's execution back to that context.</span></span> <span data-ttu-id="0ddf6-1191">但是, 上下文将决定如何将此工作的优先级设置为相对于可能挂起的其他工作。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1191">However, the context will decide how to prioritize this work relative to other work that may be pending.</span></span> <span data-ttu-id="0ddf6-1192">大多数 UI 环境中的 UI 线程上出现的同步上下文通常会将发布到上下文的工作的优先级设置为高于输入和呈现工作的优先级。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1192">The synchronization context that is present on a UI thread in most UI environments will often prioritize work posted to the context higher than input and rendering work.</span></span> <span data-ttu-id="0ddf6-1193">出于此原因, 请不要依赖`await Task.Yield();`于保持 UI 的响应能力。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1193">For this reason, do not rely on `await Task.Yield();` to keep a UI responsive.</span></span>  <span data-ttu-id="0ddf6-1194">有关详细信息, 请参阅通过 .NET 并行编程中的[System.threading.tasks.task.continuewith 启用的有用抽象](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/)博客。</span><span class="sxs-lookup"><span data-stu-id="0ddf6-1194">For more information, see the entry [Useful Abstractions Enabled with ContinueWith](https://devblogs.microsoft.com/pfxteam/useful-abstractions-enabled-with-continuewith/) in the Parallel Programming with .NET blog.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
