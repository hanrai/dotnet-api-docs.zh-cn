<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="67b64376dfff70efe0d957992c978ec33c4627ac" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68399018" /></Metadata><TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="09849-101">为用于监视缓存项所依赖数据的状态更改的派生自定义类型提供基类。</span><span class="sxs-lookup"><span data-stu-id="09849-101">Provides a base class for a derived custom type that monitors changes in the state of the data which a cache item depends on.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-102"><xref:System.Runtime.Caching.ChangeMonitor>类用作专用于特定缓存实现的派生监视器类的基类。</span><span class="sxs-lookup"><span data-stu-id="09849-102">The <xref:System.Runtime.Caching.ChangeMonitor> class is used as the base class for derived monitor classes that are specialized for particular cache implementations.</span></span> <span data-ttu-id="09849-103"><xref:System.Runtime.Caching.ChangeMonitor>实例监视缓存项所依赖的数据的状态更改。</span><span class="sxs-lookup"><span data-stu-id="09849-103">A <xref:System.Runtime.Caching.ChangeMonitor> instance monitors changes in the state of data which a cache item depends on.</span></span> <span data-ttu-id="09849-104">例如, 该项可以是其内容被缓存的文件或数据实体。</span><span class="sxs-lookup"><span data-stu-id="09849-104">For example, the item can be a file or data entity whose contents are cached.</span></span> <span data-ttu-id="09849-105">如果更新了文件或数据实体, 则还必须更改关联的缓存项。</span><span class="sxs-lookup"><span data-stu-id="09849-105">If the file or data entity is updated, the associated cache entry must be changed also.</span></span> <span data-ttu-id="09849-106">可监视的常见项包括数据实体 (如数据库字段、值、行或表)、其他缓存项以及文件和文件属性。</span><span class="sxs-lookup"><span data-stu-id="09849-106">Common items that can be monitored include data entities (such as database fields, values, rows, or tables), another cache entry, and files and file attributes.</span></span>  
  
 <span data-ttu-id="09849-107">依赖关系更改是依赖项状态的更改。</span><span class="sxs-lookup"><span data-stu-id="09849-107">A dependency change is a change in the state of a dependency.</span></span> <span data-ttu-id="09849-108">在典型的缓存实现中, <xref:System.Runtime.Caching.ChangeMonitor>在实例通知缓存依赖项已更改时, 缓存将执行所需的操作, 例如使插入的缓存项无效。</span><span class="sxs-lookup"><span data-stu-id="09849-108">In a typical cache implementation, after a <xref:System.Runtime.Caching.ChangeMonitor> instance notifies the cache that a dependency has changed, the cache performs the required action, such as invalidating the inserted cache entry.</span></span>  
  
 <span data-ttu-id="09849-109">可以<xref:System.Runtime.Caching.ChangeMonitor>自定义派生类, 以监视特定不同数据存储的依赖项更改。</span><span class="sxs-lookup"><span data-stu-id="09849-109">Derived <xref:System.Runtime.Caching.ChangeMonitor> classes can be customized to monitor dependency changes for specific different data stores.</span></span> <span data-ttu-id="09849-110">例如, 文件系统、物理内存或数据库有缓存实现。</span><span class="sxs-lookup"><span data-stu-id="09849-110">For example, there are cache implementations for a file system, physical memory, or a database.</span></span> <span data-ttu-id="09849-111"><xref:System.Runtime.Caching.ChangeMonitor>类可检查缓存外发生的更改, 然后在缓存发生更改时发出警报。</span><span class="sxs-lookup"><span data-stu-id="09849-111">The <xref:System.Runtime.Caching.ChangeMonitor> class examines changes that occur outside the cache, and then alerts the cache that changes have occurred.</span></span>  
  
 <span data-ttu-id="09849-112">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]包括从<xref:System.Runtime.Caching.ChangeMonitor>类派生的以下类:</span><span class="sxs-lookup"><span data-stu-id="09849-112">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] includes the following classes that derive from <xref:System.Runtime.Caching.ChangeMonitor> class:</span></span>  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 <span data-ttu-id="09849-113">其中每个类都适用于不同类型的依赖项。</span><span class="sxs-lookup"><span data-stu-id="09849-113">Each of these classes works with different types of dependencies.</span></span> <span data-ttu-id="09849-114">例如, 派生<xref:System.Runtime.Caching.FileChangeMonitor>类监视缓存项所依赖的文件系统数据 (文件和文件夹) 的缓存更改。</span><span class="sxs-lookup"><span data-stu-id="09849-114">For example, the derived <xref:System.Runtime.Caching.FileChangeMonitor> class monitors changes to a cache for file system data (files and folders) that the cache item depends on.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="09849-115">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="09849-115">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="09849-116">如果创建自定义缓存实现或派生的更改监视器类型, 则必须遵循特定的准则。</span><span class="sxs-lookup"><span data-stu-id="09849-116">If you create a custom cache implementation or a derived change monitor type, you must follow certain guidelines.</span></span> <span data-ttu-id="09849-117">下面的列表总结了这些准则。</span><span class="sxs-lookup"><span data-stu-id="09849-117">The following list summarizes these guidelines.</span></span> <span data-ttu-id="09849-118">有关详细信息, 请参阅各个方法或属性的文档。</span><span class="sxs-lookup"><span data-stu-id="09849-118">For more information, see the documentation for individual methods or properties.</span></span>  
  
<span data-ttu-id="09849-119">-派生类的构造函数必须在方法返回<see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />之前设置属性、开始监视和<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-119">-   The constructor of a derived class must set the <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> property, begin monitoring, and call <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method before the method returns.</span></span> <span data-ttu-id="09849-120">如果构造函数在构造过程中遇到错误并且必须释放资源, 则构造<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />函数只能在调用<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />方法后调用重载, 因为重载将引发<see cref="T:System.InvalidOperationException" />如果初始化未完成, 则为异常。</span><span class="sxs-lookup"><span data-stu-id="09849-120">If a constructor encounters an error during constructions and must have to dispose of resources, the constructor can only call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload after the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method is called because the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload will throw an <see cref="T:System.InvalidOperationException" /> exception if initialization is not completed.</span></span>  
  
<span data-ttu-id="09849-121">-如果在初始化完成之前所监视的数据发生更改, 则构造函数必须在<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />调用方法之前调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-121">-   If changes occur in the data that is being monitored before initialization is complete, the constructor must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method before calling the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method.</span></span>  
  
<span data-ttu-id="09849-122">-实例化派生<see cref="T:System.Runtime.Caching.ChangeMonitor" />类型后, 必须将监视器插入到自定义<see cref="T:System.Runtime.Caching.ObjectCache" />实现中。</span><span class="sxs-lookup"><span data-stu-id="09849-122">-   After a derived <see cref="T:System.Runtime.Caching.ChangeMonitor" /> type is instantiated, you must insert the monitor into a custom <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation.</span></span> <span data-ttu-id="09849-123">或者, 如果使用了更改监视器, 请调用<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />方法。</span><span class="sxs-lookup"><span data-stu-id="09849-123">Or if you are finished using the change monitor, call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method.</span></span>  
  
<span data-ttu-id="09849-124">-在将<see cref="T:System.Runtime.Caching.ChangeMonitor" />实例插入<see cref="T:System.Runtime.Caching.ObjectCache" />到实现中后, <see cref="T:System.Runtime.Caching.ObjectCache" />实例要求释放更改监视器。</span><span class="sxs-lookup"><span data-stu-id="09849-124">-   After a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance is inserted into a <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation, the <see cref="T:System.Runtime.Caching.ObjectCache" /> instance require that the change monitor is disposed.</span></span> <span data-ttu-id="09849-125">即使插入无效并引发异常, <see cref="T:System.Runtime.Caching.ObjectCache" />实现也必须<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />调用重载。</span><span class="sxs-lookup"><span data-stu-id="09849-125">Even if the insertion is invalid and causes an exception, the <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation must call the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload.</span></span>  
  
<span data-ttu-id="09849-126">-在将派生的更改监视器插入缓存后, <see cref="T:System.Runtime.Caching.ObjectCache" />实现必须通过传递<see cref="T:System.Runtime.Caching.OnChangedCallback" />对象<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />调用。</span><span class="sxs-lookup"><span data-stu-id="09849-126">-   After a derived change monitor is inserted into a cache, the <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation must call <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, by passing a <see cref="T:System.Runtime.Caching.OnChangedCallback" /> object.</span></span> <span data-ttu-id="09849-127"><see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />方法只能调用一次。</span><span class="sxs-lookup"><span data-stu-id="09849-127">The <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method can be called only one time.</span></span> <span data-ttu-id="09849-128">如果已发生依赖项更改, 则在<see cref="T:System.Runtime.Caching.OnChangedCallback" />调用时会<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />立即调用该实例。</span><span class="sxs-lookup"><span data-stu-id="09849-128">If a dependency change has already occurred, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called immediately when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called.</span></span> <span data-ttu-id="09849-129">否则, <see cref="T:System.Runtime.Caching.OnChangedCallback" />将只调用一次实例。</span><span class="sxs-lookup"><span data-stu-id="09849-129">Otherwise, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called only one time.</span></span> <span data-ttu-id="09849-130">当调用<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />方法时, 如果<see cref="T:System.Runtime.Caching.ChangeMonitor" />实例检测到更改, 则会发生这种一次性调用, 或在上调用方法时出现这种情况。 <see cref="T:System.Runtime.Caching.ChangeMonitor" /></span><span class="sxs-lookup"><span data-stu-id="09849-130">This one time call occurs either when the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called because the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance detected a change, or when the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called on the <see cref="T:System.Runtime.Caching.ChangeMonitor" />, whichever occurs first.</span></span>  
  
<span data-ttu-id="09849-131">-由实现提供的<see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> 实例应移除关联的缓存项,并使用枚举指定一个原因。<see cref="T:System.Runtime.Caching.OnChangedCallback" /> <see cref="T:System.Runtime.Caching.ObjectCache" /></span><span class="sxs-lookup"><span data-stu-id="09849-131">-   The <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance that is provided by an <see cref="T:System.Runtime.Caching.ObjectCache" /> implementation should remove the associated cache entry and specify a reason by using the <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> enumeration.</span></span>  
  
<span data-ttu-id="09849-132">-在<see cref="T:System.Runtime.Caching.ChangeMonitor" />缓存实现调用<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />方法<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />之前或之后, 实例可以调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-132">-   A <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method either before a cache implementation has called <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method or after.</span></span> <span data-ttu-id="09849-133"><see cref="T:System.Runtime.Caching.ChangeMonitor" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />如果在调用之前<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />调用方法,则基实现将通知缓存此已发生此情况,并将在调用时触发要立即传递给的回调。<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /></span><span class="sxs-lookup"><span data-stu-id="09849-133">If the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called before <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called, the base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> implementation will notify the cache that this has occurred and will trigger the callback to be passed to <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> immediately when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is invoked.</span></span> <span data-ttu-id="09849-134">传递给<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />方法的任何状态数据均由更改监视器保存, 并在调用<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />方法时传递<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />给方法。</span><span class="sxs-lookup"><span data-stu-id="09849-134">Any state data that is passed to the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is saved by the change monitor and subsequently passed to the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method when the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method is invoked.</span></span>  
  
<span data-ttu-id="09849-135">-更改监视器必须实现<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />方法。</span><span class="sxs-lookup"><span data-stu-id="09849-135">-   A change monitor must implement the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method.</span></span> <span data-ttu-id="09849-136">有关更多信息，请参见 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 方法文档。</span><span class="sxs-lookup"><span data-stu-id="09849-136">For more information, see the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method documentation.</span></span>  
  
<span data-ttu-id="09849-137">-必须调用<see cref="T:System.Runtime.Caching.ChangeMonitor" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />方法重载才能释放实例。</span><span class="sxs-lookup"><span data-stu-id="09849-137">-   The <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method overload must be called to dispose of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.</span></span> <span data-ttu-id="09849-138">调用 Dispose 的规则如下所示:</span><span class="sxs-lookup"><span data-stu-id="09849-138">The rules for calling Dispose are as follows:</span></span> 
<span data-ttu-id="09849-139">-在将某个项插入缓存之前, 调用方负责释放<see cref="T:System.Runtime.Caching.ChangeMonitor" />实例。</span><span class="sxs-lookup"><span data-stu-id="09849-139">-   Before an item is inserted into the cache, it is the responsibility of caller to dispose of a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.</span></span>  
  
<span data-ttu-id="09849-140">-一旦缓存项及其关联<see cref="T:System.Runtime.Caching.ChangeMonitor" />的实例被传递给缓存, 缓存实施者必须确保<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />调用方法, 即使插入操作失败也是如此。</span><span class="sxs-lookup"><span data-stu-id="09849-140">-   Once cache item and the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances that are associated with it are passed to a cache, the cache implementer must make sure that the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, even if the insert fails.</span></span>  
  
<span data-ttu-id="09849-141">-将项及其关联<see cref="T:System.Runtime.Caching.ChangeMonitor" />的实例传递给缓存后, 调用方不能释放依赖项, 因为调用<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />方法时, 调用将被视为依赖项已更改。</span><span class="sxs-lookup"><span data-stu-id="09849-141">-   After an item and its associated <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instances are passed to a cache, the caller must not dispose the dependency because when the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, the call is treated as if the dependency has changed.</span></span> <span data-ttu-id="09849-142">因此, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />会自动调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-142">As a result, the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is automatically invoked.</span></span>  
  
<span data-ttu-id="09849-143">-若要考虑这些规则, 必须<see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />通过以下方式之一调用该方法:</span><span class="sxs-lookup"><span data-stu-id="09849-143">-   Taking these rules into consideration, the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method must be called in one of the following ways:</span></span> 
<span data-ttu-id="09849-144">-如果用户决定不<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />将派生的更改监视器实例插入到缓存中, 则必须调用方法重载。</span><span class="sxs-lookup"><span data-stu-id="09849-144">-   Users must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method overload if they decide not to insert the derived change-monitor instance into a cache.</span></span>  
  
<span data-ttu-id="09849-145">-如果实现尝试将更改监视器实例插入对象缓存但插入失败, 则缓存实现将负责调用<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />重载。</span><span class="sxs-lookup"><span data-stu-id="09849-145">-   If the implementation tries to insert the change-monitor instance into an object cache but the insertion fails, the cache implementation is responsible for calling the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> overload.</span></span> <span data-ttu-id="09849-146">当插入尝试导致异常时, 缓存实现必须释放任何关联的依赖项。</span><span class="sxs-lookup"><span data-stu-id="09849-146">When the insertion attempt causes an exception, the cache implementation must dispose of any associated dependencies.</span></span>  
  
<span data-ttu-id="09849-147">-如果缓存项已移除, 则缓存实现也必须释放依赖项。</span><span class="sxs-lookup"><span data-stu-id="09849-147">-   If the cache entry is removed, the cache implementation must also dispose of the dependency.</span></span>  
  
<span data-ttu-id="09849-148">-方法在调用通过<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />注册的回调后, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />会自动调用方法。 <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /></span><span class="sxs-lookup"><span data-stu-id="09849-148">-   The internal implementation of the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method automatically calls the <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> method after it calls a callback that is registered through <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.</span></span>  
  
 <block subset="none" type="note"><para>  
 <span data-ttu-id="09849-149">仅当之前已完成<see cref="T:System.Runtime.Caching.ChangeMonitor" />实例的初始化时, 才会在事件激发期间自动调用 dispose 方法。</span><span class="sxs-lookup"><span data-stu-id="09849-149">This automatic call to the dispose method during the event firing only occurs if the initialization of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance was previously completed.</span></span>  
  
</para></block>  
  
 <span data-ttu-id="09849-150">当派生的更改监视器的构造函数调用<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />方法时, 如果更改监视器的状态已更改 (即, 当构造函数仍处于活动状态时所监视的状态已更改) <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> , 则方法将自动释放更改监视器。</span><span class="sxs-lookup"><span data-stu-id="09849-150">When a derived change monitor's constructor calls the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method, if the state of the change monitor has already changed (that is, the state that is monitored already changed when the constructor was still active) then the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method will automatically dispose of the change monitor.</span></span>  
  
<span data-ttu-id="09849-151"><see cref="T:System.Runtime.Caching.OnChangedCallback" /> <see langword="true" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> -当派生的更改监视器实例调用<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />方法之后, 无论是否已通过调用方法来设置对象,属性都设置为。<see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /></span><span class="sxs-lookup"><span data-stu-id="09849-151">-   The <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> property is set to <see langword="true" /> after the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called by the derived change-monitor instance, regardless of whether a <see cref="T:System.Runtime.Caching.OnChangedCallback" /> object has been set by a call to the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method or not.</span></span></para></block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce"><span data-ttu-id="09849-152">ASP.NET 缓存</span><span class="sxs-lookup"><span data-stu-id="09849-152">ASP.NET Caching</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09849-153">初始化 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="09849-153">Initializes a new instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span> <span data-ttu-id="09849-154">从派生类中的构造函数调用此构造函数以初始化基类。</span><span class="sxs-lookup"><span data-stu-id="09849-154">This constructor is called from constructors in derived classes to initialize the base class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-155"><xref:System.Runtime.Caching.ChangeMonitor>类具有无参数的构造函数。</span><span class="sxs-lookup"><span data-stu-id="09849-155">The <xref:System.Runtime.Caching.ChangeMonitor> class has a parameterless constructor.</span></span> <span data-ttu-id="09849-156">但是, 从基类<xref:System.Runtime.Caching.ChangeMonitor>继承并定义自定义更改监视行为的类必须在构造函数中执行初始化。</span><span class="sxs-lookup"><span data-stu-id="09849-156">However, classes that inherit from the base <xref:System.Runtime.Caching.ChangeMonitor> class and define custom change-monitoring behavior must perform initialization in the constructor.</span></span> <span data-ttu-id="09849-157">有关详细信息, 请参阅对继承者的说明部分。</span><span class="sxs-lookup"><span data-stu-id="09849-157">For more information, see the Notes for Inheritors section.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="09849-158">派生类的构造函数必须设置<see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />属性, 开始监视, 然后在返回<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />类之前调用类。</span><span class="sxs-lookup"><span data-stu-id="09849-158">The constructor of a derived class must set the <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> property, begin monitoring, and call the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> class before it returns.</span></span> <span data-ttu-id="09849-159">如果在初始化完成之前依赖项发生更改 (例如, 如果在缓存中找不到依赖缓存键), 则构造函数必须先调用<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />方法, 然后再<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-159">If a dependency changes before initialization is complete (for example, if a dependent cache key is not found in the cache), the constructor must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method before it calls the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method.</span></span> <span data-ttu-id="09849-160">在这种情况下, 构造函数<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />只能<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />在调用方法后调用方法, 因为如果<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />初始化未完成, 则该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="09849-160">In this case, constructor can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method only after the <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method is called, because the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method throws an exception if initialization is not completed.</span></span></para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="09849-161">释放 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 类的当前实例所使用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="09849-161">Releases all resources used by the current instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-162"><xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法用于<xref:System.Runtime.Caching.ChangeMonitor>释放实例和相关资源。</span><span class="sxs-lookup"><span data-stu-id="09849-162">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is used to release the <xref:System.Runtime.Caching.ChangeMonitor> instance and related resources.</span></span> <span data-ttu-id="09849-163">调用公共<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法来协调处置过程与派生的更改监视器类 (如初始化) 的密钥生命周期事件, 并<xref:System.Runtime.Caching.ChangeMonitor>释放实例, 以便可以对实例进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="09849-163">The public <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is invoked to coordinate the disposal process with key life-cycle events of derived change-monitor classes (such as initialization), and to release the <xref:System.Runtime.Caching.ChangeMonitor> instance so that the instance can be garbage collected.</span></span> <span data-ttu-id="09849-164"><xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法由派生的更改监视器类实现, 以释放其托管和非托管资源。</span><span class="sxs-lookup"><span data-stu-id="09849-164">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is implemented by derived change-monitor classes to dispose of their managed and unmanaged resources.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09849-165">释放由 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 类的当前实例占用的所有资源。</span><span class="sxs-lookup"><span data-stu-id="09849-165">Releases all resources that are used by the current instance of the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-166">第一次调用<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> 方法时,该方法只调用一次派生类的方法。<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A></span><span class="sxs-lookup"><span data-stu-id="09849-166">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method invokes the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method of derived classes only one time, the first time it is called.</span></span> <span data-ttu-id="09849-167">对方法的<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>后续调用不起作用。</span><span class="sxs-lookup"><span data-stu-id="09849-167">Subsequent calls to the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method have no effect.</span></span> <span data-ttu-id="09849-168">调用方法后, <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A>属性设置为。 `true`</span><span class="sxs-lookup"><span data-stu-id="09849-168">After the method has been called, the <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> property is set to `true`.</span></span>  
  
 <span data-ttu-id="09849-169"><xref:System.Runtime.Caching.ChangeMonitor>必须调用<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>重载才能释放实例。</span><span class="sxs-lookup"><span data-stu-id="09849-169">The <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload must be called to dispose of a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span> <span data-ttu-id="09849-170">下面是用于调用 dispose 方法的规则:</span><span class="sxs-lookup"><span data-stu-id="09849-170">The following are the rules for calling the dispose method:</span></span>  
  
-   <span data-ttu-id="09849-171">在将某个项插入缓存之前, 调用方负责释放<xref:System.Runtime.Caching.ChangeMonitor>实例。</span><span class="sxs-lookup"><span data-stu-id="09849-171">Before an item is inserted into the cache, it is the caller's responsibility to dispose of a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span>  
  
-   <span data-ttu-id="09849-172">缓存项及其关联的<xref:System.Runtime.Caching.ChangeMonitor>实例被传递到缓存后, 必须<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>确保调用的缓存实施者, 即使插入失败也是如此。</span><span class="sxs-lookup"><span data-stu-id="09849-172">Once cache item and the <xref:System.Runtime.Caching.ChangeMonitor> instances that are associated with it are passed to a cache, the cache implementer that must make sure that <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> is called, even if the insert fails.</span></span>  
  
-   <span data-ttu-id="09849-173">将项及其关联<xref:System.Runtime.Caching.ChangeMonitor>的实例传递给缓存后, 调用方不能释放依赖项, 因为调用<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法时, 调用将被视为依赖项已更改。</span><span class="sxs-lookup"><span data-stu-id="09849-173">After an item and its associated <xref:System.Runtime.Caching.ChangeMonitor> instances are passed to a cache, the caller must not dispose the dependency because when the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method is called, the call is treated as if the dependency has changed.</span></span> <span data-ttu-id="09849-174">因此, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>会自动调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-174">As a result, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is automatically invoked.</span></span>  
  
-   <span data-ttu-id="09849-175">考虑这些规则时, 必须通过<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>以下方式之一调用该方法:</span><span class="sxs-lookup"><span data-stu-id="09849-175">Taking these rules into consideration, the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method must be called in one of the following ways:</span></span>  
  
    -   <span data-ttu-id="09849-176">如果用户决定不<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>将派生的更改监视器实例插入到缓存中, 则必须调用方法重载。</span><span class="sxs-lookup"><span data-stu-id="09849-176">Users must call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method overload if they decide not to insert the derived change-monitor instance into a cache.</span></span>  
  
    -   <span data-ttu-id="09849-177">如果实现尝试将更改监视器实例插入<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>对象缓存但插入失败, 则缓存实现负责调用重载。</span><span class="sxs-lookup"><span data-stu-id="09849-177">The cache implementation is responsible for calling the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> overload if the implementation tries to insert the change-monitor instance into an object cache but the insertion fails.</span></span> <span data-ttu-id="09849-178">当插入尝试导致异常时, 缓存实现必须释放任何关联的依赖项。</span><span class="sxs-lookup"><span data-stu-id="09849-178">When the insertion attempt causes an exception, the cache implementation must dispose any associated dependencies.</span></span>  
  
    -   <span data-ttu-id="09849-179">如果删除了该缓存项, 则缓存实现也必须释放该依赖项。</span><span class="sxs-lookup"><span data-stu-id="09849-179">If the cache entry is removed, the cache implementation must also dispose the dependency.</span></span>  
  
 <span data-ttu-id="09849-180">方法在调用通过<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>方法注册的回调后, 会自动调用方法。 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A></span><span class="sxs-lookup"><span data-stu-id="09849-180">The internal implementation of the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method automatically calls the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method after it calls a callback that is registered through the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09849-181">仅当之前已完成的<xref:System.Runtime.Caching.ChangeMonitor>实例初始化时才会触发事件时的自动释放。</span><span class="sxs-lookup"><span data-stu-id="09849-181">This automatic dispose during the event firing only occurs if the initialization of the <xref:System.Runtime.Caching.ChangeMonitor> instance previously completed.</span></span>  
  
 <span data-ttu-id="09849-182">当派生的更改监视器的构造函数调用<xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>方法时, 如果更改监视器的状态已更改 (即, 当构造函数仍处于活动状态时, 所监视的状态已发生更改), 则<xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>方法将自动释放更改监视器。</span><span class="sxs-lookup"><span data-stu-id="09849-182">When a derived change monitor's constructor calls the <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method, if the state of the change monitor has already changed (that is, the state that is monitored has already changed when the constructor was still active) then <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method will automatically dispose the change monitor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09849-183">用户不应调用<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09849-183">Users should not call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method.</span></span> <span data-ttu-id="09849-184">但是, 您不能阻止用户调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-184">However, you cannot prevent users from calling the method.</span></span> <span data-ttu-id="09849-185">因此, 如果这样做, 将<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-185">Therefore, if they do, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is invoked.</span></span> <span data-ttu-id="09849-186">在这种情况下, 将通知缓存项, 就好像依赖项发生了更改。</span><span class="sxs-lookup"><span data-stu-id="09849-186">In that case, the cache entry is notified as if the dependency has changed.</span></span>  
  
 <span data-ttu-id="09849-187">若要防止派生类使用<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>重写方法, 该方法不是显式接口实现。</span><span class="sxs-lookup"><span data-stu-id="09849-187">To prevent derived classes from overriding <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method, the method is not an explicit interface implementation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09849-188">在调用 <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> 基方法的派生更改监视器类中，初始化未完成。</span><span class="sxs-lookup"><span data-stu-id="09849-188">Initialization is not complete in the derived change-monitor class that called the base <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method.</span></span></exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="09849-189">若要释放托管资源和非托管资源，以及对 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 实例的任何引用，则为 <see langword="true" />；若要仅释放非托管资源，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09849-189"><see langword="true" /> to release managed and unmanaged resources and any references to a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance; <see langword="false" /> to release only unmanaged resources.</span></span> <span data-ttu-id="09849-190">传递 <see langword="false" /> 时，<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 方法由 <see langword="finalizer" /> 线程调用，所有外部托管引用由于已经作为垃圾回收，因此可能不再有效。</span><span class="sxs-lookup"><span data-stu-id="09849-190">When <see langword="false" /> is passed, the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method is called by a <see langword="finalizer" /> thread and any external managed references are likely no longer valid because they have already been garbage collected.</span></span></param>
        <summary><span data-ttu-id="09849-191">释放所有托管资源和非托管资源，以及对 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 实例的任何引用。</span><span class="sxs-lookup"><span data-stu-id="09849-191">Releases all managed and unmanaged resources and any references to the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance.</span></span> <span data-ttu-id="09849-192">此重载必须由派生的更改监视器类实现。</span><span class="sxs-lookup"><span data-stu-id="09849-192">This overload must be implemented by derived change-monitor classes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-193">当`disposing` value 的值为`true`时, 将释放所有托管资源和非托管资源并释放对此对象的任何引用, 以便可以对派生的更改监视器实例进行垃圾回收。</span><span class="sxs-lookup"><span data-stu-id="09849-193">When the value of `disposing` value is `true`, all managed and unmanaged resources are disposed and any references to this object are released so that the derived change-monitor instance can be garbage collected.</span></span> <span data-ttu-id="09849-194">保证基<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法只调用一次已实现<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>的方法。</span><span class="sxs-lookup"><span data-stu-id="09849-194">It is guaranteed that the base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method will invoke the implemented <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method only one time.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="09849-195">当的<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> <paramref name="disposing" />值为<see langword="true" />时, 更改监视器必须实现重载才能释放所有托管资源和非托管资源。</span><span class="sxs-lookup"><span data-stu-id="09849-195">A change monitor must implement the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload to release all managed and unmanaged resources when the value of <paramref name="disposing" /> is <see langword="true" />.</span></span> <span data-ttu-id="09849-196">具有值的<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> 方法<see langword="true" />重载只调用一次, 即首次释放实例时。 <paramref name="disposing" /></span><span class="sxs-lookup"><span data-stu-id="09849-196">The <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method overload that has a <paramref name="disposing" /> value of <see langword="true" /> is called only one time, namely, when the instance is disposed for the first time.</span></span> <span data-ttu-id="09849-197">更改监视器不能直接调用<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />重载。</span><span class="sxs-lookup"><span data-stu-id="09849-197">A change monitor must not call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> overload directly.</span></span> <span data-ttu-id="09849-198">派生的更改监视器可以调用基类<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> <see cref="T:System.Runtime.Caching.ChangeMonitor" />上不太公共的无参数方法。</span><span class="sxs-lookup"><span data-stu-id="09849-198">A derived change monitor can call the public parameter-less <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method on the base <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class.</span></span>  
  
<span data-ttu-id="09849-199">或者, 更改监视器可以实现终结器方法。</span><span class="sxs-lookup"><span data-stu-id="09849-199">Alternatively, a change monitor can implement a finalizer method.</span></span> <span data-ttu-id="09849-200">在这种情况下, 终结器可以<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />调用方法并向<paramref name="disposing" />其传递值<see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09849-200">In that case, the finalizer can invoke the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> method and pass it a <paramref name="disposing" /> value of <see langword="false" />.</span></span> <span data-ttu-id="09849-201">但是, 这通常是不必要的。</span><span class="sxs-lookup"><span data-stu-id="09849-201">However, this is usually unnecessary.</span></span> <span data-ttu-id="09849-202">监视依赖项更改通常由维护对更改监视器实例的引用的服务执行。</span><span class="sxs-lookup"><span data-stu-id="09849-202">Monitoring for dependency changes is typically performed by a service that maintains a reference to the change-monitor instance.</span></span> <span data-ttu-id="09849-203">引用阻止对实例进行垃圾回收, 因此不需要终结器方法。</span><span class="sxs-lookup"><span data-stu-id="09849-203">The reference prevents the instance from being garbage collected, and therefore makes a finalizer method unnecessary.</span></span> <span data-ttu-id="09849-204">若要避免内存泄漏, 在依赖项发生更改<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />时, 方法会释放更改监视器实例 (除非初始化尚未完成)。</span><span class="sxs-lookup"><span data-stu-id="09849-204">To avoid memory leaks, when a dependency changes, the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method disposes the change-monitor instance (unless initialization has not finished).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09849-205">获取一个值，该值指示由 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 类监视的状态已发生更改。</span><span class="sxs-lookup"><span data-stu-id="09849-205">Gets a value that indicates that the state that is monitored by the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class has changed.</span></span></summary>
        <value><span data-ttu-id="09849-206">如果由 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 实例监视的状态已发生更改，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09849-206"><see langword="true" /> if the state that is monitored by the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> instance has changed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-207">可以在派生<xref:System.Runtime.Caching.ChangeMonitor>类中检查此属性的值, 以查看依赖项是否已更改。</span><span class="sxs-lookup"><span data-stu-id="09849-207">You can check the value of this property in a derived <xref:System.Runtime.Caching.ChangeMonitor> class to see whether a dependency has changed.</span></span>  
  
 <span data-ttu-id="09849-208">当发生依赖项更改`true`时 (即, 调用<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>方法时), 该值设置为。</span><span class="sxs-lookup"><span data-stu-id="09849-208">The value is set to `true` when a dependency change occurs (that is, when the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called).</span></span> <span data-ttu-id="09849-209"><xref:System.Runtime.Caching.OnChangedCallback> <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> `true`派生类调用<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>方法后, 无论是否已通过调用方法通知实例, 属性的值都将为。 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A></span><span class="sxs-lookup"><span data-stu-id="09849-209">After the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called by the derived class, the value of the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property will be `true`, regardless of whether a <xref:System.Runtime.Caching.OnChangedCallback> instance has been notified by a call to the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09849-210">调用方可以检查<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>属性, 以查看依赖项是否已更改。</span><span class="sxs-lookup"><span data-stu-id="09849-210">Callers can check the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property to see whether a dependency has changed.</span></span> <span data-ttu-id="09849-211">但在多线程环境中, 更简单、更易于维护的方法是将数据插入缓存实现, 而不检查<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>属性。</span><span class="sxs-lookup"><span data-stu-id="09849-211">However, in a multi-threaded environment, a simpler and more maintainable approach is to insert data into a cache implementation without checking the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property.</span></span> <span data-ttu-id="09849-212">缓存实现必须检查<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>属性, 如果已更改一个或多个关联的依赖项, 则不得执行插入或设置操作。</span><span class="sxs-lookup"><span data-stu-id="09849-212">Cache implementations must check the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property for you and must not perform an insert or set operation if one or more associated dependencies have already changed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="09849-213">从派生类的构造函数进行调用以指示初始化已完成。</span><span class="sxs-lookup"><span data-stu-id="09849-213">Called from the constructor of derived classes to indicate that initialization is finished.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-214">如果在派生类中完成初始化之前依赖项发生了更改, 则派生类的构造函数必须调用<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="09849-214">If a dependency changes before initialization is complete in a derived class, the constructor of the derived class must invoke the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method.</span></span>  
  
 <span data-ttu-id="09849-215">调用方法时<xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> , 更改监视器会自动将属性设置为`true`。 <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A></span><span class="sxs-lookup"><span data-stu-id="09849-215">When the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is invoked, the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property is automatically set to `true` by the change monitor.</span></span> <span data-ttu-id="09849-216">因此, 当更改监视器的构造函数调用<xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>方法时, 基类会自动<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-216">As a result, when the change monitor's constructor calls the <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> method, the base class will automatically call the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method.</span></span> <span data-ttu-id="09849-217">如果初始化完成, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>方法会自动释放派生的更改监视器实例。</span><span class="sxs-lookup"><span data-stu-id="09849-217">If initialization is complete, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method automatically disposes the derived change-monitor instance.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="09849-218">派生类的构造函数必须在构造函数返回<see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />前调用基方法。</span><span class="sxs-lookup"><span data-stu-id="09849-218">The constructor of a derived class must call the base <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> method before the constructor returns.</span></span> <span data-ttu-id="09849-219">派生类的构造函数只能在调用后<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />调用方法, 因为如果初始化未完成<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> , 则该方法将引发异常。</span><span class="sxs-lookup"><span data-stu-id="09849-219">The constructor of a derived class can call the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method only after <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> is called, because the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method throws an exception if initialization is not completed.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09849-220">获取一个值，该值指示释放 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 类的派生实例。</span><span class="sxs-lookup"><span data-stu-id="09849-220">Gets a value that indicates that the derived instance of a <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class is disposed.</span></span></summary>
        <value><span data-ttu-id="09849-221">如果释放该实例，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="09849-221"><see langword="true" /> if the instance is disposed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-222">当基`true` <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法在派生类中调用<xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>方法以释放实例时, 属性设置为。</span><span class="sxs-lookup"><span data-stu-id="09849-222">The property is set to `true` after the base <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method calls the <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> method in a derived class to dispose of the instance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback"><span data-ttu-id="09849-223">对在某个依赖项更改时要调用的方法的引用。</span><span class="sxs-lookup"><span data-stu-id="09849-223">A reference to a method that is invoked when a dependency has changed.</span></span></param>
        <summary><span data-ttu-id="09849-224">由缓存实施者调用来注册回调，并在某个依赖项已更改时通过 <see cref="T:System.Runtime.Caching.ObjectCache" /> 委托通知 <see cref="T:System.Runtime.Caching.OnChangedCallback" /> 实例。</span><span class="sxs-lookup"><span data-stu-id="09849-224">Called by Cache implementers to register a callback and notify an <see cref="T:System.Runtime.Caching.ObjectCache" /> instance through the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> delegate when a dependency has changed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-225">缓存实施者使用此方法来连接到更改监视器。</span><span class="sxs-lookup"><span data-stu-id="09849-225">Cache implementers use this method to wire themselves up to a change monitor.</span></span> <span data-ttu-id="09849-226">如果将一个或多个更改监视器与缓存项关联, 则会将<xref:System.Runtime.Caching.CacheItemPolicy>已填充的更改监视器属性的实例传递给缓存项。</span><span class="sxs-lookup"><span data-stu-id="09849-226">If you associate one or more change monitors with the cache item, you pass a <xref:System.Runtime.Caching.CacheItemPolicy> instance with a populated change monitors property to the cache item.</span></span> <span data-ttu-id="09849-227">支持更改监视器的缓存实施者负责遍历<xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A>属性, 并<xref:System.Runtime.Caching.OnChangedCallback>向其找到的每个更改监视器注册委托。</span><span class="sxs-lookup"><span data-stu-id="09849-227">A cache implementer that supports change monitors is responsible for iterating over the <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> property and register the <xref:System.Runtime.Caching.OnChangedCallback> delegates with each change monitor that it finds.</span></span>  
  
 <span data-ttu-id="09849-228"><xref:System.Runtime.Caching.OnChangedCallback>由于委托包含可选状态参数, 因此具体的更改监视器实现可以传递可选状态信息。</span><span class="sxs-lookup"><span data-stu-id="09849-228">Because the <xref:System.Runtime.Caching.OnChangedCallback> delegate includes an optional state parameter, a concrete change monitor implementation can pass optional state information.</span></span> <span data-ttu-id="09849-229">缓存实施者确定是否可以执行自定义更改监视器作为回调的一部分传递的状态类型的显式依赖项。</span><span class="sxs-lookup"><span data-stu-id="09849-229">The cache implementer determines whether an explicit dependency on the type of state that a custom change monitor passes as part of the callback can be taken.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="09849-230">基本缓存扩展性 API 不要求显式依赖于状态类型。</span><span class="sxs-lookup"><span data-stu-id="09849-230">The base cache extensibility API has no requirement for explicit dependency on the type of state.</span></span>  
  
 <span data-ttu-id="09849-231"><xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>方法的实现会自动确定在调用时间<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>方法时监视器的状态是否已更改。</span><span class="sxs-lookup"><span data-stu-id="09849-231">The implementation of the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method automatically determines whether the state of the monitor has already changed at the time <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is called.</span></span> <span data-ttu-id="09849-232">如果属性为`true`, 则方法<xref:System.Runtime.Caching.OnChangedCallback>将通过<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>方法自动调用已注册的事件处理程序。 <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A></span><span class="sxs-lookup"><span data-stu-id="09849-232">If the <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> property is `true`, then the method automatically calls the <xref:System.Runtime.Caching.OnChangedCallback> event handler, that was registered, through the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method.</span></span> <span data-ttu-id="09849-233">之所以发生这种情况, 是因为在缓存实现创建更改监视器的时间可能会导致缓存实现获得监视器并向其自身进行线路操作, 因此, 基础监视状态已更改。</span><span class="sxs-lookup"><span data-stu-id="09849-233">This occurs because it is possible that from the time a cache implementation creates a change monitor, to the time a cache implementation gets the monitor and wires itself up to it, the underlying monitored state has changed.</span></span> <span data-ttu-id="09849-234">如果状态已更改, 则传递给该<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>方法的对象是。 `null`</span><span class="sxs-lookup"><span data-stu-id="09849-234">If the state has already changed then the object that is passed to the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is `null`.</span></span>  
  
 <span data-ttu-id="09849-235"><xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>方法只能调用一次, 并将在后续调用时引发异常。</span><span class="sxs-lookup"><span data-stu-id="09849-235">The <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method can be invoked only one time, and will throw an exception on subsequent calls.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="09849-236">已调用回调方法。</span><span class="sxs-lookup"><span data-stu-id="09849-236">The callback method has already been invoked.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="09849-237"><paramref name="onChangedCallback" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09849-237"><paramref name="onChangedCallback" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="09849-238">1.您必须调用<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />方法以获得任何依赖项更改的通知。</span><span class="sxs-lookup"><span data-stu-id="09849-238">1.  You must call the <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> method to be notified of any dependency changes.</span></span> <span data-ttu-id="09849-239">如果已发生依赖项更改, 则调用<see cref="T:System.Runtime.Caching.OnChangedCallback" />时<see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />将调用该实例。</span><span class="sxs-lookup"><span data-stu-id="09849-239">If a dependency change has already occurred, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called when <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> is called.</span></span> <span data-ttu-id="09849-240">否则, <see cref="T:System.Runtime.Caching.OnChangedCallback" />在调用<see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />方法时或调用<see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />方法时 (以先发生的为准), 将调用实例一次。</span><span class="sxs-lookup"><span data-stu-id="09849-240">Otherwise, the <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance will be called one time, either when the <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> method is called or when the <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> method is called, whichever occurs first.</span></span> <span data-ttu-id="09849-241">缓存实现提供的实例应删除缓存项,如果缓存调用方请求,则将必要的更改或更新事件返回给原始缓存调用方。<see cref="T:System.Runtime.Caching.OnChangedCallback" /></span><span class="sxs-lookup"><span data-stu-id="09849-241">The <see cref="T:System.Runtime.Caching.OnChangedCallback" /> instance provided by the cache implementation should remove the cache entry and if it is requested by the cache caller, raise the necessary change or update event back to the original cache caller.</span></span>  
  
<span data-ttu-id="09849-242">2.</span><span class="sxs-lookup"><span data-stu-id="09849-242">2.</span></span>  <span data-ttu-id="09849-243">对象缓存实现必须删除与依赖项更改关联的缓存项。</span><span class="sxs-lookup"><span data-stu-id="09849-243">The object cache implementation must remove the cache entry that is associated with a dependency change.</span></span></para></block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="09849-244">更改事件的数据。</span><span class="sxs-lookup"><span data-stu-id="09849-244">The data for the change event.</span></span> <span data-ttu-id="09849-245">此值可为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="09849-245">This value can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="09849-246">由派生类调用以在某个依赖项发生更改时引发事件。</span><span class="sxs-lookup"><span data-stu-id="09849-246">Called by derived classes to raise the event when a dependency changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-247">通常, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>在依赖项发生更改时调用方法。</span><span class="sxs-lookup"><span data-stu-id="09849-247">Typically, the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called when dependency changes occur.</span></span> <span data-ttu-id="09849-248">当<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>释放更改监视器实例时, 也会调用方法, 但仅当尚未调用回调时才会进行释放。</span><span class="sxs-lookup"><span data-stu-id="09849-248">The <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is also invoked when a change-monitor instance is disposed but the disposal occurs only if the callback has not already been invoked.</span></span>  
  
 <span data-ttu-id="09849-249">如果在调用<xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>方法之前调用<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> 方法,缓存实现将保存对方法的调用中<xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>的状态数据。</span><span class="sxs-lookup"><span data-stu-id="09849-249">If the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is called before the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is called, the state data from the call to the <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> method is saved by the cache implementation.</span></span> <span data-ttu-id="09849-250">此外, 调用方法<xref:System.Runtime.Caching.OnChangedCallback> <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>时, 将立即调用方法的回调。</span><span class="sxs-lookup"><span data-stu-id="09849-250">Also, the callback to the <xref:System.Runtime.Caching.OnChangedCallback> method is invoked immediately when the <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> method is invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="09849-251">获取一个表示 <see cref="T:System.Runtime.Caching.ChangeMonitor" /> 类实例的值。</span><span class="sxs-lookup"><span data-stu-id="09849-251">Gets a value that represents the <see cref="T:System.Runtime.Caching.ChangeMonitor" /> class instance.</span></span></summary>
        <value><span data-ttu-id="09849-252">某个更改监视器实例的标识符。</span><span class="sxs-lookup"><span data-stu-id="09849-252">The identifier for a change-monitor instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="09849-253">属性值通常由依赖关系名称组合而成, 这些数据可唯一地标识<xref:System.Runtime.Caching.ChangeMonitor>实例所监视的数据。 <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A></span><span class="sxs-lookup"><span data-stu-id="09849-253">The <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> property value typically consists of dependency names combined string data that uniquely identifiers the data that is being monitored by a <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span> <span data-ttu-id="09849-254"><xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A>属性的值为字符串。</span><span class="sxs-lookup"><span data-stu-id="09849-254">The value of the <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> property is a string.</span></span> <span data-ttu-id="09849-255">字符串的值用于分配<xref:System.Runtime.Caching.ChangeMonitor>实例的唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="09849-255">The value of the string is used to assign the unique ID of the <xref:System.Runtime.Caching.ChangeMonitor> instance.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="09849-256">通过重写属性, 可以为属性的字符串值定义自定义实现, 以便为其分配唯一 ID。</span><span class="sxs-lookup"><span data-stu-id="09849-256">By overriding the property, you can define a custom implementation for the string value of the property in order to assign it a unique ID.</span></span></para></block>
        <block subset="none" type="overrides"><para><span data-ttu-id="09849-257">在派生类中, 必须在构造函数中设置属性的值。</span><span class="sxs-lookup"><span data-stu-id="09849-257">In derived classes, you must set the value of the property in the constructor.</span></span></para></block>
      </Docs>
    </Member>
  </Members>
</Type>