<Type Name="DynamicMethod" FullName="System.Reflection.Emit.DynamicMethod">
  <Metadata><Meta Name="ms.openlocfilehash" Value="71e905a95bc7051f218f8ee2fb82ff422b40b7d3" /><Meta Name="ms.sourcegitcommit" Value="74239f3977d28923e5020663db2c4e91601bea79" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/24/2019" /><Meta Name="ms.locfileid" Value="68437199" /></Metadata><TypeSignature Language="C#" Value="public sealed class DynamicMethod : System.Reflection.MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit DynamicMethod extends System.Reflection.MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.DynamicMethod" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DynamicMethod&#xA;Inherits MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class DynamicMethod sealed : System::Reflection::MethodInfo" />
  <TypeSignature Language="F#" Value="type DynamicMethod = class&#xA;    inherit MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodInfo</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>定义并表示一种可编译、执行和丢弃的动态方法。 丢弃的方法可用于垃圾回收。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用<xref:System.Reflection.Emit.DynamicMethod>类在运行时生成和执行方法, 而不必生成动态程序集和动态类型来包含方法。 回收<xref:System.Reflection.Emit.DynamicMethod>对象时, 由实时 (JIT) 编译器创建的可执行代码将被回收。 动态方法是生成和执行少量代码的最有效方法。  
  
 动态方法可以是匿名承载的, 也可以逻辑上与模块或类型相关联。  
  
-   如果动态方法是匿名承载的, 则该方法位于系统提供的程序集中, 因此与其他代码隔离。 默认情况下, 它无权访问任何非公共数据。 匿名托管的动态方法可以具有跳过 JIT 编译器的可见性检查的受限能力, 前提是该方法<xref:System.Security.Permissions.ReflectionPermission>已被<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>授予标志。 动态方法访问其非公共成员的程序集的信任级别必须等于发出动态方法的调用堆栈的信任级别 (或的子集)。 有关匿名承载的动态方法的详细信息, [请参阅演练:在部分信任方案](~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md)中发出代码。  
  
-   如果动态方法与指定的模块相关联, 动态方法将在该模块中有效地成为全局方法。 它可以访问模块中的所有类型以及这些`internal`类型`Friend`的所有 (在 Visual Basic 中) 成员。 无论是否已创建模块, 都可以将动态方法与任何模块相关联, 前提是包含代码的调用<xref:System.Security.Permissions.ReflectionPermission>堆栈可以<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>满足带标志的请求。 如果该<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志包含在 grant 中, 则动态方法可以跳过 JIT 编译器的可见性检查并访问在该模块中声明的所有类型的私有数据或任何程序集中的任何其他模块。  
  
    > [!NOTE]
    >  指定与动态方法关联的模块时, 该模块不得位于系统提供的程序集中, 该程序集用于匿名托管。  
  
-   如果动态方法与指定的类型相关联, 则它有权访问该类型的所有成员, 而不考虑访问级别。 此外, 还可以跳过 JIT 可见性检查。 这为动态方法提供对在同一模块中或在任何程序集中的任何其他模块中声明的其他类型的私有数据的访问。 可以将动态方法与任何类型相关联, 但必须<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>同时向代码授予和<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>标志。  
  
 下表显示了匿名托管的动态方法可访问的类型和成员 (带有和不带 JIT 可见性检查), 具体<xref:System.Security.Permissions.ReflectionPermission>取决于<xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>是否授予了标志。  
  
||没有 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|通过 <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess>|  
|-|-|-|  
|不跳过 JIT 可见性检查|任何程序集中公共类型的公共成员。|任何程序集中公共类型的公共成员。|  
|跳过 JIT 可见性检查, 但有限制|任何程序集中公共类型的公共成员。|所有类型的所有成员, 仅在其信任级别等于或小于发出动态方法的程序集的信任级别的程序集中。|  
  
> [!NOTE]
>  在[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]之前, 发出<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType>标记所需<xref:System.Security.Permissions.ReflectionPermission>的代码。 默认情况下, 此权限包含在 FullTrust 和 LocalIntranet 命名权限集中, 而不是在 Internet 权限集中。 因此, [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]在早期版本的库中, 只有当库<xref:System.Security.SecurityCriticalAttribute>具有<xref:System.Security.PermissionSet.Assert%2A>特性并为<xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>执行时, 才能与 Internet 权限一起使用。 这种库需要进行仔细的安全检查，因为编码错误可能会导致安全漏洞。 [!INCLUDE[net_v20SP1_short](~/includes/net-v20sp1-short-md.md)] 允许以部分信任形式发出代码而无需发出任何安全请求，因为生成代码本身不是一项特权操作。 也就是说，生成的代码不会具有比发出它的程序集更多的权限。 这使得发出代码的库是安全透明的，且不再需要断言 <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit>，这简化了编写安全库任务。 若要使用此功能, 应用程序应面向[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]或更高版本。  
  
 下表显示了与模块或模块中的类型相关联的动态方法可以访问的类型和成员。  
  
||与模块关联|与类型关联|  
|-|-|-|  
|不跳过 JIT 可见性检查|模块中公共类型、内部类型和私有类型的公共和内部成员。<br /><br /> 任何程序集中公共类型的公共成员。|关联类型的所有成员。 模块中所有其他类型的公共和内部成员。<br /><br /> 任何程序集中公共类型的公共成员。|  
|跳过 JIT 可见性检查|所有程序集中的所有类型的所有成员。|所有程序集中的所有类型的所有成员。|  
  
 与模块关联的动态方法具有该模块的权限。 与某一类型关联的动态方法具有包含该类型的模块的权限。  
  
 动态方法及其参数无需命名, 但你可以指定名称来帮助进行调试。 动态方法或其参数不支持自定义属性。  
  
 尽管动态方法是`static`方法 (`Shared` Visual Basic 中的方法), 但中引入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]委托绑定的宽松规则允许将动态方法绑定到对象, 以便在使用该委托实例调用。 此示例演示了如何为<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载提供此方法。  
  
> [!NOTE]
>  在中[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)], 动态方法不支持符号信息, 即局部变量名称和行号映射。 在将来的版本中可能会删除此限制。 你可以在<xref:System.Reflection.Emit.AssemblyBuilder>开发过程中使用来简化生成的 Microsoft 中间语言 (MSIL) 的调试, 然后在最终部署过程中切换到动态<xref:System.Reflection.Emit.ILGenerator>方法, 因为这两种情况下的调用都是相同的。  
  
## <a name="verification"></a>确认  
 下面的列表汇总了动态方法可包含无法验证的代码的情况。 (例如, 如果动态方法的属性设置为, <xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>则无法`false`对其进行验证。)  
  
-   与安全关键程序集关联的动态方法也是安全关键的, 可跳过验证。 例如, 如果程序集不具有作为桌面应用程序运行的安全属性, 则运行时将其视为安全关键。 如果将动态方法与程序集相关联, 则动态方法可能包含不可验证的代码。  
  
-   如果包含不可验证代码的动态方法与具有级别1透明度的程序集相关联, 则实时 (JIT) 编译器将注入安全要求。 仅当动态方法由完全受信任的代码执行时, 请求才会成功。 请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)。  
  
-   如果包含不可验证代码的动态方法与具有2级透明度 (如 mscorlib.dll) 的程序集相关联, 则它会引发异常 (由 JIT 编译器注入), 而不是发出安全要求。 请参阅[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
-   包含不可验证的代码的匿名托管动态方法始终引发异常。 即使它是由完全受信任的代码创建和执行的, 它也永远不会跳过验证。  
  
 对于不可验证的代码引发的异常会根据动态方法的调用方式而有所不同。 如果使用从<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法返回的委托调用动态方法<xref:System.Security.VerificationException> , 则将引发。 如果通过使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法<xref:System.Reflection.TargetInvocationException> , 则将引发与内部<xref:System.Security.VerificationException>的。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.All#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.All#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.All#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
    <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">演练：在部分信任应用场景中发出代码</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建动态方法。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <summary>初始化匿名承载的动态方法，指定方法名称、返回类型和参数类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建的动态方法与匿名程序集相关联, 而不是与现有类型或模块关联。 匿名程序集的存在只是为了为动态方法提供沙盒环境, 即, 将它们与其他代码隔离开来。 此环境使动态方法可由部分受信任的代码发出并执行。  
  
 此构造函数指定将对动态方法的 Microsoft 中间语言 (MSIL) 强制执行实时 (JIT) 可见性检查。 也就是说, 动态方法中的代码可以访问公共类的公共方法。 如果方法尝试访问的类型或`private`成员为、或`internal` (`Friend`在 Visual Basic 中`protected`), 则会引发异常。 若要创建具有跳过 JIT 可见性检查的受限能力的动态方法, <xref:System.Reflection.Emit.DynamicMethod.%23ctor%28System.String%2CSystem.Type%2CSystem.Type%5B%5D%2CSystem.Boolean%29>请使用构造函数。  
  
 构造匿名托管的动态方法时, 将包含发出程序集的调用堆栈。 调用方法时, 将使用发出程序集的权限, 而不是实际调用方的权限。 因此, 动态方法无法以比发出它的程序集更高的特权级别执行, 即使该方法传递到并且由具有较高信任级别的程序集执行。  
  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  此构造函数是在或[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]更高版本中引入的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">演练：在部分信任应用场景中发出代码</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, bool restrictedSkipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), restrictedSkipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, bool restrictedSkipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, restrictedSkipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="restrictedSkipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="restrictedSkipVisibility">如果为 <see langword="true" />，则跳过针对动态方法的 MSIL 访问的类型和成员进行的 JIT 可见性检查，含此限制：包含这些类型和成员的程序集的信任级别必须等于或小于发出动态方法的调用堆栈的信任级别；否则为 <see langword="false" />。</param>
        <summary>初始化匿名托管的动态方法，同时指定方法名称、返回类型、参数类型并指定是否应针对动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数创建的动态方法与匿名程序集相关联, 而不是与现有类型或模块关联。 匿名程序集的存在只是为了为动态方法提供沙盒环境, 即, 将它们与其他代码隔离开来。 此环境使动态方法可由部分受信任的代码发出并执行。  
  
 匿名`private`托管的`protected`动态方法`Friend`不能自动访问任何类型或成员(在VisualBasic中)。`internal` 这不同于与现有类型或模块关联的动态方法, 这些方法可以访问其关联范围内的隐藏成员。  
  
 `true` `private`如果动态`protected`方法必须访问、或`internal`类型的类型或成员, 请指定。 `restrictedSkipVisibility` 这为动态方法授予了对这些成员的有限访问权限。 也就是说, 仅当满足以下条件时, 才能访问成员:  
  
-   目标成员属于具有等于或小于发出动态方法的调用堆栈的信任级别的程序集。  
  
-   向发出动态方法的调用堆栈授予<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>标志。 在完全信任的情况下执行代码时, 这始终为 true。 对于部分受信任的代码, 仅当主机显式授予权限时才为 true。  
  
    > [!IMPORTANT]
    >  如果尚未授予该权限, 则在<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>调用或调用动态方法时, 而不是在调用此构造函数时, 将引发安全异常。 发出动态方法不需要任何特殊权限。  
  
 例如, 如果已向调用堆栈授予受限成员`restrictedSkipVisibility`访问权限`true` , 则使用设置为的创建的动态方法可以访问调用堆栈上任何程序集的私有成员。 如果动态方法是使用调用堆栈上部分受信任的代码创建的, 则它无法访问[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]程序集中类型的私有成员, 因为此类程序集是完全受信任的。  
  
 如果`restrictedSkipVisibility` 为`false`, 则强制执行 JIT 可见性检查。 动态方法中的代码有权访问公共类的公共方法, 如果尝试访问的类型或成员`private`为、 `protected`或`internal`, 则会引发异常。  
  
 构造匿名托管的动态方法时, 将包含发出程序集的调用堆栈。 调用方法时, 将使用发出调用堆栈的权限, 而不是实际调用方的权限。 因此, 动态方法无法以比发出它的程序集更高的特权级别执行, 即使该方法传递到并且由具有较高信任级别的程序集执行。  
  
 此构造函数指定方法属性<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>和<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  此构造函数是在或[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]更高版本中引入的。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/walkthrough-emitting-code-in-partial-trust-scenarios.md">演练：在部分信任应用场景中发出代码</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 而不会跳过实时 (JIT) 可见性检查。  
  
 使用此构造函数创建的动态方法可以访问模块`internal` `m`中包含`Friend`的所有类型的公共和 (在 Visual Basic) 成员。  
  
> [!NOTE]
>  为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果同时<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>满足以下条件, 则此构造函数要求`m`带有标志: 是一个模块, 而不是调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块, <xref:System.Security.Permissions.ReflectionPermission>并且具有标志的要求已失败。 如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29>方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
或 
 <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">将动态方法与调用模块以外的模块关联。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" /> 。</param>
        <param name="owner">一个 <see cref="T:System.Type" />，动态方法与其逻辑关联。 动态方法可以访问类型的所有成员。</param>
        <summary>创建一个动态方法，指定方法名称、返回类型、参数类型和动态方法逻辑关联的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法`owner`具有对该类型的所有成员的访问权限, 以及对包含`owner`的模块中所有其他类型的公共和`internal` (`Friend`在 Visual Basic) 成员的访问。  
  
 此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>属性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>, 而不会跳过实时 (JIT) 可见性检查。  
  
> [!NOTE]
>  为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果满足<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>以下条件, 则此构造函数要求带有`owner`标志: 位于调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块以外的模块中, 且<xref:System.Security.Permissions.ReflectionPermission>具有标志失败。 如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
   
  
## Examples  
 下面的代码示例创建一个<xref:System.Reflection.Emit.DynamicMethod>与类型逻辑上关联的。 此关联使其能够访问该类型的私有成员。  
  
 此代码示例定义了一个名`Example`为的类, 该类具有私有字段`DerivedFromExample` , 该类是从第一个类派生的名为`UseLikeStatic`的类, 它是一个名`Example`为的委托类型, 它返回<xref:System.Int32>并具有类型为和<xref:System.Int32>和一个名为`UseLikeInstance`的委托类型, 它返回<xref:System.Int32>并具有一个类型<xref:System.Int32>为的参数。  
  
 然后, 该代码示例创建<xref:System.Reflection.Emit.DynamicMethod>一个, 它将更改`Example`实例的私有字段并返回以前的值。  
  
> [!NOTE]
>  通常, 更改类的内部字段并不是面向对象的适当编码做法。  
  
 示例代码创建的`Example`实例, 然后创建两个委托。 第一个类型`UseLikeStatic`为, 它具有与动态方法相同的参数。 第二种类型`UseLikeInstance`为, 它缺少第一个参数 (类型`Example`为)。 此委托是使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载创建的; 此方法重载的第二个参数是的`Example`实例, 在本例中为刚创建的实例, 该实例绑定到新创建的委托。 无论何时调用该委托, 动态方法都将对的绑定实例`Example`起作用。  
  
> [!NOTE]
>  这是中引入的[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]委托绑定的宽松规则的示例, 以及<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法的新重载。 有关更多信息，请参见 <xref:System.Delegate> 类。  
  
 调用委托, 并传入绑定到`UseLikeInstance`委托的的`Example`实例。 `UseLikeStatic` 然后调用`Example`委托, 使这两个委托对相同的实例执行操作。 `UseLikeInstance` 在每次调用后, 将显示内部字段的值中的更改。 最后, `UseLikeInstance`委托绑定到的`DerivedFromExample`实例, 并且委托调用重复。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
或 
 <paramref name="owner" /> 是一个接口、一个数组、一个开放式泛型类型或一个泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 为 <see langword="null" />，或者为 <see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与调用模块以外的模块中的类型相关联, 则为。 关联的枚举<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />:。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <param name="skipVisibility">要跳过对动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>特性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
 使用此构造函数创建的动态方法有权访问包含`internal`模块`Friend` `m`中所有类型的公共和 (在 Visual Basic) 成员中。 通过跳过 JIT 编译器的可见性检查, 动态方法还可以访问所有其他类型的私有和受保护成员。 例如, 在编写代码以序列化对象时, 这很有用。  
  
> [!NOTE]
>  为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果同时<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>满足以下条件, 则此构造函数要求`m`带有标志: 是一个模块, 而不是调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块, <xref:System.Security.Permissions.ReflectionPermission>并且具有标志的要求已失败。 如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">将动态方法与调用模块以外的模块关联。 关联的枚举<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />:。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" />。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" /> 。</param>
        <param name="owner">一个 <see cref="T:System.Type" />，动态方法与其逻辑关联。 动态方法可以访问类型的所有成员。</param>
        <param name="skipVisibility">要跳过动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个动态方法，指定方法名称、返回类型、参数类型、动态方法逻辑关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法`owner`具有对该类型的所有成员的访问权限, 以及对包含`owner`的模块中所有其他类型的公共和`internal` (`Friend`在 Visual Basic) 成员的访问。 通过跳过 JIT 编译器的可见性检查, 动态方法还可以访问所有其他类型的私有和受保护成员。 例如, 在编写代码以序列化对象时, 这很有用。  
  
 此构造函数指定方法<xref:System.Reflection.MethodAttributes.Public?displayProperty=nameWithType>特性<xref:System.Reflection.MethodAttributes.Static?displayProperty=nameWithType>和和调用约定<xref:System.Reflection.CallingConventions.Standard?displayProperty=nameWithType>。  
  
> [!NOTE]
>  为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果满足<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>以下条件, 则此构造函数要求带有`owner`标志: 位于调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块以外的模块中, 且<xref:System.Security.Permissions.ReflectionPermission>具有标志失败。 如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
或 
 <paramref name="owner" /> 是一个接口、一个数组、一个开放式泛型类型或一个泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="returnType" /> 为 <see langword="null" />，或者为 <see cref="P:System.Type.IsByRef" /> 返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与调用模块以外的模块中的类型相关联, 则为。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Reflection.Module m, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Reflection.Module,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), m As Module, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, System::Reflection::Module ^ m, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * System.Reflection.Module * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, m, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="m" Type="System.Reflection.Module" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="attributes"><see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合，指定动态方法的属性。 允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">动态方法的调用约定。 必须为 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" /> 。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" />。</param>
        <param name="m">一个 <see cref="T:System.Reflection.Module" />，表示动态方法将与之逻辑关联的模块。</param>
        <param name="skipVisibility">要跳过动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个对模块全局有效的动态方法，指定方法名称、属性、调用约定、返回类型、参数类型和模块，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此构造函数创建的动态方法可以访问模块`internal` `m`中包含`Friend`的所有公共和内部类型的公共和 (在 Visual Basic) 成员。  
  
 通过跳过 JIT 编译器的可见性检查, 动态方法可以访问模块和所有其他程序集中的所有其他类型的私有和受保护成员。 例如, 在编写代码以序列化对象时, 这很有用。  
  
> [!NOTE]
>  为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果同时<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>满足以下条件, 则此构造函数要求`m`带有标志: 是一个模块, 而不是调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块, <xref:System.Security.Permissions.ReflectionPermission>并且具有标志的要求已失败。 如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
- 或 - 
 <paramref name="m" /> 是为动态方法提供匿名承载的模块。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="m" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。  
  
或 
 <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  
  
或 
 <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">将动态方法与调用模块以外的模块关联。 关联的枚举<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />:。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DynamicMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, class System.Type owner, bool skipVisibility) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.#ctor(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, attributes As MethodAttributes, callingConvention As CallingConventions, returnType As Type, parameterTypes As Type(), owner As Type, skipVisibility As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DynamicMethod(System::String ^ name, System::Reflection::MethodAttributes attributes, System::Reflection::CallingConventions callingConvention, Type ^ returnType, cli::array &lt;Type ^&gt; ^ parameterTypes, Type ^ owner, bool skipVisibility);" />
      <MemberSignature Language="F#" Value="new System.Reflection.Emit.DynamicMethod : string * System.Reflection.MethodAttributes * System.Reflection.CallingConventions * Type * Type[] * Type * bool -&gt; System.Reflection.Emit.DynamicMethod" Usage="new System.Reflection.Emit.DynamicMethod (name, attributes, callingConvention, returnType, parameterTypes, owner, skipVisibility)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="owner" Type="System.Type" />
        <Parameter Name="skipVisibility" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">动态方法的名称。 它可以是长度为零的字符串，但不能为 <see langword="null" />。</param>
        <param name="attributes"><see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合，指定动态方法的属性。 允许的唯一组合为 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" />。</param>
        <param name="callingConvention">动态方法的调用约定。 必须为 <see cref="F:System.Reflection.CallingConventions.Standard" />。</param>
        <param name="returnType">一个 <see cref="T:System.Type" /> 对象，用于指定动态方法的返回类型，如果此方法没有返回类型，则为 <see langword="null" /> 。</param>
        <param name="parameterTypes">指定动态方法的参数类型的 <see cref="T:System.Type" /> 对象数组，如果此方法不具有任何参数，则为 <see langword="null" /> 。</param>
        <param name="owner">一个 <see cref="T:System.Type" />，动态方法与其逻辑关联。 动态方法可以访问类型的所有成员。</param>
        <param name="skipVisibility">要跳过动态方法的 MSIL 访问的类型和成员的 JIT 可见性检查，则为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>创建一个动态方法，指定方法名称、特性、调用约定、返回类型、参数类型、动态方法逻辑关联的类型，并指定动态方法的 Microsoft 中间语言 (MSIL) 访问的类型和成员是否应跳过实时 (JIT) 可见性检查。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态方法对于包含该类型`owner`的模块是全局性的。 它有权访问该类型`owner`的所有成员。  
  
 使用此构造函数创建的动态方法`owner`具有对该类型的所有成员的访问权限, 以及对包含在包含在包含`owner`的模块中的所有类型的公共和`internal` (`Friend`在 Visual Basic) 成员的访问。 通过跳过 JIT 编译器的可见性检查, 动态方法还可以访问所有其他类型的私有和受保护成员。 例如, 在编写代码以序列化对象时, 这很有用。  
  
> [!NOTE]
>  为实现向后兼容性, <xref:System.Security.Permissions.SecurityPermission>如果满足<xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence?displayProperty=nameWithType>以下条件, 则此构造函数要求带有`owner`标志: 位于调用<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>模块以外的模块中, 且<xref:System.Security.Permissions.ReflectionPermission>具有标志失败。 如果成功的请求<xref:System.Security.Permissions.SecurityPermission> , 则允许执行该操作。  
  
> [!NOTE]
>  从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.ReflectionEmit?displayProperty=nameWithType> , 此成员不再需要带有标志的。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] (请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。)若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="parameterTypes" /> 的元素为 <see langword="null" /> 或 <see cref="T:System.Void" />。  
  
或 
 <paramref name="owner" /> 是一个接口、一个数组、一个开放式泛型类型或一个泛型类型或方法的类型参数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。  
  
或 
 <paramref name="owner" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="attributes" /> 是标志的组合，而不是 <see cref="F:System.Reflection.MethodAttributes.Public" /> 和 <see cref="F:System.Reflection.MethodAttributes.Static" /> 的组合。  
  
或 
 <paramref name="callingConvention" /> 不是 <see cref="F:System.Reflection.CallingConventions.Standard" />。  
  
- 或 - 
 <paramref name="returnType" /> 是一种 <see cref="P:System.Type.IsByRef" /> 为其返回 <see langword="true" /> 的类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">若要将动态方法与调用模块以外的模块中的类型相关联, 则为。 关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess" />。</permission>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.MethodAttributes" Usage="System.Reflection.Emit.DynamicMethod.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取创建动态方法时指定的属性。</summary>
        <value><see cref="T:System.Reflection.MethodAttributes" /> 值的按位组合，表示方法的属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前, 动态方法的方法特性始终<xref:System.Reflection.MethodAttributes.Public>为和。 <xref:System.Reflection.MethodAttributes.Static>  
  
   
  
## Examples  
 下面的代码示例显示动态方法的方法特性。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#21](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#21)]
 [!code-csharp[Reflection.DynamicMethod.All#21](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#21)]
 [!code-vb[Reflection.DynamicMethod.All#21](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public override System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberSignature Language="F#" Value="member this.CallingConvention : System.Reflection.CallingConventions" Usage="System.Reflection.Emit.DynamicMethod.CallingConvention" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取创建动态方法时指定的调用约定。</summary>
        <value>一个 <see cref="T:System.Reflection.CallingConventions" /> 值，它指示方法的调用约定。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前, 动态方法的调用约定始终<xref:System.Reflection.CallingConventions.Standard>为。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的调用约定。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#22](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#22)]
 [!code-csharp[Reflection.DynamicMethod.All#22](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#22)]
 [!code-vb[Reflection.DynamicMethod.All#22](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>完成动态方法并创建一个可执行此方法的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type -&gt; Delegate" Usage="dynamicMethod.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType">一个签名与动态方法的签名匹配的委托类型。</param>
        <summary>完成动态方法并创建一个可执行此方法的委托。</summary>
        <returns>一个指定类型的委托，可用于执行动态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>调用方法<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>或方法完成动态方法。 将忽略更改动态方法的任何进一步尝试, 如修改参数定义或发出更多 Microsoft 中间语言 (MSIL);不引发异常。  
  
 若要在有自己的 MSIL 生成器时为动态方法创建方法体, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法以<xref:System.Reflection.Emit.DynamicILInfo>获取对象。 如果没有自己的 MSIL 生成器, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法来<xref:System.Reflection.Emit.ILGenerator>获取可用于生成方法体的对象。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="delegateType" /> 的参数数量不正确，或者参数类型不正确。</exception>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public override sealed Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="dynamicMethod.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType">一个签名与动态方法的签名匹配的委托类型，不包括第一个参数。</param>
        <param name="target">委托绑定到的对象。 其类型必须与动态方法的第一个参数的类型相同。</param>
        <summary>完成动态方法并创建一个可用于执行该方法的委托，指定委托类型和委托绑定到的对象。</summary>
        <returns>一个指定类型的委托，可用于对指定的目标对象执行动态方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法重载创建绑定到特定对象的委托。 此类委托被称为通过其第一个参数关闭。 尽管该方法是静态的, 但它的作用就像是实例方法;实例为`target`。  
  
 此方法重载需要`target`与动态方法的第一个参数具有相同的类型, 或可分配给该类型 (例如, 派生类)。  的`delegateType`签名包含除第一个以外的动态方法的所有参数。 例如, 如果动态方法具有参数<xref:System.String>、 <xref:System.Int32>和<xref:System.Byte>, 则`delegateType`具有参数<xref:System.Int32>和<xref:System.Byte>;`target`的类型<xref:System.String>为。  
  
 <xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>调用方法<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>或方法完成动态方法。 将忽略更改动态方法的任何进一步尝试, 如修改参数定义或发出更多 Microsoft 中间语言 (MSIL);不引发异常。  
  
 若要在有自己的 MSIL 生成器时为动态方法创建方法体, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo%2A>方法以<xref:System.Reflection.Emit.DynamicILInfo>获取对象。 如果没有自己的 MSIL 生成器, 请调用<xref:System.Reflection.Emit.DynamicMethod.GetILGenerator%2A>方法来<xref:System.Reflection.Emit.ILGenerator>获取可用于生成方法体的对象。  
  
   
  
## Examples  
 下面的代码示例创建委托, 该委托<xref:System.Reflection.Emit.DynamicMethod>将绑定到类型的实例, 以便在每次调用该方法时, 该方法都在同一实例上操作。  
  
 此代码示例定义了一个名`Example`为的类, 该类具有私有字段`DerivedFromExample` , 该类是从第一个类派生的名为`UseLikeStatic`的类, 它是一个名`Example`为的委托类型, 它返回<xref:System.Int32>并具有类型为和<xref:System.Int32>和一个名为`UseLikeInstance`的委托类型, 它返回<xref:System.Int32>并具有一个类型<xref:System.Int32>为的参数。  
  
 然后, 该代码示例创建<xref:System.Reflection.Emit.DynamicMethod>一个, 它将更改`Example`实例的私有字段并返回以前的值。  
  
> [!NOTE]
>  通常, 更改类的内部字段并不是面向对象的适当编码做法。  
  
 示例代码创建的`Example`实例, 然后创建两个委托。 第一个类型`UseLikeStatic`为, 它具有与动态方法相同的参数。 第二种类型`UseLikeInstance`为, 它缺少第一个参数 (类型`Example`为)。 此委托是使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>方法重载创建的; 此方法重载的第二个参数是的`Example`实例, 在本例中为刚创建的实例, 该实例绑定到新创建的委托。 无论何时调用该委托, 动态方法都将对的绑定实例`Example`起作用。  
  
> [!NOTE]
>  这是中引入的[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]委托绑定的宽松规则的示例, 以及<xref:System.Delegate.CreateDelegate%2A?displayProperty=nameWithType>方法的新重载。 有关更多信息，请参见 <xref:System.Delegate> 类。  
  
 调用委托, 并传入绑定到`UseLikeInstance`委托的的`Example`实例。 `UseLikeStatic` 然后调用`Example`委托, 使这两个委托对相同的实例执行操作。 `UseLikeInstance` 在每次调用后, 将显示内部字段的值中的更改。 最后, `UseLikeInstance`委托绑定到的`DerivedFromExample`实例, 并且委托调用重复。  
  
 [!code-csharp[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/cs/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ClosedOver#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ClosedOver/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> 的类型与动态方法的第一个参数的类型不同，不能赋值给该类型。  
  
或 
 <paramref name="delegateType" /> 的参数数量不正确，或者参数类型不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Reflection.Emit.DynamicMethod.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取声明方法的类型，对于动态方法，类型始终为 <see langword="null" />。</summary>
        <value>总是为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终为`null`动态方法返回。 即使动态方法与类型在逻辑上相关联, 它也不是由类型声明的。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的声明类型。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#23](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#23)]
 [!code-csharp[Reflection.DynamicMethod.All#23](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#23)]
 [!code-vb[Reflection.DynamicMethod.All#23](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#23)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string parameterName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ParameterBuilder DefineParameter(int32 position, valuetype System.Reflection.ParameterAttributes attributes, string parameterName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineParameter (position As Integer, attributes As ParameterAttributes, parameterName As String) As ParameterBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ParameterBuilder ^ DefineParameter(int position, System::Reflection::ParameterAttributes attributes, System::String ^ parameterName);" />
      <MemberSignature Language="F#" Value="member this.DefineParameter : int * System.Reflection.ParameterAttributes * string -&gt; System.Reflection.Emit.ParameterBuilder" Usage="dynamicMethod.DefineParameter (position, attributes, parameterName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ParameterBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameterName" Type="System.String" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="position">参数在参数列表中的位置。 为参数编索引，第一个参数从数字 1 开始。</param>
        <param name="attributes"><see cref="T:System.Reflection.ParameterAttributes" /> 值的按位组合，用于指定参数的属性。</param>
        <param name="parameterName">参数的名称。 名称可以为零长度字符串。</param>
        <summary>定义动态方法的参数。</summary>
        <returns>始终返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`position`为 0, 则<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>该方法引用返回值。 设置参数信息不会影响返回值。  
  
 如果已通过调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法, 则该<xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>方法不起作用。 不引发异常。  
  
   
  
## Examples  
 下面的代码示例演示如何定义动态方法的参数信息。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#33](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#33)]
 [!code-csharp[Reflection.DynamicMethod.All#33](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#33)]
 [!code-vb[Reflection.DynamicMethod.All#33](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">此方法没有参数。  
  
- 或 - 
 <paramref name="position" /> 小于 0。  
  
或 
 <paramref name="position" /> 大于此方法的参数数目。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="override this.GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="dynamicMethod.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回方法的基实现。</summary>
        <returns>方法的基实现。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法始终返回当前`DynamicMethod`对象。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回应用于此方法的自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</param>
        <summary>返回为此方法定义的所有自定义属性。</summary>
        <returns>表示此方法的所有自定义属性的对象数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法, 为`true` `inherit`指定不起作用, 因为方法未在类型中声明。  
  
> [!NOTE]
>  动态方法当前不支持自定义特性。 返回的唯一属性为<xref:System.Runtime.CompilerServices.MethodImplAttribute>; <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>使用方法可以更轻松地获取方法实现标志。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="dynamicMethod.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">一个 <see cref="T:System.Type" />，表示要返回的自定义特性类型。</param>
        <param name="inherit">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</param>
        <summary>返回应用于此方法的指定类型的自定义属性。</summary>
        <returns>一个对象数组，表示此方法的属性为 <paramref name="attributeType" /> 类型或派生自 <paramref name="attributeType" /> 类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法, 为`true` `inherit`指定不起作用, 因为方法未在类型中声明。  
  
> [!NOTE]
>  动态方法当前不支持自定义特性。 返回的唯一属性为<xref:System.Runtime.CompilerServices.MethodImplAttribute>; <xref:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags%2A>使用方法可以更轻松地获取方法实现标志。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GetDynamicILInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.DynamicILInfo GetDynamicILInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.DynamicILInfo GetDynamicILInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetDynamicILInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDynamicILInfo () As DynamicILInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::DynamicILInfo ^ GetDynamicILInfo();" />
      <MemberSignature Language="F#" Value="member this.GetDynamicILInfo : unit -&gt; System.Reflection.Emit.DynamicILInfo" Usage="dynamicMethod.GetDynamicILInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.DynamicILInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象，该对象可用于从元数据标记、范围和 Microsoft 中间语言 (MSIL) 流生成方法体。</summary>
        <returns>一个 <see cref="T:System.Reflection.Emit.DynamicILInfo" /> 对象，可用于从元数据标记、范围和 MSIL 流生成方法体。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 提供<xref:System.Reflection.Emit.DynamicILInfo>类以支持非托管代码生成。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">执行非托管代码。 关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />:。</permission>
        <altmember cref="T:System.Reflection.Emit.DynamicILInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetILGenerator">
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回一个 MSIL 生成器，该生成器可用于发出动态方法的方法体。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator () As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator();" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : unit -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为该方法返回一个具有默认 MSIL 流大小（64 字节）的 Microsoft 中间语言 (MSIL) 生成器。</summary>
        <returns>该方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在通过调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法后, 将忽略添加 MSIL 的任何进一步尝试。 不引发异常。  
  
> [!NOTE]
>  对于动态方法中的不可验证代码, 即使在某些完全信任的情况下也存在限制。 请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。  
  
   
  
## Examples  
 下面的代码示例创建一个带有两个参数的动态方法。 该示例发出一个简单的函数体, 将第一个参数输出到控制台, 该示例使用第二个参数作为方法的返回值。 该示例通过创建委托来完成方法, 使用不同的参数调用委托, 最后使用<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法调用动态方法。  
  
 [!code-cpp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/cpp/source.cpp#1)]
 [!code-csharp[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/CS/source.cs#1)]
 [!code-vb[Reflection.DynamicMethod.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.ctor1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetILGenerator">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ILGenerator GetILGenerator (int streamSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ILGenerator GetILGenerator(int32 streamSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetILGenerator(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetILGenerator (streamSize As Integer) As ILGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::ILGenerator ^ GetILGenerator(int streamSize);" />
      <MemberSignature Language="F#" Value="member this.GetILGenerator : int -&gt; System.Reflection.Emit.ILGenerator" Usage="dynamicMethod.GetILGenerator streamSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ILGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="streamSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="streamSize">MSIL 流的大小，以字节为单位。</param>
        <summary>为方法返回一个具有指定 MSIL 流大小的 Microsoft 中间语言 (MSIL) 生成器。</summary>
        <returns>方法的 <see cref="T:System.Reflection.Emit.ILGenerator" /> 对象，具有指定的 MSIL 流大小。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在通过调用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>方法完成动态方法后, 将忽略添加 MSIL 的任何进一步尝试。 不引发异常。  
  
> [!NOTE]
>  对于动态方法中的不可验证代码, 即使在某些完全信任的情况下也存在限制。 请参阅“验证”部分中的 <xref:System.Reflection.Emit.DynamicMethod> 注释。  
  
   
  
## Examples  
 下面的代码示例演示了此方法重载。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#2](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#2)]
 [!code-csharp[Reflection.DynamicMethod.All#2](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#2)]
 [!code-vb[Reflection.DynamicMethod.All#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-define-and-execute-dynamic-methods.md">如何：定义和执行动态方法</related>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberSignature Language="F#" Value="override this.GetMethodImplementationFlags : unit -&gt; System.Reflection.MethodImplAttributes" Usage="dynamicMethod.GetMethodImplementationFlags " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此方法的实现标志。</summary>
        <returns><see cref="T:System.Reflection.MethodImplAttributes" /> 值的按位组合，表示此方法的实现标志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前, 动态方法的方法实现属性始终<xref:System.Reflection.MethodImplAttributes.IL>为和。 <xref:System.Reflection.MethodImplAttributes.NoInlining>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberSignature Language="F#" Value="override this.GetParameters : unit -&gt; System.Reflection.ParameterInfo[]" Usage="dynamicMethod.GetParameters " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回动态方法的参数。</summary>
        <returns>一个 <see cref="T:System.Reflection.ParameterInfo" /> 对象数组，表示动态方法的参数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回的对象仅用于信息。<xref:System.Reflection.ParameterInfo> <xref:System.Reflection.Emit.DynamicMethod.DefineParameter%2A>使用方法可设置或更改参数的特征。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的参数。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#34](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#34)]
 [!code-csharp[Reflection.DynamicMethod.All#34](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#34)]
 [!code-vb[Reflection.DynamicMethod.All#34](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#34)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.DefineParameter(System.Int32,System.Reflection.ParameterAttributes,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="InitLocals">
      <MemberSignature Language="C#" Value="public bool InitLocals { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InitLocals" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberSignature Language="VB.NET" Value="Public Property InitLocals As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InitLocals { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.InitLocals : bool with get, set" Usage="System.Reflection.Emit.DynamicMethod.InitLocals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示方法中的局部变量是否初始化为零。</summary>
        <value>如果方法中的局部变量初始化为零，则为 <see langword="true" />；否则为 <see langword="false" />。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为`true`, 则发出的 Microsoft 中间语言 (MSIL) 包括初始化局部变量。 如果将其设置为`false`, 则不初始化局部变量, 并且无法验证所生成的代码。  
  
   
  
## Examples  
 下面的代码示例显示动态<xref:System.Reflection.Emit.DynamicMethod.InitLocals%2A>方法的属性。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#24](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#24)]
 [!code-csharp[Reflection.DynamicMethod.All#24](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#24)]
 [!code-vb[Reflection.DynamicMethod.All#24](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#24)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="dynamicMethod.Invoke (obj, invokeAttr, binder, parameters, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="parameters" Type="System.Object[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">因为动态方法是静态的，所以对于动态方法，忽略此参数。 指定 <see langword="null" />。</param>
        <param name="invokeAttr"><see cref="T:System.Reflection.BindingFlags" /> 值的按位组合。</param>
        <param name="binder">一个 <see cref="T:System.Reflection.Binder" /> 对象，该对象通过反射来启用绑定、参数类型强制、成员调用以及对 <see cref="T:System.Reflection.MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。 有关更多详细信息，请参阅 <see cref="T:System.Reflection.Binder" />。</param>
        <param name="parameters">自变量列表。 这是一个参数数组，这些参数与要调用的方法的参数具有相同的数目、顺序和类型。 如果没有任何参数，则此参数应为 <see langword="null" />。</param>
        <param name="culture">用于控制类型强制的 <see cref="T:System.Globalization.CultureInfo" /> 的实例。 如果这是 <see langword="null" />，则使用当前线程的 <see cref="T:System.Globalization.CultureInfo" />。 例如，将表示 1000 的 <see cref="T:System.String" /> 正确转换为 <see cref="T:System.Double" /> 值时需要此信息，因为不同的区域性使用不同的形式表示 1000。</param>
        <summary>使用指定的参数，在指定的联编程序的约束下，使用指定的区域性信息调用动态方法。</summary>
        <returns>一个 <see cref="T:System.Object" />，包含调用的方法的返回值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 除了列出的异常, 调用代码还应准备好捕获动态方法引发的任何异常。  
  
 使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>方法创建的委托执行动态方法比<xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>使用方法执行动态方法更有效。  
  
 <xref:System.Reflection.Emit.DynamicMethod.Invoke%2A>调用方法<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%2A>或方法完成动态方法。 将忽略更改动态方法的任何进一步尝试, 如修改参数定义或发出更多 Microsoft 中间语言 (MSIL);不引发异常。  
  
 所有动态方法都是静态的`obj` , 因此始终忽略参数。 若要将动态方法视为实例方法, 请使用<xref:System.Reflection.Emit.DynamicMethod.CreateDelegate%28System.Type%2CSystem.Object%29>采用对象实例的重载。  
  
 如果动态方法没有参数, 则的`parameters`值应为。 `null` 否则, 参数数组中元素的数量、类型和顺序应与动态方法的参数的数量、类型和顺序相同。  
  
> [!NOTE]
>  此方法重载由<xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Object%5B%5D%29> <xref:System.Reflection.MethodBase>从类继承的方法重载调用, 因此上述备注适用于这两个重载。  
  
 此方法不直接要求权限, 但调用动态方法可能会导致安全要求, 具体取决于方法。 例如, 对于在`restrictedSkipVisibility`参数设置为`false`的情况下创建的匿名托管动态方法, 不会产生任何要求。 另一方面, 如果你`restrictedSkipVisibility`创建了一个设置为`true`的方法, 以便它可以访问目标程序集的隐藏成员, 则该方法将导致要求<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>目标程序集的权限加上<xref:System.Security.Permissions.ReflectionPermission>标志。  
  
> [!NOTE]
>  在[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]之前, 此方法需要<xref:System.Security.Permissions.ReflectionPermission>带有<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess>标志。  
  
   
  
## Examples  
 下面的代码示例使用美国英语区域性调用具有完全绑定的动态方法。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#4](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#4)]
 [!code-csharp[Reflection.DynamicMethod.All#4](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#4)]
 [!code-vb[Reflection.DynamicMethod.All#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">不支持 <see cref="F:System.Reflection.CallingConventions.VarArgs" /> 调用约定。</exception>
        <exception cref="T:System.Reflection.TargetParameterCountException"><paramref name="parameters" /> 中的元素数量与动态方法中的参数数量不匹配。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="parameters" /> 的一个或多个元素的类型与动态方法的相应参数的类型不匹配。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">该动态方法与模块关联，并且不是匿名承载的，而是在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造的，但是该动态方法可以访问不是 <see langword="public" /> 或 <see langword="internal" />（在 Visual Basic 中为 <see langword="Friend" />）的成员。  
  
- 或 - 
该动态方法是匿名承载的，并且是在 <paramref name="skipVisibility" /> 设置为 <see langword="false" /> 的情况下构造的，但是它可以访问不是 <see langword="public" /> 的成员。  
  
或 
动态方法包含不可验证的代码。 请参阅“验证”部分中的 <see cref="T:System.Reflection.Emit.DynamicMethod" /> 注释。</exception>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.CreateDelegate(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="override this.IsDefined : Type * bool -&gt; bool" Usage="dynamicMethod.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">一个 <see cref="T:System.Type" />，表示要搜索的自定义特性类型。</param>
        <param name="inherit">为 <see langword="true" /> 则搜索方法的继承链以查找自定义属性；为 <see langword="false" /> 则仅检查当前方法。</param>
        <summary>指示是否定义了指定的自定义特性类型。</summary>
        <returns>如果定义了指定的自定义属性类型，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于动态方法, 将`true`指定`inherit`为不起作用。 动态方法没有继承链。  
  
> [!NOTE]
>  动态方法当前不支持自定义特性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Emit.DynamicMethod.GetCustomAttributes(System.Type,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前动态方法是安全关键的还是安全可靠关键的，因此可以执行关键操作。</summary>
        <value>如果当前动态方法是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、和属性<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>报告由公共语言运行时 (CLR) 确定的动态方法的透明度级别。 <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A> 下表显示了这些属性的组合:  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度取决于它所关联的模块。 如果动态方法与类型而不是模块相关联, 则其透明度取决于包含类型的模块。 动态方法没有安全批注, 因此它们被分配了关联模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的, 因为系统提供的包含它们的模块是透明的。  
  
-   下表描述了与受信任的程序集 (即, 全局程序集缓存中安装的强名称程序集) 关联的动态方法的透明度。  
  
    |程序集批注|1级透明度|2级透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合透明度|透明|透明|  
    |不可知安全|安全-关键|严重|  
  
     例如, 如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联, 则动态方法是透明的, 不能执行关键代码。 有关透明度级别的信息, 请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  将动态方法与受信任的第1级程序集 (如 System.object) 中的模块关联不允许提升信任。 如果调用动态方法的代码的授予集不包括在调用动态方法时引发的权限集 (即完全信任), <xref:System.Security.SecurityException>则会引发。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。 如果程序集在部分信任的情况下 (例如, 在沙盒应用程序域中) 加载, 则运行时将忽略程序集的安全注释。 程序集及其所有类型和成员 (包括动态方法) 都被视为透明的。 只有在完全信任的情况下 (例如, 在桌面应用程序的默认应用程序域中) 加载部分信任程序集时, 运行时才会注意到安全注释。 在这种情况下, 运行时将根据程序集的批注为方法分配默认透明度。  
  
 有关反射发出和透明度的详细信息, 请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4.0 版中的安全性更改</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全透明代码, 级别1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全透明的代码，级别 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前动态方法在当前信任级别上是否是安全可靠关键的；即它是否可以执行关键操作并可以由透明代码访问。</summary>
        <value>如果动态方法在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、和属性<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>报告由公共语言运行时 (CLR) 确定的动态方法的透明度级别。 <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A> 下表显示了这些属性的组合:  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度取决于它所关联的模块。 如果动态方法与类型而不是模块相关联, 则其透明度取决于包含类型的模块。 动态方法没有安全批注, 因此它们被分配了关联模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的, 因为系统提供的包含它们的模块是透明的。  
  
-   下表描述了与受信任的程序集 (即, 全局程序集缓存中安装的强名称程序集) 关联的动态方法的透明度。  
  
    |程序集批注|1级透明度|2级透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合透明度|透明|透明|  
    |不可知安全|安全-关键|严重|  
  
     例如, 如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联, 则动态方法是透明的, 不能执行关键代码。 有关透明度级别的信息, 请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  将动态方法与受信任的第1级程序集 (如 System.object) 中的模块关联不允许提升信任。 如果调用动态方法的代码的授予集不包括在调用动态方法时引发的权限集 (即完全信任), <xref:System.Security.SecurityException>则会引发。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。 如果程序集在部分信任的情况下 (例如, 在沙盒应用程序域中) 加载, 则运行时将忽略程序集的安全注释。 程序集及其所有类型和成员 (包括动态方法) 都被视为透明的。 只有在完全信任的情况下 (例如, 在桌面应用程序的默认应用程序域中) 加载部分信任程序集时, 运行时才会注意到安全注释。 在这种情况下, 运行时将根据程序集的批注为方法分配默认透明度。  
  
 有关反射发出和透明度的详细信息, 请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4.0 版中的安全性更改</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全透明代码, 级别1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全透明的代码，级别 2</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.Emit.DynamicMethod.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示动态方法在当前信任级别上是透明的，因此无法执行关键操作。</summary>
        <value>如果动态方法在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.DynamicMethod.IsSecurityCritical%2A>、和属性<xref:System.Reflection.Emit.DynamicMethod.IsSecurityTransparent%2A>报告由公共语言运行时 (CLR) 确定的动态方法的透明度级别。 <xref:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical%2A> 下表显示了这些属性的组合:  
  
|安全级别|IsSecurityCritical|IsSecurityCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|严重|`true`|`false`|`false`|  
|安全关键|`true`|`true`|`false`|  
|透明|`false`|`false`|`true`|  
  
 使用这些属性比检查程序集及其类型的安全批注、检查当前的信任级别，以及尝试复制运行时的规则要简单得多。  
  
 动态方法的透明度取决于它所关联的模块。 如果动态方法与类型而不是模块相关联, 则其透明度取决于包含类型的模块。 动态方法没有安全批注, 因此它们被分配了关联模块的默认透明度。  
  
-   匿名托管的动态方法始终是透明的, 因为系统提供的包含它们的模块是透明的。  
  
-   下表描述了与受信任的程序集 (即, 全局程序集缓存中安装的强名称程序集) 关联的动态方法的透明度。  
  
    |程序集批注|1级透明度|2级透明度|  
    |-------------------------|--------------------------|--------------------------|  
    |完全透明|透明|透明|  
    |完全关键|严重|严重|  
    |混合透明度|透明|透明|  
    |不可知安全|安全-关键|严重|  
  
     例如, 如果将动态方法与包含第2级混合透明度的 mscorlib.dll 类型相关联, 则动态方法是透明的, 不能执行关键代码。 有关透明度级别的信息, 请参阅[安全透明代码, 级别 1](~/docs/framework/misc/security-transparent-code-level-1.md)和[安全透明代码, 级别 2](~/docs/framework/misc/security-transparent-code-level-2.md)。  
  
    > [!NOTE]
    >  将动态方法与受信任的第1级程序集 (如 System.object) 中的模块关联不允许提升信任。 如果调用动态方法的代码的授予集不包括在调用动态方法时引发的权限集 (即完全信任), <xref:System.Security.SecurityException>则会引发。  
  
-   与部分受信任的程序集关联的动态方法的透明度取决于程序集的加载方式。 如果程序集在部分信任的情况下 (例如, 在沙盒应用程序域中) 加载, 则运行时将忽略程序集的安全注释。 程序集及其所有类型和成员 (包括动态方法) 都被视为透明的。 只有在完全信任的情况下 (例如, 在桌面应用程序的默认应用程序域中) 加载部分信任程序集时, 运行时才会注意到安全注释。 在这种情况下, 运行时将根据程序集的批注为方法分配默认透明度。  
  
 有关反射发出和透明度的详细信息, 请参阅[反射发出中的安全问题](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md)。 有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态方法没有方法体。</exception>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md">反射发出中的安全问题</related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md">反射的安全注意事项</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4.0 版中的安全性更改</related>
        <related type="Article" href="https://msdn.microsoft.com/library/5fd8f46d-3961-46a7-84af-2eb1f48e75cf">安全透明代码, 级别1</related>
        <related type="Article" href="https://msdn.microsoft.com/library/4d05610a-0da6-4f08-acea-d54c9d6143c0">安全透明的代码，级别 2</related>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public override RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodHandle : RuntimeMethodHandle" Usage="System.Reflection.Emit.DynamicMethod.MethodHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>动态方法不支持。</summary>
        <value>动态方法不支持。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">动态方法不允许。</exception>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.MethodImplementationFlags : System.Reflection.MethodImplAttributes" Usage="System.Reflection.Emit.DynamicMethod.MethodImplementationFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Module" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Reflection.Emit.DynamicMethod.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法逻辑关联的模块。</summary>
        <value>动态方法当前关联的 <see cref="T:System.Reflection.Module" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在创建动态方法时指定了模块, 则此属性将返回该模块。 如果在创建动态方法时指定了类型作为所有者, 则此属性将返回包含该类型的模块。  
  
   
  
## Examples  
 下面的代码示例显示动态<xref:System.Reflection.Emit.DynamicMethod.Module%2A>方法的属性。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#26](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#26)]
 [!code-csharp[Reflection.DynamicMethod.All#26](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#26)]
 [!code-vb[Reflection.DynamicMethod.All#26](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Reflection.Emit.DynamicMethod.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的名称。</summary>
        <value>方法的简称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  不需要命名动态方法。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的名称。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#27](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#27)]
 [!code-csharp[Reflection.DynamicMethod.All#27](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#27)]
 [!code-vb[Reflection.DynamicMethod.All#27](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#27)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取在反射中用于获取方法的类。</summary>
        <value>总是为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终为`null`动态方法返回。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的反射类型。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#28](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#28)]
 [!code-csharp[Reflection.DynamicMethod.All#28](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#28)]
 [!code-vb[Reflection.DynamicMethod.All#28](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public override System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.Emit.DynamicMethod.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回参数。</summary>
        <value>总是为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性始终为`null`动态方法返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public override Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.Emit.DynamicMethod.ReturnType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回值的类型。</summary>
        <value>一个 <see cref="T:System.Type" />，表示当前方法的返回值的类型；如果该方法没有返回类型，则为 <see cref="T:System.Void" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果`null`在创建动态方法时为返回类型指定, 则此属性返回<xref:System.Void?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的代码示例显示动态方法的返回类型。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#30](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#30)]
 [!code-csharp[Reflection.DynamicMethod.All#30](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#30)]
 [!code-vb[Reflection.DynamicMethod.All#30](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.Emit.DynamicMethod.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取动态方法的返回类型的自定义属性。</summary>
        <value>一个 <see cref="T:System.Reflection.ICustomAttributeProvider" />，表示动态方法的返回类型的自定义属性。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态方法的返回类型不支持自定义特性, 因此该<xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A>方法返回的自定义特性的数组始终为空。  
  
   
  
## Examples  
 下面的代码示例演示如何显示动态方法的返回类型的自定义特性。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#31](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#31)]
 [!code-csharp[Reflection.DynamicMethod.All#31](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#31)]
 [!code-vb[Reflection.DynamicMethod.All#31](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#31)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.Emit.DynamicMethod.ReturnType" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.DynamicMethod.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dynamicMethod.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit.Lightweight</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回方法的签名，以字符串表示。</summary>
        <returns>表示方法签名的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 签名仅包括类型和方法名称 (如果有)。 不包含参数名称。  
  
   
  
## Examples  
 下面的代码示例显示<xref:System.Reflection.Emit.DynamicMethod.ToString%2A>动态方法的方法。 此代码示例是为<xref:System.Reflection.Emit.DynamicMethod>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection.DynamicMethod.All#32](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection.DynamicMethod.All/cpp/source.cpp#32)]
 [!code-csharp[Reflection.DynamicMethod.All#32](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection.DynamicMethod.All/CS/source.cs#32)]
 [!code-vb[Reflection.DynamicMethod.All#32](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection.DynamicMethod.All/VB/source.vb#32)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>