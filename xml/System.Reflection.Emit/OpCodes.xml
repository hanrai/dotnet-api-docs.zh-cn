<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aea33b9e902b909e4adf9f543fadb5190ce68f9b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69109972" /></Metadata><TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <TypeSignature Language="VB.NET" Value="Public Class OpCodes" />
  <TypeSignature Language="C++ CLI" Value="public ref class OpCodes" />
  <TypeSignature Language="F#" Value="type OpCodes = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>通过 <see cref="T:System.Reflection.Emit.ILGenerator" /> 类成员（例如 <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />）为发出提供 Microsoft 中间语言 (MSIL) 指令的字段表示形式。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关成员操作码的详细说明, 请参阅公共语言基础结构 (CLI) 文档, 尤其是 "第三部分:CIL 指令集 "和" 第二部分:元数据定义和语义 "。 可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。  
  
   
  
## Examples  
 下面的示例演示使用<xref:System.Reflection.Emit.ILGenerator>向发出`OpCodes` <xref:System.Reflection.Emit.MethodBuilder>的动态方法的构造。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相加并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|58|add|将两个数值相加, 并返回一个新的数值。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;将添加到`value2`。 `value1`  
  
4.  将结果推送到堆栈上。  
  
 未检测到用于整数运算的溢出 (有关正确的溢出处理<xref:System.Reflection.Emit.OpCodes.Add_Ovf>, 请参阅)。  
  
 整数加法换行, 而不是尽量充满。 例如, 假设8位整数, 其中`value1`设置为 255, 并且`value2`设置为 1, 则包装的结果为0而不是256。  
  
 浮点溢出返回`+inf` (`PositiveInfinity`) 或`-inf` (`NegativeInfinity`)。  
  
 下表列出了可接受的操作数类型及其对应的结果数据类型。 如果没有特定类型组合的条目 (例如和`int32` `float`), 则为;`int32` 和`int64`) 是无效的 Microsoft 中间语言 (MSIL), 并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`add`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D6|add.ovf|使用溢出检查添加两个有符号整数值。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1`添加到`value2` , 并检查溢出。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException>如果结果类型未表示结果, 则会引发。  
  
 您可以对有符号整数执行此操作。 对于浮点值, 请使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表列出了可接受的操作数类型及其对应的结果数据类型。 如果没有特定类型组合的条目 (例如和`int32` `float`), 则为;`int32` 和`int64`), 它是无效的 Microsoft 中间语言 (MSIL) 指令并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`add.ovf`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Add_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Add_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Add_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相加，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D7|add.ovf.un|使用溢出检查添加两个无符号整数值。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1`添加到`value2` , 并检查溢出。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException>如果结果类型未表示结果, 则会引发。  
  
 您可以对有符号整数执行此操作。 对于浮点值, 请使用<xref:System.Reflection.Emit.OpCodes.Add>。  
  
 下表列出了可接受的操作数类型及其对应的结果数据类型。 如果没有特定类型组合的条目 (例如和`int32` `float`), 则为;`int32` 和`int64`), 它是无效的 Microsoft 中间语言 (MSIL) 指令并生成错误。  
  
|操作数|value1 类型|value2 类型|结果类型|  
|-------------|-----------------|-----------------|-----------------|  
|add|`int32`|`int32`|`int32`|  
|添加|`int32`|`native int`|`native int`|  
|添加|`int32`|`&`|`&`|  
|添加|`int32`|`*`|`*`|  
|添加|`int64`|`int64`|`int64`|  
|添加|`native int`|`int32`|`native int`|  
|添加|`native int`|`native int`|`native int`|  
|添加|`native int`|`&`|`&`|  
|添加|`native int`|`*`|`*`|  
|添加|`F`|`F`|`F`|  
|添加|`&`|`int32`|`&`|  
|添加|`&`|`native int`|`&`|  
|添加|`*`|`int32`|`*`|  
|add|`*`|`native int`|`*`|  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`add.ovf.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly And As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode And;" />
      <MemberSignature Language="F#" Value=" staticval mutable And : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算两个值的按位"与"并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|指令|说明|  
|------------|-----------------|-----------------|  
|5F|和|确定两个整数值的按位 "与"。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value1`和`value2`从堆栈中弹出; 这两个值的按位 and。  
  
4.  将结果推送到堆栈上。  
  
 `and`指令计算堆栈上的前两个值的按位 "与", 并将结果保留在堆栈上。  
  
 `And`是特定于整数的操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`and`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Arglist As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Arglist;" />
      <MemberSignature Language="F#" Value=" staticval mutable Arglist : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>返回指向当前方法的参数列表的非托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 00|arglist|返回当前方法的参数列表句柄。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 指令返回一个不透明的句柄 (类型`native int`的非托管指针), 表示当前方法的参数列表。 `arglist` 此句柄仅在当前方法的生存期内有效。 但是, 只要当前方法在控制线程上, 你就可以将该句柄传递给其他方法。 只能在采用可变数目`arglist`的参数的方法中执行指令。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`arglist`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3B < `int32` >|beq`target`|如果两个值相等, 则`target`分支到目标指令的偏移量。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`等于`value2`, 则会执行分支操作。  
  
 如果`beq` 等于`value1` ,则指令将控制转移到指定`value2`的目标指令。 其效果与执行`ceq`指令后跟`brtrue`特定目标指令的分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 可接受的操作数类型如下所示:  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。  
  
 此`try` `catch` `filter`指令不`finally`能执行控制传入和传出、、和块的控制 (此类传输受到严格限制, 因此必须改用指令)。<xref:System.Reflection.Emit.OpCodes.Leave>  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`beq`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Beq_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Beq_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Beq_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果两个值相等，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2E < `int8` >|beq`target`|`target`如果相等, 则分支到目标指令 (如果相等), 短格式|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`等于`value2`, 则会执行分支操作。  
  
 如果`beq.s` 等于`value1` ,则指令将控制转移到指定`value2`的目标指令。 其效果与执行`ceq`指令后跟`brtrue`特定目标指令的分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 可接受的操作数类型如下所示:  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。  
  
 此`try` `catch` `filter`指令不`finally`能执行控制传入和传出、、和块的控制 (此类传输受到严格限制, 因此必须改用指令)。<xref:System.Reflection.Emit.OpCodes.Leave>  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`beq.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3C `<int32>`|bge`target`|如果第一个值大于或等于第二个值, 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`大于或等于, 则会执行分支操作。  
  
 如果`bge` 大于`value1`或等于, 则指令将控制转移到指定的目标指令。 `value2` 此效果与执行`clt.un`指令后跟特定目标指令的`brfalse`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bge`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2F `<int8>`|bge`target`|如果第一个值大于或等于第二个值, 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`大于或等于, 则会执行分支操作。  
  
 如果`bge.s` 大于`value1`或等于, 则指令将控制转移到指定的目标指令。 `value2` 此效果与执行`clt.un`指令后跟特定目标指令的`brfalse`分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bge.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge`target`|如果第一个值大于或等于第二个值 (无符号值), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`大于或等于, 则会执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果大于或等于, 则指令将控制转移到指定的目标指令。`bge.un` 此效果与执行`clt`指令后跟特定目标指令的`brfalse`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bge.un`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bge_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bge_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bge_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge`target`|如果第一个值大于或等于第二个值 (无符号值), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`大于或等于, 则会执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果大于或等于, 则指令将控制转移到指定的目标指令。`bge.un.s` 此效果与执行`clt`指令后跟特定目标指令的`brfalse`分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bge.un.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3D < `int32` >|预算`target`|如果第一个值大于第二个值, 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`大于`value2`, 则执行分支操作。  
  
 如果`bgt` 大于`value1` ,则指令将控制转移到指定`value2`的目标指令。 此效果与执行`cgt`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bgt`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|30 < `int8` >|预算`target`|如果第一个值大于第二个值, 则按指定的偏移量分支到目标指令 (缩写形式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`大于`value2`, 则执行分支操作。  
  
 如果`bgt.s` 大于`value1` ,则指令将控制转移到指定`value2`的目标指令。 此效果与执行`cgt`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bgt.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|42 < `int32` >|预算`target`|如果第一个值大于第二个值 (无符号值), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`大于`value2`, 则执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果大于,指令将控制转移到指定的目标指令。`bgt.un` 此效果与执行`cgt.un`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bgt.un`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bgt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bgt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bgt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值大于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|35 < `int8` >|预算`target`|如果第一个值大于第二个值 (无符号值), 则按指定的偏移量分支到目标指令 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`大于`value2`, 则执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果大于,指令将控制转移到指定的目标指令。`bgt.un.s` 此效果与执行`cgt.un`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bgt.un.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3E `<int32>`|ble`target`|如果第一个值小于或等于第二个值, 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`小于或等于, 则会执行分支操作。  
  
 如果`ble` 小于`value1`或等于, 则指令将控制转移到指定的目标指令。 `value2` 此效果等同于执行`cgt`指令 (`cgt.un`对于浮点), 后跟特定目标`brfalse`指令的分支。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ble`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble`target`|如果第一个值小于或等于第二个值, 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`小于或等于, 则会执行分支操作。  
  
 如果`ble.s` 小于`value1`或等于, 则指令将控制转移到指定的目标指令。 `value2` 此效果等同于执行`cgt`指令 (`cgt.un`对于浮点型) 指令, 后跟特定`brfalse`目标指令的分支。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ble.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble`target`|如果第一个值小于或等于第二个值 (无符号值), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`小于或等于, 则会执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果小于或等于, 则指令将控制转移到指定的目标指令。`ble.un` 此效果等同于执行`cgt.un`指令 (`cgt`对于浮点), 后跟特定目标`brfalse`指令的分支。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ble.un`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ble_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ble_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ble_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于或等于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble`target`|如果第一个值小于或等于第二个值 (无符号值), 则按指定的偏移量分支到目标指令 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1` `value2`小于或等于, 则会执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果小于或等于, 则指令将控制转移到指定的目标指令。`ble.un.s` 此效果等同于执行`cgt.un`指令 (`cgt`对于浮点), 后跟特定目标`brfalse`指令的分支。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ble.un.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3F < `int32` >|blt`target`|如果第一个值小于第二个值, 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`小于`value2`, 则执行分支操作。  
  
 如果`blt` 小于`value1`或等于, 则指令将控制转移到指定的目标指令。 `value2` 此效果与执行`clt`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`blt`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt`target`|如果第一个值小于第二个值, 则按指定的偏移量分支到目标指令 (缩写形式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`小于`value2`, 则执行分支操作。  
  
 如果`blt.s` 小于`value1` ,则指令将控制转移到指定`value2`的目标指令。 此效果与执行`clt`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`blt.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或未经排序的浮点值时，如果第一个值小于第二个值，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt`target`|如果第一个值小于第二个值 (无符号值), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`小于`value2`, 则执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果小于, 则指令将控制转移到指定的目标指令。`blt.un` 此效果与执行`clt.un`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`blt.un`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Blt_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Blt_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Blt_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当比较无符号整数值或不可排序的浮点型值时，如果第一个值小于第二个值，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt`target`|如果第一个值小于第二个值 (无符号值), 则按指定的偏移量分支到目标指令 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`小于`value2`, 则执行分支操作。  
  
 当使用无符号整数或无序浮点值`value1`进行比较时`value2`, 如果小于, 则指令将控制转移到指定的目标指令。`blt.un` 此效果与执行`clt.un`指令后跟特定目标指令的`brtrue`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`blt.un.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或未经排序的浮点值不相等时，将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne`target`|如果两个无符号整数值不相等 (无符号值), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`不等于`value2`, 则执行分支操作。  
  
 如果`bne.un` 不`value1` 等于`value2`, 则当使用无符号整数或无序浮点值进行比较时, 指令将控制转移到指定的目标指令。 此效果与执行`ceq`指令后跟特定目标指令的`brfalse`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bne.un`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Bne_Un_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Bne_Un_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Bne_Un_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当两个无符号整数值或不可排序的浮点型值不相等时，将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne`target`|如果两个无符号整数值不相等 (无符号值), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出; 如果`value1`不等于`value2`, 则执行分支操作。  
  
 如果`bne.un` 不`value1` 等于`value2`, 则当使用无符号整数或无序浮点值进行比较时, 指令将控制转移到指定的目标指令。 此效果与执行`ceq`指令后跟特定目标指令的`brfalse`分支相同。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`bne.un.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Box As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Box;" />
      <MemberSignature Language="F#" Value=" staticval mutable Box : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类转换为对象引用（<see langword="O" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8C < `T` >|文本框`valTypeToken`|将值类型 (在中`valTypeToken`指定的类型) 转换为真正的对象引用。|  
  
 堆栈转换行为顺序如下:  
  
1.  值类型被推送到堆栈上。  
  
2.  从堆栈中弹出值类型;执行`box`操作。  
  
3.  对生成的 "装箱" 值类型的对象引用被推送到堆栈上。  
  
 值类型在公共语言基础结构 (CLI) 中具有两种不同的表示形式:  
  
-   当值类型嵌入到另一个对象或堆栈上时使用的 "原始" 窗体。  
  
-   "装箱" 窗体, 其中值类型中的数据被包装 (装箱) 到对象中, 因此它可以作为独立实体存在。  
  
 指令将 "raw" (未装箱) 值类型转换为对象引用 (类型`O`)。 `box` 为此, 可以创建一个新的对象, 并将数据从值类型复制到新分配的对象。 `valTypeToken`一个元数据标记, 指示堆栈上值类型的类型。  
  
 <xref:System.OutOfMemoryException>如果内存不足, 无法满足请求, 则会引发。  
  
 <xref:System.TypeLoadException>如果找不到类, 则会引发。 当 Microsoft 中间语言 (MSIL) 转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`box`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br `target`|按指定的偏移量分支到目标指令。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 `br`指令将控制无条件地转移到目标指令。 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`br`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Br_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Br_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Br_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>无条件地将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2B < `int8` >|br`target`|按指定的偏移量 (短格式) 分支到目标指令。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 `br.s`指令将控制无条件地转移到目标指令。 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`br.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Break As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Break;" />
      <MemberSignature Language="F#" Value=" staticval mutable Break : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>向公共语言结构 (CLI) 发出信号以通知调试器已撞上了一个断点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|01|break|通知调试器已达到断点。|  
  
 此操作不会执行任何计算堆栈行为。  
  
 `break`指令用于调试支持。 它向 CLI 发出信号, 通知调试器中断点已被终止。 它对解释器状态没有其他影响。  
  
 `break`指令的最小可能指令大小允许代码使用断点进行修补, 并为环绕代码生成最小的干扰。  
  
 `break`指令可以捕获到调试器、不执行任何操作, 或者引发安全异常。 确切的行为是实现定义的。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`break`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用（Visual Basic 中的 <see langword="Nothing" />）或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse`target`<br /><br /> brnull`target`<br /><br /> brzero`target`|如果`false`为, 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`由上一个操作推送到堆栈上。  
  
2.  `value`从堆栈中弹出;如果`value` `target`为`false`, 则分支到。  
  
 `brnull` `brzero`如果`brfalse` (类型`int64`、、对象引用`O`、托管指针), 说明 (及其别名和) 将控制转移到指定的目标指令`int32` `value`, 暂时性`*`指针) 为零 (`false`)。 `native int` `&` 如果`value`为非零 (`true`), 则在下一条指令时继续执行。  
  
 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`brfalse`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brfalse_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brfalse_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brfalse_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="false" />、空引用或零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse`target`<br /><br /> brnull`target`<br /><br /> brzero`target`|如果`false`为, 则按指定的偏移量分支到目标指令 (缩写形式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`由上一个操作推送到堆栈上。  
  
2.  `value`从堆栈中弹出;如果`value` `target`为`false`, 则分支到。  
  
 `brnull` `brzero`如果`brfalse.s` (类型`int64`、、对象引用`O`、托管指针), 说明 (及其别名和) 将控制转移到指定的目标指令`int32` `value`, 暂时性`*`指针) 为零 (`false`)。 `native int` `&` 如果`value`为非零 (`true`), 则在下一条指令时继续执行。  
  
 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`brfalse.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|3A < `int32` >|brtrue`target`<br /><br /> brinst`target`|如果为非零 (`true`), 则按指定的偏移量分支到目标指令。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`由上一个操作推送到堆栈上。  
  
2.  `value`从堆栈中弹出;如果`value` `target`为`true`, 则分支到。  
  
 `true`如果`brtrue` (`value` type`native int`) 的值不为零 (), 指令会将控制转移到指定的目标指令。 如果`value`为零 (`false`), 则执行将在下一条指令继续。  
  
 如果`value`是对象引用 (类型`O`), 则`brinst`为的对象引用`brtrue`(如果它表示对象的实例, 则为) 传输控件 (例如, 如果它不是 null 对象引用, 请<xref:System.Reflection.Emit.OpCodes.Ldnull>参见)。  
  
 目标指令表示为与当前指令后面的指令开头之间的4字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`brtrue`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Brtrue_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Brtrue_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Brtrue_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果 <paramref name="value" /> 为 <see langword="true" />、非空或非零，则将控制转移到目标指令（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2D < `int8` >|brtrue`target`<br /><br /> brinst`target`|如果非零 (), 则按指定的偏移量分支到`true`目标指令 (缩写形式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`由上一个操作推送到堆栈上。  
  
2.  `value`从堆栈中弹出;如果`value` `target`为`true`, 则分支到。  
  
 `true`如果`brtrue.s` (`value` type`native int`) 的值不为零 (), 指令会将控制转移到指定的目标指令。 如果`value`为零 (`false`), 则执行将在下一条指令继续。  
  
 如果`value`是对象引用 (类型`O`), 则`brinst`为的对象引用`brtrue`(如果它表示对象的实例, 则为) 传输控件 (例如, 如果它不是 null 对象引用, 请<xref:System.Reflection.Emit.OpCodes.Ldnull>参见)。  
  
 目标指令表示为与当前指令后面的指令开头之间的1字节有符号偏移量。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`brtrue.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Call As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Call;" />
      <MemberSignature Language="F#" Value=" staticval mutable Call : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>调用由传递的方法说明符指示的方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|28 < `T` >|拨`methodDesc`|调用所描述`methodDesc`的方法。|  
  
 堆栈转换行为顺序如下:  
  
1.  `arg1` 通过`argN`将方法参数推送到堆栈上。  
  
2.  `arg1` 通过`argN`从堆栈中弹出方法自变量; 使用这些参数执行方法调用, 并将控件传输到方法说明符所引用的方法。 完成后, 调用方方法将生成一个返回值, 并将其发送给调用方。  
  
3.  将返回值推送到堆栈上。  
  
 `call`指令调用通过指令传递的方法说明符指示的方法。 方法描述符是一种元数据标记, 用于指示要调用的方法, 以及要传递到该方法的堆栈上的参数的数量、类型和顺序, 以及要使用的调用约定。 指令前面可以跟一个`tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前缀指令, 以指定在传输控件之前应释放当前方法状态。 `call` 如果调用将控制转移到比源方法更高的信任方法, 则不会释放堆栈帧。 相反, 执行将以无提示方式继续`tail` , 就好像尚未提供。 元数据标记携带足够的信息来确定调用是静态方法、实例方法、虚方法还是全局函数。 在所有这些情况下, 均从方法描述符完全确定目标地址 (与<xref:System.Reflection.Emit.OpCodes.Callvirt>调用虚拟方法的指令相比, 其中, 目标地址也依赖于实例的运行时类型)在之前推送的<xref:System.Reflection.Emit.OpCodes.Callvirt>引用。  
  
 自变量以从左到右的顺序放置在堆栈上。 也就是说, 第一个参数是计算并放置在堆栈上, 然后是第三个参数, 然后是第三个参数, 直到所有必需的参数按降序排列。 有三个重要的特殊情况:  
  
 1. 对实例 (或虚拟) 方法的调用必须将该实例引用推送到任何用户可见参数之前。 实例引用不得为空引用。 在元数据中携带的签名不包含用于`this`指针的参数列表中的条目; 相反, 它使用位来指示该方法是否要求`this`传递指针。  
  
 2. 使用`call` (`callvirt`而不是) 调用虚拟方法是有效的; 这表示使用方法指定的类 (而不是从所调用的对象动态指定) 解析方法。  
  
 3. 请注意, 可以使用`Invoke` `call`或`callvirt`指令调用委托的方法。  
  
 <xref:System.Security.SecurityException>如果系统安全不允许调用方访问调用的方法, 则可能会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 可能会进行安全检查。  
  
> [!NOTE]
>  当在值类型上调用 system.object 的方法时, 请考虑将`constrained`前缀`callvirt`与`call`指令一起使用, 而不是发出指令。 这就不必发出不同的 IL, 具体取决于值类型是否重写方法, 避免出现潜在的版本控制问题。 对值类型`constrained`调用接口方法时, 请考虑使用前缀, 因为实现接口方法的值类型方法可`MethodImpl`使用进行更改。 <xref:System.Reflection.Emit.OpCodes.Constrained>操作码中更详细地介绍了这些问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`call`使用操作码:  
  
-   ILGenerator (操作码, MethodInfo)  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
> [!NOTE]
>  为<xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> 调用`varargs`提供了方法。 <xref:System.Reflection.Emit.ILGenerator.Emit%2A>使用方法进行正常调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Calli As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Calli;" />
      <MemberSignature Language="F#" Value=" staticval mutable Calli : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>通过调用约定描述的参数调用在计算堆栈上指示的方法（作为指向入口点的指针）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli`callSiteDescr`|使用调用约定描述的参数调用指向的方法。|  
  
 堆栈转换行为顺序如下:  
  
1.  `arg1` 通过`argN`将方法参数推送到堆栈上。  
  
2.  方法输入指针被推送到堆栈上。  
  
3.  方法自`arg1`变量`argN`到, 并从堆栈中弹出方法输入指针; 执行对方法的调用。 完成后, 调用方方法将生成一个返回值, 并将其发送给调用方。  
  
4.  将返回值推送到堆栈上。  
  
 指令使用参数`arg1` 通过`argN`调用方法输入指针。 `calli` 这些参数的类型由特定的调用约定 (`callSiteDesc`) 描述。 指令前面可以跟前缀 (<xref:System.Reflection.Emit.OpCodes.Tailcall>), 以指定在传输控制之前应释放当前方法状态。 `tail` `calli` 如果调用会将控制传输到比源方法更高的信任方法, 则不会释放堆栈帧;相反, 执行将以无提示方式继续, `tail`就好像尚未提供。  
  
 假定方法输入指针是指向本机代码 (目标计算机) 的特定指针, 该指针可以使用调用约定描述的参数 (独立签名的元数据标记) 合法调用。 此类指针可使用<xref:System.Reflection.Emit.OpCodes.Ldftn>或<xref:System.Reflection.Emit.OpCodes.Ldvirtftn>说明创建, 或通过本机代码传入。  
  
 不动态检查调用约定, 因此, 如果目标不实际使用`calli`指定的调用约定, 则使用指令的代码将无法正常运行。  
  
 自变量以从左到右的顺序放置在堆栈上。 也就是说, 第一个参数是计算并放置在堆栈上, 然后是第三个参数, 然后是第三个参数, 直到所有必需的参数按降序排列。 实例或虚方法的参数生成代码序列必须在任何用户可见参数之前推送该实例引用 (不得为空引用)。  
  
 <xref:System.Security.SecurityException>如果系统安全不允许调用方访问调用的方法, 则可能会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时时, 可能会进行安全检查。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A>方法可用于对堆栈`calli`执行指令。 请注意`calli` , 应通过以下方法调用, 而不是<xref:System.Reflection.Emit.ILGenerator.Emit%2A>使用类将指令直接放置在堆栈上。  
  
-   对于使用托管调用约定的调用, EmitCalli (操作码、CallingConventions、Type、type []、Type [])。  
  
-   ILGenerator 使用非托管调用约定调用 EmitCalli (Opcode, CallingConvention, Type, Type [])。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Callvirt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Callvirt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Callvirt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对对象调用后期绑定方法，并且将返回值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6F < `T` >|callvirt`method`|调用与`obj`相关联的特定方法。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`obj`被推送到堆栈上。  
  
2.  `arg1` 通过`argN`将方法参数推送到堆栈上。  
  
3.  通过`arg1` `obj` `obj`和从堆栈中弹出对象引用的方法参数; 使用这些参数执行方法调用, 并将控件传输到方法所引用的方法`argN`元数据标记。 完成后, 调用方方法将生成一个返回值, 并将其发送给调用方。  
  
4.  将返回值推送到堆栈上。  
  
 `callvirt`指令对对象调用后期绑定方法。 也就是说, 将根据的运行时类型`obj`而不是方法指针中的编译时类选择方法。 `Callvirt`可用于调用虚拟方法和实例方法。 指令前面可以跟一个`tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) 前缀, 以指定在传输控制之前应释放当前堆栈帧。 `callvirt` 如果调用会将控制传输到比原始方法更高的信任方法, 则不会释放堆栈帧。  
  
 方法元数据标记提供要调用的方法的名称、类和签名。 与`obj`关联的类是它是其实例的类。 如果类定义了与指定方法名称和签名匹配的非静态方法, 则会调用此方法。 否则, 会按顺序检查此类的基类链中的所有类。 如果未找到任何方法, 则是错误的。  
  
 `Callvirt`在调用方法之前, 将对象和关联参数从计算堆栈中弹出。 如果该方法具有返回值, 则在方法完成后将其推送到堆栈上。 在被调用方方, `obj`参数作为`arg1`参数1访问, 依此类推。  
  
 自变量以从左到右的顺序放置在堆栈上。 也就是说, 第一个参数是计算并放置在堆栈上, 然后是第三个参数, 然后是第三个参数, 直到所有必需的参数按降序排列。 实例引用`obj` (始终`callvirt`需要) 必须在任何用户可见参数之前推送。 签名 (包含在元数据标记中) 不需要包含在此指针的参数列表中的条目。  
  
 请注意, 还可以使用<xref:System.Reflection.Emit.OpCodes.Call>指令调用虚拟方法。  
  
 <xref:System.MissingMethodException>如果在与其关联`obj`的类或其任何基类中找不到具有指定名称和签名的非静态方法, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 <xref:System.NullReferenceException>如果 obj 为 null, 则引发。  
  
 <xref:System.Security.SecurityException>如果系统安全不向调用方授予对所调用方法的访问权限, 则会引发。 当 CIL 转换为本机代码而不是运行时, 可能会进行安全检查。  
  
> [!NOTE]
>  当在值类型上调用 system.object 的方法时, 请考虑在`constrained` `callvirt`指令中使用前缀。 这就不必发出不同的 IL, 具体取决于值类型是否重写方法, 避免出现潜在的版本控制问题。 对值类型`constrained`调用接口方法时, 请考虑使用前缀, 因为实现接口方法的值类型方法可`MethodImpl`使用进行更改。 <xref:System.Reflection.Emit.OpCodes.Constrained>操作码中更详细地介绍了这些问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`callvirt`使用操作码:  
  
-   ILGenerator (操作码, MethodInfo)  
  
-   ILGenerator.EmitCall(OpCode, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Castclass As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Castclass;" />
      <MemberSignature Language="F#" Value=" staticval mutable Castclass : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>尝试将引用传递的对象转换为指定的类。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass`class`|将对象强制转换为类型`class`的新对象。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用;被引用对象被强制转换为指定`class`的。  
  
3.  如果成功, 则将新的对象引用推送到堆栈上。  
  
 指令尝试将位于堆栈顶部的对象引用 ( `O`类型) 强制转换为指定的类。 `castclass` 新类由指示所需类的元数据标记指定。 如果堆栈顶部对象的类未实现新类 (假定新类为接口), 并且不是新类<xref:System.InvalidCastException>的派生类, 则会引发。 如果对象引用为空引用, 则将`castclass`成功, 并返回新的对象作为空引用。  
  
 <xref:System.InvalidCastException>如果无法将 obj 强制转换为类, 则会引发。  
  
 <xref:System.TypeLoadException>如果找不到类, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`castclass`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ceq As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ceq;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ceq : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果这两个值相等，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；否则，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 01|ceq|如果`value1` 等于`value2`, 则推送 1; 否则推送0。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1`与进行`value2`比较。  
  
4.  `value1` 如果`value2`等于, 则将1推送到堆栈上; 否则, 将0推送到堆栈上。  
  
 指令比较`value1` 和`value2`。 `ceq` 如果`value1` `int32`等于, 则将 1 (类型) 推送到堆栈上。 `value2` 否则, 将 0 ( `int32`类型) 推送到堆栈上。  
  
 对于浮点数, 如果数字`ceq`未排序 (或两者均为 NaN), 则将返回0。 无限值等于自身。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ceq`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 02|cgt|`value1` 如果`value2`大于, 则返回 1; 否则推送0。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`cgt`如果大于`value1`,则测试。 `value2`  
  
4.  `value1` 如果`value2`大于, 则将1推送到堆栈上; 否则, 将0推送到堆栈上。  
  
 指令比较`value1` 和`value2`。 `cgt` 如果`value1`严格`int32`大于, 则将值1推送到堆栈上。 `value2` 否则, `int32`将值0推送到堆栈上。  
  
-   对于浮点数, 如果数字`cgt`未排序 (也就是说, 如果一个参数或两个参数均为 NaN), 则返回0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`cgt`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cgt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cgt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cgt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个无符号的或不可排序的值。 如果第一个值大于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 03|cgt.un|`value1` 如果`value2`大于, 则推送 1; 否则推送 0 (无符号值)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`cgt.un`如果大于`value1`,则测试。 `value2`  
  
4.  `value1` 如果`value2`大于, 则将1推送到堆栈上; 否则, 将0推送到堆栈上。  
  
 如果下列任一项为`true` , 则将值1推送到堆栈上:`int32`  
  
 对于浮点数, `value1`不按`value2`相对顺序排序。  
  
 对于整数值, `value1`严格`value2`大于被视为无符号数字。  
  
 否则, 将值0推送到堆栈上。 `int32`  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`cgt.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ckfinite As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ckfinite;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ckfinite : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果值不是有限数，则引发 <see cref="T:System.ArithmeticException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|C3|ckfinite|如果<xref:System.ArithmeticException>值不是有限数, 则引发。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。 
  
2.  `value`从堆栈中弹出, 并`ckfinite`对其执行指令。  
  
3.  `value`如果未引发异常, 则将被推送回堆栈。  
  
 如果`ckfinite instruction` <xref:System.ArithmeticException> `+-` (浮点数) 为 "不是数字" 值 (NaN) 或无穷值, 则会引发。 `value` `Ckfinite`如果没有引发异常, 则将值保留在堆栈上。 如果`value`不是浮点数, 则不指定执行。  
  
 <xref:System.ArithmeticException>如果`value`不是 "normal" 数字, 则会引发。  
  
 请注意, 特殊异常或派生类<xref:System.ArithmeticException>可能更合适, 将错误值传递到异常处理程序。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ckfinite`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较两个值。 如果第一个值小于第二个值，则将整数值 1 <see langword="(int32" />) 推送到计算堆栈上；反之，将 0 (<see langword="int32" />) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 04|clt|`value1` 如果`value2`小于, 则返回 1; 否则推送0。|  
  
 堆栈转换行为顺序如下: 

1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`clt`如果小于`value1`,则测试。 `value2`  
  
4.  `value1` 如果`value2`小于, 则将1推送到堆栈上; 否则, 将0推送到堆栈上。  
  
 指令比较`value1` 和`value2`。 `clt` 如果`value1`严格`int32`小于, 则将值1推送到堆栈上。 `value2` 否则, `int32`将值0推送到堆栈上。  
  
-   对于浮点数, 如果数字`clt`未排序 (也就是说, 如果一个参数或两个参数均为 NaN), 则返回0。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`clt`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Clt_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Clt_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Clt_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>比较无符号的或不可排序的值 <paramref name="value1" /> 和 <paramref name="value2" />。 如果 <paramref name="value1" /> 小于 <paramref name="value2" />，则将整数值 1 <see langword="(int32" /> ) 推送到计算堆栈上；反之，将 0 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 05|clt.un|`value1` 如果`value2`小于, 则推送 1; 否则推送 0 (无符号值)。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`clt.un`如果小于`value1`,则测试。 `value2`  
  
4.  `value1` 如果`value2`小于, 则将1推送到堆栈上; 否则, 将0推送到堆栈上。  
  
 指令比较`value1` 和`value2`。 `clt.un` 如果满足以下任一条件, 则将值1推送到堆栈上:`int32`  
  
-   `value1`严格小于`value2` (对于`clt`)。  
  
-   对于浮点数, `value1`不按`value2`相对顺序排序。  
  
-   对于整数值, `value1`严格`value2`小于被视为无符号数字。  
  
 否则, `int32`将值0推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`clt.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Constrained As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Constrained;" />
      <MemberSignature Language="F#" Value=" staticval mutable Constrained : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>约束要对其进行虚方法调用的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 16 <`T` >|有限. `thisType`|对被约束为类型`T`的类型调用虚方法。|  
  
 仅允许`callvirt`对指令使用前缀。`constrained`  
  
 此时 MSIL 堆栈的状态必须如下所示:  
  
1.  托管指针`ptr`将被推送到堆栈上。 的`ptr`类型必须为的托管指针 (`&`) `thisType`。 请注意, 这与没有前缀`callvirt`指令的大小写不同, 后者需要`thisType`引用。  
  
2.  方法自`arg1`变量`argN`会被推送到堆栈上, 就像使用没有前缀`callvirt`指令一样。  
  
 前缀旨在允许`callvirt`以统一的方式进行说明, 而不管`thisType`它是值类型还是引用类型。 `constrained`  
  
 如果指令已作为前缀,则将按如下所示执行指令:`thisType` `constrained` `callvirt` `method`  
  
-   如果`thisType`是引用类型 (而不是值类型), 则`ptr`将取消引用并将作为 " `callvirt` this" 指针传递到的`method`。  
  
-   如果`thisType`是值类型并`thisType`实现`method` `method` , 则`ptr` `call` 会将未修改的作为"this`method` " 指针传递到指令, 以便实现`thisType`.  
  
-   如果`thisType`是值类型且`thisType`不实现`method` , 则`ptr`将取消引用并装箱`callvirt` `method` , 并将其作为 "this" 指针传递到指令。  
  
 仅当`method`在、 <xref:System.Object> <xref:System.ValueType>或`thisType`上定义时, 才会发生这种情况, 而不会重写。 <xref:System.Enum> 在这种情况下, 装箱会导致生成原始对象的副本。 但是, 因为<xref:System.Object>、 <xref:System.ValueType>和<xref:System.Enum>的任何方法都不能修改对象的状态, 所以无法检测到这种情况。  
  
 `constrained`前缀支持创建泛型代码的 IL 生成器。 通常, `callvirt`指令在值类型上无效。 相反, 在编译时 IL 编译器必须有效地执行上面所述的 "this" 转换, 具体取决于`ptr`和所调用方法的类型。 但是, 如果`ptr`是在编译时未知的泛型类型, 则不能在编译时进行此转换。  
  
 操作码允许 IL 编译器以统一的方式对虚拟函数进行调用, 而不管`ptr`它是值类型还是引用类型。 `constrained` 尽管它适用于`thisType`属于泛型类型变量的情况`constrained` , 但前缀还适用于非泛型类型, 并且可以降低以隐藏值类型之间的区别的语言生成虚拟调用的复杂性引用类型。  
  
 `constrained`使用前缀还可以避免值类型出现潜在的版本管理问题。 如果未使用前缀, 则必须根据值类型是否重写 system.object 的方法来发出不同的 IL。 `constrained` 例如, 如果值`V`类型重写对象 ToString () 方法`Object.ToString()` `call` `V.ToString()` , 则会`box`发出指令; 如果不是, 则发出指令和`callvirt`指令。 如果稍后要删除重写, 并且在后一种情况下, 如果后来添加了替代, 则可能会出现版本控制问题。  
  
 前缀还可用于对值类型调用接口方法, 因为实现接口方法的值类型方法可`MethodImpl`使用进行更改。 `constrained` 如果未使用前缀, 则强制编译器在编译时选择要绑定到的值类型的方法。 `constrained` `constrained`使用前缀允许 MSIL 绑定到在运行时实现接口方法的方法, 而不是在编译时。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`constrained`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D3|约定|转换为`native int`, 推送`native int`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.i`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.i`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int8" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|67|约定 i1|转换为`int8`, 推送`int32`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.i1`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.i1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int16" />，然后将其扩展（填充）为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|68|约定|转换为`int16`, 推送`int32`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.i2`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.i2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|69|i4|转换为`int32`, 推送`int32`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.i4`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.i4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6A|i8|转换为`int64`, 推送`int64`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.i8`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.i8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D4|ovf。 i|转换为`native int` (在堆栈上为`native int`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8A|将 ovf|将无符号值转换为`native int` (在堆栈上为`native int`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号的 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B3|conv.ovf.i1|转换为`int8` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i1` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|82|conv.ovf.i1.un|将无符号值转换为`int8` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i1.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i1.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B5|conv.ovf.i2|转换为`int16` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i2` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|83|conv.ovf.i2.un|将无符号值转换为`int16` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i2.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i2.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B7|conv.ovf.i4|转换为`int32` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i4` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|84|conv.ovf.i4.un|将无符号值转换为`int32` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i4.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i4.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B9|conv.ovf.i8|转换为`int64` (在堆栈上为`int64`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i8` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_I8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_I8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为有符号 <see langword="int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|85|conv.ovf.i8.un|将无符号值转换为`int64` (在堆栈上为`int64`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.i8.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.i8.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D5|conv.ovf.u|转换为`unsigned native int` (在堆栈上为`native int`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned native int" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8B|conv.ovf.u.un|将无符号值转换为`unsigned native int` (在堆栈上为`native int`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.uvf.u.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B4|conv.ovf.u1|转换为`unsigned int8` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u1` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U1_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U1_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int8" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|86|conv.ovf.u1.un|将无符号值转换为`unsigned int8` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u1.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u1.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B6|conv.ovf.u2|转换为`unsigned int16` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u2` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U2_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U2_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int16" /> 并将其扩展为 <see langword="int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|87|conv.ovf.u2.un|将无符号值转换为`unsigned int16` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u2.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u2.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|B8|conv.ovf.u4|转换为`unsigned int32` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u4` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U4_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U4_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int32" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|88|conv.ovf.u4.un|将无符号值转换为`unsigned int32` (在堆栈上为`int32`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u4.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u4.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的有符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|BA|conv.ovf.u8|转换为`unsigned int64` (在堆栈上为`int64`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u8` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_Ovf_U8_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_Ovf_U8_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号值转换为 <see langword="unsigned int64" />，并在溢出时引发 <see cref="T:System.OverflowException" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|89|conv.ovf.u8.un|将无符号值转换为`unsigned int64` (在堆栈上为`int64`), 并在溢出时引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。 如果发生溢出, 则会引发异常。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 操作码将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值置于堆栈的顶部。`value` `conv.ovf.u8.un` 如果值太大或太小而无法由目标类型表示, 则会引发异常。  
  
 从浮点数到整数值的转换会将数字截断到零。 请注意, 小于4个字节的整数值在加载`int32`到计算堆栈上时将扩展到 (除非`conv.ovf.i`使用`conv.ovf.u`或, 在这种情况下, 结果也`native int`是)。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.ovf.u8.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的无符号整数值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|76|约定|将无符号整数转换为浮点, 并`F`推送堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.r.un`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果在将浮点类型转换为整数时发生溢出, 则不`result`指定返回的。 操作将从堆栈中提取一个整数, 将其解释为无符号, 并将其替换为浮点数以表示整数: `float32`或者, 如果此宽度足以表示整数而不丢失精度, 则为; 否则为`conv.r.un`一个`float64`。  
  
 使用此字段时, 不会引发异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.r.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6B|conv.r4|转换为`float32`, 推送`F`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.r4`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.r4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="float64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6C|conv.r8|转换为`float64`, 推送`F`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.r8`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.r8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned native int" />，然后将其扩展为 <see langword="native int" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|E0|约定|转换为`unsigned native int`, 推送`native int`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.u`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.u`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int8" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D2|约定|转换为`int8`, 推送`int32`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.u1`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.u1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int16" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D1|约定|转换为`int16`, 推送`int32`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.u2`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.u2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int32" />，然后将其扩展为 <see langword="int32" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6D|u4|转换为`unsigned int32`, 推送`int32`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.u4`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.u4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Conv_U8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Conv_U8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Conv_U8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值转换为 <see langword="unsigned int64" />，然后将其扩展为 <see langword="int64" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|6E|u8|转换为`int64`, 推送`int64`堆栈。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并尝试执行转换操作。  
  
3.  如果转换成功, 则将结果值推送到堆栈上。  
  
 `conv.u8`操作码`value`将堆栈顶部的转换为操作码中指定的类型, 并将转换后的值保留在堆栈的顶部。 小于4个字节的整数值在加载到`int32`计算堆栈上时将扩展到 (除非`conv.i`使用或`conv.u` , 在这种情况下, 结果也`native int`是)。 将浮点值转换为`F`类型。  
  
 从浮点数到整数值的转换会将数字截断到零。 从`float64` 转换`float32`到时, 精度可能会丢失。 如果`value`太大`float32 (F)`而无法容纳, 则返回正无穷 (如果`value`为正) 或负无穷 (如果`value`为负)。 如果在将一个整数类型转换为另一个整数类型时发生溢出, 则会截断高序位。 如果结果`int32`小于, 则值将进行符号扩展以填充槽。  
  
 如果发生溢出, 将浮点类型转换为整数, 则返回的值是未指定的。  
  
 使用此字段时, 不会引发异常。 有关<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8>在<xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un>结果类型无法正确表示结果值时将引发异常的等效说明, 请参见和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`conv.u8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定数目的字节从源地址复制到目标地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|将数据从一个内存块复制到另一个内存块。|  
  
 堆栈转换行为顺序如下:  
  
1.  目标地址被推送到堆栈上。  
  
2.  源地址被推送到堆栈上。  
  
3.  要复制的字节数将被推送到堆栈上。  
  
4.  从堆栈中弹出的字节数、源地址和目标地址;指定的字节数从源地址复制到目标地址。  
  
 `native int` `native int` `&` `&` `*` `*`指令将字节数 (类型`unsigned int32`) 从源地址 (类型为、或) 复制到目标地址 (类型为、或)。 `cpblk` 如果源区域`cpblk`和目标区域重叠, 则的行为是未指定的。  
  
 `cpblk`假设源和目标地址都与计算机的自然大小对齐。 指令前面可以紧跟指令, 以指示源或目标是未对齐的。 `unaligned.<prefix>` `cpblk`  
  
 `cpblk`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`cpblk`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Cpobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Cpobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Cpobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）地址的值类型复制到目标对象（<see langword="&amp;" />、<see langword="*" /> 或 <see langword="native int" /> 类型）的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj`classTok`|将值类型从源对象复制到目标对象。|  
  
 堆栈转换行为顺序如下:  
  
1.  目标对象引用被推送到堆栈上。  
  
2.  源对象引用被推送到堆栈上。  
  
3.  从堆栈中弹出两个对象引用;将源对象地址的值类型复制到目标对象的地址。  
  
 如果源对象`cpobj`和目标对象引用不是指向类标记`classTok` ( `typeref`或`typedef`) 表示的类的实例的指针, 或者如果`classTok`不表示, 则的行为是未指定的。值类型。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`cpobj`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将结果作为浮点（<see langword="F" /> 类型）或商（<see langword="int32" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5B|div|将两个值相除以返回商或浮点结果。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1`除以。`value2`  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1`div value2 满足以下条件:  
  
 &#124;`result` &#124; = &#124; / &#124;和: &#124; &#124; `value1` `value2`  
  
 `value2``value1``value2``value1`sign ()=+,ifsign()=sign()或-,ifsign()~=sign()`result`  
  
 `div`指令计算结果并将结果推送到堆栈上。  
  
 整数除法向零截断。  
  
 有限数除以零会生成正确的无符号无限值。  
  
 零除以零或无穷大按无穷产生 NaN (非数字) 值。 除以无限大的任何数字都会产生零值。  
  
 如果无法用<xref:System.ArithmeticException>结果类型表示结果, 则整型运算将引发。 如果`value1`是最大负值且`value2`为-1, 则可能会发生这种情况。  
  
 <xref:System.DivideByZeroException> 如果`value2`为零, 则引发整数运算。  
  
 请注意, 在基于 Intel 的平台<xref:System.OverflowException>上, 计算时引发 (minint div-1)。 浮点运算永远不会引发异常 (而是生成 Nan 或无穷大)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`div`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Div_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Div_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Div_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>两个无符号整数值相除并将结果 ( <see langword="int32" /> ) 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5C|div. un|将两个值相除, 并返回商。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1`除以。`value2`  
  
4.  将结果推送到堆栈上。  
  
 `result`指令计算`value1` 除以`value2`, 同时作为无符号整数, 并将推送到堆栈上。 `div.un`  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`div.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Dup As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Dup;" />
      <MemberSignature Language="F#" Value=" staticval mutable Dup : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>复制计算堆栈上当前最顶端的值，然后将副本推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|25|重复|复制堆栈顶部的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出以进行复制。  
  
3.  `value`被推送回堆栈上。  
  
4.  将重复的值推送到堆栈上。  
  
 `dup`指令复制堆栈的顶部元素, 并将两个相同的值保留在其中。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`dup`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfilter As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfilter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfilter : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常的 <see langword="filter" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 11|执行 endfilter|SEH 异常处理的结束筛选器子句。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出;`endfilter`执行, 并将控制权传输到异常处理程序。  
  
 `Value`(必须为类型`int32` , 并且是从筛选子句返回的一组特定值中的一组值)。 它应该是以下其中之一:  
  
-   `exception_continue_search`(`value` = 0) 以继续搜索异常处理程序  
  
-   `exception_execute_handler`(`value` = 1), 用于启动异常处理的第二个阶段, 其中 finally 块将一直运行, 直到找到与此筛选器子句关联的处理程序。 发现后, 将执行处理程序。  
  
 其他整数值将产生未指定的结果。  
  
 筛选器的入口点 (如方法的异常表中所示) 必须是筛选器的代码块中的第一个指令。 指令必须是筛选器的代码块中的最后一个指令 (因此, 对于任何单个筛选`endfilter`器块, 只能有一个)。 `endfilter` 执行`endfilter`指令后, 控件以逻辑方式流回 CLI 异常处理机制。  
  
 不能将控件传输到筛选器块中, 除非通过异常机制。 除了通过使用`throw`指令或通过执行最后一个`endfilter`指令以外, 不能从筛选器块中转移控件。 不能将`try`块嵌入到`filter`块中。 如果在`filter`块内引发异常, 则将被截获并返回值 0 (`exception_continue_search`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`endfilter`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Endfinally As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Endfinally;" />
      <MemberSignature Language="F#" Value=" staticval mutable Endfinally : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将控制从异常块的 <see langword="fault" /> 或 <see langword="finally" /> 子句转移回公共语言结构 (CLI) 异常处理程序。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DC|执行 endfinally<br /><br /> endfault|结束异常`finally`块`fault`的或子句。|  
  
 此指令没有堆栈转换行为。  
  
 `Endfinally`并`endfault`向`finally`或子句的末尾发出信号,以便在调用异常处理程序之前,堆栈展开可以继续。`fault` `endfinally` 或`endfault`指令将控制转移回 CLI 异常机制。 然后, 如果受保护的块`finally`退出并带有 leave 指令, 则该机制会搜索链中的下一个子句。 如果受保护的块退出但出现异常, 则 CLI 将搜索下一个`finally`或`fault`, 或输入在第一次处理异常过程中选择的异常处理程序。  
  
 指令只能出现`finally`在块中的词法上。 `endfinally` 与说明不同, 不要求块以`endfinally`指令结束, 并且在所需的块中可以有任意数量`endfinally`的指令。 `endfilter` 这些相同的`endfault`限制适用于指令`fault`和块。  
  
 不能将控件传输到`finally` (或`fault`) 块中, 除非通过异常机制。 `finally` `fault`除了通过使用`endfinally`指令或执行 (或`endfault`) 指令以外, 不能从 (或) 块中转移控件。 `throw` 特别是`finally` , 不能 "跳出" (或`fault`) <xref:System.Reflection.Emit.OpCodes.Ret>块, 也不能在`finally` (或`fault`) <xref:System.Reflection.Emit.OpCodes.Leave>块中执行或指令。  
  
 请注意`endfinally` ,和说明是别名,它们对应于相同`endfault`的操作码。  
  
 下面<xref:System.Reflection.Emit.ILGenerator.Emit%2A>的方法重载可以`endfinally`使用 (`endfault`) 操作码`ILGenerator`以及方法<xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>。  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initblk As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initblk;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initblk : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定地址的内存的指定块初始化为给定大小和初始值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 18|initblk|将内存块中的每个位置设置为给定值。|  
  
 堆栈转换行为顺序如下:  
  
1.  起始地址被推送到堆栈上。  
  
2.  将初始化值推送到堆栈上。  
  
3.  要初始化的字节数将被推送到堆栈上。  
  
4.  从堆栈中弹出字节数、初始化值和起始地址, 并按它们的值执行初始化。  
  
 `&``unsigned int32` `unsigned int8` `*`指令将从指定的地址 (类型`native int`为、或) 开始的字节数 () 设置为初始化值 (类型为)。 `initblk` `initblk`假定起始地址与计算机的自然大小对齐。  
  
 `initblk`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`initblk`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Initobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Initobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Initobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定地址的值类型的每个字段初始化为空引用或适当的基元类型的 0。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 15 <`T` >|`initobj` `typeTok`|初始化值类型。|  
  
 堆栈转换行为顺序如下:  
  
1.  要初始化的值类型的地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;指定地址处的值类型初始化为类型`typeTok`。  
  
 指令将按下推送地址 (类型`native int`为、 `&`或`*`) 指定的值类型的每个字段初始化为空引用或适当的基元类型的0。 `initobj` 调用此方法后, 该实例已准备好调用构造函数方法。 如果`typeTok`是引用类型, 则此指令具有与`ldnull`后跟`stind.ref`的相同效果。  
  
 与<xref:System.Reflection.Emit.OpCodes.Newobj>不同`initobj` , 不调用构造函数方法。 `Initobj`用于初始化值类型, 而`newobj`用于分配和初始化对象。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`initobj`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Isinst As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Isinst;" />
      <MemberSignature Language="F#" Value=" staticval mutable Isinst : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>测试对象引用（<see langword="O" /> 类型）是否为特定类的实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst`class`|测试对象引用是否为的实例`class`, 同时返回空引用或该类或接口的实例。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用并对其进行测试, 以查看它是否为传入`class`类的实例。  
  
3.  结果 (对象引用或空引用) 被推送到堆栈上。  
  
 `Class`指示所需类的元数据标记。 如果堆栈顶部`class`对象的类实现 (如果`class`是接口) 或是的`class`派生类 (如果`class`是常规类), 则将其强制转换为类型`class` , 并将结果推送到堆栈上。完全像<xref:System.Reflection.Emit.OpCodes.Castclass>调用一样。 否则, 在堆栈上推送空引用。 如果对象引用本身为空引用, 则`isinst`同样返回空引用。  
  
 <xref:System.TypeLoadException>如果找不到类, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`isinst`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Jmp As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Jmp;" />
      <MemberSignature Language="F#" Value=" staticval mutable Jmp : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出当前方法并跳至指定方法。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|27 < `T` >|跳转`method`|退出当前方法并跳至指定方法。|  
  
 此指令没有堆栈转换行为。  
  
 (跳转) 指令将控制转移到`method`指定的方法, 该方法是方法引用的元数据标记。 `jmp` 当前参数将传输到目标方法。  
  
 执行此指令时, 计算堆栈必须为空。 目标地址的调用约定、数量和参数类型必须与当前方法的参数匹配。  
  
 `filter` `try` `finally` `catch`指令不能用于将控制转移出、、或块。 `jmp`  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`jmp`使用操作码:  
  
-   ILGenerator (操作码, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数（由指定索引值引用）加载到堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 09 < `unsigned int16` >|ldarg`index`|将参数`index`加载到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  位于处`index`的参数值被推送到堆栈上。  
  
 指令将在处`index`编制索引的自变量推送到计算堆栈上, 其中自变量的索引从0开始。 `ldarg` `ldarg`指令可用于通过从传入参数复制来将值类型或基元值加载到堆栈上。 参数值的类型与参数的类型相同, 后者由当前方法的签名指定。  
  
 对于采用可变长度参数列表的过程, `ldarg`指令只能用于初始固定参数, 而不能用于签名的变量部分中的参数 (有关详细信息, <xref:System.Reflection.Emit.OpCodes.Arglist>请参阅指令)。  
  
 如果参数包含小于4个字节的整数值, 则在将其`int32`加载到堆栈上时, 将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarg`使用操作码:  
  
-   ILGenerator (操作码, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引为 0 的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|02|ldarg|将参数0加载到堆栈上|  
  
 堆栈转换行为顺序如下:  
  
1.  将索引0处的参数值推送到堆栈上。  
  
 `ldarg.0`指令是用于在索引0处加载参数值的有效编码。  
  
 指令`ldarg.0`将索引为0的参数推送到计算堆栈上。 `ldarg.0`指令可用于通过从传入参数复制来将值类型或基元值加载到堆栈上。 参数值的类型与参数的类型相同, 后者由当前方法的签名指定。  
  
 如果参数包含小于4个字节的整数值, 则在将其`int32`加载到堆栈上时, 将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarg.0`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 1 处的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|03|ldarg|将参数1加载到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  将索引为1的参数值推送到堆栈上。  
  
 `ldarg.1`指令是用于在索引1处加载参数值的有效编码。  
  
 `ldarg.1`指令将索引为1的参数推送到计算堆栈上。 `ldarg.1`指令可用于通过从传入参数复制来将值类型或基元值加载到堆栈上。 参数值的类型与参数的类型相同, 后者由当前方法的签名指定。  
  
 如果参数包含小于4个字节的整数值, 则在将其`int32`加载到堆栈上时, 将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarg.1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 2 处的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|04|ldarg|将参数2加载到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  索引2处的参数值被推送到堆栈上。  
  
 `ldarg.2`指令是用于在索引2处加载参数值的有效编码。  
  
 `ldarg.2`指令将索引为2的参数推送到计算堆栈上。 `ldarg.2`指令可用于通过从传入参数复制来将值类型或基元值加载到堆栈上。 参数值的类型与参数的类型相同, 后者由当前方法的签名指定。  
  
 如果参数包含小于4个字节的整数值, 则在将其`int32`加载到堆栈上时, 将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarg.2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 3 处的参数加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|05|ldarg|将参数3加载到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  将索引为3的参数值推送到堆栈上。  
  
 `ldarg.3`指令是用于在索引3处加载参数值的有效编码。  
  
 `ldarg.3`指令将索引为3的参数推送到计算堆栈上。 `ldarg.3`指令可用于通过从传入参数复制来将值类型或基元值加载到堆栈上。 参数值的类型与参数的类型相同, 后者由当前方法的签名指定。  
  
 如果参数包含小于4个字节的整数值, 则在将其`int32`加载到堆栈上时, 将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarg.3`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数（由指定的短格式索引引用）加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0E < `unsigned int8` >|ldarg`index`|将参数`index`加载到堆栈上 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  位于处`index`的参数值被推送到堆栈上。  
  
 `ldarg.s`指令是用于加载从4到255的索引参数的有效编码。  
  
 指令将在处`index`编制索引的自变量推送到计算堆栈上, 其中自变量的索引从0开始。 `ldarg.s` `ldarg.s`指令可用于通过从传入参数复制来将值类型或基元值加载到堆栈上。 参数值的类型与参数的类型相同, 后者由当前方法的签名指定。  
  
 对于采用可变长度参数列表的过程, `ldarg.s`指令只能用于初始固定参数, 而不能用于签名的变量部分中的参数 (有关详细信息, <xref:System.Reflection.Emit.OpCodes.Arglist>请参阅指令)。  
  
 如果参数包含小于4个字节的整数值, 则在将其`int32`加载到堆栈上时, 将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarg.s`使用操作码:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将参数地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0A < `unsigned int16` >|ldarga`index`|提取由`index`索引的参数的地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  索引的`addr`自变量的地址被推送到堆栈上。`index`  
  
 指令获取`*`索引`index`的自变量的地址 (类型), 其中参数从0开始编制索引。 `ldarga` 地址`addr`始终与目标计算机上的自然边界对齐。  
  
 对于采用可变长度参数列表的过程, `ldarga`指令只能用于初始固定参数, 而不能用于签名的变量部分。  
  
 `ldarga`用于通过引用传递的参数。 对于其他情况, <xref:System.Reflection.Emit.OpCodes.Ldarg>应<xref:System.Reflection.Emit.OpCodes.Starg>使用和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarga`使用操作码:  
  
-   ILGenerator (操作码, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldarga_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldarga_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldarga_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>以短格式将参数地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0F < `unsigned int8` >|ldarga`index`|提取按`index`短格式索引的参数的地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  索引的`addr`自变量的地址被推送到堆栈上。`index`  
  
 `ldarga.s`(的缩写形式`ldarga`) 应用于0到255之间的参数号, 并且是一种更有效的编码。  
  
 指令获取`*`索引`index`的自变量的地址 (类型), 其中参数从0开始编制索引。 `ldarga.s` 地址`addr`始终与目标计算机上的自然边界对齐。  
  
 对于采用可变长度参数列表的过程, `ldarga.s`指令只能用于初始固定参数, 而不能用于签名的变量部分。  
  
 `ldarga.s`用于通过引用传递的参数。 对于其他情况, <xref:System.Reflection.Emit.OpCodes.Ldarg_S>应<xref:System.Reflection.Emit.OpCodes.Starg_S>使用和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldarga.s`使用操作码:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc. i4`num`|将值`num`推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值`num`推送到堆栈上。  
  
 请注意, 对于从-128 到127的整数, 会有特殊的简短编码 (因而更有效), 尤其是-1 到8的短编码。 所有短编码将4字节整数推送到堆栈上。 较长的编码用于8字节整数、4字节和8字节浮点数, 以及不符合短格式的4字节值。 有三种方法可将8字节整数常量推送到堆栈上  
  
 1. 对于必须以32多位表示的常量, 请使用指令。<xref:System.Reflection.Emit.OpCodes.Ldc_I8>  
  
 2. 对需要9到32位的常量使用后跟<xref:System.Reflection.Emit.OpCodes.Ldc_I4> <xref:System.Reflection.Emit.OpCodes.Conv_I8>的指令。  
  
 3. 对于可以用8个或更少<xref:System.Reflection.Emit.OpCodes.Conv_I8>位表示的常量, 请使用短格式指令, 后面跟有一个。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4`使用操作码:  
  
-   ILGenerator (OpCode, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 0 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|将0推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值0被推送到堆栈上。  
  
 这是一个用于推送整数值0的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.0`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|将1推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值1被推送到堆栈上。  
  
 这是用于推送整数值1的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 2 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|将2推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值2被推送到堆栈上。  
  
 这是用于推送整数值2的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 3 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|将3推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值3被推送到堆栈上。  
  
 这是用于推送整数值3的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.3`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 4 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|将4推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值4被推送到堆栈上。  
  
 这是一个用于推送整数值4的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 5 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|将5推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值5被推送到堆栈上。  
  
 这是一个用于推送整数值5的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.5`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 6 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|将6推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值6被推送到堆栈上。  
  
 这是一个用于推送整数值6的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.6`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 7 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1D|ldc.i4.7|将7推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值7被推送到堆栈上。  
  
 这是一个用于推送整数值7的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.7`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 8 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|将8推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值8被推送到堆栈上。  
  
 这是用于推送整数值8的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_M1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_M1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_M1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值 -1 作为 <see langword="int32" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|15|ldc.i4.m1|将-1 推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值-1 被推送到堆栈上。  
  
 这是用于推送整数值-1 的特殊短编码。 所有特殊的短编码将4字节整数推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.m1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I4_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I4_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I4_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的 <see langword="int8" /> 值作为 <see langword="int32" /> 推送到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|1F <`int8` >|ldc. i4`num`|`num` 以`int32`短格式推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值`num`推送到堆栈上。  
  
 `ldc.i4.s`是一种更有效的编码方式, 用于将从-128 到127的整数推送到计算堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i4.s`使用操作码:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.i8 `num`|将`num` 作为`int64`推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值`num`推送到堆栈上。  
  
 此编码将`int64`值推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.i8`使用操作码:  
  
-   ILGenerator (操作码, 长)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc. r4`num`|将`num` 作为`F`推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值`num`推送到堆栈上。  
  
 此编码将`float32`值推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.r4`使用操作码:  
  
-   ILGenerator (操作码, single)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldc_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldc_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldc_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将所提供的 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc. r8`num`|将`num` 作为`F`推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  值`num`推送到堆栈上。  
  
 此编码将`float64`值推送到堆栈上。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldc.r8`使用操作码:  
  
-   ILGenerator (操作码, 双精度)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>按照指令中指定的类型，将指定数组索引中的元素加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A3 < `T` >|ldelem`typeTok`|将元素`index`作为类型`typeTok`加载到堆栈顶部。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem` 数组是对象, 因此表示为类型`O`的值。  
  
 返回值的类型由指令中的标记`typeTok`指定。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的上限`array`, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="native int" /> 类型的元素作为 <see langword="native int" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|97|ldelem。 i|将`native int` 类型`native int`为的元素作为加载到堆栈顶部`index` 。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.i` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.i`为`native int`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.i`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|90|ldelem.i1|将`int8` 类型`int32`为的元素作为加载到堆栈顶部`index` 。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.i1` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.i1`为`int8`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.i1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|92|ldelem.i2|将`int16` 类型`int32`为的元素作为加载到堆栈顶部`index` 。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.i2` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.i2`为`int16`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.i2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|94|ldelem.i4|将`int32` 类型`int32`为的元素作为加载到堆栈顶部`index` 。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.i4` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.i4`为`int32`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.i4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="int64" /> 类型的元素作为 <see langword="int64" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|96|ldelem.i8|将`int64` 类型`int64`为的元素作为加载到堆栈顶部`index` 。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.i8` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.i8`为`int64`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.i8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float32" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|98|ldelem.r4|将类型`float32` `F`为的元素作为类型加载到堆栈顶部。`index`|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.r4` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.r4`为`float32`。  
  
 将浮点值加载到计算堆栈上`F`时, 会将其转换为类型。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.r4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="float64" /> 类型的元素作为 <see langword="F" /> 类型（浮点型）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|99|ldelem.r8|将类型`float64` `F`为的元素作为类型加载到堆栈顶部。`index`|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.r8` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.r8`为`float64`。  
  
 将浮点值加载到计算堆栈上`F`时, 会将其转换为类型。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.r8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的包含对象引用的元素作为 <see langword="O" /> 类型（对象引用）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9A|ldelem.ref|将具有对象引用`index`的元素作为类型`O`加载到堆栈顶部。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.ref` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.ref`为类型`O` (对象引用)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.ref`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int8" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|91|ldelem.u1|将`unsigned int8` 类型`int32`为的元素作为加载到堆栈顶部`index` 。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.u1` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.u1`为`int8`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.u1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int16" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|93|ldelem.u2|`unsigned int16` 将`int32`位于索引处的类型的元素作为加载到堆栈顶部。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.u2` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.u2`为`int16`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.u2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelem_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelem_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelem_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引处的 <see langword="unsigned int32" /> 类型的元素作为 <see langword="int32" /> 加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|95|ldelem.u4|`unsigned int32` 将`int32`位于索引处的类型的元素作为加载到堆栈顶部。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`将`array`从堆栈中弹出和, 并在中`array`查找存储`index`在位置的值。  
  
4.  值推送到堆栈上。  
  
 指令在从零开始的一维数组`array`中`index`加载带有`native int`索引 (类型) 的元素的值, 并将其放在堆栈顶部。 `ldelem.u4` 数组是对象, 因此表示为类型`O`的值。  
  
 的返回值`ldelem.u4`为`int32`。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果数组不包含所需类型的元素, 则会引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelem.u4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldelema As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldelema;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldelema : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于指定数组索引的数组元素的地址作为 <see langword="&amp;" /> 类型（托管指针）加载到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8F < `T` >|ldelema`class`|将数组元素`index`的地址作为类型`&` (托管指针) 加载到计算堆栈的顶部。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`array`被推送到堆栈上。  
  
2.  索引值`index`被推送到堆栈上。  
  
3.  `index`和`array`是从堆栈中弹出的; 查找存储在中`index` `array`位置的地址。  
  
4.  该地址将被推送到堆栈上。  
  
 用于检索对象数组中特定索引处的对象的地址 (类型`class`为)。 `ldelema` 指令在从零开始的一维数组`array`中`index`的索引`native int`(类型) 处加载值的地址, 并将其放在堆栈顶部。 `ldelema` 数组是对象, 因此表示为类型`O`的值。 该值必须是随指令传递`class`的类型。  
  
 的返回值`ldelema`为托管指针 (类型`&`)。  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldelema`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7B < `T` >|ldfld`field`|将指定对象中的字段的值推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用 (或指针) 被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用 (或指针);找到对象中指定字段的值。  
  
3.  存储在字段中的值将被推送到堆栈上。  
  
 `ldfld`指令将位于对象中的字段的值推送到堆栈上。 对象必须位于堆栈上, 作为`O`对象引用 (类型)、托管指针 (类型`&`)、非托管指针 (类型`native int`)、暂时性指针 (类型`*`) 或值类型的实例。 可验证代码中不允许使用非托管指针。 对象的字段由必须引用字段成员的元数据标记指定。 返回类型与字段关联的类型相同。 字段可以是实例字段 (在这种情况下, 对象不得为空引用) 或静态字段。  
  
 指令前面可以是<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile> /或前缀。 `ldfld`  
  
 <xref:System.NullReferenceException>如果对象为 null, 并且该字段不是静态的, 则会引发。  
  
 <xref:System.MissingFieldException>如果在元数据中找不到指定的字段, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时, 通常会检查此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldfld`使用操作码:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>查找对象中其引用当前位于计算堆栈的字段的地址。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7C < `T` >|ldflda`field`|将指定对象`field`中的地址推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用 (或指针) 被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用 (或指针);找到对象中指定字段的地址。  
  
3.  指定字段的地址被推送到堆栈上。  
  
 `ldflda`指令将位于对象中的字段的地址推送到堆栈上。 对象必须位于堆栈上, 作为`O`对象引用 (类型)、托管指针 (类型`&`)、非托管指针 (类型`native int`)、暂时性指针 (类型`*`) 或值类型的实例。 可验证代码中不允许使用非托管指针。 对象的字段由必须引用字段成员的元数据标记指定。  
  
 返回`ldflda`的值是托管指针 (类型`&`), 除非该对象被推送到堆栈上作为非托管指针, 在这种情况下, 返回地址也是非托管指针 ( `native int`类型)。  
  
 指令前面可以是<xref:System.Reflection.Emit.OpCodes.Unaligned>和<xref:System.Reflection.Emit.OpCodes.Volatile> /或前缀。 `ldflda`  
  
 <xref:System.InvalidOperationException>如果对象不在从中访问它的应用程序域中, 则会引发。 不在访问应用程序域中的字段的地址无法加载。  
  
 <xref:System.NullReferenceException>如果对象为 null, 并且该字段不是静态的, 则会引发。  
  
 <xref:System.MissingFieldException>如果在元数据中找不到指定的字段, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时, 通常会检查此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldflda`使用操作码:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现特定方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 06 < `T` >|ldftn`method`|将一个指针推送到堆栈`method`上的引用的方法。|  
  
 堆栈转换行为顺序如下:  
  
1.  指向特定方法的非托管指针将被推送到堆栈上。  
  
 如果特定方法 (`method`) 引用托管方法 (或<xref:System.Reflection.Emit.OpCodes.Calli>从托管代码转换为非托管代码的存根), 则可以使用指令进行调用。  
  
 返回的值指向使用 CLR 调用约定的本机代码。 此方法指针不应作为回调例程传递到非托管的本机代码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldftn`使用操作码:  
  
-   ILGenerator (操作码, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="native int" /> 类型的值作为 <see langword="native int" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4D|ldind。 i|将`native int` `addr`地址处的值作为加载到堆栈上。`native int`|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `native int` `native int` `&`指令将一个值从指定的地址 (类型为、或 *) 作为`native int`直接加载到堆栈上。 `ldind.i`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.i`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|46|ldind|将地址`int8` `addr`处的值作为加载`int32`到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。 
  
 `int8` `native int` `&`指令将值从指定的地址 (类型为、、或 *) 作为`int32`直接加载到堆栈上。 `ldind.i1`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.i1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|48|ldind|将地址`int16` `addr`处的值作为加载`int32`到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `int16` `native int` `&`指令将值从指定的地址 (类型为、、或 *) 作为`int32`直接加载到堆栈上。 `ldind.i2`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.i2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4A|ldind. i4|将地址`int32` `addr`处的值作为加载`int32`到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `int32` `native int` `&`指令将值从指定的地址 (类型为、、或 *) 作为`int32`直接加载到堆栈上。 `ldind.i4`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.i4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="int64" /> 类型的值作为 <see langword="int64" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4C|ldind. i8|将地址`int64` `addr`处的值作为加载`int64`到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `int64` `native int` `&`指令将值从指定的地址 (类型为、、或 *) 作为`int64`直接加载到堆栈上。 `ldind.i8`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.i8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float32" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4E|ldind. r4|将地址`float32` `addr`处的值作为类型`F`加载到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `float32` `native int` `&`指令将值从指定的地址 (类型为、或 *) 中作为类型`F`间接加载到堆栈上。 `ldind.r4`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.r4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="float64" /> 类型的值作为 <see langword="F" /> (float) 类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4F|ldind. r8|将地址`float64` `addr`处的值作为类型`F`加载到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `float64` `native int` `&`指令将一个值从指定的地址 (类型为、或 *) 作为`float64`直接加载到堆栈上。 `ldind.r8`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.r8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对象引用作为 <see langword="O" />（对象引用）类型间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|50|ldind.ref|将地址`addr`处的对象引用作为类型加载到堆栈上`O`|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;提取位于地址处的对象引用。  
  
3.  提取的引用将被推送到堆栈上。  
  
 指令将对象引用 (类型`native int`为、 `&`或 *) 的指定地址作为类型`O`间接加载到堆栈上。 `ldind.ref`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.ref`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int8" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|47|ldind|将地址`unsigned int8` `addr`处的值作为加载`int32`到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `unsigned int8` `native int` `&`指令将值从指定的地址 (类型为、、或 *) 作为`int32`直接加载到堆栈上。 `ldind.u1`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.u1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int16" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|49|ldind|将地址`unsigned int16` `addr`处的值作为加载`int32`到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `unsigned int16` `native int` `&`指令将值从指定的地址 (类型为、、或 *) 作为`int32`直接加载到堆栈上。 `ldind.u2`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.u2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldind_U4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldind_U4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldind_U4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将 <see langword="unsigned int32" /> 类型的值作为 <see langword="int32" /> 间接加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|4B|ldind. u4|将地址`unsigned int32` `addr`处的值作为加载`int32`到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址;获取位于地址的值。  
  
3.  提取的值被推送到堆栈上。  
  
 `unsigned int32` `native int` `&`指令将值从指定的地址 (类型为、、或 *) 作为`int32`直接加载到堆栈上。 `ldind.u4`  
  
 所有说明都是指定相应内置值<xref:System.Reflection.Emit.OpCodes.Ldobj>类的指令的快捷方式。 `ldind`  
  
 请注意, 小于4个字节的整数值在加载`int32`到计算`native int`堆栈上时将扩展到 (而不是)。 将浮点值加载到计算堆栈`F`上时, 会将其转换为类型。  
  
 格式正确的 Microsoft 中间语言 (MSIL) 可确保`ldind`以与指针类型一致的方式使用指令。  
  
 最初推送到堆栈上的地址必须与计算机上对象的自然大小对齐, 否则<xref:System.NullReferenceException>可能会发生 (请参阅预防措施的<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀说明)。 返回地址 (例如<xref:System.Reflection.Emit.OpCodes.Ldloca>和<xref:System.Reflection.Emit.OpCodes.Ldarga>) 的所有 MSIL 指令的结果都安全对齐。 对于大于1个字节的数据类型, 字节排序依赖于目标 CPU。 依赖于字节排序的代码可能无法在所有平台上运行。  
  
 <xref:System.NullReferenceException>如果检测到无效地址, 则可能会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldind.u4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldlen As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldlen;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldlen : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将从零开始的、一维数组的元素的数目推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8E|ldlen|将数组的长度 (类型`natural unsigned int`) 推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组的对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出数组引用并计算长度。  
  
3.  长度被推送到堆栈上。  
  
 数组是对象, 因此表示为类型`O`的值。 长度以形式`natural unsigned int`返回。  
  
 <xref:System.NullReferenceException>如果数组引用为空引用, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldlen`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定索引处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0C < `unsigned int16` >|ldloc`index`|将索引`index`处的局部变量加载到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  将指定索引处的本地变量值推送到堆栈上。  
  
 `ldloc`指令将传递的索引处的局部变量号的内容推送到计算堆栈上, 其中本地变量从0开始编号。 仅当方法的 initialize 标志为 true 时, 才在输入方法之前, 将局部变量初始化为0。 可能存在 65535 (2 ^ 16-1) 个本地变量 (0-65534)。 索引65535无效, 因为可能的实现将使用2字节整数跟踪本地的索引, 以及给定方法的局部变量总数。 如果已将65535的索引设为有效, 则需要更宽的整数来跟踪此类方法中的局部变量的数目。  
  
 、、和指令`ldloc.3`为访问前四个局部变量提供了有效编码。 `ldloc.1` `ldloc.0` `ldloc.2`  
  
 值的类型与在方法头中指定的局部变量的类型相同。 请参阅 Partition I. 小于4个字节的局部变量在加载到堆栈上时`int32`将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloc`使用操作码:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (操作码, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 0 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|06|ldloc|将索引 0 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  将索引0处的局部变量值推送到堆栈上。  
  
 `ldloc.0`是的<xref:System.Reflection.Emit.OpCodes.Ldloc>有效编码, 允许访问索引0处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时`int32` , 它们将展开为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloc.0`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 1 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|07|ldloc.1|将索引 1 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  位于索引1处的局部变量值被推送到堆栈上。  
  
 `ldloc.1`是的一个特别高效的<xref:System.Reflection.Emit.OpCodes.Ldloc>编码, 允许访问索引1处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时`int32` , 它们将展开为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloc.1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 2 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|08|ldloc.2|将索引 2 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  将索引2处的局部变量值推送到堆栈上。  
  
 `ldloc.2`是的一个特别高效的<xref:System.Reflection.Emit.OpCodes.Ldloc>编码, 允许访问索引2处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时`int32` , 它们将展开为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloc.2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将索引 3 处的局部变量加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|09|ldloc.3|将索引 3 处的局部变量加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  将索引为3的本地变量值推送到堆栈上。  
  
 `ldloc.3`是的一个特别高效的<xref:System.Reflection.Emit.OpCodes.Ldloc>编码, 允许访问索引3处的局部变量。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 在将小于4个字节的局部变量加载到堆栈上时`int32` , 它们将展开为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloc.3`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将特定索引处的局部变量加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|ldloc`index`|将索引`index`处的局部变量加载到堆栈上 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  将指定索引处的本地变量值推送到堆栈上。  
  
 `ldloc.s`指令将传递的索引处的局部变量号的内容推送到计算堆栈上, 其中本地变量从0开始编号。 如果对方法的 initialize 标志为 true, 则在输入方法之前, 本地变量将初始化为0。 可以使用 256 (2 ^ 8) 个本地变量 (0-255), 这是一个比`ldloc`更有效的编码。  
  
 值的类型与在方法头中指定的局部变量的类型相同。 请参阅 Partition I. 小于4个字节的局部变量在加载到堆栈上时`int32`将扩展为类型。 浮点值扩展为其本机大小 (类型`F`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloc.s`使用操作码:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE OD <`unsigned int16` >|ldloca`index`|将局部变量`index`的地址加载到计算堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  存储在本地变量中指定索引处的地址被推送到堆栈上。  
  
 `ldloca`指令将传递的索引处的局部变量号的地址推送到堆栈上, 其中局部变量从0开始编号。 在堆栈上推送的值已正确对齐, 可用于<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>等说明。 结果为暂时性指针 (类型`*`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloca`使用操作码:  
  
-   ILGenerator (操作码, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldloca_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldloca_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldloca_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于特定索引处的局部变量的地址加载到计算堆栈上（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca`index`|将局部变量`index`的地址加载到计算堆栈上 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  存储在本地变量中指定索引处的地址被推送到堆栈上。  
  
 `ldloca.s`指令将传递的索引处的局部变量号的地址推送到堆栈上, 其中局部变量从0开始编号。 在堆栈上推送的值已正确对齐, 可用于<xref:System.Reflection.Emit.OpCodes.Ldind_I>和<xref:System.Reflection.Emit.OpCodes.Stind_I>等说明。 结果为暂时性指针 (类型`*`)。  
  
 `ldloca.s`说明提供了一个有效的编码, 可与局部变量0到255一起使用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldloca.s`使用操作码:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldnull As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldnull;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldnull : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将空引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|14|ldnull|在堆栈上推送空引用|  
  
 堆栈转换行为顺序如下:  
  
1.  空对象引用被推送到堆栈上。  
  
 `ldnull`将空引用 (类型`O`) 推送到堆栈上。 这用于在使用数据填充位置之前或在位置被弃用时初始化位置。  
  
 `ldnull`提供一个与大小无关的空引用。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldnull`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将地址指向的值类型对象复制到计算堆栈的顶部。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj`class`|将值类型`class`的实例复制到堆栈中。|  
  
 堆栈转换行为顺序如下:  
  
1.  值类型对象的地址被推送到堆栈上。  
  
2.  从堆栈中弹出该地址, 并查找该特定地址处的实例。  
  
3.  存储在该地址的对象的值被推送到堆栈上。  
  
 `ldobj`指令用于作为参数传递值类型。  
  
 `ldobj`指令将`addrOfValObj` (类型`&`为、 `*`或)指向的值复制到堆栈的顶部。`native int` 已复制的字节数取决于类 (由`class`参数指定) 的大小。 `class`参数是表示值类型的元数据标记。  
  
 `ldobj`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.TypeLoadException>如果找不到类, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldobj`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的值推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7E < `T` >|ldsfld`field`|将的`field`值推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  将特定字段的值推送到堆栈上。  
  
 `ldsfld`指令将静态 (在类的所有实例中共享) 字段的值推送到堆栈上。 返回类型是与传递的元数据标记`field`相关联的。  
  
 `ldsfld`指令可以<xref:System.Reflection.Emit.OpCodes.Volatile>有前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldsfld`使用操作码:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldsflda As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldsflda;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldsflda : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将静态字段的地址推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7F < `T` >|ldsflda`field`|推送堆栈上的`field`地址|  
  
 堆栈转换行为顺序如下:  
  
1.  将特定字段的地址推送到堆栈上。  
  
 `ldsflda`指令将静态的地址 (在类的所有实例中共享) 推送到堆栈上。 如果元数据标记`*` `field`引用其内存被管理的类型, 则该地址可以表示为暂时性指针 (类型)。 否则, 它对应于非托管指针 (类型`native int`)。 请注意`field` , 可以是静态全局的, 它具有分配的相对虚拟地址 (该字段的偏移量, 其中其包含的 PE 文件将加载到内存中), 其中内存是非托管的。  
  
 `ldsflda`指令可以<xref:System.Reflection.Emit.OpCodes.Volatile>有前缀。  
  
 <xref:System.MissingFieldException>如果在元数据中找不到字段, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检查此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldsflda`使用操作码:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldstr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldstr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldstr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>推送对元数据中存储的字符串的新对象引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr`mdToken`|为元数据字符串标记`mdToken`推送字符串对象。|  
  
 堆栈转换行为顺序如下:  
  
1.  将对字符串的对象引用推送到堆栈上。  
  
 指令将对象引用 (类型`O`) 推送到表示元数据中存储的特定字符串文本的新字符串对象。 `ldstr` `ldstr`指令分配所需的内存量, 并执行任何格式转换, 以将字符串文本从文件中使用的格式转换为运行时所需的字符串格式。  
  
 公共语言基础结构 (CLI) 保证两个`ldstr`指令的结果引用两个具有相同字符序列的元数据标记, 这会完全返回相同的字符串对象 (称为 "字符串暂留" 的过程)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldstr`使用操作码:  
  
-   ILGenerator (OpCode, string)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldtoken As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldtoken;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldtoken : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将元数据标记转换为其运行时表示形式，并将其推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D0 < `T` >|ldtoken`token`|将元数据标记转换为其运行时表示形式。|  
  
 堆栈转换行为顺序如下:  
  
1.  传递的标记将转换为`RuntimeHandle`并推送到堆栈上。  
  
 `ldtoken`指令`RuntimeHandle`为指定的元数据标记推送。 `RuntimeHandle`可以是`typeref/typedef`、或`methodref/methoddef`。 `fieldref/fielddef`  
  
 可以在对系统类库中的方法的调用中使用`Reflection`推送到堆栈上的值。  
  
 有关运行时句柄的信息, 请参阅以下<xref:System.RuntimeFieldHandle>类<xref:System.RuntimeTypeHandle>:、 <xref:System.RuntimeMethodHandle>和。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldtoken`使用操作码:  
  
-   ILGenerator (操作码, MethodInfo)  
  
-   ILGenerator (OpCode, FieldInfo)  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ldvirtftn As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ldvirtftn;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ldvirtftn : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指向实现与指定对象关联的特定虚方法的本机代码的非托管指针（<see langword="native int" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 07 < `T` >|ldvirtftn`method`|将指针推送到堆栈上对象的虚拟`method`方法。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用, 并查找方法 (由元数据标记`method`指定) 的入口点地址。  
  
3.  指向`method`的指针将被推送到堆栈上。  
  
 如果通过`ldvirtftn`指令将生成的非托管指针引用托管方法 (或从托管<xref:System.Reflection.Emit.OpCodes.Calli>代码转换为非托管代码的存根), 则可以使用指令调用该指针。  
  
 非托管指针使用 CLR 调用约定指向本机代码。 此方法指针不应作为回调例程传递到非托管的本机代码。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ldvirtftn`使用操作码:  
  
-   ILGenerator (操作码, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到特定目标指令。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DD < `int32` >|遗留`target`|退出受保护的代码区域。|  
  
 没有为此指令指定堆栈转换行为。  
  
 `leave`指令无条件地将控制转移到特定目标指令, 表示为从当前指令后面的指令开头开始的4字节有符号偏移量。  
  
 `br` `try` `filter`指令与指令类似, 但它可用于退出、或`catch`阻止, 而普通分支指令只能在此类块中用于传输控制`leave`以便. 指令`leave`将清空计算堆栈, 并确保执行适当的周围`finally`块。  
  
 不能使用`leave`指令`finally`退出块。 为了简化异常处理程序的代码生成, 从 catch 块内部有效, 使用`leave`指令将控制转移到关联`try`块中的任何指令。  
  
 如果指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`leave`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Leave_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Leave_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Leave_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>退出受保护的代码区域，无条件将控制转移到目标指令（缩写形式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DE < `int8` >|离开`target`|退出受保护的代码区域 (缩写形式)。|  
  
 没有为此指令指定堆栈转换行为。  
  
 `leave.s`指令无条件地将控制转移到传递的目标指令, 表示为从当前指令后面的指令开头开始的1字节有符号偏移量。  
  
 `br` `try` `filter`指令与指令类似, 但它可用于退出、或`catch`阻止, 而普通分支指令只能在此类块中用于传输控制`leave.s`以便. 指令`leave.s`将清空计算堆栈, 并确保执行适当的周围`finally`块。  
  
 不能使用`leave.s`指令`finally`退出块。 为了简化异常处理程序的代码生成, 从 catch 块内部有效, 使用`leave.s`指令将控制转移到关联`try`块中的任何指令。  
  
 如果指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`leave.s`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Localloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Localloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Localloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从本地动态内存池分配特定数目的字节并将第一个分配的字节的地址（瞬态指针，<see langword="*" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|从本地堆中分配空间。|  
  
 堆栈转换行为顺序如下:  
  
1.  要分配的字节数将被推送到堆栈上。  
  
2.  从堆栈中弹出字节数;与该大小相对应的内存量从本地堆中分配。  
  
3.  指向分配的内存的第一个字节的指针被推送到堆栈上。  
  
 指令从本地`size`动态内存`natural unsigned int`池分配 (类型) 字节, 并返回第一个分配的字节的地址 (瞬态`*`指针, 类型)。 `localloc` 仅当方法的 initialize 标志为时`true`, 返回的内存块才会初始化为0。 当当前方法执行<xref:System.Reflection.Emit.OpCodes.Ret>时, 本地内存池可供重复使用。  
  
 生成的地址是对齐的, `stind`以便可以使用指令 ( <xref:System.Reflection.Emit.OpCodes.Stind_I4>如`ldind` ) 将任何基元数据类型存储在此处, 并使用指令 (如<xref:System.Reflection.Emit.OpCodes.Ldind_I4>) 加载。  
  
 `filter` `catch` `finally`指令不能出现在、、或`fault`块中。 `localloc`  
  
 <xref:System.StackOverflowException>如果没有足够的内存来为请求提供服务, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`localloc`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mkrefany As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mkrefany;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mkrefany : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对特定类型实例的类型化引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|C6 < `T` >|mkrefany`class`|将类型的类型`class`化引用推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  指向片段的数据被推送到堆栈上。  
  
2.  弹出指针并将其转换为类型`class`的类型化引用。  
  
3.  类型化的引用被推送到堆栈上。  
  
 `mkrefany`指令支持动态类型化引用的传递。 指针必须是、 `&` `*`或`native int`类型, 并保存数据片段的有效地址。 `Class`类标记, 用于描述指针所引用的数据的类型。 `Mkrefany`将类型化引用推送到堆栈上, 并提供指针和类型`class`的不透明说明符。  
  
 对类型化引用允许的唯一有效操作是将其传递到要求类型化引用作为参数的方法。 然后, 调用方可以使用<xref:System.Reflection.Emit.OpCodes.Refanytype>和<xref:System.Reflection.Emit.OpCodes.Refanyval>指令分别检索类型 (类) 和地址。  
  
 <xref:System.TypeLoadException>如果`class`找不到, 则引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`mkrefany`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相乘并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5A|mul|将两个值相乘。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1` 与`value2`相乘。  
  
4.  将结果推送到堆栈上。  
  
 `mul` 指令`value1`乘以并将结果推送到堆栈上。`value2` 整数运算在溢出时无提示截断高位。  
  
 有关<xref:System.Reflection.Emit.OpCodes.Mul_Ovf>使用溢出处理的特定于整数的乘法运算, 请参阅。  
  
 对于浮点类型, 为 0 * 无穷 = NaN。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`mul`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D8|mul.ovf|使用溢出检查将堆栈上的两个整数值相乘。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1`乘以,并`value2`进行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 指令`mul.ovf`将`value1` 整数`value2`乘以整数并将结果推送到堆栈上。 如果结果类型中不能容纳结果, 则会引发异常。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`mul.ovf`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Mul_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Mul_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号整数值相乘，执行溢出检查，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|D9|mul.ovf.un|将堆栈上的两个无符号值与溢出检查相乘。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value1`乘以,并`value2`进行溢出检查。  
  
4.  将结果推送到堆栈上。  
  
 指令`mul.ovf.un`将无符号整数`value1`乘以无符号`value2`整数, 并将结果推送到堆栈上。 如果结果类型中不能容纳结果, 则会引发异常。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`mul.ovf.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Neg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Neg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Neg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>对一个值执行求反并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|65|neg|对当前位于堆栈顶部的值求反。|  
  
 堆栈转换行为顺序如下:  
  
1.  将值推送到堆栈上。  
  
2.  从堆栈中弹出一个值并对其进行求反。  
  
3.  将结果推送到堆栈上。  
  
 `neg`指令对值进行求反并将结果推送到堆栈顶部。 返回类型与操作数类型相同。  
  
 整数值的求反是标准2的补码反运算。 特别是, 取消最多负数 (不具有正号) 将产生最大的负数。 若要检测此溢出<xref:System.Reflection.Emit.OpCodes.Sub_Ovf> , 请改用指令 (即从0中减去)。  
  
 取消浮点数不能溢出, 取消 NaN 返回 NaN。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`neg`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newarr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newarr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newarr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将对新的从零开始的一维数组（其元素属于特定类型）的对象引用推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|8D < `T` >|newarr`etype`|创建具有类型`etype`的元素的新数组。|  
  
 堆栈转换行为顺序如下:  
  
1.  数组中的元素数被推送到堆栈上。  
  
2.  从堆栈中弹出元素数并创建数组。  
  
3.  对新数组的对象引用被推送到堆栈上。  
  
 指令将对象引用 (类型`O`) 推送到新的从零开始的一维数组, 该数组的元素类型`etype`为 (描述该类型的元数据标记)。 `newarr` 新数组中的元素数应指定为`native int`。 有效的数组索引范围从零到最大元素数减一。  
  
 数组元素可以是任何类型, 包括值类型。  
  
 从零开始的一维数组, 使用引用适当值类型 (<xref:System.Int32>等) 的元数据标记创建。 数组的元素初始化为适当类型的0。  
  
 <xref:System.Reflection.Emit.OpCodes.Newobj> 使用`newarr`而不是创建从零开始的一维数组和多维数组。 通常, 它们是使用 .NET Framework 中的<xref:System.Array>类的方法创建的。  
  
 <xref:System.OutOfMemoryException>如果内存不足, 无法满足请求, 则会引发。  
  
 <xref:System.OverflowException>小于0时`numElems`引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`newarr`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Newobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Newobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Newobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>创建一个值类型的新对象或新实例，并将对象引用（<see langword="O" /> 类型）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj`ctor`|分配未初始化的对象或值类型, 并调用构造`ctor`函数方法。|  
  
 堆栈转换行为顺序如下:  
  
1.  自变量`arg1`按顺序推送到堆栈上。 `argn`  
  
2.  `ctor`通过`argn` 从堆栈中弹出并将参数传递给来创建对象。`arg1`  
  
3.  对新的对象的引用被推送到堆栈上。  
  
 `newobj`指令创建新的对象或值类型的新实例。 `Ctor`是要调用的构造函数`methodref`的`methoddef`名称、类和签名的元数据标记 (或必须标记为构造函数的或)。  
  
 指令分配与`ctor`关联的类的新实例, 并根据需要将新实例中的所有字段初始化为 0 (适当的类型) 或空引用。 `newobj` 然后, 它将调用`ctor`具有给定参数的构造函数和新创建的实例。 调用构造函数后, 即会将初始化的对象引用 (类型`O`) 推送到堆栈上。  
  
 从构造函数的角度来看, 未初始化的对象是参数 0, 传递给 newobj 的其他参数按照顺序排列。  
  
 使用<xref:System.Reflection.Emit.OpCodes.Newarr>而不`newobj`是创建所有从零开始的一维数组。 另一方面, 将使用`newobj`创建所有其他数组 (不止一个维度, 或一维但不是从零开始的数组)。  
  
 通常不使用`newobj`创建值类型。 它们通常作为参数或局部变量分配, 使用`newarr` (对于从零开始的一维数组) 或作为对象的字段。 分配后, 将使用<xref:System.Reflection.Emit.OpCodes.Initobj>对其进行初始化。 但是, `newobj`可以使用指令在堆栈上创建值类型的新实例, 然后可以将该实例作为参数进行传递, 并将其存储在本地, 依此类推。  
  
 <xref:System.OutOfMemoryException>如果内存不足, 无法满足请求, 则会引发。  
  
 <xref:System.MissingMethodException>如果找不到具有指定`ctor`名称、类和签名的构造函数方法, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`newobj`使用操作码:  
  
-   ILGenerator (OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Nop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Nop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Nop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>如果修补操作码，则填充空间。 尽管可能消耗处理周期，但未执行任何有意义的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|00|nop|执行不具有行为的操作。|  
  
 没有为此指令定义堆栈过渡行为。  
  
 `nop`操作不执行任何操作。 它用于在对操作码进行修补时填充空间。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`nop`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Not As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Not;" />
      <MemberSignature Language="F#" Value=" staticval mutable Not : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算堆栈顶部整数值的按位求补并将结果作为相同的类型推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|66|not|计算值的按位求补。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value`被推送到堆栈上。  
  
2.  `value`从堆栈中弹出, 并计算按位求补。  
  
3.  将结果推送到堆栈上。  
  
 `not`指令计算整数值的按位求补并将结果推送到堆栈上。 返回类型与操作数类型相同。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`not`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Or As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Or;" />
      <MemberSignature Language="F#" Value=" staticval mutable Or : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于堆栈顶部的两个整数值的按位求补并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|60|or|计算两个整数值的按位 "或", 返回整数。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出, 并按位或计算。  
  
4.  将结果推送到堆栈上。  
  
 `or`指令计算堆栈顶部的两个值的按位 "或", 并将结果推送到堆栈上。  
  
 `Or`是特定于整数的操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`or`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Pop As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Pop;" />
      <MemberSignature Language="F#" Value=" staticval mutable Pop : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>移除当前位于计算堆栈顶部的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|26|pop|从堆栈中弹出顶部值。|  
  
 堆栈转换行为顺序如下:  
  
1.  顶部值从堆栈中弹出。  
  
 `pop`指令从堆栈中移除顶部元素。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`pop`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix5 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix5;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix5 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix6 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix6;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix6 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefix7 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefix7;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefix7 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Prefixref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Prefixref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Prefixref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>此指令为保留指令。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Readonly As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Readonly;" />
      <MemberSignature Language="F#" Value=" staticval mutable Readonly : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定后面的数组地址操作在运行时不执行类型检查，并且返回可变性受限的托管指针。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1E|只读.|指定后续数组地址操作在运行时不执行类型检查, 并且它返回具有受限可变性的托管指针。|  
  
 此前缀只能出现在`ldelema`指令之前, 并调用数组的特殊`Address`方法。 其对后续操作的影响是双重的:  
  
1.  在运行时, 不执行任何类型检查操作。 请注意, 在引用类型数组上使用时, `ldelema`通常`stelem`会对和说明进行隐式类型检查。 没有值类的运行时类型检查, 因此`readonly`在这种情况下, 不会执行任何操作。  
  
2.  验证程序将操作地址操作的结果视为具有受限可变性的托管指针。  
  
 指针被称为具有受限的可变性, 因为定义类型控制值是否可转变。 对于公开无公共字段或更新就地值的方法的值类, 该指针为只读 (因此为前缀的名称)。 特别是, 表示基元类型的类 (例如, System.object) 不公开赋值函数, 因此它们是只读的。  
  
 以这种方式限制的托管指针只能通过以下方式使用:  
  
-   为`ldfld`、 `object` 、、`ldflda`或指令`constrained callvirt`的参数`stfld`。 `call`  
  
-   作为`ldobj`指令`pointer`的参数`ldind`或指令的参数之一。  
  
-   作为`cpobj`指令`source`的参数。  
  
 不允许所有其他操作, 包括`stobj`、 `initobj`、或`mkrefany`操作, 或者任何`stind`说明。  
  
 `readonly`前缀的用途是在从泛型代码中的数组获取元素时避免类型检查。 例如, 如果数组`arr[i].m()` `arr`的元素类型是一个已被约束为具有方法`m`的接口的泛型类型, 则该表达式可能会编译为以下 MSIL。  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 如果没有`ldelema`前缀, 则指令将在! 0 是引用类型的情况下执行类型检查。 `readonly` 这种类型的检查不仅低效, 而且它在语义上不正确。 的类型检查`ldelema`是完全匹配, 这太强。 如果数组持有类型为! 0 的子类, 则上述代码将无法通过类型检查。  
  
 提取数组元素的地址, 而不是元素本身, 以获得适用于值类型和引用类型`arr[i]`的的句柄, 因此可将其传递`constrained callvirt`给指令。  
  
 通常, 如果数组持有引用类型的元素, 则跳过运行时检查是不安全的。 为安全起见, 需要确保不通过此指针对数组进行任何修改。 验证程序规则确保这一点。 受限制的托管指针可以作为实例方法调用的对象进行传递, 因此对于值类型而言, 并不严格地说是只读的, 但对于值类型, 不存在任何类型安全问题。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`readonly`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanytype As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanytype;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanytype : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的类型标记。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|推送在类型化引用中存储的类型标记。|  
  
 堆栈转换行为顺序如下:  
  
1.  值类型引用被推送到堆栈上。  
  
2.  类型化引用从堆栈中弹出, 并检索其相应的类型标记。  
  
3.  类型标记被推送到堆栈上。  
  
 类型化引用包含对象实例的类型标记和地址。  
  
 `refanytype`指令检索嵌入在类型化引用中的类型标记。 有关创建类型化引用的信息, 请参阅说明。<xref:System.Reflection.Emit.OpCodes.Mkrefany>  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`refanytype`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Refanyval As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Refanyval;" />
      <MemberSignature Language="F#" Value=" staticval mutable Refanyval : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>检索嵌入在类型化引用内的地址（<see langword="&amp;" /> 类型）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|C2 < `T` >|refanyval`type`|推送在类型化引用中存储的地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  值类型引用被推送到堆栈上。  
  
2.  从堆栈中弹出类型化引用和检索到相应的地址。  
  
3.  该地址将被推送到堆栈上。  
  
 类型化引用包含对象实例的类型标记和地址。  
  
 `refanyval`指令检索嵌入在类型化引用中的地址。 在堆栈上提供的类型化引用中嵌入的类型必须与`type` (元数据标记, `typedef`或`typeref`) 指定的类型匹配。 请参阅<xref:System.Reflection.Emit.OpCodes.Mkrefany>相关内容的说明。  
  
 <xref:System.InvalidCastException>如果`type`与类型引用中存储的类型 (在这种情况下, 是提供给<xref:System.Reflection.Emit.OpCodes.Mkrefany>构造`type`的类型化引用的指令) 不完全相同, 则会引发。  
  
 <xref:System.TypeLoadException>如果`type`找不到, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`refanyval`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5D|剩余|将除除以`value1` `value2`的余数推送到堆栈上。|  
  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`将从堆栈中弹出和`value2`计算的`value1` `div`其余部分。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1``rem` 满足`value2`下列条件:  
  
 `result` = `value1` - `value2``×` (`value1` )和:`div` `value2`  
  
 0 = &#124; `result` &#124; < &#124; (`result`) = `div` sign (`value1`), 其中是向零截断的除法指令。 `value2` &#124;  
  
 如果`value2`为零或`value1`无穷大, 则结果为 NaN。 如果`value2`是无限的, 则结果`value1`为 (对`-infinity`求反)。  
  
 <xref:System.DivideByZeroException> 如果`value2`为零, 则引发整数运算。  
  
 请注意, 在基于 Intel 的平台<xref:System.OverflowException>上, 计算时将引发 (minint `rem` -1)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`rem`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rem_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rem_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rem_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将两个无符号值相除并将余数推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|5E|rem.un|将未`value1` `value2`签名的的剩余部分推送到堆栈上。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`将从堆栈中弹出和`value2`计算的`value1` `div`其余部分。  
  
4.  将结果推送到堆栈上。  
  
 `result` = `value1``rem.un` 满足`value2`下列条件:  
  
 `result` = `value1` - `value2`x (`value1` `div.un` )和`value2`:  
  
 0 = `result`  <  ,其中`div.un`是无符号除法指令。 `value2`  
  
 `rem.un`指令计算`result`并将其推送到堆栈上。 `Rem.un`将其参数视为无符号整数, <xref:System.Reflection.Emit.OpCodes.Rem>同时将它们视为有符号整数。  
  
 `Rem.un`对于浮点数未指定。  
  
 <xref:System.DivideByZeroException> 如果`value2`为零, 则引发整数运算。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`rem.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Ret As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Ret;" />
      <MemberSignature Language="F#" Value=" staticval mutable Ret : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从当前方法返回，并将返回值（如果存在）从调用方的计算堆栈推送到被调用方的计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|2A|ret|从方法返回, 可能返回值。|  
  
 堆栈转换行为顺序如下:  
  
1.  从被调用方的计算堆栈中弹出返回值。  
  
2.  在步骤1中获取的返回值被推送到调用方计算堆栈上。  
  
 如果返回值不在被调用方的计算堆栈上, 则不返回任何值 (对于被调用方或调用方方法, 不返回任何堆栈转换行为)。  
  
 当前方法的返回值的类型 (如果有) 确定要从堆栈顶部获取的值的类型, 并将其复制到调用当前方法的方法的堆栈上。 当前方法的计算堆栈必须为空, 但要返回的值除外。  
  
 `filter``try` `finally` `catch`指令不能用于将控制传输到、、或块。 `ret` 从`try`或`catch`中, 将<xref:System.Reflection.Emit.OpCodes.Leave>指令与所有封闭异常块之外的`ret`指令的目标结合使用。 `filter`因为和`finally`块在逻辑上是异常处理的一部分, 而不是其代码的嵌入方法, 所以, 正确生成的 Microsoft 中间语言 (MSIL) 指令并不执行从`filter`或。`finally`  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`ret`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Rethrow As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Rethrow;" />
      <MemberSignature Language="F#" Value=" staticval mutable Rethrow : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>再次引发当前异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1A|重新引发|重新引发当前异常|  
  
 没有为此指令定义堆栈转换行为。  
  
 仅允许在`catch`处理程序的主体中使用指令。`rethrow` 它将引发与此处理程序捕获的异常。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`rethrow`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shl As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shl;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shl : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值左移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|62|shl|向左移动一个整数 (以零为变化)。|  
  
 堆栈转换行为顺序如下:  
  
1.  将值推送到堆栈上。  
  
2.  要移动的位数将被推送到堆栈上。  
  
3.  要移动的位数以及从堆栈中弹出的值的数目;该值将向左移动指定的位数。  
  
4.  将结果推送到堆栈上。  
  
 指令`shl`将值 (类型`int32`, `int64`或`native int`) 向左移动指定的位数。 位数为或`int32` `native int`类型的值。 如果要移位的位数大于或等于所提供值的宽度 (以位为单位), 则返回值为未指定。  
  
 `Shl`在每个移位的最小位置插入零位。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`shl`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将整数值右移（保留符号）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|63|shr|向右移动一个整数 (移位)。|  
  
 堆栈转换行为顺序如下:  
  
1.  将值推送到堆栈上。  
  
2.  要移动的位数将被推送到堆栈上。  
  
3.  要移动的位数以及从堆栈中弹出的值的数目;值向右移动指定的位数。  
  
4.  将结果推送到堆栈上。  
  
 指令将值 (类型`int32`, `int64`或`native int`) 向右移动指定的位数。 `shr.un` 位数为或`int32` `native int`类型的值。 如果要移位的位数大于或等于所提供值的宽度 (以位为单位), 则返回值为未指定。  
  
 `Shr`复制每个移位上的高序位, 同时保留中`result`原始值的符号。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`shr`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Shr_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Shr_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Shr_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将无符号整数值右移（用零填充）指定的位数，并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|64|shr|向右移动一个整数 (以零为变化)。|  
  
 堆栈转换行为顺序如下:  
  
1.  将值推送到堆栈上。  
  
2.  要移动的位数将被推送到堆栈上。  
  
3.  要移动的位数以及从堆栈中弹出的值的数目;值向右移动指定的位数。  
  
4.  将结果推送到堆栈上。  
  
 指令将值 (类型`int32`, `int64`或`native int`) 向右移动指定的位数。 `shr.un` 位数为`int32` `int64`或类型的值。`native int` 如果要移位的位数大于或等于所提供值的宽度 (以位为单位), 则返回值为未指定。  
  
 `Shr.un`在每个移位上的最高位置插入零位。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`shr.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sizeof As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sizeof;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sizeof : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将提供的值类型的大小（以字节为单位）推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 1C < `T` >|sizeof`valType`|将值类型的大小 (以字节为单位) 作为`unsigned int32`推送。|  
  
 堆栈转换行为顺序如下:  
  
1.  将提供的值类型 (`valType`) 的大小 (以字节为单位) 推送到堆栈上。  
  
 `valType`必须是元数据标记 ( `typeref`或`typedef`), 它指定值类型、引用类型或泛型类型参数。  
  
 对于引用类型, 返回的大小为相应类型的引用值的大小 (32 位系统上为4个字节), 而不是存储在引用值引用的对象中的数据的大小。 泛型类型参数只能在定义它的类型或方法的主体中使用。 当对该类型或方法进行实例化时, 泛型类型参数被替换为值类型或引用类型。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`sizeof`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储到位于指定索引的参数槽中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0B <`unsigned int16` >|starg`num`|从堆栈中弹出顶部值并将其存储在参数槽`num`中。|  
  
 堆栈转换行为顺序如下:  
  
1.  当前位于堆栈顶部的值会弹出并置于参数槽`num`中。  
  
 指令从堆栈中弹出一个值, 并将该值放入参数`num`槽。 `starg` 值的类型必须与当前方法的签名中指定的参数的类型匹配。  
  
 对于采用变量参数列表的过程, `starg`指令只能用于初始固定参数, 而不能用于签名的变量部分。  
  
 如果将存储区的参数保留为小于4个字节的整数值, 则会在从堆栈移到参数时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`starg`使用操作码:  
  
-   ILGenerator (操作码, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Starg_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Starg_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Starg_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将位于计算堆栈顶部的值存储在参数槽中的指定索引处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|starg`num`|从堆栈中弹出顶部值并将其存储在参数槽`num`中 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  当前位于堆栈顶部的值会弹出并置于参数槽`num`中。  
  
 指令从堆栈中弹出一个值, 并将该值放入参数`num`槽。 `starg.s` 值的类型必须与当前方法的签名中指定的参数的类型匹配。  
  
 `starg.s`说明提供了一个有效的编码, 可用于前256个参数。  
  
 对于采用变量参数列表的过程, `starg.s`指令只能用于初始固定参数, 而不能用于签名的变量部分。  
  
 如果将存储区的参数保留为小于4个字节的整数值, 则会在从堆栈移到参数时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`starg.s`使用操作码:  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈中的值替换给定索引处的数组元素，其类型在指令中指定。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A4 < `T` >|stelem`typeTok`|将所提供索引处的数组元素替换为堆栈上的`typeTok`类型值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  的索引值`index` `array`被推送到堆栈上。  
  
3.  指令中指定的类型的值被推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用值替换一维数组`array`中提供的从零开始的索引处的元素的值。 `stelem` 值具有指令中的标记`typeTok`所指定的类型。  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="native int" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9B|stelem。 i|将所提供的索引处的数组元素替换`native int`为堆栈上的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用`index` 推送到`array`堆栈上的值替换一维数组中的元素的值。`native int` `stelem.i`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.i`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int8" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9C|stelem.i1|将所提供的索引处的数组元素替换`int8`为堆栈上的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用`index` 推送到`array`堆栈上的值替换一维数组中的元素的值。`int8` `stelem.i1`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.i1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int16" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9D|stelem.i2|将所提供的索引处的数组元素替换`int16`为堆栈上的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用`index` 推送到`array`堆栈上的值替换一维数组中的元素的值。`int16` `stelem.i2`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.i2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9E|stelem.i4|将所提供的索引处的数组元素替换`int32`为堆栈上的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用`index` 推送到`array`堆栈上的值替换一维数组中的元素的值。`int32` `stelem.i4`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.i4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="int64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|9F|stelem.i8|将所提供的索引处的数组元素替换`int64`为堆栈上的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用`index` 推送到`array`堆栈上的值替换一维数组中的元素的值。`int64` `stelem.i8`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.i8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float32" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A0|stelem.r4|将所提供的索引处的数组元素替换`float32`为堆栈上的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用`index` 推送到`array`堆栈上的值替换一维数组中的元素的值。`float32` `stelem.r4`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.r4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的 <see langword="float64" /> 值替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A1|stelem.r8|将所提供的索引处的数组元素替换`float64`为堆栈上的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令用`index` 推送到`array`堆栈上的值替换一维数组中的元素的值。`float64` `stelem.r8`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.r8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stelem_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stelem_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stelem_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用计算堆栈上的对象 ref 值（<see langword="O" /> 类型）替换给定索引处的数组元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A2|stelem.ref|将所提供的索引处的数组元素替换`ref`为堆栈上`O`的值 (类型)。|  
  
 堆栈转换行为顺序如下:  
  
1.  对数组`array`的对象引用被推送到堆栈上。  
  
2.  将中`array`元素的有效索引推送到堆栈上。  
  
3.  将值推送到堆栈上。  
  
4.  从堆栈中弹出值、索引和数组引用;将值放入给定索引处的数组元素。  
  
 指令将在一维数组`array`中所提供索引处的元素的值替换为`ref`堆栈上推送的 ( `O`类型) 值。 `stelem.ref`  
  
 数组是对象, 因此表示为类型`O`的值。 索引的类型`native int`为。  
  
 请注意`stelem.ref` , 在为数组元素赋值之前, 会将`array`提供的值隐式转换为的元素类型。 此强制转换可能会失败, 即使对于已验证的代码也是如此。 因此, `stelem.ref`该指令可能<xref:System.InvalidCastException>会引发。 对于不是从零开始的一维数组和多维数组, <xref:System.Array>该类提供了一个<xref:System.Array.SetValue%2A>方法。  
  
 <xref:System.NullReferenceException>如果`array`为 null 引用, 则引发。  
  
 <xref:System.IndexOutOfRangeException>如果`index`为负或大于的`array`界限, 则引发。  
  
 <xref:System.ArrayTypeMismatchException>如果`array`不包含所需类型的元素, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stelem.ref`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用新值替换在对象引用或指针的字段中存储的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7D < `T` >|stfld`field`|将对象的值`field`替换为新值。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用或指针被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和对象引用/指针;对象`field`中的值将替换为提供的值。  
  
 `native int` `&` `*`指令替换对象 (类型`O`) 的字段的值, 或通过指针 (类型、或) 替换给定的值。 `stfld` `Field`引用字段成员引用的元数据标记。 指令可以具有和<xref:System.Reflection.Emit.OpCodes.Unaligned> <xref:System.Reflection.Emit.OpCodes.Volatile>/或的前缀。 `stfld`  
  
 <xref:System.NullReferenceException>如果对象引用或指针为空引用, 并且该字段不是静态的, 则会引发。  
  
 <xref:System.MissingFieldException>如果`field`在元数据中找不到, 则引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检查此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stfld`使用操作码:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="native int" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DF|stind。 i|`native int`将值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `native int` `native int` `*`指令将值存储在所提供的地址上 (类型为、 `&`或)。 `stind.i`  
  
 类型安全操作要求`stind.i`指令的使用方式与指针的类型一致。 `stind.i`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.i`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int8" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|52|stind|`int8`将值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `int8` `native int` `*`指令将值存储在所提供的地址上 (类型为、 `&`或)。 `stind.i1`  
  
 类型安全操作要求`stind.i1`指令的使用方式与指针的类型一致。 `stind.i1`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.i1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int16" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|53|stind|`int16`将值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `int16` `native int` `*`指令将值存储在所提供的地址上 (类型为、 `&`或)。 `stind.i2`  
  
 类型安全操作要求`stind.2i`指令的使用方式与指针的类型一致。 `stind.i2`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.i2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|54|stind. i4|`int32`将值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `int32` `native int` `*`指令将值存储在所提供的地址上 (类型为、 `&`或)。 `stind.i4`  
  
 类型安全操作要求`stind.i4`指令的使用方式与指针的类型一致。 `stind.i4`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.i4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_I8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_I8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_I8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="int64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|55|stind. i8|`int64`将值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `int64` `native int` `*`指令将值存储在所提供的地址上 (类型为、 `&`或)。 `stind.i8`  
  
 类型安全操作要求`stind.i8`指令的使用方式与指针的类型一致。 `stind.i`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.i8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R4 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R4;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R4 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float32" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|56|stind.r4|`float32`将值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `float32` `native int` `*`指令将值存储在所提供的地址上 (类型为、 `&`或)。 `stind.r4`  
  
 类型安全操作要求`stind.r4`指令的使用方式与指针的类型一致。 `stind.r4`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.r4`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_R8 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_R8;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_R8 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在所提供的地址存储 <see langword="float64" /> 类型的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|57|stind. r8|`float64`将值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 `float64` `native int` `*`指令将值存储在所提供的地址上 (类型为、 `&`或)。 `stind.r8`  
  
 类型安全操作要求`stind.r8`指令的使用方式与指针的类型一致。 `stind.r8`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.r8`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stind_Ref As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stind_Ref;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stind_Ref : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>存储所提供地址处的对象引用值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|51|stind.ref|将对象引用 (类型`O`) 值存储在给定地址。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  将值推送到堆栈上。  
  
3.  从堆栈中弹出值和地址;值存储在地址上。  
  
 指令将对象引用值存储在所提供的地址上 ( `native int`类型`*`为、 `&`或)。 `stind.ref`  
  
 类型安全操作要求`stind.ref`指令的使用方式与指针的类型一致。 `stind.ref`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.NullReferenceException>如果`addr`对指令后缀隐含的参数类型不进行自然对齐, 则会引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stind.ref`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到指定索引处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 0E <`unsigned int16` >|stloc`index`|从堆栈中弹出一个值并将其存储在局部变量`index`中。|  
  
 堆栈转换行为顺序如下:  
  
1.  从堆栈中弹出一个值并将其放入本地变量`index`中。  
  
 指令从计算堆栈中弹出顶部值并将其移动到局部变量号`index`, 其中局部变量从0开始编号。 `stloc` 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 如果存储在保持小于4个字节的整数值的局部变量中, 长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 更正 Microsoft 中间语言 (MSIL) 指令需要为`index`有效的本地索引。 对于指令, `index`必须在0到65534的范围内 (具体而言, 65535 是无效的)。 `stloc` 排除65535的原因是实际的: 可能的实现将使用2字节整数跟踪本地的索引, 以及给定方法的局部变量总数。 如果已将65535的索引设为有效, 则需要更宽的整数来跟踪此类方法中的局部变量的数目。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stloc`使用操作码:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (操作码, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_0 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_0;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_0 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 0 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0A|stloc.0|将值从堆栈中弹出到局部变量0中。|  
  
 堆栈转换行为顺序如下:  
  
1.  从堆栈中弹出一个值, 并将其放入索引为0的局部变量。  
  
 `stloc.0`指令从计算堆栈中弹出顶部值, 并将其移动到索引为0的局部变量中。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.0`是用于将值存储在局部变量0中的特别有效的编码。  
  
 如果存储在保持小于4个字节的整数值的局部变量中, 长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stloc.0`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_1 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_1;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_1 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 1 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0B|stloc.1|将值从堆栈中弹出到局部变量1中。|  
  
 堆栈转换行为顺序如下:  
  
1.  从堆栈中弹出一个值, 并将其放入索引为1的局部变量。  
  
 `stloc.1`指令从计算堆栈中弹出顶部值, 并将其移动到索引为1的局部变量。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.1`是用于在局部变量1中存储值的一个特别高效的编码。  
  
 如果存储在保持小于4个字节的整数值的局部变量中, 长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stloc.1`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_2 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_2;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_2 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 2 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0C|stloc.2|将值从堆栈中弹出到局部变量2中|  
  
 堆栈转换行为顺序如下:  
  
1.  从堆栈中弹出一个值, 并将其放入索引为2的局部变量中。  
  
 `stloc.2`指令从计算堆栈中弹出顶部值, 并将其移动到索引为2的局部变量中。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.2`是用于将值存储在局部变量2中的一个特别高效的编码。  
  
 如果存储在保持小于4个字节的整数值的局部变量中, 长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stloc.2`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_3 As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_3;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_3 : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储到索引 3 处的局部变量列表中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|0D|stloc.3|从堆栈中弹出一个值到局部变量3|  
  
 堆栈转换行为顺序如下:  
  
1.  从堆栈中弹出一个值, 并将其放入索引为3的局部变量。  
  
 `stloc.3`指令从计算堆栈中弹出顶部值, 并将其移动到索引为3的本地变量中。 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.3`是用于将值存储在局部变量3中的一个特别高效的编码。  
  
 如果存储在保持小于4个字节的整数值的局部变量中, 长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stloc.3`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stloc_S As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stloc_S;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stloc_S : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从计算堆栈的顶部弹出当前值并将其存储在局部变量列表中的 <paramref name="index" /> 处（短格式）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc`index`|从堆栈中弹出一个值并将其存储在本地`index`变量中 (短格式)。|  
  
 堆栈转换行为顺序如下:  
  
1.  从堆栈中弹出一个值并将其放入本地变量`index`中。  
  
 指令从计算堆栈中弹出顶部值并将其移动到局部变量号`index`, 其中局部变量从0开始编号。 `stloc.s` 值的类型必须与当前方法本地签名中指定的局部变量的类型匹配。  
  
 `stloc.s`指令为局部变量0到255提供有效编码。  
  
 如果存储在保持小于4个字节的整数值的局部变量中, 长时间将在从堆栈移到局部变量时截断值。 浮点值从其本机大小 (类型`F`) 舍入到与参数关联的大小。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stloc.s`使用操作码:  
  
-   ILGenerator (OpCode, LocalBuilder)  
  
-   ILGenerator (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stobj As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stobj;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stobj : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指定类型的值从计算堆栈复制到所提供的内存地址中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj`class`|将类型`class`的值存储在内存中。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
2.  类型`class`的值类型对象被推送到堆栈上。  
  
3.  从堆栈中弹出对象和地址;值类型对象存储在地址上。  
  
 指令将值类型对象复制到地址指定的地址 (类型`native int`为、 `*`或`&`的指针)。 `stobj` 已复制的字节数取决于由表示`class`的类的大小, 即表示值类型的元数据标记。  
  
 `stobj`指令的操作可以通过紧靠上<xref:System.Reflection.Emit.OpCodes.Volatile>或<xref:System.Reflection.Emit.OpCodes.Unaligned>前缀指令来更改。  
  
 <xref:System.TypeLoadException>如果找不到类, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stobj`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Stsfld As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Stsfld;" />
      <MemberSignature Language="F#" Value=" staticval mutable Stsfld : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>用来自计算堆栈的值替换静态字段的值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld`field`|将中`field`的值替换为提供的值。|  
  
 堆栈转换行为顺序如下:  
  
1.  将值推送到堆栈上。  
  
2.  从堆栈中弹出一个值并将其存储`field`在中。  
  
 `stsfld`指令用来自堆栈的值替换静态字段的值。 `field`必须引用静态字段成员的元数据标记。  
  
 指令可以为<xref:System.Reflection.Emit.OpCodes.Volatile>前缀。 `stsfld`  
  
 <xref:System.MissingFieldException>如果在元数据中找不到字段, 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是在运行时, 通常会检查此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`stsfld`使用操作码:  
  
-   ILGenerator (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从其他值中减去一个值并将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|59|sub|从一个值中减去另一个值, 返回新的数值。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value2`从中`value1`减去。  
  
4.  将结果推送到堆栈上。  
  
 未检测到用于整数运算的溢出 (有关正确的溢出处理<xref:System.Reflection.Emit.OpCodes.Sub_Ovf>, 请参阅)。  
  
 整数减法环绕, 而不是尽量充满。 例如: 假设8位整数, 其中`value1`设置为 0, 且`value2`设置为 1, 则 "已包装" 结果将为255。  
  
 浮点溢出返回`+inf` (`PositiveInfinity`) 或`-inf` (`NegativeInfinity`)。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`sub`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DA|sub.ovf|使用溢出检查从一个整数值中减去另一个整数值。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value2`从中`value1`减去, 并选中溢出。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 此操作在有符号整数上执行;对于浮点值, 请使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`sub.ovf`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Sub_Ovf_Un As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="F#" Value=" staticval mutable Sub_Ovf_Un : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>从另一值中减去一个无符号整数值，执行溢出检查，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|DB|sub.ovf.un|使用溢出检查从一个无符号整数值减去另一个无符号整数值。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`和`value1`从堆栈中弹出;`value2`从中`value1`减去, 并选中溢出。  
  
4.  将结果推送到堆栈上。  
  
 <xref:System.OverflowException>如果结果不能用结果类型表示, 则会引发。  
  
 此操作在有符号整数上执行;对于浮点值, 请使用<xref:System.Reflection.Emit.OpCodes.Sub>。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`sub.ovf.un`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Switch As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Switch;" />
      <MemberSignature Language="F#" Value=" staticval mutable Switch : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>实现跳转表。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` > .。。<`int32` >|switch (`N`, `t1`, `t2`.。。`tN`)|跳转到其中`N`一个值。|  
  
 堆栈转换行为顺序如下:  
  
1.  将值推送到堆栈上。  
  
2.  该值将从堆栈中弹出, 并按照值索引的偏移量 (其中值小于`N`) 将执行传输到指令。  
  
 `switch`指令实现跳转表。 指令`unsigned int32`的格式表示目标`N`的数量, 后跟`N`指定跳转目标的 int32 值。 在此`switch`指令后面的指令的开头, 这些目标表示为偏移量 (正面或负数)。  
  
 指令从堆栈中弹出一个值, 并将其作为无符号整数与进行`N`比较。 `switch` 如果值小于`N`, 执行将传输到通过值索引的目标, 其中目标从0开始编号 (例如, 值0采用第一个目标, 值为 1, 则使用第二个目标, 依此类推)。 如果该值大于或等于`N`, 则继续执行下一条指令 (贯穿)。  
  
 如果目标指令具有一个或多个前缀代码, 则只能将控制转移到其中的第一个前缀。  
  
 此指令无法执行控制传入`try`和`catch`传出`filter`、、 `finally`和块的控制。 (此类传输受到严格限制, 因此必须改用 leave 指令)。  
  
 下面<xref:System.Reflection.Emit.ILGenerator.Emit%2A>的方法重载可以`switch`使用操作码。 `Label[]`参数是表示32位偏移量的标签数组。  
  
-   ILGenerator.Emit(OpCode, Label[])  
  
   
  
## Examples  
 下面的代码示例说明了如何使用`Switch`操作码来使用<xref:System.Reflection.Emit.Label>数组生成跳转表。  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Tailcall As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Tailcall;" />
      <MemberSignature Language="F#" Value=" staticval mutable Tailcall : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>执行后缀的方法调用指令，以便在执行实际调用指令前移除当前方法的堆栈帧。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 14|侧.|后续调用终止当前方法|  
  
 没有为此指令定义堆栈转换行为。  
  
 前缀指令必须紧跟在<xref:System.Reflection.Emit.OpCodes.Call>、 <xref:System.Reflection.Emit.OpCodes.Calli>或<xref:System.Reflection.Emit.OpCodes.Callvirt>指令之前。 `tail` 它指示在执行调用指令之前应移除当前方法的堆栈帧。 它还意味着从以下调用返回的值也是当前方法返回的值, 因此可以将调用转换为交叉方法跳转。  
  
 堆栈必须为空, 但通过以下调用传输的参数除外。 调用指令后面的指令必须是 ret。因此, 唯一有效的代码序列`tail. call`是 ( `calli` `callvirt`或)。 更正 Microsoft 中间语言 (MSIL) 指令不能分支到`call`指令, 但它们可能会分支到后面<xref:System.Reflection.Emit.OpCodes.Ret>的。  
  
 如果控件从不受信任的代码传输到受信任的代码, 则无法放弃当前帧, 因为这会危及代码标识安全性。 因此, .NET Framework 安全检查可能会导致`tail`忽略, 而保留标准<xref:System.Reflection.Emit.OpCodes.Call>说明。 同样, 若要允许在调用返回后退出已同步的区域, 则在用于退出标记`tail`为已同步的方法时将忽略该前缀。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`tail`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TakesSingleByteArgument (inst As OpCode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TakesSingleByteArgument(System::Reflection::Emit::OpCode inst);" />
      <MemberSignature Language="F#" Value="static member TakesSingleByteArgument : System.Reflection.Emit.OpCode -&gt; bool" Usage="System.Reflection.Emit.OpCodes.TakesSingleByteArgument inst" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">操作码对象的实例。</param>
        <summary>如果提供的操作码采用单字节参数则返回真或假。</summary>
        <returns><see langword="true" /> 或 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法可用于查找要在优化代码中使用的 MSIL 操作码为 "短格式"。  
  
 `TakesSingleByteArgument`如果实例在以下情况下采用单个字节参数, 则返回`true`: <xref:System.Reflection.Emit.OpCode>  
  
-   操作码对字节大小的地址 (例如<xref:System.Reflection.Emit.OpCodes.Br_S>和<xref:System.Reflection.Emit.OpCodes.Bgt_S>) 执行分支指令。  
  
-   操作码将一个字节值推送到堆栈上 (例如, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>)。  
  
-   操作码通过字节大小的 "缩写" (例如, <xref:System.Reflection.Emit.OpCodes.Ldloc_S>和<xref:System.Reflection.Emit.OpCodes.Stloc_S>) 引用变量或参数。  
  
 否则，它将返回 `false`。  
  
 下面的示例演示了`TakesSingleByteArgument` `OpCodes`如何通过反射到类并进行测试来查看每个`OpCode`字段是否采用单字节参数。  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Throw As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Throw;" />
      <MemberSignature Language="F#" Value=" staticval mutable Throw : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>引发当前位于计算堆栈上的异常对象。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|7A|throw|引发异常。|  
  
 堆栈转换行为顺序如下:  
  
1.  将对象引用 (对异常) 推送到堆栈上。  
  
2.  从堆栈中弹出对象引用并引发异常。  
  
 指令引发当前堆栈上的异常对象`O`(类型)。 `throw`  
  
 <xref:System.NullReferenceException>如果对象引用为空引用, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`throw`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unaligned As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unaligned;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unaligned : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示当前位于计算堆栈上的地址可能没有与紧接的 <see langword="ldind" />、<see langword="stind" />、<see langword="ldfld" />、<see langword="stfld" />、<see langword="ldobj" />、<see langword="stobj" />、<see langword="initblk" /> 或 <see langword="cpblk" /> 指令的自然大小对齐。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 12 <`unsigned int8` >|未对齐. `alignment`|指示后面的指针指令可能是不对齐的。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
 `Unaligned`指定堆栈上的地址 (非托管指针`native int`) 可能不会与`ldind`紧跟其后的`stobj`、 `stind`、 `ldfld`、 `stfld` `ldobj`、、、`initblk`或`cpblk`指令。 也就是说, 对于<xref:System.Reflection.Emit.OpCodes.Ldind_I4>说明, 地址的对齐方式可能不会为4字节边界。 对于`initblk`和`cpblk` , 默认对齐方式取决于体系结构依赖 (32 位 cpu 上的4个字节, 64 位 cpu 上的8个字节)。 如果在编译时不知道对齐方式为8字节, 则不会将其`unaligned`输出限制为32位 word 的代码生成器必须使用。  
  
 "对齐" 的值必须是1、2或 4, 这意味着生成的代码应分别假定地址是字节、双字节或4字节对齐。 请注意, 临时指针 ( `*`类型) 始终对齐。  
  
 尽管`cpblk`指令的对齐在逻辑上需要两个数字 (一个用于源, 另一个用于目标), 但如果只指定了较小的数字, 则不会对性能产生显著影响。  
  
 `unaligned` 和`volatile`前缀可以按任意顺序进行组合。 它们`ldind`必须紧跟在`stind` `ldfld`、 、、`stfld`、、、或`cpblk`指令之前。 `ldobj` `stobj` `initblk` 和说明只允许使用<xref:System.Reflection.Emit.OpCodes.Volatile> 前缀。<xref:System.Reflection.Emit.OpCodes.Stsfld> <xref:System.Reflection.Emit.OpCodes.Ldsfld>  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`unaligned`使用操作码:  
  
-   ILGenerator (操作码、标签)  
  
-   ILGenerator (Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将值类型的已装箱的表示形式转换为其未装箱的形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|79 < `T` >|装箱`valType`|从其装箱表示形式中`obj`提取值类型数据。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用, 并取消装箱到值类型指针。  
  
3.  值类型指针被推送到堆栈上。  
  
 值类型在公共语言基础结构 (CLI) 中具有两种不同的表示形式:  
  
-   当值类型嵌入到另一个对象中时使用的 "原始" 窗体。  
  
-   "装箱" 窗体, 其中值类型中的数据被包装 (装箱) 到对象中, 因此它可以作为独立实体存在。  
  
 指令将对象引用 (类型`O`)、值类型的装箱表示形式转换为值类型指针 (托管指针、类型`&`)、其未装箱形式。 `unbox` 提供的值类型 (`valType`) 是元数据标记, 用于指示装箱对象中包含的值类型类型。  
  
 与<xref:System.Reflection.Emit.OpCodes.Box>(需要创建值类型的副本以便在对象中使用) `unbox`不需要从对象复制值类型。 通常, 它只是计算装箱对象内已存在的值类型的地址。  
  
 <xref:System.InvalidCastException>如果对象未装箱为`valType`, 则会引发。  
  
 <xref:System.NullReferenceException>如果对象引用为空引用, 则引发。  
  
 <xref:System.TypeLoadException>如果找不到值类型`valType` , 则会引发。 当 Microsoft 中间语言 (MSIL) 指令转换为本机代码而不是运行时, 通常会检测到此情况。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`unbox`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Unbox_Any As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Unbox_Any;" />
      <MemberSignature Language="F#" Value=" staticval mutable Unbox_Any : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>将指令中指定类型的已装箱的表示形式转换成未装箱形式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|A5 < `T` >|取消装箱。`typeTok`|从`obj`中提取数据, 其装箱表示形式。|  
  
 堆栈转换行为顺序如下:  
  
1.  对象引用`obj`被推送到堆栈上。  
  
2.  从堆栈中弹出对象引用, 并取消装箱到指令中指定的类型。  
  
3.  生成的对象引用或值类型被推送到堆栈上。  
  
 当应用于值类型的装箱形式`unbox.any`时, 指令提取中`obj`包含的值 (类型`O`为), 因而等效`unbox`于后面的`ldobj`。  
  
 当应用于引用类型时, `unbox.any`指令与具有相同的`castclass` `typeTok`效果。  
  
 如果操作数`typeTok`是泛型类型参数, 则运行时行为取决于为该泛型类型参数指定的类型。  
  
 <xref:System.InvalidCastException>如果`obj`不是装箱类型, 则会引发。  
  
 <xref:System.NullReferenceException>如果`obj`为 null 引用, 则引发。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`unbox.any`使用操作码:  
  
-   ILGenerator (OpCode, Type)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Volatile As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Volatile;" />
      <MemberSignature Language="F#" Value=" staticval mutable Volatile : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指定当前位于计算堆栈顶部的地址可以是易失的，并且读取该位置的结果不能被缓存，或者对该地址的多个存储区不能被取消。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|FE 13|失效.|指示后续指针引用是可变的。|  
  
 堆栈转换行为顺序如下:  
  
1.  地址被推送到堆栈上。  
  
 `volatile`。 指定该地址是一个可变地址 (即, 可以从外部引用到当前执行线程), 并且无法缓存读取该位置的结果, 或者无法禁止显示此位置的多个存储。 将访问标记为`volatile`只影响单一访问权限; 对同一位置的其他访问必须单独标记。 不需要以原子方式执行对可变位置的访问。  
  
 <xref:System.Reflection.Emit.OpCodes.Unaligned> 和`volatile`前缀可以按任意顺序进行组合。 它们`ldind`必须紧跟在`stind` `ldfld`、 、、`stfld`、、、或`cpblk`指令之前。 `ldobj` `stobj` `initblk` 和说明只允许使用`volatile` 前缀。<xref:System.Reflection.Emit.OpCodes.Stsfld> <xref:System.Reflection.Emit.OpCodes.Ldsfld>  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`volatile`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Xor As OpCode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::Emit::OpCode Xor;" />
      <MemberSignature Language="F#" Value=" staticval mutable Xor : System.Reflection.Emit.OpCode" Usage="System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>计算位于计算堆栈顶部的两个值的按位异或，并且将结果推送到计算堆栈上。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出了指令的十六进制和 Microsoft 中间语言 (MSIL) 程序集格式以及简短的参考摘要:  
  
|格式|程序集格式|说明|  
|------------|---------------------|-----------------|  
|61|xor|计算两个整数值的按位 XOR 并返回整数。|  
  
 堆栈转换行为顺序如下:  
  
1.  `value1`被推送到堆栈上。  
  
2.  `value2`被推送到堆栈上。  
  
3.  `value2`从`value1`堆栈中弹出和, 并计算按位 XOR。  
  
4.  `value2` 和`value1`的按位 XOR 被推送到堆栈上。  
  
 `xor`指令计算堆栈顶部两个值的按位 XOR, 并将结果保留在堆栈上。  
  
 `Xor`是特定于整数的操作。  
  
 以下<xref:System.Reflection.Emit.ILGenerator.Emit%2A>方法重载可以`xor`使用操作码:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
