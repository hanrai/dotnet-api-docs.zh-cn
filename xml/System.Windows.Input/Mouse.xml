<Type Name="Mouse" FullName="System.Windows.Input.Mouse">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b74c1fc91dbccb0eaeef3d5dc5f2451716a7a24f" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65004670" /></Metadata><TypeSignature Language="C#" Value="public static class Mouse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Mouse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Input.Mouse" />
  <TypeSignature Language="VB.NET" Value="Public Class Mouse" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mouse abstract sealed" />
  <TypeSignature Language="F#" Value="type Mouse = class" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>将鼠标设备表示为特定线程。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.Mouse>类提供与鼠标相关的事件、方法和属性, 这些属性提供有关鼠标状态的信息。  
  
 定义为附加<xref:System.Windows.Input.Mouse>事件的每个事件也由基元素类<xref:System.Windows.UIElement>和<xref:System.Windows.ContentElement>新的路由事件重新公开。 通常, 在和<xref:System.Windows.UIElement> <xref:System.Windows.ContentElement>上处理应用程序的鼠标事件更方便<xref:System.Windows.Input.Mouse> , 而不是使用事件。 有关详细信息, 请参阅[输入概述](~/docs/framework/wpf/advanced/input-overview.md)。  
  
 <xref:System.Windows.Input.Mouse>类的静态成员委托给调用线程的输入<xref:System.Windows.Input.MouseDevice>管理器的主成员。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void AddLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void AddPreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddPreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddPreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddPreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddPreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddPreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddPreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void AddQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.AddQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member AddQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.AddQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>为 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件添加处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Capture">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将鼠标输入捕获到指定元素。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时, 它将接收鼠标输入, 无论光标是否在其边界内。  
  
 如果未指定, 则默认值<xref:System.Windows.Input.CaptureMode>为<xref:System.Windows.Input.CaptureMode.Element>。 <xref:System.Windows.Input.CaptureMode>  
  
 若要释放鼠标捕获, <xref:System.Windows.Input.Mouse.Capture%2A>请`null`调用作为要捕获的元素传递。  
  
 如果在引发<xref:System.Windows.Input.Mouse.MouseDown>或<xref:System.Windows.Input.Mouse.MouseUp>事件时捕获鼠标, 并且输入不会转到鼠标<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement>下的元素, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement>则首先引发。  这使得捕获的元素有机会在路由<xref:System.Windows.Input.Mouse.MouseDown>和<xref:System.Windows.Input.Mouse.MouseUp>事件之前释放捕获。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Capture (element As IInputElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement -&gt; bool" Usage="System.Windows.Input.Mouse.Capture element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="element">要捕获鼠标的元素。</param>
        <summary>将鼠标输入捕获到指定元素。</summary>
        <returns>如果元素能够捕获鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时, 它将接收鼠标输入, 无论光标是否在其边界内。  
  
 如果未指定, 则默认值<xref:System.Windows.Input.CaptureMode>为<xref:System.Windows.Input.CaptureMode.Element>。 <xref:System.Windows.Input.CaptureMode>  
  
 若要释放鼠标捕获, <xref:System.Windows.Input.Mouse.Capture%2A>请`null`调用作为要捕获的元素传递。  
  
 如果在引发<xref:System.Windows.Input.Mouse.MouseDown>或<xref:System.Windows.Input.Mouse.MouseUp>事件时捕获鼠标, 并且输入不会转到鼠标<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement>下的元素, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement>则首先引发。  这使得捕获的元素有机会在路由<xref:System.Windows.Input.Mouse.MouseDown>和<xref:System.Windows.Input.Mouse.MouseUp>事件之前释放捕获。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Windows.Input.Mouse.Capture%2A>方法将鼠标捕获到特定元素。  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public static bool Capture (System.Windows.IInputElement element, System.Windows.Input.CaptureMode captureMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Capture(class System.Windows.IInputElement element, valuetype System.Windows.Input.CaptureMode captureMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Capture(System.Windows.IInputElement,System.Windows.Input.CaptureMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Capture(System::Windows::IInputElement ^ element, System::Windows::Input::CaptureMode captureMode);" />
      <MemberSignature Language="F#" Value="static member Capture : System.Windows.IInputElement * System.Windows.Input.CaptureMode -&gt; bool" Usage="System.Windows.Input.Mouse.Capture (element, captureMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.IInputElement" />
        <Parameter Name="captureMode" Type="System.Windows.Input.CaptureMode" />
      </Parameters>
      <Docs>
        <param name="element">要捕获鼠标的元素。</param>
        <param name="captureMode">要使用的捕获策略。</param>
        <summary>使用指定的 <see cref="T:System.Windows.Input.CaptureMode" /> 将鼠标输入捕获到指定元素。</summary>
        <returns>如果元素能够捕获鼠标，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时, 它将接收鼠标输入, 无论光标是否在其边界内。  
  
 若要释放鼠标捕获, <xref:System.Windows.Input.Mouse.Capture%2A>请`null`调用作为要捕获的元素传递。  
  
 如果在引发<xref:System.Windows.Input.Mouse.MouseDown>或<xref:System.Windows.Input.Mouse.MouseUp>事件时捕获鼠标, 并且输入不会转到鼠标<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement>下的元素, <xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement>则首先引发。  这使得捕获的元素有机会在路由<xref:System.Windows.Input.Mouse.MouseDown>和<xref:System.Windows.Input.Mouse.MouseUp>事件之前释放捕获。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Windows.Input.Mouse.Capture%2A>方法将鼠标捕获到特定元素。  
  
 [!code-csharp[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecaptursamplecaptureelement)]
 [!code-vb[MouseCaptureSample#MouseCapturSampleCaptureElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecaptursamplecaptureelement)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Captured">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement Captured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement Captured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.Captured" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Captured As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ Captured { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Captured : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.Captured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取捕获了鼠标的元素。</summary>
        <value>由鼠标捕获的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时, 它将接收鼠标输入, 无论光标是否在其边界内。 通常, 仅在拖放操作过程中以这种方式捕获鼠标, 并保留捕获, 直到拖放操作的删除操作发生。  
  
   
  
## Examples  
 下面的示例演示如何获取具有鼠标捕获的元素。  
  
 [!code-csharp[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseCaptureSample/CSharp/Window1.xaml.cs#mousecapturemousecaptured)]
 [!code-vb[mousecapturesample#MouseCaptureMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseCaptureSample/visualbasic/window1.xaml.vb#mousecapturemousecaptured)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectlyOver">
      <MemberSignature Language="C#" Value="public static System.Windows.IInputElement DirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.IInputElement DirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.DirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DirectlyOver As IInputElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::IInputElement ^ DirectlyOver { System::Windows::IInputElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectlyOver : System.Windows.IInputElement" Usage="System.Windows.Input.Mouse.DirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取鼠标指针正好悬停于的元素。</summary>
        <value>鼠标指针悬停的元素。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件可以包含多个元素。 <xref:System.Windows.Input.Mouse.DirectlyOver%2A>报告复合控件中的鼠标指针位于的特定元素, 而不是控件本身。 例如, 根据指针的<xref:System.Windows.Controls.Button>哪一部分<xref:System.Windows.Input.Mouse.DirectlyOver%2A> , 属性<xref:System.Windows.Controls.ContentControl.Content%2A>可能会报告<xref:System.Windows.Controls.TextBox>属性或<xref:Microsoft.Windows.Themes.ButtonChrome>的。  
  
 使用和<xref:System.Windows.IInputElement.IsMouseOver%2A> 上<xref:System.Windows.ContentElement>的属性来确定鼠标是否位于元素上, 该元素包括其可视子元素或控件复合元素。 <xref:System.Windows.UIElement>  
  
 如果某个元素具有鼠标捕获, 则在该元素上直接考虑鼠标指针, 而不考虑鼠标指针的位置。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseOver" />
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="GetIntermediatePoints">
      <MemberSignature Language="C#" Value="public static int GetIntermediatePoints (System.Windows.IInputElement relativeTo, System.Windows.Point[] points);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetIntermediatePoints(class System.Windows.IInputElement relativeTo, valuetype System.Windows.Point[] points) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetIntermediatePoints(System.Windows.IInputElement,System.Windows.Point[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetIntermediatePoints (relativeTo As IInputElement, points As Point()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetIntermediatePoints(System::Windows::IInputElement ^ relativeTo, cli::array &lt;System::Windows::Point&gt; ^ points);" />
      <MemberSignature Language="F#" Value="static member GetIntermediatePoints : System.Windows.IInputElement * System.Windows.Point[] -&gt; int" Usage="System.Windows.Input.Mouse.GetIntermediatePoints (relativeTo, points)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
        <Parameter Name="points" Type="System.Windows.Point[]" />
      </Parameters>
      <Docs>
        <param name="relativeTo"><paramref name="points" /> 所关联的元素。</param>
        <param name="points">对象数组。</param>
        <summary>检索以前的自上一个鼠标移动事件以来的鼠标指针坐标（最多可检索 64 个）。</summary>
        <returns>返回的点数。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPosition">
      <MemberSignature Language="C#" Value="public static System.Windows.Point GetPosition (System.Windows.IInputElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.Point GetPosition(class System.Windows.IInputElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.GetPosition(System.Windows.IInputElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPosition (relativeTo As IInputElement) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Point GetPosition(System::Windows::IInputElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="static member GetPosition : System.Windows.IInputElement -&gt; System.Windows.Point" Usage="System.Windows.Input.Mouse.GetPosition relativeTo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeTo" Type="System.Windows.IInputElement" />
      </Parameters>
      <Docs>
        <param name="relativeTo">计算鼠标在其中的位置的坐标空间。</param>
        <summary>获取与指定元素相对的鼠标位置。</summary>
        <returns>与参数 <paramref name="relativeTo" /> 相对的鼠标位置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 相对于指定元素计算鼠标指针的位置时, 该元素的左上角是原点, 0, 0。  
  
 在拖放操作过程中, 无法通过<xref:System.Windows.Input.Mouse.GetPosition%2A>可靠地确定鼠标的位置。 这是因为, 拖放操作完成后, 拖动的源元素 (可能包括捕获) 会控制鼠标控制 (可能包括捕获), 其中的大部分行为由基础[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]调用控制。 请尝试改用以下方法:  
  
-   <xref:System.Windows.ContentElement.DragOver> <xref:System.Windows.DragEventArgs> <xref:System.Windows.ContentElement.DragLeave>调用传递给拖动事件的的<xref:System.Windows.ContentElement.DragEnter> <xref:System.Windows.DragEventArgs.GetPosition%2A>方法 (、、)。  
  
-   使用 P/Invoke 调用[GetCursorPos](https://msdn.microsoft.com/library/default.asp?url=/library/winui/winui/windowsuserinterface/resources/cursors/cursorreference/cursorfunctions/getcursorpos.asp)。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Windows.Input.Mouse.GetPosition%2A>确定鼠标指针的位置。  鼠标指针的位置存储在<xref:System.Windows.Point>结构中。  对象的<xref:System.Windows.Point.X%2A>和<xref:System.Windows.Point.Y%2A>值<xref:System.Windows.Controls.TextBox>显示在中。 <xref:System.Windows.Point>  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetspositionmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsPositionMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetspositionmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Input.MouseEventArgs.GetPosition(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" Usage="see AddGotMouseCaptureHandler, and RemoveGotMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在元素捕获到鼠标时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时, 它将接收鼠标输入, 无论光标是否在其边界内。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 由于冒泡路由, 具有捕获的实际元素可以是子元素, 而不一定是实际附加了事件处理程序的元素。 检查事件<xref:System.Windows.RoutedEventArgs.Source%2A>参数中的, 以确定具有鼠标捕获的实际元素。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.GotMouseCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   未定义相应的隧道事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeftButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState LeftButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState LeftButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.LeftButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LeftButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState LeftButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.LeftButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.LeftButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取鼠标左键的状态。</summary>
        <value>鼠标左键的状态。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何通过检查的<xref:System.Windows.Input.Mouse.LeftButton%2A>状态是否等于<xref:System.Windows.Input.MouseButtonState>枚举值<xref:System.Windows.Input.MouseButtonState.Pressed>来确定是否按下了鼠标左键。  如果按下该按钮, 将调用一个方法, 该方法将更新示例中的显示元素。  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="ILAsm" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberSignature Language="F#" Value="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" Usage="see AddLostMouseCaptureHandler, and RemoveLostMouseCaptureHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在元素丢失鼠标捕获时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当某个元素捕获鼠标时, 它将接收鼠标输入, 无论光标是否在其边界内。 T  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 由于冒泡路由, 丢失捕获的实际元素可以是子元素, 而不一定是实际附加了事件处理程序的元素。 检查事件<xref:System.Windows.RoutedEventArgs.Source%2A>参数中的, 以确定丢失捕获的实际元素。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.LostMouseCaptureEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   未定义相应的隧道事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MiddleButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState MiddleButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState MiddleButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.MiddleButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MiddleButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState MiddleButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.MiddleButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.MiddleButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取鼠标中键的状态。</summary>
        <value>鼠标中键的状态。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何通过检查的<xref:System.Windows.Input.Mouse.MiddleButton%2A>状态是否等于<xref:System.Windows.Input.MouseButtonState>枚举值<xref:System.Windows.Input.MouseButtonState.Pressed>来确定是否按下鼠标中键。  如果按下该按钮, 将调用一个方法, 该方法将更新示例中的显示元素。  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetmiddlebuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetMiddleButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetmiddlebuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddMouseDownHandler, and RemoveMouseDownHandler" Usage="see AddMouseDownHandler, and RemoveMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当按下任何鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要确定鼠标按下了哪个按钮, <xref:System.Windows.Input.MouseButtonEventArgs.ChangedButton%2A>请在传递<xref:System.Windows.Input.MouseButtonEventArgs>到处理程序的中检查属性。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseRightButtonDown> <xref:System.Windows.UIElement> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]此框架通过在和<xref:System.Windows.ContentElement>上将其作为两个不同的事件进行呈现, 在此附加事件上生成: 和。 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 这些实现处理基础<xref:System.Windows.Input.Mouse.MouseDown>事件并读取事件的参数, 以确定是否涉及鼠标左键或右键。 对于三按钮鼠标, 中间按钮没有框架级别的事件支持。 应该使用<xref:System.Windows.Input.Mouse.MouseDown>事件并检查事件参数中<xref:System.Windows.Input.MouseEventArgs.MiddleButton%2A>的状态。  
  
> [!IMPORTANT]
>  有些<xref:System.Windows.ContentElement>具有类似于控件的行为的派生类 ( <xref:System.Windows.Documents.Hyperlink>例如,) 可能具有鼠标按钮事件的固有类处理。 鼠标左键按下事件是在控件中具有类处理的最可能的事件。 类处理通常将基础<xref:System.Windows.Input.Mouse>类事件标记为已处理。 将该事件标记为已处理后, 通常不会引发附加到该元素的其他实例处理程序。 通常也不会引发在冒泡方向上沿 UI 树中的根向下附加到元素的任何其他类或实例处理程序。  
  
 您可以通过使用以下任一解决方案解决前面重要说明中列出的问题, <xref:System.Windows.UIElement.MouseDown>并仍在具有类处理的派生类上接收鼠标左键按下事件的事件:  
  
-   为<xref:System.Windows.UIElement.PreviewMouseDown>事件附加处理程序, 这些处理程序未标记为由控件处理。 请注意, 因为这是预览事件, 所以路由从根节点开始, 向下隧道到控件。  
  
-   通过调用<xref:System.Windows.UIElement.AddHandler%2A>并选择允许处理程序侦听事件的签名选项 (即使它们已在路由事件数据中标记为已处理), 在控件过程上注册处理程序。  
  
 对于与鼠标相关的路由事件, 请注意如何或何时将其标记为已处理。 对父元素是否也应该知道是否还应知道父元素是否还应知道是否应该知道是否有任何给定鼠标[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]操作的难点在于, 这是因为框架选择了将基础鼠标[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]路由事件呈现为的模型沿路由的事件。 隧道鼠标事件存在类似问题。  是否应处理事件, 而不让其通过其他子级进行处理, 以及如何影响组合项可能具有预期鼠标行为的控件？  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.MouseDownEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   对应的隧道事件为<xref:System.Windows.Input.Mouse.PreviewMouseDown>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberSignature Language="F#" Value="see AddMouseEnterHandler, and RemoveMouseEnterHandler" Usage="see AddMouseEnterHandler, and RemoveMouseEnterHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当鼠标指针进入元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 此事件使用直接事件处理路由策略。 直接路由事件不沿路由引发 (它们只能在引发它们的同一元素中进行处理)。  但是, 它们会启用路由事件行为的其他方面, 如样式中的事件触发器。  
  
 尽管此事件用于跟踪鼠标进入元素的时间, 但它也报告此元素上的<xref:System.Windows.UIElement.IsMouseOver%2A>属性已从`false`更改为`true` 。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.MouseEnterEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" Usage="see AddMouseLeaveHandler, and RemoveMouseLeaveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当鼠标指针离开元素的边界时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 此事件使用直接事件处理路由策略。 直接路由事件不遵循路由 (它们只能在引发它们的同一元素中进行处理)。  但是, 它们会启用路由事件行为的其他方面, 如样式中的事件触发器。  
  
 尽管此事件用于跟踪鼠标离开元素的时间, 但它也报告此元素上的<xref:System.Windows.UIElement.IsMouseOver%2A>属性值已从`true`更改为`false` 。  
  
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.MouseLeaveEvent>|  
|路由策略|直接|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddMouseMoveHandler, and RemoveMouseMoveHandler" Usage="see AddMouseMoveHandler, and RemoveMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在鼠标指针移动时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.MouseMoveEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   对应的隧道事件为<xref:System.Windows.Input.Mouse.PreviewMouseMove>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddMouseUpHandler, and RemoveMouseUpHandler" Usage="see AddMouseUpHandler, and RemoveMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当释放任何鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已释放的鼠标按钮通过检查事件的参数来确定。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 <xref:System.Windows.UIElement.MouseRightButtonUp> <xref:System.Windows.UIElement.MouseLeftButtonUp> <xref:System.Windows.UIElement> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]此框架通过将其作为两个不同的事件呈现在上, 在此附加事件上生成: 和。 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 这些实现处理基础<xref:System.Windows.Input.Mouse.MouseUp>事件并读取事件的参数, 以确定是否涉及鼠标左键或右键。 对于三按钮, 中间按钮没有框架级事件支持, 您应该使用<xref:System.Windows.Input.Mouse.MouseUp>事件并检查事件参数中的中间按钮条件。  
  
 对于与鼠标相关的路由事件, 请注意如何或何时将其标记为已处理。 对父元素是否还应告知父元素是否还应知道是否应该知道是否有任何给定鼠标操作的难点是[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , 这是因为框架选择了将<xref:System.Windows.Input.Mouse>基础路由事件作为[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]沿路由的所有事件。  
  
 隧道鼠标事件存在类似问题。  是否应该处理事件, 而不是由进一步流向源的子级处理, 以及如何影响组合项可能具有预期的鼠标行为的控件中的组合？  
  
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.MouseUpEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 对应的隧道事件为<xref:System.Windows.Input.Mouse.PreviewMouseUp>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddMouseWheelHandler, and RemoveMouseWheelHandler" Usage="see AddMouseWheelHandler, and RemoveMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在鼠标滚轮转动时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦点或鼠标捕获优先于鼠标指针所在的位置。  如果从焦点或捕获的元素接收此事件, 则鼠标指针实际上可能位于另一个元素上。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.MouseWheelEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   对应的隧道事件为<xref:System.Windows.Input.Mouse.PreviewMouseWheel>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelDeltaForOneLine">
      <MemberSignature Language="C#" Value="public const int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MouseWheelDeltaForOneLine = (120)" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberSignature Language="VB.NET" Value="Public Const MouseWheelDeltaForOneLine As Integer  = 120" />
      <MemberSignature Language="C++ CLI" Value="public: int MouseWheelDeltaForOneLine = 120;" />
      <MemberSignature Language="F#" Value="val mutable MouseWheelDeltaForOneLine : int" Usage="System.Windows.Input.Mouse.MouseWheelDeltaForOneLine" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>120</MemberValue>
      <Docs>
        <summary>代表鼠标滚轮要滚过一行而转动的单位数。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在当前[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]中, 此字段的值为120。 现场公开的目的是允许供应商在未来生成更精细的鼠标轮, 这可能包括无凹槽的自由旋转滚轮。 预期是这样一种设备会为每个轮换发送更多的消息, 但每条消息中的值越小。 若要支持这种可能性, 应添加传入的增量值, 直到<xref:System.Windows.Input.Mouse.MouseWheelDeltaForOneLine>达到所需的量 (以便获得相同的响应, 以便进行增量轮换), 或滚动部分行来响应更频繁的消息。 你还可以选择自己的滚动粒度并累积你自己选择的增量, 直到达到该增量, 或者可能引用用户控制的系统参数以实现鼠标敏感度并将这些参数外推到鼠标滚轮增量阈值。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseWheelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverrideCursor">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.Cursor OverrideCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.Cursor OverrideCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.OverrideCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OverrideCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::Cursor ^ OverrideCursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OverrideCursor : System.Windows.Input.Cursor with get, set" Usage="System.Windows.Input.Mouse.OverrideCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置整个应用程序的光标。</summary>
        <value>重写的光标，如果没有设置 <see cref="P:System.Windows.Input.Mouse.OverrideCursor" />，则为 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Input.Cursor> 设置为的将应用<xref:System.Windows.Input.Mouse.OverrideCursor%2A>于整个应用程序。  
  
 若要清除替代<xref:System.Windows.Input.Cursor>, 请<xref:System.Windows.Input.Mouse.OverrideCursor%2A>将`null`设置为。  
  
 设置<xref:System.Windows.Input.Mouse.OverrideCursor%2A> 为<xref:System.Windows.Input.Cursors.None%2A>将强制鼠标光标不显示, 但仍会处理鼠标事件。  
  
   
  
## Examples  
 下面的示例演示了用于在<xref:System.Windows.Controls.RadioButton>单个元素和整个应用程序之间切换游标更改范围的的事件处理程序。  如果引发`rbScopeElement`事件的控件为<xref:System.Windows.Controls.RadioButton>, 则将设置一个标志, 该标志指示游标更改的作用域, 并<xref:System.Windows.Input.Mouse.OverrideCursor%2A>将设置为`null`。  如果引发事件的`rbScopeApplication`控件为<xref:System.Windows.Controls.RadioButton>, 则将设置一个标志, 用于指示游标更改的作用域, <xref:System.Windows.FrameworkElement.Cursor%2A>并<xref:System.Windows.Input.Mouse.OverrideCursor%2A>将其设置为名`DisplayArea`为的<xref:System.Windows.Controls.Border>控件的属性。  
  
 [!code-csharp[cursors#CursorsSampleOverrideCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#cursorssampleoverridecursor)]
 [!code-vb[cursors#CursorsSampleOverrideCursor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#cursorssampleoverridecursor)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" Usage="see AddPreviewMouseDownHandler, and RemovePreviewMouseDownHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当按下任何鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通过检查事件的参数来确定按下的鼠标按钮。 这是一个附加事件 (使用隧道路由策略), 该事件通过附加事件语法供接受输入的现有[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]元素引用。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown> <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> <xref:System.Windows.UIElement> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]此框架通过将其作为两个不同的事件呈现在上, 在此附加事件上生成: 和。 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 这些实现处理基础<xref:System.Windows.Input.Mouse.PreviewMouseDown>事件并读取事件的参数, 以确定是否涉及鼠标左键或右键。 对于三按钮, 中间按钮没有框架级事件支持, 您应该使用<xref:System.Windows.Input.Mouse.PreviewMouseDown>事件并检查事件参数中的中间按钮条件。  
  
 对于与鼠标相关的路由事件, 请注意如何或何时将其标记为已处理。 处理根附近的事件, 并通过源进一步对源进行处理可能不适用于复合控件, 其中的组合项可能具有预期的鼠标行为。 对其他元素是否还应知道是否还应该知道是否还应知道是否有关于任何给定鼠标操作的相关选择[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , 这一<xref:System.Windows.Input.Mouse> 难题非常困难。[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]沿路由的事件。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.PreviewMouseDownEvent>|  
|路由策略|建立|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   对应的冒泡事件为<xref:System.Windows.Input.Mouse.MouseDown>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" Usage="see AddPreviewMouseDownOutsideCapturedElementHandler, and RemovePreviewMouseDownOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当在捕获鼠标事件的元素之外按下主鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 此事件不 resurfaced 在基元素上。 主要是为了控制在其控件组合中尝试协调鼠标捕获和鼠标输入的作者。  
  
<a name="routedEventInfo_PreviewMouseDownOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent>|  
|路由策略|建立|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" Usage="see AddPreviewMouseMoveHandler, and RemovePreviewMouseMoveHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在鼠标移过元素时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当鼠标指针在元素边界内最近移动时, 以及当鼠标指针移动到元素边界内并且仍在移动时, 将发生此事件。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.PreviewMouseMoveEvent>|  
|路由策略|建立|  
|委托|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   对应的冒泡事件为<xref:System.Windows.Input.Mouse.MouseMove>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" Usage="see AddPreviewMouseUpHandler, and RemovePreviewMouseUpHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当释放任何鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 已释放的鼠标按钮通过检查事件的参数来确定。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp> <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> <xref:System.Windows.UIElement> [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]此框架通过将其作为两个不同的事件呈现在上, 在此附加事件上生成: 和。 [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] 这些实现处理基础<xref:System.Windows.Input.Mouse.PreviewMouseUp>事件并读取事件的参数, 以确定是否涉及鼠标左键或右键。 对于三按钮, 中间按钮没有框架级事件支持, 您应该使用<xref:System.Windows.Input.Mouse.PreviewMouseUp>事件并检查事件参数中的中间按钮条件。  
  
 对于与鼠标相关的路由事件, 请注意如何或何时将其标记为已处理。 处理根附近的事件, 而不对源进行的处理可能不适用于组合控件, 其中的合成部分可能具有预期的鼠标行为。 对其他元素是否还应知道是否还应该知道是否还应知道是否有关于任何给定鼠标操作的相关选择[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] , 这一<xref:System.Windows.Input.Mouse> 难题非常困难。[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]沿路由的事件。  
  
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.PreviewMouseUpEvent>|  
|路由策略|建立|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   对应的冒泡事件为<xref:System.Windows.Input.Mouse.MouseUp>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElement">
      <MemberSignature Language="C#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" Usage="see AddPreviewMouseUpOutsideCapturedElementHandler, and RemovePreviewMouseUpOutsideCapturedElementHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当在捕获鼠标事件的元素之外释放主鼠标按钮时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
 此事件不 resurfaced 在基元素上。 主要是为了控制在其控件组合中尝试协调鼠标捕获和鼠标输入的作者。  
  
<a name="routedEventInfo_PreviewMouseUpOutsideCaptureElement"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent>|  
|路由策略|建立|  
|委托|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   没有相应的冒泡事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpOutsideCapturedElementEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpOutsideCapturedElementEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpOutsideCapturedElementEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpOutsideCapturedElementEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElementEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="ILAsm" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberSignature Language="F#" Value="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" Usage="see AddPreviewMouseWheelHandler, and RemovePreviewMouseWheelHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在鼠标滚轮转动时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 焦点或鼠标捕获优先于鼠标指针所在的位置;因此, 如果从焦点或捕获的元素接收此事件, 则鼠标指针实际上可能位于另一个元素上。  
  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.PreviewMouseWheelEvent>|  
|路由策略|建立|  
|委托|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   对应的冒泡事件为<xref:System.Windows.Input.Mouse.MouseWheel>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrimaryDevice">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseDevice PrimaryDevice { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Input.MouseDevice PrimaryDevice" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PrimaryDevice As MouseDevice" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseDevice ^ PrimaryDevice { System::Windows::Input::MouseDevice ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PrimaryDevice : System.Windows.Input.MouseDevice" Usage="System.Windows.Input.Mouse.PrimaryDevice" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseDevice</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取主鼠标设备。</summary>
        <value>设备。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性支持 Windows Presentation Foundation 基础结构, 不应在代码中直接使用。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="ILAsm" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Input.Mouse.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberSignature Language="F#" Value="see AddQueryCursorHandler, and RemoveQueryCursorHandler" Usage="see AddQueryCursorHandler, and RemoveQueryCursorHandler" />
      <MemberType>AttachedEvent</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>当元素查询当前鼠标光标时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是一个附加事件。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]将附加事件作为路由事件实现。 附加事件本质上是[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]一种用于引用事件的语言概念, 这些事件可在未定义该事件的对象[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]上进行处理, 后者通过同时启用事件来遍历路由。 附加事件在代码中没有直接处理语法;若要在代码中附加路由事件的处理程序, 请使用指定的 Add * 处理程序方法。 有关详细信息, 请参阅[附加事件概述](~/docs/framework/wpf/advanced/attached-events-overview.md)。  
  
<a name="routedEventInfo_Querycursor"></a>   
## <a name="routed-event-information"></a>路由事件信息  
  
|||  
|-|-|  
|标识符字段|<xref:System.Windows.Input.Mouse.QueryCursorEvent>|  
|路由策略|冒泡|  
|委托|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
 未定义相应的隧道事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.Input.Mouse.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>标识 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在注册路由事件时创建路由事件标识符, 并将结果存储为注册路由事件的类中的字段。 这些标识符包含标识名称、所有者类型、处理程序类型、路由策略和用于为事件添加所有者的实用工具方法。 通常使用这些标识符作为事件系统方法的参数来标识特定路由事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGotMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveGotMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveGotMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveGotMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveGotMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveGotMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveGotMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveLostMouseCaptureHandler">
      <MemberSignature Language="C#" Value="public static void RemoveLostMouseCaptureHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveLostMouseCaptureHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveLostMouseCaptureHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveLostMouseCaptureHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveLostMouseCaptureHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveLostMouseCaptureHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.MouseDown" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseEnterHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseEnterHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseEnterHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseEnterHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseEnterHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseEnterHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseEnterHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseEnterHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseLeaveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseLeaveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseLeaveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseLeaveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseLeaveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseLeaveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseLeaveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseLeaveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.MouseMove" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.MouseUp" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemoveMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseDownOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseDownOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseDownOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseDownOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseDownOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseDownOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseDownOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseDownOutsideCapturedElement" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseMoveHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseMoveHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseMoveHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler(System.Windows.DependencyObject,System.Windows.Input.MouseEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseMoveHandler (element As DependencyObject, handler As MouseEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseMoveHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseMoveHandler : System.Windows.DependencyObject * System.Windows.Input.MouseEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseMoveHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseUpOutsideCapturedElementHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseUpOutsideCapturedElementHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseButtonEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseUpOutsideCapturedElementHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseButtonEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler(System.Windows.DependencyObject,System.Windows.Input.MouseButtonEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseUpOutsideCapturedElementHandler (element As DependencyObject, handler As MouseButtonEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseUpOutsideCapturedElementHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseButtonEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseUpOutsideCapturedElementHandler : System.Windows.DependencyObject * System.Windows.Input.MouseButtonEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseUpOutsideCapturedElementHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseButtonEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseUpOutsideCapturedElement" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovePreviewMouseWheelHandler">
      <MemberSignature Language="C#" Value="public static void RemovePreviewMouseWheelHandler (System.Windows.DependencyObject element, System.Windows.Input.MouseWheelEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemovePreviewMouseWheelHandler(class System.Windows.DependencyObject element, class System.Windows.Input.MouseWheelEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler(System.Windows.DependencyObject,System.Windows.Input.MouseWheelEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemovePreviewMouseWheelHandler (element As DependencyObject, handler As MouseWheelEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemovePreviewMouseWheelHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::MouseWheelEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemovePreviewMouseWheelHandler : System.Windows.DependencyObject * System.Windows.Input.MouseWheelEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemovePreviewMouseWheelHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.MouseWheelEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>删除 <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveQueryCursorHandler">
      <MemberSignature Language="C#" Value="public static void RemoveQueryCursorHandler (System.Windows.DependencyObject element, System.Windows.Input.QueryCursorEventHandler handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveQueryCursorHandler(class System.Windows.DependencyObject element, class System.Windows.Input.QueryCursorEventHandler handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.RemoveQueryCursorHandler(System.Windows.DependencyObject,System.Windows.Input.QueryCursorEventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveQueryCursorHandler (element As DependencyObject, handler As QueryCursorEventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveQueryCursorHandler(System::Windows::DependencyObject ^ element, System::Windows::Input::QueryCursorEventHandler ^ handler);" />
      <MemberSignature Language="F#" Value="static member RemoveQueryCursorHandler : System.Windows.DependencyObject * System.Windows.Input.QueryCursorEventHandler -&gt; unit" Usage="System.Windows.Input.Mouse.RemoveQueryCursorHandler (element, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="handler" Type="System.Windows.Input.QueryCursorEventHandler" />
      </Parameters>
      <Docs>
        <param name="element">侦听此事件的 <see cref="T:System.Windows.UIElement" /> 或 <see cref="T:System.Windows.ContentElement" />。</param>
        <param name="handler">事件处理程序。</param>
        <summary>移除 <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> 附加事件的处理程序。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RightButton">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState RightButton { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState RightButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.RightButton" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RightButton As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState RightButton { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.RightButton : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.RightButton" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取鼠标右键的状态。</summary>
        <value>鼠标右键的状态。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何通过检查的<xref:System.Windows.Input.Mouse.RightButton%2A>状态是否等于<xref:System.Windows.Input.MouseButtonState>枚举值<xref:System.Windows.Input.MouseButtonState.Pressed>来确定是否按下了鼠标右键。  如果按下该按钮, 将调用一个方法, 该方法将更新示例中的显示元素。  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetrightbuttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetRightButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetrightbuttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="SetCursor">
      <MemberSignature Language="C#" Value="public static bool SetCursor (System.Windows.Input.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetCursor(class System.Windows.Input.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.SetCursor(System.Windows.Input.Cursor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetCursor(System::Windows::Input::Cursor ^ cursor);" />
      <MemberSignature Language="F#" Value="static member SetCursor : System.Windows.Input.Cursor -&gt; bool" Usage="System.Windows.Input.Mouse.SetCursor cursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cursor" Type="System.Windows.Input.Cursor" />
      </Parameters>
      <Docs>
        <param name="cursor">要将鼠标指针设置为的光标。</param>
        <summary>将鼠标指针设置到指定的 <see cref="T:System.Windows.Input.Cursor" />。</summary>
        <returns>如果设置了光标，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 正在设置的游标不适用于任何特定的元素, 而是应用于整个应用程序。  因此, 如果在设置光标后将鼠标指针移动到设置光标的对象上, 则将再次更改光标。  
  
 若要强制鼠标指针指向特定<xref:System.Windows.Input.Cursor>的并对<xref:System.Windows.Input.Mouse.OverrideCursor%2A>所有元素<xref:System.Windows.Input.Cursor>强制执行此设置, 请设置属性。  
  
 若要在特定元素上设置光标, 请<xref:System.Windows.FrameworkElement.Cursor%2A> <xref:System.Windows.FrameworkElement>在或<xref:System.Windows.FrameworkContentElement>上使用属性。  有关基元素的详细信息, 请参阅[基元素概述](~/docs/framework/wpf/advanced/base-elements-overview.md)。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursors" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="Synchronize">
      <MemberSignature Language="C#" Value="public static void Synchronize ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Synchronize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.Synchronize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Synchronize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Synchronize();" />
      <MemberSignature Language="F#" Value="static member Synchronize : unit -&gt; unit" Usage="System.Windows.Input.Mouse.Synchronize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>强制同步鼠标重新。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Input.MouseDevice" />
        <altmember cref="M:System.Windows.Input.Mouse.Synchronize" />
      </Docs>
    </Member>
    <Member MemberName="UpdateCursor">
      <MemberSignature Language="C#" Value="public static void UpdateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UpdateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Input.Mouse.UpdateCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UpdateCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UpdateCursor();" />
      <MemberSignature Language="F#" Value="static member UpdateCursor : unit -&gt; unit" Usage="System.Windows.Input.Mouse.UpdateCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>强制更新鼠标光标。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="XButton1">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton1 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton1" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton1" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton1 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton1 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton1 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取第一个扩展按钮的状态。</summary>
        <value>第一个鼠标扩展按钮的状态。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何通过检查的状态<xref:System.Windows.Input.Mouse.XButton1%2A>是否等于<xref:System.Windows.Input.MouseButtonState>枚举值<xref:System.Windows.Input.MouseButtonState.Pressed>来确定是否按下了第一个鼠标扩展按钮。  如果按下该按钮, 将调用一个方法, 该方法将更新示例中的显示元素。  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx1buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX1ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx1buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="XButton2">
      <MemberSignature Language="C#" Value="public static System.Windows.Input.MouseButtonState XButton2 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Input.MouseButtonState XButton2" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Input.Mouse.XButton2" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property XButton2 As MouseButtonState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Input::MouseButtonState XButton2 { System::Windows::Input::MouseButtonState get(); };" />
      <MemberSignature Language="F#" Value="member this.XButton2 : System.Windows.Input.MouseButtonState" Usage="System.Windows.Input.Mouse.XButton2" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取第二个扩展按钮的当前状态。</summary>
        <value>第二个鼠标扩展按钮的状态。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例演示如何通过检查的状态<xref:System.Windows.Input.Mouse.XButton2%2A>是否等于<xref:System.Windows.Input.MouseButtonState>枚举值<xref:System.Windows.Input.MouseButtonState.Pressed>来确定是否按下了第二个鼠标扩展按钮。  如果按下该按钮, 将调用一个方法, 该方法将更新示例中的显示元素。  
  
 [!code-csharp[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetx2buttonmouse)]
 [!code-vb[MouseRelatedSnippets#MouseRelatedSnippetsGetX2ButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetx2buttonmouse)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.MouseButtonEventArgs" />
      </Docs>
    </Member>
  </Members>
</Type>