<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a9f9c0589c228e3c4dfc0dcc9de08488d92bee1b" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69231940" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为将作为服务应用程序的一部分而存在的服务提供基类。 在创建新的服务类时，必须从 <see cref="T:System.ServiceProcess.ServiceBase" /> 派生。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当在<xref:System.ServiceProcess.ServiceBase>服务应用程序中定义服务类时, 派生自。 任何有用的服务都<xref:System.ServiceProcess.ServiceBase.OnStart%2A>将<xref:System.ServiceProcess.ServiceBase.OnStop%2A>重写和方法。 对于其他功能, 可以重写<xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> , 以响应服务状态的更改。  
  
 服务是长时间运行的可执行文件, 它不支持用户界面, 而且可能不会在登录用户帐户下运行。 此服务可以在没有任何用户登录到计算机的情况下运行。  
  
 默认情况下, 服务在系统帐户下运行, 该帐户不是管理员帐户。 不能更改系统帐户的权限。 或者, 你可以使用<xref:System.ServiceProcess.ServiceProcessInstaller>来指定将在其下运行服务的用户帐户。  
  
 可执行文件可以包含多个服务, 但每个服务<xref:System.ServiceProcess.ServiceInstaller>必须包含单独的服务。 <xref:System.ServiceProcess.ServiceInstaller>实例向系统注册该服务。 安装程序还将每个服务与可用于记录服务命令的事件日志相关联。 可`main()`执行文件中的函数定义应运行哪些服务。 服务的当前工作目录是系统目录, 而不是可执行文件所在的目录。  
  
 启动服务时, 系统将查找可执行文件, 并运行<xref:System.ServiceProcess.ServiceBase.OnStart%2A>该服务的方法, 该方法包含在可执行文件中。 但是, 运行该服务与运行可执行文件不同。 可执行文件只会加载服务。 服务可通过服务控制管理器进行访问 (例如, 已启动和停止)。  
  
 第一次在<xref:System.ServiceProcess.ServiceBase>服务上调用时, 可执行文件调用派生类的构造函数。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>命令处理方法将在构造函数执行后立即调用。 在第一次加载服务后, 不会再次执行构造函数, 因此, 需要将由构造函数执行的处理与执行<xref:System.ServiceProcess.ServiceBase.OnStart%2A>的过程分离。 应在中<xref:System.ServiceProcess.ServiceBase.OnStop%2A> <xref:System.ServiceProcess.ServiceBase.OnStart%2A>创建可以由释放的任何资源。 如果在释放资源后<xref:System.ServiceProcess.ServiceBase.OnStop%2A>再次启动了服务, 则在构造函数中创建资源可防止正确创建这些资源。  
  
 服务控制管理器 (SCM) 提供了一种与服务交互的方式。 可以使用 SCM 将开始、停止、暂停、继续或自定义命令传递到服务中。 SCM 使用<xref:System.ServiceProcess.ServiceBase.CanStop%2A>和<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>的值来确定服务是否接受 "停止"、"暂停" 或 "继续" 命令。 仅当相应的属性<xref:System.ServiceProcess.ServiceBase.CanStop%2A> `true`或<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>在服务类中时, 才会在 SCM 的上下文菜单中启用 "停止"、"暂停" 和 "继续"。 如果启用, 则会将命令传递到服务, 并<xref:System.ServiceProcess.ServiceBase.OnStop%2A>调用<xref:System.ServiceProcess.ServiceBase.OnPause%2A>、或<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> 。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>、 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>或为,`false`则不会处理相应的命令处理方法 ( <xref:System.ServiceProcess.ServiceBase.OnStop%2A>如), 即使您已实现了方法也是如此。 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>  
  
 可以使用<xref:System.ServiceProcess.ServiceController>类以编程方式使用用户界面执行 SCM 操作。 可以自动执行控制台中提供的任务。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A>、 <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>或为,`true`但尚未实现相应的命令处理方法 (如<xref:System.ServiceProcess.ServiceBase.OnStop%2A>), 则系统将引发异常并忽略命令。 <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>  
  
 无需在中<xref:System.ServiceProcess.ServiceBase.OnStart%2A> <xref:System.ServiceProcess.ServiceBase>实现、 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>或任何其他方法。 但是, 此服务的行为在中<xref:System.ServiceProcess.ServiceBase.OnStart%2A>进行了描述, 因此至少应重写此成员。 可`main()`执行文件的函数通过<xref:System.ServiceProcess.ServiceBase.Run%2A>调用方法, 将可执行文件中的服务注册到服务控制管理器。 传递给<xref:System.ServiceProcess.ServiceBase.ServiceName%2A> <xref:System.ServiceProcess.ServiceBase> <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A>方法的对象的属性必须<xref:System.ServiceProcess.ServiceBase.Run%2A>与该服务的服务安装程序的属性相匹配。  
  
 您可以使用`InstallUtil.exe`在您的系统上安装服务。  
  
> [!NOTE]
>  您可以指定除应用程序事件日志以外的日志来接收服务调用的通知, 但<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> <xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性和属性都不能写入自定义日志。 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>你`false`不希望使用自动日志记录, 则设置为。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>创建 <see cref="T:System.ServiceProcess.ServiceBase" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 请勿创建<xref:System.ServiceProcess.ServiceBase>类的实例。 相反, 派生自<xref:System.ServiceProcess.ServiceBase>并实例化派生类。 在从<xref:System.ServiceProcess.ServiceBase>继承的类的构造函数中实现所需的最小值是在<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>组件上设置。 构造函数中不特别需要其他处理。 你应在中<xref:System.ServiceProcess.ServiceBase.OnStart%2A>处理大多数初始化, 而不是在构造函数中。 否则, 在服务停止后重新启动该服务时, 对象将重新初始化。  
  
 如果重写派生类中的构造函数, 请在代码中调用基类构造函数。  
  
 构造函数将<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>设置`true`为。 <xref:System.ServiceProcess.ServiceBase> 如果你不希望从服务控制管理器 (SCM) 自动记录对服务的调用, 请将设置<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>为`false`。  
  
 如果可执行文件包含单个服务, 则在从 SCM 中选择 "启动" 时, 系统会调用服务的构造函数, 如果调用了 Stop, 则会运行析构函数。  
  
 如果可执行文件包含多个服务, 则对一个服务调用 "启动" 将导致为可执行文件中的所有服务调用构造函数, 但只启动指定的服务。 所有服务都已停止时, 服务的析构函数会一起运行, 而不会在每个服务停止时单独运行。  
  
> [!NOTE]
>  如果重写基类构造函数, 则应在派生类的构造函数中显式调用它。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指示是否在事件日志中报告“开始”、“停止”、“暂停”以及“继续”命令。</summary>
        <value>为 <see langword="true" /> 时在事件日志中报告信息；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 设置<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 以`true`指示服务使用应用程序事件日志报告命令失败, 并指示服务上的 "启动"、"停止"、"暂停" 和 "继续" 事件的状态更改信息。 服务的名称将用作日志的<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>名称。  
  
 若要将信息报告给自定义事件日志而不是应用程序<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>日志`false` , 请将设置为, 并在命令<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>处理<xref:System.ServiceProcess.ServiceBase.OnPause%2A>方法、 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>或中写入说明, 以发布到适当的日志。  
  
> [!NOTE]
>  在<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>服务尝试写入事件日志之前, 必须设置用于提供事件日志的源字符串的。 尝试在设置源名称之前访问事件日志会引发异常。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务是否可以处理计算机电源状态更改通知。</summary>
        <value>如果服务处理 <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> 类中指示的计算机电源状态更改，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当计算机电源状态更改时, 服务控制管理器 (SCM) 使用的<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>值验证服务是否接受电源事件命令。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>为`true`, 则将该命令传递到服务, 并在定义时调用方法。 如果<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>未在派生类中实现, 则 SCM 通过空<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType>基类方法处理电源事件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此属性将在服务启动后被修改。</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务是否可以处理从终端服务器会话接收到的会话更改事件。</summary>
        <value>如果服务可以处理终端服务器会话更改事件，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">此属性将在服务启动后被修改。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示服务是否可以暂停并再继续的值。</summary>
        <value>如果服务可以暂停，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在服务的构造函数<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>中设置属性的值。  
  
 服务暂停时, 它会暂停正在进行的操作。 当你通过服务控制管理器或以编程方式继续服务时, <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>将运行。  
  
 向服务发送暂停请求可以节省系统资源。 暂停可能不会释放所有系统资源, 而是停止。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>通常用于执行比<xref:System.ServiceProcess.ServiceBase.OnStop%2A>和<xref:System.ServiceProcess.ServiceBase.OnStart%2A>更少的处理。  
  
 当<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>为`true`时, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>重<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>写并指定在服务控制管理器 (SCM) 向服务传递暂停或继续请求时应发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>应实现以撤消中<xref:System.ServiceProcess.ServiceBase.OnPause%2A>的处理。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>为`false`, 则 SCM 将不会向服务传递暂停或继续请求, 因此, 不会调用和方法, 即使它们是实现的。 在`Pause` SCM 中, 在为`Continue` <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> `false`时禁用和控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> 属性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示系统关闭时是否应通知服务。</summary>
        <value>如果系统关闭时应通知服务，则为 <see langword="true" />；否则为 <see langword="false" />。  默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> 为`true`, 则在系统关闭时通知服务。 关机时, 如果<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>已在派生类中实现, 则调用方法。  
  
> [!NOTE]
>  只有系统会导致<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>执行方法; 服务可以调用该方法, 但这不是建议的方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> 属性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值指示服务启动后是否可以停止。</summary>
        <value>如果服务可以停止并调用了 <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> 方法，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当对服务调用 "停止" 时, 服务控制管理器 (SCM) 使用的<xref:System.ServiceProcess.ServiceBase.CanStop%2A>值验证服务是否接受停止命令。 对于大多数服务, 的值<xref:System.ServiceProcess.ServiceBase.CanStop%2A>为`true`, 但某些操作系统服务不允许用户将其停止。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A> <xref:System.ServiceProcess.ServiceBase.OnStop%2A>为`true`, 则将停止命令传递给服务, 如果定义了方法, 则调用方法。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>未在派生类中实现, 则 SCM 通过空<xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType>基类方法处理 Stop 命令。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> 属性。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示释放托管资源和非托管资源；<see langword="false" /> 表示仅释放非托管资源。</param>
        <summary>处置由 <see cref="T:System.ServiceProcess.ServiceBase" /> 占用的资源（内存除外）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.ServiceProcess.ServiceBase.Dispose%2A>派生类完成后, 在派生类中调用, <xref:System.ServiceProcess.ServiceBase>在派生类中调用, 并在类中调用。 <xref:System.ServiceProcess.ServiceBase.Dispose%2A>方法使派生类处于不可用状态。 调用<xref:System.ServiceProcess.ServiceBase.Dispose%2A>之后, 必须释放对派生<xref:System.ServiceProcess.ServiceBase>类的所有引用, 以便垃圾回收可以回收它们占用的内存。  
  
> [!NOTE]
>  在您<xref:System.ServiceProcess.ServiceBase.Dispose%2A>释放对派生自<xref:System.ServiceProcess.ServiceBase>的类的最后一个引用之前, 始终调用。 否则, 在垃圾<xref:System.ServiceProcess.ServiceBase>回收调用对象的析构函数之前, 将不会释放资源和派生类。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>通常实现来处理中<xref:System.ServiceProcess.ServiceBase.OnPause%2A>的代码, 并结合对的<xref:System.ServiceProcess.ServiceBase.Dispose%2A>调用。 如果在派生类中选择执行此操作, 则可通过实现<xref:System.ServiceProcess.ServiceBase.OnStart%2A>来分配任何<xref:System.ServiceProcess.ServiceBase.Dispose%2A>已释放的。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个事件日志，它可用于将服务命令调用的通知（如“开始”和“停止”）写入“应用程序”事件日志。</summary>
        <value><see cref="T:System.Diagnostics.EventLog" /> 实例，它的源注册到 Application 日志中。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数将<xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性初始化为<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>具有和<xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType>属性集的实例。 源是<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>服务的, 日志是计算机的应用程序日志。 这些值是自动设置的, 不能更改以自动记录服务命令。  
  
 当<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 为`true`时, 会自动在应用程序事件日志中记录 "启动"、"停止"、"暂停"、"继续" 和自定义命令。 还可以使用<xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性将其他消息写入该日志。 组件使用此<xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> <xref:System.ServiceProcess.ServiceBase.EventLog%2A>成员进行调用。  
  
 若要将信息报告给自定义事件日志而不是应用程序<xref:System.ServiceProcess.ServiceBase.AutoLog%2A>日志`false` , 请将设置为, 并在命令<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>处理<xref:System.ServiceProcess.ServiceBase.OnPause%2A>方法、 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>或中写入说明, 以发布到适当的日志。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置服务的退出代码。</summary>
        <value>服务的退出代码。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将该<xref:System.ServiceProcess.ServiceBase.ExitCode%2A>属性设置为一个非零值, 然后停止该服务以向服务控制管理器指示错误。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>指示服务名称的最大大小。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName 和 DisplayName 都具有大小限制, 在设置服务类的属性时必须遵循这些限制。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，<see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> 于“服务控制管理器”(SCM) 将“继续”命令发送到服务时运行。 指定要在服务暂停后恢复正常功能时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 实现<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> , 以便将应用程序的响应<xref:System.ServiceProcess.ServiceBase.OnPause%2A>镜像到。 当你通过服务控制台或以编程方式继续服务时, 处理将<xref:System.ServiceProcess.ServiceBase.OnContinue%2A>运行, 并且服务将再次变为活动状态。  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>当<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>属性为`true`时, 应重写。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>为`false`, 则 SCM 将不会向服务传递暂停或继续请求, 因此, 不会调用和方法, 即使它们是实现的。 在`Pause` SCM 中, 在为`Continue` <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> `false`时禁用和控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">发送给服务的命令消息。</param>
        <summary>在派生类中实现时，<see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> 于“服务控制管理器”(SCM) 向服务传递自定义命令时执行。 指定要在具有指定参数值的命令出现时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A>允许你指定除启动、停止、暂停和继续服务以外的其他功能。  
  
 SCM 不检查自定义命令来验证服务是否支持传入的`command`参数。 它将自定义命令直接传递给服务。 如果服务不能识别`command`参数, 则不会执行任何操作。  
  
 自定义命令由<xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> <xref:System.ServiceProcess.ServiceController>组件中的语句引发。 使用 switch 语句或 if .。。用于处理在服务上定义的自定义命令的条件。  
  
 可在应用程序中定义或在中<xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A>使用的自定义命令的唯一值是128和255之间的值。 低于128的整数对应于系统保留值。  
  
 如果属性为`true`, 则自定义命令 (如所有其他命令) 将条目写入事件日志, 以报告方法执行是成功还是失败。 <xref:System.ServiceProcess.ServiceBase.AutoLog%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，该方法于“服务控制管理器”(SCM) 将“暂停”命令发送到服务时执行。 指定要在服务暂停时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于<xref:System.ServiceProcess.ServiceBase.OnPause%2A>指定在服务接收暂停命令时发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>当<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A>属性为`true`时, 应重写。  
  
 当你通过服务控制台或以编程方式继续暂停的服务时, <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>将运行处理, 并且该服务将再次变为活动状态。  
  
 Pause 命令仅允许应用程序响应特定事件。 <xref:System.ServiceProcess.ServiceBase.OnPause%2A>对未定义的服务执行任何操作。  
  
 向服务发送暂停请求可能会保留系统资源, 因为暂停无需释放所有系统资源。 例如, 如果线程已由进程打开, 则暂停服务而不是停止它可以使线程保持打开状态, 避免在服务继续时需要重新分配它们。 如果将 Pause 定义为释放所有系统资源, 它的行为类似于停止命令。  
  
 设置<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnPause%2A>为`true`, 并重写和<xref:System.ServiceProcess.ServiceBase.OnContinue%2A> , 以指定当 SCM 向服务传递暂停或继续请求时应发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>应实现以撤消中<xref:System.ServiceProcess.ServiceBase.OnPause%2A>的处理。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>为`false`, 则 SCM 将不会向服务传递暂停或继续请求, 因此, 即使实现了, 也不会调用和方法。 在`Pause` SCM 中, 在为`Continue` <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> `false`时禁用和控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus"><see cref="T:System.ServiceProcess.PowerBroadcastStatus" />，指示来自系统的有关电源状态的通知。</param>
        <summary>当在派生类中实现时，该方法于计算机电源状态更改时执行。 这适用于膝上型计算机进入挂起模式时的情况，该模式不同于系统关闭。</summary>
        <returns>当在派生类中实现时，应用程序的需要将确定要返回的值。 例如，如果传递了 <see langword="QuerySuspend" /> 广播状态，则可以通过返回 <see langword="false" /> 来使应用程序拒绝查询。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于<xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>指定在<xref:System.ServiceProcess.PowerBroadcastStatus>枚举中指示的系统事件发生时所发生的处理过程, 例如, 当计算机处于挂起模式或指示电池电量不足时。  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A>当<xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>属性为`true`时, 应重写。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="changeDescription">标识更改类型的结构。</param>
        <summary>从终端服务器会话接收到更改事件时执行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将<xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A>属性设置为`true`以启用此方法的执行。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，该方法于系统即将关闭时执行。 该方法指定应在系统即将关闭前执行的处理。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于<xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>指定系统关闭时进行的处理。  
  
 此事件仅在操作系统关闭时出现, 而不在计算机关闭时发生。  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A>当<xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>属性为`true`时, 应重写。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">启动命令传递的数据。</param>
        <summary>当在派生类中实现时，在下列情况下执行：在“服务控制管理器”(SCM) 向服务发送“开始”命令时，或者在操作系统启动时（对于自动启动的服务）。 指定服务启动时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于<xref:System.ServiceProcess.ServiceBase.OnStart%2A>指定在服务接收开始命令时发生的处理。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>用于指定服务的行为的方法。 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>可以采用自变量作为传递数据的一种方法, 但这种用法非常罕见。  
  
> [!CAUTION]
>  不要使用构造函数来执行应该在中<xref:System.ServiceProcess.ServiceBase.OnStart%2A>的处理。 使用<xref:System.ServiceProcess.ServiceBase.OnStart%2A>处理服务的所有初始化。 此构造函数在应用程序的可执行文件运行时调用, 而不是在服务运行时调用。 可执行文件在<xref:System.ServiceProcess.ServiceBase.OnStart%2A>之前运行。 例如, 当继续操作时, 不会再次调用构造函数, 因为 SCM 已在内存中保存对象。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>释放在构造函数中分配的资源而<xref:System.ServiceProcess.ServiceBase.OnStart%2A>不是, 则在第二次调用服务时, 不会再次创建所需的资源。  
  
 在计算机重新启动时, 可以将服务设置为自动启动, <xref:System.ServiceProcess.ServiceInstaller.StartType%2A>方法是将该服务的<xref:System.ServiceProcess.ServiceStartMode.Automatic>安装程序上的设置为。 在这种情况下<xref:System.ServiceProcess.ServiceBase.OnStart%2A> , 将在系统启动时调用。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>应在派生类中重写。 若要使服务有用, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> <xref:System.ServiceProcess.ServiceBase.OnStop%2A>应在服务类中实现。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A>方法中的服务的处理初始化参数, 而不是在 Main 方法中。 可以在 "服务`args` " 控制台中服务的 "属性" 窗口中手动设置参数数组中的参数。 不保存在控制台中输入的参数;从 "控制面板" 启动该服务时, 它们将一次性传递到服务。 自动启动服务时必须存在的参数可放置在服务注册表项的 ImagePath 字符串值中 (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\*\<service name >*). 您可以使用<xref:System.Environment.GetCommandLineArgs%2A>方法从注册表获取参数, 例如: `string[] imagePathArgs = Environment.GetCommandLineArgs();`。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中实现时，该方法于“服务控制管理器”(SCM) 将“停止”命令发送到服务时执行。 指定服务停止运行时采取的操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用于<xref:System.ServiceProcess.ServiceBase.OnStop%2A>指定在服务接收到 Stop 命令时发生的处理。  
  
 当 SCM 收到停止命令时, 它将使用的<xref:System.ServiceProcess.ServiceBase.CanStop%2A>值来验证服务是否接受停止命令。 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A> <xref:System.ServiceProcess.ServiceBase.OnStop%2A>为`true`, 则将停止命令传递给服务, 并在定义方法时调用。 如果<xref:System.ServiceProcess.ServiceBase.OnStop%2A>在服务中未实现, 则 SCM 处理 Stop 命令。  
  
 如果<xref:System.ServiceProcess.ServiceBase.CanStop%2A> 为`false`, 则 SCM 忽略停止命令。 它不会传递给服务。 Stop 命令返回并引发异常。  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A>应在派生类中重写。 若要使服务有用, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> <xref:System.ServiceProcess.ServiceBase.OnStop%2A>应在服务类中实现。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="milliseconds">请求的时间（以毫秒为单位）。</param>
        <summary>为挂起操作请求额外的时间。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> <xref:System.ServiceProcess.ServiceBase.OnPause%2A> <xref:System.ServiceProcess.ServiceBase.OnStart%2A>方法旨在由重写的、、或<xref:System.ServiceProcess.ServiceBase.OnStop%2A>方法调用, 以请求挂起操作的额外时间, 以防止服务控制管理器 (SCM) 标记<xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A>服务不响应。  如果挂起操作不是 "继续"、"暂停"、"启动" 或<xref:System.InvalidOperationException> "停止", 则会引发。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务不处于挂起状态。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>为服务可执行文件提供主入口点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service"><see cref="T:System.ServiceProcess.ServiceBase" />，指示要启动的服务。</param>
        <summary>在服务控制管理器 (SCM) 中注册服务的可执行文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在服务可执行文件`main()`的函数中调用此重载, 以向服务控制管理器注册该服务。 调用<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>后, 服务控制管理器将发出一个启动命令, 该命令将导致调用服务中<xref:System.ServiceProcess.ServiceBase.OnStart%2A>的方法。 在执行开始命令之前, 不会启动该服务。  
  
 调用方法的方式与 Windows 窗体应用程序的方式<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>几乎相同。 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> `service`为`true`, 则如果参数指定的服务无法启动, 则会将一个项写入事件日志。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">一组 ServiceBase 实例，指示要启动的服务。</param>
        <summary>在服务控制管理器 (SCM) 中注册多项服务的可执行文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在服务可执行文件`main()`的函数中调用此重载, 将服务注册到服务控制管理器。 调用<xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>后, 服务控制管理器会发出启动命令, 从而导致对服务中的<xref:System.ServiceProcess.ServiceBase.OnStart%2A>方法的调用。 在执行开始命令之前, 服务不会启动。  
  
 调用方法的方式与 Windows 窗体应用程序的<xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType>方法大致相同。 <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType>  
  
 如果<xref:System.ServiceProcess.ServiceBase.AutoLog%2A> 为`true`, 则当数组中的任何服务启动失败时, 会向事件日志写入一项。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">未提供要启动的服务。 该数组可能为 <see langword="null" /> 或空。</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取服务的服务控制句柄。</summary>
        <value>一个 <see cref="T:System.IntPtr" /> 结构，包含服务的服务控制句柄。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 服务控制句柄用于与服务控制管理器 (SCM) 进行通信。  该句柄可用于使用非托管`SetServiceStatus`函数为调用服务更新服务控制管理器的状态信息。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问非托管代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="argPointer" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="argCount">参数数组中的参数个数。</param>
        <param name="argPointer">指向参数数组的 <see cref="T:System.IntPtr" /> 结构。</param>
        <summary>注册命令处理程序并启动服务。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于向系统标识服务的简短名称。</summary>
        <value>服务的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 向服务控制管理器标识服务。<xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 此属性的值必须与在相应的安装程序类的<xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType>属性中为服务记录的名称相同。 在代码中, <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>服务的通常`main()`在可执行文件的函数中设置。  
  
 还可用于指定与<xref:System.ServiceProcess.ServiceBase.EventLog%2A>属性关联<xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>的。 <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> 这<xref:System.ServiceProcess.ServiceBase.EventLog%2A>是将服务命令信息写入应用程序日志的实例。  
  
 在<xref:System.ServiceProcess.ServiceBase.ServiceName%2A>服务写入事件日志之前, 必须设置用于提供事件日志的源字符串的。 尝试在设置源名称之前访问事件日志会导致引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">服务已启动。 在服务启动后不能更改 <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> 属性。</exception>
        <exception cref="T:System.ArgumentException">指定的名称为零长度字符串，或长于 <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" />，就或者指定的名称包含前斜线或后斜线字符。</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>停止执行服务。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法将服务状态设置为指示停止处于挂起状态, 并<xref:System.ServiceProcess.ServiceBase.OnStop%2A>调用方法。 <xref:System.ServiceProcess.ServiceBase.Stop%2A>  停止应用程序后, 服务状态将设置为 "已停止"。 如果应用程序是托管服务, 则卸载应用程序域。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>
