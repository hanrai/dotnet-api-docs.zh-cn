<Type Name="RemotingConfiguration" FullName="System.Runtime.Remoting.RemotingConfiguration">
  <Metadata><Meta Name="ms.openlocfilehash" Value="515e332eee9448da12aa414da1fff1055bdfc41d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69060908" /></Metadata><TypeSignature Language="C#" Value="public static class RemotingConfiguration" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RemotingConfiguration extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Remoting.RemotingConfiguration" />
  <TypeSignature Language="VB.NET" Value="Public Class RemotingConfiguration" />
  <TypeSignature Language="C++ CLI" Value="public ref class RemotingConfiguration abstract sealed" />
  <TypeSignature Language="F#" Value="type RemotingConfiguration = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供多种配置远程处理结构的静态方法。</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ApplicationId">
      <MemberSignature Language="C#" Value="public static string ApplicationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ApplicationId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前正在执行的应用程序的 ID。</summary>
        <value>一个 <see cref="T:System.String" />，包含当前正在执行的应用程序的 ID。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 应用程序 ID 预置于当前正在执行的应用程序所创建的对象的 URI。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">直接调用方没有基础结构权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于处理基础结构代码。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置远程处理应用程序的名称。</summary>
        <value>远程处理应用程序的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅可通过当前属性或通过配置文件设置应用程序名称一次。 如果应用程序在宿主环境中运行 (例如 Internet Information Services (IIS)), 则此值可能已设置 (通常为虚拟目录)。 如果尚未设置应用程序`null`名称, 则当前属性将返回。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Runtime.Remoting.RemotingConfiguration.ApplicationName%2A>属性来指示远程处理应用程序的名称。 有关完整的示例代码, 请参阅<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>和<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A>方法的示例。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
  
 下面的代码示例演示如何访问从命名应用程序进行远程处理的对象。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
 [!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。 仅在设置该属性值时才会引发此异常。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename);" />
      <MemberSignature Language="F#" Value="static member Configure : string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure filename" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use Configure(String,Boolean)")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Use System.Runtime.Remoting.RemotingConfiguration.Configure(string fileName, bool ensureSecurity) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">远程处理配置文件的名称。 可以为 <see langword="null" />。</param>
        <summary>读取配置文件并配置远程处理结构。 <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String)" /> 已过时。 请改用 <see cref="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%29> 已过时。 请改用 <xref:System.Runtime.Remoting.RemotingConfiguration.Configure%28System.String%2CSystem.Boolean%29>。  
  
 作为参数传递`null`将导致默认远程处理初始化,而不需要配置文件存在。`filename`  
  
 有关配置文件语法, 请参阅[远程处理设置架构](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。  
  
> [!NOTE]
>  引用封送对象 (Mbr) 不会永久驻留在内存中。 相反, 除非类型重写<xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType>来控制其自身的生存期策略, 否则, 每个 MBR 在 .NET Framework 远程处理系统开始删除它并回收内存之前, 将具有有限的生存期。 有关详细信息, 请参阅[生存期租约](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a)。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_Configure_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#1)]
 [!code-vb[RemotingConfiguration_Configure_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Configure">
      <MemberSignature Language="C#" Value="public static void Configure (string filename, bool ensureSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Configure(string filename, bool ensureSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.Configure(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Configure (filename As String, ensureSecurity As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Configure(System::String ^ filename, bool ensureSecurity);" />
      <MemberSignature Language="F#" Value="static member Configure : string * bool -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.Configure (filename, ensureSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ensureSecurity" Type="System.Boolean" Index="1" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="filename">远程处理配置文件的名称。 可以为 <see langword="null" />。</param>
        <param name="ensureSecurity">如果设置为 <see langword="true" />，则安全是必选项。 如果设置为 <see langword="false" />，则安全不是必选项，但仍可能会用到。</param>
        <summary>读取配置文件并配置远程处理结构。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 作为参数传递`null`将导致默认远程处理初始化,而不需要配置文件存在。`filename` 有关远程处理和安全性的详细信息, 请参阅[远程处理中的安全性。](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/9hwst9th(v=vs.100))  
  
 有关配置文件语法, 请参阅[远程处理设置架构](https://msdn.microsoft.com/library/dc2d1e62-9af7-4ca1-99fd-98b93bb4db9e)。  
  
> [!NOTE]
>  引用封送对象 (Mbr) 不会永久驻留在内存中。 相反, 除非类型重写<xref:System.MarshalByRefObject.InitializeLifetimeService%2A?displayProperty=nameWithType>来控制其自身的生存期策略, 否则, 每个 MBR 在 .NET Framework 远程处理系统开始删除它并回收内存之前, 将具有有限的生存期。 有关详细信息, 请参阅[生存期租约](https://msdn.microsoft.com/library/c72d561c-1266-4c8b-b258-2c168c08da9a)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsEnabled">
      <MemberSignature Language="C#" Value="public static bool CustomErrorsEnabled (bool isLocalRequest);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CustomErrorsEnabled(bool isLocalRequest) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CustomErrorsEnabled (isLocalRequest As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CustomErrorsEnabled(bool isLocalRequest);" />
      <MemberSignature Language="F#" Value="static member CustomErrorsEnabled : bool -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsEnabled isLocalRequest" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isLocalRequest" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isLocalRequest"><see langword="true" /> 用于指定本地调用方，<see langword="false" /> 用于指定远程调用方。</param>
        <summary>指示该应用程序域中的服务器信道是将筛选过的异常信息返回给本地调用方或远程调用方，还是将完整的异常信息返回给本地调用方或远程调用方。</summary>
        <returns>如果只将筛选过的异常信息返回给本地调用方或远程调用方（具体返回给哪些调用方由 <paramref name="isLocalRequest" /> 参数指定），则为 <see langword="true" />；如果返回完整的异常信息，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 完整的异常信息包括确切的服务器异常信息和服务器堆栈跟踪信息。 筛选后的信息包括标准的远程异常信息，但不包括服务器堆栈跟踪信息。  
  
 方法反映在应用程序配置文件的`<customErrors>`元素的属性中指定的配置设置。`mode` `CustomErrorsEnabled` 有关配置选项的详细信息, 请参阅[远程应用程序的配置](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/b8tysty8(v=vs.100))。  
  
 下表显示了三个服务器通道属性值, 这些值指定哪些调用方会收到异常信息以及接收到的信息类型。  
  
|值|说明|  
|-----------|-----------------|  
|`off`|所有调用方均接收完整的异常信息。|  
|`on`|所有调用方均接收筛选过的异常信息。|  
|`remoteOnly`|本地调用方接收完整的异常信息，而远程调用方则接收筛选过的异常信息。|  
  
 下表显示了`isLocalRequest`参数和服务器信道属性的交互。  
  
|值|isLocalRequest|返回值|说明|  
|-----------|--------------------|------------------|-----------------|  
|`on`|`true`|`true`|本地调用方接收筛选的异常信息。|  
|`on`|`false`|`true`|远程调用方接收筛选的异常信息。|  
|`off`|`true`|`false`|本地调用方接收完整的异常信息。|  
|`off`|`false`|`false`|远程调用方接收完整的异常信息。|  
|`remoteOnly`|`true`|`false`|本地调用方接收完整的异常信息。|  
|`remoteOnly`|`false`|`true`|远程调用方接收筛选的异常信息。|  
  
 有关使用应用程序配置文件来控制将异常信息返回给调用方的信息, 请`<customErrors>`参阅元素。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomErrorsMode">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Runtime.Remoting.CustomErrorsModes CustomErrorsMode" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CustomErrorsMode As CustomErrorsModes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::CustomErrorsModes CustomErrorsMode { System::Runtime::Remoting::CustomErrorsModes get(); void set(System::Runtime::Remoting::CustomErrorsModes value); };" />
      <MemberSignature Language="F#" Value="member this.CustomErrorsMode : System.Runtime.Remoting.CustomErrorsModes with get, set" Usage="System.Runtime.Remoting.RemotingConfiguration.CustomErrorsMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.CustomErrorsModes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置指示如何处理自定义错误的值。</summary>
        <value>一个 <see cref="T:System.Runtime.Remoting.CustomErrorsModes" /> 枚举的成员，指示如何处理自定义错误。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedClientTypes () As ActivatedClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedClientTypeEntry ^&gt; ^ GetRegisteredActivatedClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedClientTypes : unit -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索对象类型的数组，这些对象类型在客户端上注册为将被远程激活的类型。</summary>
        <returns>对象类型的数组，这些对象类型在客户端上注册为将被远程激活的类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关客户端激活的对象的详细说明, 请参阅[客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredActivatedServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredActivatedServiceTypes () As ActivatedServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::ActivatedServiceTypeEntry ^&gt; ^ GetRegisteredActivatedServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredActivatedServiceTypes : unit -&gt; System.Runtime.Remoting.ActivatedServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredActivatedServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索在服务端上注册的对象类型的数组，可以从客户端根据请求激活这些对象类型。</summary>
        <returns>在服务端上注册的对象类型的数组，可以从客户端根据请求激活这些对象类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关客户端激活的对象的详细说明, 请参阅[客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#2)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownClientTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownClientTypes () As WellKnownClientTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownClientTypeEntry ^&gt; ^ GetRegisteredWellKnownClientTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownClientTypes : unit -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownClientTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索对象类型的数组，这些对象类型在客户端上注册为已知类型。</summary>
        <returns>对象类型的数组，这些对象类型在客户端上注册为已知类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 众所周知的对象类型可以是单一调用, 也可以是 singleton。 如果对象类型是单一调用, 则每次传入来自客户端的调用时, 都将创建该对象的新实例。 对单一实例对象的所有调用都是由该对象的一个实例来处理的。  
  
 有关众所周知对象的更详细说明, 请参阅[服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CPP/remotingconfiguration_getregisteredwellknownclient_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/CS/remotingconfiguration_getregisteredwellknownclient_client.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredWellKnownClient_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredWellKnownClient_Client/VB/remotingconfiguration_getregisteredwellknownclient_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetRegisteredWellKnownServiceTypes">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetRegisteredWellKnownServiceTypes () As WellKnownServiceTypeEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Runtime::Remoting::WellKnownServiceTypeEntry ^&gt; ^ GetRegisteredWellKnownServiceTypes();" />
      <MemberSignature Language="F#" Value="static member GetRegisteredWellKnownServiceTypes : unit -&gt; System.Runtime.Remoting.WellKnownServiceTypeEntry[]" Usage="System.Runtime.Remoting.RemotingConfiguration.GetRegisteredWellKnownServiceTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownServiceTypeEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检索对象类型的数组，这些对象类型在服务端上注册为已知类型。</summary>
        <returns>对象类型的数组，这些对象类型在服务端上注册为已知类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 众所周知的对象类型可以是单一调用, 也可以是 singleton。 如果对象类型是单一调用, 则每次传入来自客户端的调用时, 都将创建该对象的新实例。 对单一实例对象的所有调用都是由该对象的一个实例来处理的。  
  
 有关众所周知对象的更详细说明, 请参阅[服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CPP/remotingconfiguration_configure_server.cpp#2)]
 [!code-csharp[RemotingConfiguration_Configure_Client#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/CS/remotingconfiguration_configure_server.cs#2)]
 [!code-vb[RemotingConfiguration_Configure_Client#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_Configure_Client/VB/remotingconfiguration_configure_server.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
        <altmember cref="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsActivationAllowed">
      <MemberSignature Language="C#" Value="public static bool IsActivationAllowed (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsActivationAllowed(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsActivationAllowed (svrType As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsActivationAllowed(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsActivationAllowed : Type -&gt; bool" Usage="System.Runtime.Remoting.RemotingConfiguration.IsActivationAllowed svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">要检查的对象 <see cref="T:System.Type" />。</param>
        <summary>返回一个布尔值，该值指示是否允许由客户端激活指定的 <see cref="T:System.Type" />。</summary>
        <returns>如果允许由客户端激活指定的 <see cref="T:System.Type" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在服务器端使用当前方法来确定服务器是否显式允许激活对象<xref:System.Type> 。  
  
   
  
## Examples  
 [!code-cpp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CPP/RemotingConfiguration_GetRegisteredActivatedService_server.cpp#1)]
 [!code-csharp[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/CS/remotingconfiguration_getregisteredactivatedservice_server.cs#1)]
 [!code-vb[RemotingConfiguration_GetRegisteredActivatedServer_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_GetRegisteredActivatedServer_Client/VB/remotingconfiguration_getregisteredactivatedservice_server.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsRemotelyActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检查指定的对象类型是否注册为远程激活的客户端类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (svrType As Type) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : Type -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">要检查的对象类型。</param>
        <summary>检查指定的对象 <see cref="T:System.Type" /> 是否注册为远程激活的客户端类型。</summary>
        <returns>与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/CS/remotingconfiguration_isremotelyactivatedclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType1_Client/VB/remotingconfiguration_isremotelyactivatedclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)">客户端激活</related>
      </Docs>
    </Member>
    <Member MemberName="IsRemotelyActivatedClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRemotelyActivatedClientType (typeName As String, assemblyName As String) As ActivatedClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ActivatedClientTypeEntry ^ IsRemotelyActivatedClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsRemotelyActivatedClientType : string * string -&gt; System.Runtime.Remoting.ActivatedClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsRemotelyActivatedClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ActivatedClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要检查的对象的类型名称。</param>
        <param name="assemblyName">要检查的对象的程序集名称。</param>
        <summary>检查由其类型名称和程序集名称指定的对象是否注册为远程激活的客户端类型。</summary>
        <returns>与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CPP/remotingconfiguration_isremotelyactivatedclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/CS/remotingconfiguration_isremotelyactivatedclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsRemotelyActivatedClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsRemotelyActivatedClientType2_Client/VB/remotingconfiguration_isremotelyactivatedclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100)">客户端激活</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检查指定的对象类型是否注册为已知客户端类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (Type svrType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(class System.Type svrType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (svrType As Type) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(Type ^ svrType);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : Type -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType svrType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="svrType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="svrType">要检查的对象 <see cref="T:System.Type" />。</param>
        <summary>检查指定的对象 <see cref="T:System.Type" /> 是否注册为已知客户端类型。</summary>
        <returns>与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CPP/remotingconfiguration_iswellknownclienttype1_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/CS/remotingconfiguration_iswellknownclienttype1_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType1_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType1_Client/VB/remotingconfiguration_iswellknownclienttype1_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)">服务器激活</related>
      </Docs>
    </Member>
    <Member MemberName="IsWellKnownClientType">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType (string typeName, string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsWellKnownClientType (typeName As String, assemblyName As String) As WellKnownClientTypeEntry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::WellKnownClientTypeEntry ^ IsWellKnownClientType(System::String ^ typeName, System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="static member IsWellKnownClientType : string * string -&gt; System.Runtime.Remoting.WellKnownClientTypeEntry" Usage="System.Runtime.Remoting.RemotingConfiguration.IsWellKnownClientType (typeName, assemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.WellKnownClientTypeEntry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">要检查的对象的类型名称。</param>
        <param name="assemblyName">要检查的对象的程序集名称。</param>
        <summary>检查由其类型名称和程序集名称指定的对象是否注册为已知客户端类型。</summary>
        <returns>与指定的对象类型对应的 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-cpp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CPP/remotingconfiguration_iswellknownclienttype2_client.cpp#1)]
 [!code-csharp[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/CS/remotingconfiguration_iswellknownclienttype2_client.cs#1)]
 [!code-vb[RemotingConfiguration_IsWellKnownClientType2_Client#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration_IsWellKnownClientType2_Client/VB/remotingconfiguration_iswellknownclienttype2_client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100)">服务器激活</related>
      </Docs>
    </Member>
    <Member MemberName="ProcessId">
      <MemberSignature Language="C#" Value="public static string ProcessId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProcessId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProcessId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessId : string" Usage="System.Runtime.Remoting.RemotingConfiguration.ProcessId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前正在执行的进程的 ID。</summary>
        <value>一个 <see cref="T:System.String" />，其中包含当前正在执行的进程的 ID。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">直接调用方没有基础结构权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于处理基础结构代码。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将客户端上的对象 <see cref="T:System.Type" /> 注册为可在服务器上激活的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (System.Runtime.Remoting.ActivatedClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Runtime.Remoting.ActivatedClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedClientType (entry As ActivatedClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(System::Runtime::Remoting::ActivatedClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : System.Runtime.Remoting.ActivatedClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">客户端激活类型的配置设置。</param>
        <summary>将在客户端提供的 <see cref="T:System.Type" /> 中记录的对象 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> 注册为可在服务器上激活的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在服务器上创建客户端激活的对象的实例, 必须知道其<xref:System.Type> , 并且必须<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>使用方法在服务器端上注册它。 若要获取客户端激活对象的新实例的代理, 客户端必须首先向注册通道<xref:System.Runtime.Remoting.Channels.ChannelServices> , 然后通过调用`new`来激活该对象。  
  
 若要使用`new`关键字激活客户端激活的对象类型, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>使用方法在客户端上注册对象类型。 调用方法可为远程处理基础结构提供`new`尝试创建远程应用程序的位置。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 另一方面, 如果使用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来创建客户端激活的对象的新实例, 则必须提供远程应用程序的 URL 作为参数, 因此, 在客户端上注册之前不需要。 若要为<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>该方法提供要在其中创建对象的服务器的 url, 则必须将该 url 封装在<xref:System.Runtime.Remoting.Activation.UrlAttribute>类的实例中。  
  
 有关客户端激活的对象的详细说明, 请参阅[客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedClientType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedClientType (Type type, string appUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedClientType(class System.Type type, string appUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedClientType(Type ^ type, System::String ^ appUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType (type, appUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="appUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">对象 <see cref="T:System.Type" />。</param>
        <param name="appUrl">在该处激活类型的应用程序的 URL。</param>
        <summary>通过使用给定的参数初始化 <see cref="T:System.Type" /> 类的新实例，将客户端上的对象 <see cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" /> 注册为可在服务器上激活的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在服务器上创建客户端激活的对象的实例, 必须知道其<xref:System.Type> , 并且必须<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>使用方法在服务器端上注册它。 若要获取客户端激活对象的新实例的代理, 客户端必须首先向注册通道<xref:System.Runtime.Remoting.Channels.ChannelServices> , 然后通过调用`new`来激活该对象。  
  
 若要使用`new`关键字激活客户端激活的对象类型, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>使用方法在客户端上注册对象类型。 调用方法可为远程处理基础结构提供`new`尝试创建远程应用程序的位置。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 另一方面, 如果使用<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>方法来创建客户端激活的对象的新实例, 则必须提供远程应用程序的 URL 作为参数, 因此, 在客户端上注册之前不需要。 若要为<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>该方法提供要在其中创建对象的服务器的 url, 则必须将该 url 封装在<xref:System.Runtime.Remoting.Activation.UrlAttribute>类的实例中。  
  
 有关客户端激活的对象的详细说明, 请参阅[客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))  
  
   
  
## Examples  
 下面的代码示例演示如何在客户端上将对象类型注册为可在服务器上激活的类型。 有关与所提供的客户端代码相对应的服务器代码, 请参阅<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>方法的示例。  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/client.cpp#1)]
 [!code-csharp[RemotingConfiguration.ClientActivation#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/client.cs#1)]
 [!code-vb[RemotingConfiguration.ClientActivation#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/client.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 或 <paramref name="URI" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterActivatedServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将服务端上的对象 <see cref="T:System.Type" /> 注册为可根据请求从客户端激活的类型。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (System.Runtime.Remoting.ActivatedServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Runtime.Remoting.ActivatedServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterActivatedServiceType (entry As ActivatedServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(System::Runtime::Remoting::ActivatedServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : System.Runtime.Remoting.ActivatedServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.ActivatedServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">客户端激活类型的配置设置。</param>
        <summary>将在服务端提供的 <see cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" /> 中记录的对象类型注册为可根据请求从客户端激活的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在服务器上创建客户端激活的对象的实例, 必须知道其<xref:System.Type> , 并且必须<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>使用方法在服务器端上注册它。 若要获取客户端激活对象的新实例的代理, 客户端必须首先向注册通道<xref:System.Runtime.Remoting.Channels.ChannelServices> , 然后通过调用`new`或<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>激活该对象。  
  
 若要使用`new`关键字激活客户端激活的对象类型, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>使用方法在客户端上注册对象类型。 调用方法将为远程处理基础结构提供远程应用程序的位置`new` , 并尝试创建该应用程序。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 另一方面, 如果使用<xref:System.Activator.CreateInstance%2A>方法来创建客户端激活的对象的新实例, 则必须提供远程应用程序的 URL 作为参数, 因此, 在客户端上注册之前不需要。 若要为<xref:System.Activator.CreateInstance%2A>该方法提供要在其中创建对象的服务器的 url, 则必须将该 url 封装在<xref:System.Runtime.Remoting.Activation.UrlAttribute>类的实例中。  
  
 有关客户端激活的对象的详细说明, 请参阅[客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterActivatedServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterActivatedServiceType (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterActivatedServiceType(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterActivatedServiceType(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member RegisterActivatedServiceType : Type -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要注册的对象的 <see cref="T:System.Type" />。</param>
        <summary>将服务端上指定的对象类型注册为可根据请求从客户端激活的类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在服务器上创建客户端激活的对象的实例, 必须知道其<xref:System.Type> , 并且必须<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedServiceType%2A>使用方法在服务器端上注册它。 若要获取客户端激活对象的新实例的代理, 客户端必须首先向注册通道<xref:System.Runtime.Remoting.Channels.ChannelServices> , 然后通过调用`new`或<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>激活该对象。  
  
 若要使用`new`关键字激活客户端激活的对象类型, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>使用方法在客户端上注册对象类型。 调用方法将为远程处理基础结构提供远程应用程序的位置`new` , 并尝试创建该应用程序。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A> 另一方面, 如果使用<xref:System.Activator.CreateInstance%2A>方法来创建客户端激活的对象的新实例, 则必须提供远程应用程序的 URL 作为参数, 因此, 在客户端上注册之前不需要。 若要为<xref:System.Activator.CreateInstance%2A>该方法提供要在其中创建对象的服务器的 url, 则必须将该 url 封装在<xref:System.Runtime.Remoting.Activation.UrlAttribute>类的实例中。  
  
 有关客户端激活的对象的详细说明, 请参阅[客户端激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/w93betdk(v=vs.100))。  
  
   
  
## Examples  
 下面的代码示例演示如何将服务器上的对象类型注册为可由客户端激活的类型。 有关对应于所提供的服务器代码的客户端代码, 请参阅<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterActivatedClientType%2A>方法的示例。  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/server.cpp#2)]
 [!code-csharp[RemotingConfiguration.ClientActivation#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/server.cs#2)]
 [!code-vb[RemotingConfiguration.ClientActivation#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/server.vb#2)]  
  
 下面的代码示例演示了在上面的示例代码中注册的服务对象。  
  
 [!code-cpp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CPP/service.cpp#3)]
 [!code-csharp[RemotingConfiguration.ClientActivation#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/CS/service.cs#3)]
 [!code-vb[RemotingConfiguration.ClientActivation#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ClientActivation/VB/service.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.ActivatedServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.ActivatedClientTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownClientType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将客户端上的对象 <see cref="T:System.Type" /> 注册为已知类型（“单个调用”(singlecall) 或 singleton）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (System.Runtime.Remoting.WellKnownClientTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Runtime.Remoting.WellKnownClientTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownClientType (entry As WellKnownClientTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(System::Runtime::Remoting::WellKnownClientTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : System.Runtime.Remoting.WellKnownClientTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">已知类型的配置设置。</param>
        <summary>将在客户端提供的 <see cref="T:System.Type" /> 中记录的对象 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> 注册为可在服务器上激活的已知类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已注册的已知对象的 URI 的任何客户端都可以通过注册它首选<xref:System.Runtime.Remoting.Channels.ChannelServices>的信道来获取该对象的代理, 并通过调用`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>激活该对象。 若要使用`new`激活已知对象, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>使用方法在客户端上注册众所周知的对象类型。 调用方法为远程处理基础结构提供了远程对象的位置, 这`new`允许关键字创建该对象。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 另一方面, 如果使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法来激活已知对象, 则必须将该对象的 URL 作为参数提供, 因此不需要在客户端上进行事先注册。  
  
 有关已知对象的详细说明, 请参阅[服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownClientType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownClientType (Type type, string objectUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownClientType(class System.Type type, string objectUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownClientType(Type ^ type, System::String ^ objectUrl);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownClientType : Type * string -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType (type, objectUrl)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">对象 <see cref="T:System.Type" />。</param>
        <param name="objectUrl">已知客户端对象的 URL。</param>
        <summary>通过使用给定的参数初始化 <see cref="T:System.Type" /> 类的新实例，将客户端上的对象 <see cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" /> 注册为可在服务器上激活的已知类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已注册的已知对象的 URI 的任何客户端都可以通过注册它首选<xref:System.Runtime.Remoting.Channels.ChannelServices>的信道来获取该对象的代理, 并通过调用`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>激活该对象。 若要使用`new`激活已知对象, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>使用方法在客户端上注册众所周知的对象类型。 调用方法为远程处理基础结构提供了远程对象的位置, 这`new`允许关键字创建该对象。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 另一方面, 如果使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法来激活已知对象, 则必须将该对象的 URL 作为参数提供, 因此不需要在客户端上进行事先注册。  
  
 有关已知对象的详细说明, 请参阅[服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 下面的代码示例演示如何在客户端上将对象类型注册为已知类型。 有关与所提供的客户端代码相对应的服务器代码, 请参阅<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType%2A>方法的示例。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#5)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#5)]
 [!code-vb[RemotingConfiguration.ServerActivation1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#5)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#6)]
[!code-csharp[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#6)]
[!code-vb[RemotingConfiguration.ServerActivation1#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#6)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/client.cpp#7)]
[!code-csharp[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/client.cs#7)]
[!code-vb[RemotingConfiguration.ServerActivation1#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/client.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWellKnownServiceType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将服务端上的对象 <see cref="T:System.Type" /> 注册为已知类型（“单个调用”(singlecall) 或 singleton）。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (System.Runtime.Remoting.WellKnownServiceTypeEntry entry);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Runtime.Remoting.WellKnownServiceTypeEntry entry) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterWellKnownServiceType (entry As WellKnownServiceTypeEntry)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(System::Runtime::Remoting::WellKnownServiceTypeEntry ^ entry);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : System.Runtime.Remoting.WellKnownServiceTypeEntry -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType entry" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entry" Type="System.Runtime.Remoting.WellKnownServiceTypeEntry" />
      </Parameters>
      <Docs>
        <param name="entry">已知类型的配置设置。</param>
        <summary>将在服务端提供的 <see cref="T:System.Type" /> 中记录的对象 <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> 注册为已知类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已注册的已知对象的 URI 的任何客户端都可以通过注册它喜欢<xref:System.Runtime.Remoting.Channels.ChannelServices>的通道, 并通过调用`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法激活该对象来获取该对象的代理。 若要使用`new`激活已知对象, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>使用方法在客户端上注册众所周知的对象类型。 调用方法为远程处理基础结构提供了远程对象的位置, 这`new`允许关键字创建该对象。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 另一方面, 如果使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法来激活已知对象, 则必须将该对象的 URL 作为参数提供, 因此不需要在客户端上进行事先注册。  
  
 当调用到达服务器时, .NET Framework 从消息中提取 URI, 检查远程处理表以找到与 URI 匹配的对象的引用, 然后根据需要实例化对象 (如有必要), 将方法调用转发给对象。 如果将对象注册为<xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, 则在方法调用完成后将其销毁。 将为每个调用的方法创建对象的新实例。 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 和`new`之间唯一的区别在于前者允许您指定一个 url 作为参数, 后者从配置中获取 url。  
  
 注册过程不会实例化远程对象本身。 仅当客户端尝试调用对象上的方法或从客户端激活对象时, 才会发生这种情况。  
  
 有关已知对象的详细说明, 请参阅[服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 [!code-cpp[CreateObjRef2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/CreateObjRef2/CPP/example.cpp#2)]
 [!code-csharp[CreateObjRef2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/CreateObjRef2/CS/example.cs#2)]
 [!code-vb[CreateObjRef2#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/CreateObjRef2/VB/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
    <Member MemberName="RegisterWellKnownServiceType">
      <MemberSignature Language="C#" Value="public static void RegisterWellKnownServiceType (Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterWellKnownServiceType(class System.Type type, string objectUri, valuetype System.Runtime.Remoting.WellKnownObjectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(System.Type,System.String,System.Runtime.Remoting.WellKnownObjectMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterWellKnownServiceType(Type ^ type, System::String ^ objectUri, System::Runtime::Remoting::WellKnownObjectMode mode);" />
      <MemberSignature Language="F#" Value="static member RegisterWellKnownServiceType : Type * string * System.Runtime.Remoting.WellKnownObjectMode -&gt; unit" Usage="System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType (type, objectUri, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="objectUri" Type="System.String" />
        <Parameter Name="mode" Type="System.Runtime.Remoting.WellKnownObjectMode" />
      </Parameters>
      <Docs>
        <param name="type">对象 <see cref="T:System.Type" />。</param>
        <param name="objectUri">对象 URI。</param>
        <param name="mode">正在被注册的已知对象类型的激活方式。 （参见 <see cref="T:System.Runtime.Remoting.WellKnownObjectMode" />。）</param>
        <summary>通过使用给定的参数初始化 <see cref="T:System.Type" /> 的新实例，将服务端上的对象 <see cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" /> 注册为已知类型。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 知道已注册的已知对象的 URI 的任何客户端都可以通过注册它喜欢<xref:System.Runtime.Remoting.Channels.ChannelServices>的通道, 并通过调用`new`或<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法激活该对象来获取该对象的代理。 若要使用`new`激活已知对象, 必须先<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>使用方法在客户端上注册众所周知的对象类型。 调用方法为远程处理基础结构提供了远程对象的位置, 这`new`允许关键字创建该对象。 <xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A> 另一方面, 如果使用<xref:System.Activator.GetObject%2A?displayProperty=nameWithType>方法来激活已知对象, 则必须将该对象的 URL 作为参数提供, 因此不需要在客户端上进行事先注册。  
  
 当调用到达服务器时, .NET Framework 从消息中提取 URI, 检查远程处理表以找到与 URI 匹配的对象的引用, 然后根据需要实例化对象 (如有必要), 将方法调用转发给对象。 如果将对象注册为<xref:System.Runtime.Remoting.WellKnownObjectMode.SingleCall>, 则在方法调用完成后将其销毁。 将为每个调用的方法创建对象的新实例。 <xref:System.Activator.GetObject%2A?displayProperty=nameWithType> 和`new`之间唯一的区别在于前者允许您指定一个 url 作为参数, 后者从配置中获取 url。  
  
 注册过程不会实例化远程对象本身。 仅当客户端尝试调用对象上的方法或从客户端激活对象时, 才会发生这种情况。  
  
 有关已知对象的详细说明, 请参阅[服务器激活](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/y0h540a7(v=vs.100))。  
  
   
  
## Examples  
 下面的代码示例演示如何在服务器上将对象类型注册为众所周知的对象类型。 有关对应于所提供的服务器代码的客户端代码, 请参阅<xref:System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownClientType%2A>方法的示例。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#1)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#1)]
 [!code-vb[RemotingConfiguration.ServerActivation1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#1)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#2)]
[!code-csharp[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#2)]
[!code-vb[RemotingConfiguration.ServerActivation1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#2)]  
[!code-cpp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/server.cpp#3)]
[!code-csharp[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/server.cs#3)]
[!code-vb[RemotingConfiguration.ServerActivation1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/server.vb#3)]  
  
 下面的代码示例演示了在上面的示例代码中注册的服务对象。  
  
 [!code-cpp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CPP/service.cpp#4)]
 [!code-csharp[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/CS/service.cs#4)]
 [!code-vb[RemotingConfiguration.ServerActivation1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/RemotingConfiguration.ServerActivation1/VB/service.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">在调用堆栈上部，至少有一个调用方没有配置远程处理类型和通道的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于配置远程处理基础结构。 要求值: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />;权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.RemotingConfiguration" /></permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownServiceTypeEntry" />
        <altmember cref="T:System.Runtime.Remoting.WellKnownClientTypeEntry" />
      </Docs>
    </Member>
  </Members>
</Type>
