<Type Name="CodeDomProvider" FullName="System.CodeDom.Compiler.CodeDomProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="49dbf9fc3e3c148aaedf969701a304cffd34c946" /><Meta Name="ms.sourcegitcommit" Value="81833381d2d0b5a8c55f71b43f00769fd38298af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/17/2019" /><Meta Name="ms.locfileid" Value="69568452" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomProvider : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomProvider extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.CodeDom.Compiler.CodeDomProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomProvider&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomProvider abstract : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type CodeDomProvider = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.CodeDom</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>为 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现提供基类。 此类为抽象类。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider>可用于创建和检索代码生成器和代码编译器的实例。 代码生成器可用于以特定的语言生成代码，而代码编译器可用于将代码编译为程序集。  
  
> [!NOTE]
>  在中[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)], 代码生成器和代码编译器中提供的方法可直接从代码提供程序获得。 不需要调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>或<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>访问方法, 这些方法被标记为过时。 这适用于预先存在的以及新的代码提供程序实现。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider>实现通常提供代码生成和/或代码编译接口, 用于为单一编程语言生成代码和管理编译。 <xref:System.CodeDom.Compiler.CodeDomProvider> 附带[!INCLUDE[winsdklong](~/includes/winsdklong-md.md)]的实现支持多种语言。 这些语言包括 C#、Visual Basic、C++ 和 JScript。 开发人员或编译器供应商可以<xref:System.CodeDom.Compiler.ICodeGenerator>实现<xref:System.CodeDom.Compiler.ICodeCompiler>和接口, 并<xref:System.CodeDom.Compiler.CodeDomProvider>提供将 CodeDOM 支持扩展到其他编程语言的。  
  
 计算机配置文件 (machine.config) 中的[ &lt;&gt; system.object 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)提供了一种机制, 使开发人员和编译器供应商可以为其他<xref:System.CodeDom.Compiler.CodeDomProvider>实现添加配置设置。  
  
 类提供静态方法用于发现和枚举计算机上<xref:System.CodeDom.Compiler.CodeDomProvider>的实现。 <xref:System.CodeDom.Compiler.CodeDomProvider> 方法返回计算机上所有<xref:System.CodeDom.Compiler.CodeDomProvider>实现的设置。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> 方法根据编程语言名称返回特定<xref:System.CodeDom.Compiler.CodeDomProvider>实现的设置。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A> 方法返回特定语言的<xref:System.CodeDom.Compiler.CodeDomProvider>实现的实例。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>  
  
 有关配置文件中的语言提供程序设置的更多详细信息, 请参阅[编译器和语言提供程序设置架构](~/docs/framework/configure-apps/file-schema/compiler/index.md)。  
  
> [!NOTE]
>  此类在类级别建立链接要求和继承要求。 如果直接调用方或派生类不具有 "完全信任" 权限, 则会引发。<xref:System.Security.SecurityException> 有关安全要求的详细信息, 请参阅[链接要求](~/docs/framework/misc/link-demands.md)和[继承要求](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/x4yx82e6(v=vs.100))。  
  
   
  
## Examples  
 下面的示例程序可以基于使用<xref:System.Console>类打印 "Hello World" 的程序的 CodeDOM 模型生成和编译源代码。 提供 Windows 窗体用户界面。 用户可以从多个选项中选择目标编程语言:C#、Visual Basic 和 JScript。  
  
 [!code-cpp[CodeDomExample#1](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#1)]
 [!code-csharp[CodeDomExample#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#1)]
 [!code-vb[CodeDomExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此类不能由部分信任的代码使用。</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">完全信任继承者。 此类不能由部分信任的代码继承。</permission>
    <block subset="none" type="overrides"><para>在 .NET Framework 版本1.0 和1.1 中, 代码提供<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />程序由<see cref="T:System.CodeDom.Compiler.ICodeParser" />、 <see cref="T:System.CodeDom.Compiler.ICodeGenerator" />、和<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />的实现组成。 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]在中<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> , <see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> <see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> 、和方法<see cref="T:System.CodeDom.Compiler.CodeDomProvider" />已过时, 并且和的方法直接在类中可用。 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" /> <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 应在代码提供程序实现中重写这些方法, 而不调用基方法。</para></block>
    <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
    <altmember cref="T:Microsoft.CSharp.CSharpCodeProvider" />
    <altmember cref="T:Microsoft.VisualBasic.VBCodeProvider" />
    <altmember cref="T:Microsoft.JScript.JScriptCodeProvider" />
    <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">编译器和语言提供程序设置架构</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 类的新实例。</summary>
        <remarks>To be added.</remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此类不能由部分信任的代码使用。</permission>
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromDom">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom (System.CodeDom.Compiler.CompilerParameters options, params System.CodeDom.CodeCompileUnit[] compilationUnits);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromDom(class System.CodeDom.Compiler.CompilerParameters options, class System.CodeDom.CodeCompileUnit[] compilationUnits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromDom(System.CodeDom.Compiler.CompilerParameters,System.CodeDom.CodeCompileUnit[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromDom (options As CompilerParameters, ParamArray compilationUnits As CodeCompileUnit()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromDom(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::CodeDom::CodeCompileUnit ^&gt; ^ compilationUnits);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromDom : System.CodeDom.Compiler.CompilerParameters * System.CodeDom.CodeCompileUnit[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromDom (options, compilationUnits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="compilationUnits" Type="System.CodeDom.CodeCompileUnit[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</param>
        <param name="compilationUnits"><see cref="T:System.CodeDom.CodeCompileUnit" /> 类型数组，指示要编译的代码。</param>
        <summary>基于包含在 <see cref="N:System.CodeDom" /> 对象的指定数组中的 <see cref="T:System.CodeDom.CodeCompileUnit" /> 树，使用指定的编译器设置编译程序集。</summary>
        <returns>一个 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象，它指示编译的结果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeCompiler>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />的方法在派生类中创建一个生成器, 以便与使用代码编译器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码编译器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromFile">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile (System.CodeDom.Compiler.CompilerParameters options, params string[] fileNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromFile(class System.CodeDom.Compiler.CompilerParameters options, string[] fileNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromFile(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromFile (options As CompilerParameters, ParamArray fileNames As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromFile(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ fileNames);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromFile : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromFile (options, fileNames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="fileNames" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示编译的设置。</param>
        <param name="fileNames">要编译的文件名称的数组。</param>
        <summary>从包含在指定文件中的源代码，使用指定的编译器设置编译程序集。</summary>
        <returns>指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeCompiler>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />的方法在派生类中创建一个生成器, 以便与使用代码编译器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码编译器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CompileAssemblyFromSource">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource (System.CodeDom.Compiler.CompilerParameters options, params string[] sources);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.CompilerResults CompileAssemblyFromSource(class System.CodeDom.Compiler.CompilerParameters options, string[] sources) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CompileAssemblyFromSource(System.CodeDom.Compiler.CompilerParameters,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CompileAssemblyFromSource (options As CompilerParameters, ParamArray sources As String()) As CompilerResults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::CompilerResults ^ CompileAssemblyFromSource(System::CodeDom::Compiler::CompilerParameters ^ options, ... cli::array &lt;System::String ^&gt; ^ sources);" />
      <MemberSignature Language="F#" Value="abstract member CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults&#xA;override this.CompileAssemblyFromSource : System.CodeDom.Compiler.CompilerParameters * string[] -&gt; System.CodeDom.Compiler.CompilerResults" Usage="codeDomProvider.CompileAssemblyFromSource (options, sources)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerResults</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.CodeDom.Compiler.CompilerParameters" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="sources" Type="System.String[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="options">一个 <see cref="T:System.CodeDom.Compiler.CompilerParameters" /> 对象，它指示此编译的编译器设置。</param>
        <param name="sources">要编译的源代码字符串的数组。</param>
        <summary>从包含源代码的字符串的指定数组，使用指定的编译器设置编译程序集。</summary>
        <returns>指示编译结果的 <see cref="T:System.CodeDom.Compiler.CompilerResults" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeCompiler>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeCompiler>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />的方法在派生类中创建一个生成器, 以便与使用代码编译器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeCompiler" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码编译器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.CodeDom.Compiler.CompilerParameters" />
        <altmember cref="T:System.CodeDom.Compiler.CompilerResults" />
      </Docs>
    </Member>
    <Member MemberName="CreateCompiler">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeCompiler CreateCompiler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeCompiler CreateCompiler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateCompiler" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCompiler () As ICodeCompiler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeCompiler ^ CreateCompiler();" />
      <MemberSignature Language="F#" Value="abstract member CreateCompiler : unit -&gt; System.CodeDom.Compiler.ICodeCompiler" Usage="codeDomProvider.CreateCompiler " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeCompiler is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeCompiler interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeCompiler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码编译器。</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeCompiler" />，可用于编译基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在中[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]已过时。 建议的替代<xref:System.CodeDom.Compiler.ICodeCompiler>方法是调用可直接在代码提供程序中使用的方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在中<see cref="T:System.CodeDom.Compiler.ICodeCompiler" /> <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> , 应在类中实现成员, 并在调用此<see cref="T:System.NotSupportedException" />方法时引发。 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateEscapedIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateEscapedIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateEscapedIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateEscapedIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateEscapedIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateEscapedIdentifier : string -&gt; string&#xA;override this.CreateEscapedIdentifier : string -&gt; string" Usage="codeDomProvider.CreateEscapedIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要为其创建转义标识符的字符串。</param>
        <summary>创建指定值的转义标识符。</summary>
        <returns>值的转义标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateEscapedIdentifier%2A>测试标识符是否与任何保留关键字或语言关键字冲突, 如果是, 则返回具有特定于语言的转义代码格式的等效名称。 这称为转义标识符。 该转义标识符包含相同`value`的, 但已添加转义码格式设置, 以使标识符有别于关键字。 两个实现示例前面`value`带有 "@", 或`value`括号为 "[" 和 "]"。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateGenerator">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码生成器。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public abstract System.CodeDom.Compiler.ICodeGenerator CreateGenerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateGenerator () As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator();" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : unit -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeGenerator is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeGenerator interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码生成器。</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在中[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]已过时。 建议的替代<xref:System.CodeDom.Compiler.ICodeGenerator>方法是调用<xref:System.CodeDom.Compiler.CodeDomProvider>类中直接可用的方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>在中<see cref="T:System.CodeDom.Compiler.ICodeGenerator" /> <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> , 应在类中实现成员, 并在调用此<see cref="T:System.NotSupportedException" />方法时引发。 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (System.IO.TextWriter output);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(class System.IO.TextWriter output) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (output As TextWriter) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::IO::TextWriter ^ output);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : System.IO.TextWriter -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator output" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="output" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="output">用于输出的 <see cref="T:System.IO.TextWriter" />。</param>
        <summary>在派生类中重写时，使用指定的 <see cref="T:System.IO.TextWriter" /> 创建新的代码生成器以用于输出。</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用为输出<xref:System.IO.TextWriter>指定的。 此方法支持更多优化的代码生成, 以增量方式更新源代码。  
  
> [!NOTE]
>  基类实现调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法, 该方法[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]在中已过时, <xref:System.NotSupportedException>如果不返回<xref:System.CodeDom.Compiler.ICodeGenerator>对象, 则会生成。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.IO.TextWriter" />
      </Docs>
    </Member>
    <Member MemberName="CreateGenerator">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeGenerator CreateGenerator (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeGenerator CreateGenerator(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateGenerator (fileName As String) As ICodeGenerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeGenerator ^ CreateGenerator(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="abstract member CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator&#xA;override this.CreateGenerator : string -&gt; System.CodeDom.Compiler.ICodeGenerator" Usage="codeDomProvider.CreateGenerator fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeGenerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">要输出到的文件名。</param>
        <summary>在派生类中重写时，使用指定文件名创建新的代码生成器以用于输出。</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeGenerator" />，可用于生成基于 <see cref="N:System.CodeDom" /> 的源代码表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用指定的输出文件名。  
  
> [!NOTE]
>  基类实现调用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法, 该方法[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]在中已过时, <xref:System.NotSupportedException>如果不返回<xref:System.CodeDom.Compiler.ICodeGenerator>对象, 则会生成。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParser">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.ICodeParser CreateParser ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.Compiler.ICodeParser CreateParser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateParser () As ICodeParser" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::Compiler::ICodeParser ^ CreateParser();" />
      <MemberSignature Language="F#" Value="abstract member CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser&#xA;override this.CreateParser : unit -&gt; System.CodeDom.Compiler.ICodeParser" Usage="codeDomProvider.CreateParser " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("ICodeParser is obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.Obsolete("Callers should not use the ICodeParser interface and should instead use the methods directly on the CodeDomProvider class. Those inheriting from CodeDomProvider must still implement this interface, and should exclude this warning or also obsolete this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.ICodeParser</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在派生类中重写时，创建一个新的代码分析器。</summary>
        <returns><see cref="T:System.CodeDom.Compiler.ICodeParser" />，可用于分析源代码。 此基实现总是返回 <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProvider">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <summary>获取指定语言的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</summary>
        <returns>为指定语言名称实现的 CodeDOM 提供程序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此方法最常用于在应用程序中创建代码提供程序的实例, 该实例可以选择使用多个提供程序之一。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>允许你在运行时指定要实例化的代码提供程序。 如果您在设计时知道要使用哪一个代码提供程序, 则应创建该代码提供程序的实例, 而不是<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>使用方法。  
  
 方法返回特定语言名称的<xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 实例;与使用语言提供程序类型调用方法类似。<xref:System.CodeDom.Compiler.CodeDomProvider> <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A> 需要<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>动态查找语言名称的已配置提供程序实现时, 请使用。  
  
 如果为语言名称配置了多个提供程序实现, <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>则返回最后一个匹配配置元素的提供程序实例。  
  
 如果需要特定的语言提供程序实现, 请使用方法重载。<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType> 例如, 使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>方法获取支持语言名称`"CSharp"`的提供程序实例; 使用<xref:System.Activator.CreateInstance%28System.Type%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29?displayProperty=nameWithType>方法重载获取专用于<xref:Microsoft.CSharp.CSharpCodeProvider?displayProperty=nameWithType>实现的提供程序实例。 应使用 [\], CultureInfo, 对象\<x: 28system.object% 2csystem.string% 2csystem.string% 2csystem.string%%%%%。对象% 5b% 5d%如果你有多个语言的代码提供程序, 并且你希望实例化特定的代码提供程序, 则 2Csystem.string% 2Csystem.string% 5B% 5D% 29？ displayProperty = Namewithtype> > 方法。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法检查是否至少有一个提供程序实现支持特定语言。 在将语言名称传递给之前<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> , 可以使用对<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>其进行验证。 如果将不支持的语言名称传递<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>到<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> , 则会引发。  
  
 方法可用于确定计算机上的所有<xref:System.CodeDom.Compiler.CodeDomProvider>实现, 包括系统中标识的开发人员和编译器供应商提供的附加实现<xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A> [ &lt;&gt;](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)计算机配置文件 (machine.config) 中的元素。  
  
 方法返回特定语言的<xref:System.CodeDom.Compiler.CodeDomProvider>实现的实例。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%2A>  
  
 语言名称不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定输入<xref:System.CodeDom.Compiler.CodeDomProvider>语言的实现, 并显示语言提供程序的配置设置。 此代码示例是为<xref:System.CodeDom.Compiler.CompilerInfo>类提供的更大示例的一部分。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="language" /> 在此计算机上没有已配置的提供程序。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="language" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateProvider">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CodeDomProvider CreateProvider (string language, System.Collections.Generic.IDictionary&lt;string,string&gt; providerOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CodeDomProvider CreateProvider(string language, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; providerOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String,System.Collections.Generic.IDictionary{System.String,System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateProvider (language As String, providerOptions As IDictionary(Of String, String)) As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CodeDomProvider ^ CreateProvider(System::String ^ language, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ providerOptions);" />
      <MemberSignature Language="F#" Value="static member CreateProvider : string * System.Collections.Generic.IDictionary&lt;string, string&gt; -&gt; System.CodeDom.Compiler.CodeDomProvider" Usage="System.CodeDom.Compiler.CodeDomProvider.CreateProvider (language, providerOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="providerOptions" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <param name="providerOptions">来自配置文件的提供程序选项的集合。</param>
        <summary>获取指定的语言和提供程序选项的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实例。</summary>
        <returns>为指定语言名称和选项实现的 CodeDOM 提供程序。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  此方法最常用于在应用程序中创建代码提供程序的实例, 该实例可以选择使用多个提供程序之一。 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>使你能够在运行时指定要实例化的代码提供程序的版本。 如果在设计时知道要使用哪种代码提供程序, 则应创建该代码提供程序的实例, 而不是使用<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>方法。  
  
 当<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%2CSystem.Collections.Generic.IDictionary%7BSystem.String%2CSystem.String%7D%29>你想要针对特定语言和选项动态查找配置的提供程序实现时, 请使用。 语言名称不区分大小写。 有关支持的提供程序选项的信息, 请参阅特定的 CodeDOM 提供程序文档。  
  
 有关为语言名称配置了多个提供程序实现的验证提供程序和调用提供程序的信息, 请参见<xref:System.CodeDom.Compiler.CodeDomProvider.CreateProvider%28System.String%29>方法的 "备注" 部分。  
  
   
  
## Examples  
 下面的示例演示如何使用`providerOptions`参数创建提供程序的实例。  
  
 [!code-csharp[CodeDomProvider.ProviderOptions#1](~/samples/snippets/csharp/VS_Snippets_CLR/codedomprovider.provideroptions/cs/program.cs#1)]
 [!code-vb[CodeDomProvider.ProviderOptions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/codedomprovider.provideroptions/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual string CreateValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string CreateValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateValidIdentifier (value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ CreateValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CreateValidIdentifier : string -&gt; string&#xA;override this.CreateValidIdentifier : string -&gt; string" Usage="codeDomProvider.CreateValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要为其生成有效标识符的字符串。</param>
        <summary>为指定的值创建有效标识符。</summary>
        <returns>指定值的有效标识符。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.CreateValidIdentifier%2A>测试标识符是否与保留关键字或语言关键字冲突, 如果是, 则将尝试返回一个不冲突的有效标识符名称。 通常, 只会略微修改返回的标识符, 以区别关键字中的标识符;例如, 名称前面可能有下划线 ("_") 字符。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
      </Docs>
    </Member>
    <Member MemberName="FileExtension">
      <MemberSignature Language="C#" Value="public virtual string FileExtension { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FileExtension" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FileExtension As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FileExtension { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FileExtension : string" Usage="System.CodeDom.Compiler.CodeDomProvider.FileExtension" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于当前语言的源代码文件的默认文件扩展名。</summary>
        <value>与当前语言的源文件扩展名相对应的文件扩展名。 此基实现总是返回 <see cref="F:System.String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 代码生成器和代码编译器使用此属性来指示应生成或使用的文件扩展名。  
  
   
  
## Examples  
 下面的代码示例创建的<xref:Microsoft.VisualBasic.VBCodeProvider?displayProperty=nameWithType>一个实例。 该示例显示了新提供程序实例的提供程序名称、哈希代码和默认文件扩展名。  
  
 [!code-cpp[CodeDom_CompilerInfo#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#3)]
 [!code-csharp[CodeDom_CompilerInfo#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#3)]
 [!code-vb[CodeDom_CompilerInfo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromCompileUnit">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromCompileUnit (System.CodeDom.CodeCompileUnit compileUnit, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromCompileUnit(class System.CodeDom.CodeCompileUnit compileUnit, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit(System.CodeDom.CodeCompileUnit,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromCompileUnit (compileUnit As CodeCompileUnit, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromCompileUnit(System::CodeDom::CodeCompileUnit ^ compileUnit, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromCompileUnit : System.CodeDom.CodeCompileUnit * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromCompileUnit (compileUnit, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="compileUnit" Type="System.CodeDom.CodeCompileUnit" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="compileUnit">要为其生成代码的 <see cref="T:System.CodeDom.CodeCompileUnit" />。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 编译单元生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromCompileUnit%2A>方法为<xref:System.CodeDom.CodeCompileUnit>中的 "Hello World" 应用程序生成代码。 此示例是为<xref:System.CodeDom.Compiler.CodeDomProvider>类提供的更大示例的一部分。  
  
 [!code-cpp[CodeDomExample#3](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDomExample/CPP/source.cpp#3)]
 [!code-csharp[CodeDomExample#3](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDomExample/CS/source.cs#3)]
 [!code-vb[CodeDomExample#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDomExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromExpression">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromExpression (System.CodeDom.CodeExpression expression, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromExpression(class System.CodeDom.CodeExpression expression, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromExpression(System.CodeDom.CodeExpression,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromExpression (expression As CodeExpression, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromExpression(System::CodeDom::CodeExpression ^ expression, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromExpression : System.CodeDom.CodeExpression * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromExpression (expression, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="expression" Type="System.CodeDom.CodeExpression" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="expression">一个 <see cref="T:System.CodeDom.CodeExpression" /> 对象，指示要为其生成代码的表达式。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 表达式生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeExpression" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromMember">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromMember (System.CodeDom.CodeTypeMember member, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromMember(class System.CodeDom.CodeTypeMember member, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember(System.CodeDom.CodeTypeMember,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromMember (member As CodeTypeMember, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromMember(System::CodeDom::CodeTypeMember ^ member, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromMember : System.CodeDom.CodeTypeMember * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromMember (member, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="member" Type="System.CodeDom.CodeTypeMember" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="member">一个 <see cref="T:System.CodeDom.CodeTypeMember" /> 对象，指示要为其生成代码的成员。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 成员声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基类实现引发<xref:System.NotImplementedException>。 有关<xref:Microsoft.CSharp.CSharpCodeProvider.GenerateCodeFromMember%2A?displayProperty=nameWithType>描述此方法的实现的文档, 请参阅。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromMember%2A> <xref:Microsoft.CSharp.CSharpCodeProvider>和<xref:Microsoft.VisualBasic.VBCodeProvider>类实现的方法。  
  
 [!code-csharp[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/cs/program.cs#1)]
 [!code-vb[CodeDom_GenerateCodeFromMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_GenerateCodeFromMember/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法不会在派生类中被重写。</exception>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeMember" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromNamespace">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromNamespace (System.CodeDom.CodeNamespace codeNamespace, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromNamespace(class System.CodeDom.CodeNamespace codeNamespace, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromNamespace(System.CodeDom.CodeNamespace,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromNamespace(System::CodeDom::CodeNamespace ^ codeNamespace, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromNamespace : System.CodeDom.CodeNamespace * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromNamespace (codeNamespace, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeNamespace" Type="System.CodeDom.CodeNamespace" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeNamespace">一个 <see cref="T:System.CodeDom.CodeNamespace" /> 对象，指示要为其生成代码的命名空间。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 命名空间生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeNamespace" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromStatement">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromStatement (System.CodeDom.CodeStatement statement, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromStatement(class System.CodeDom.CodeStatement statement, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromStatement(System.CodeDom.CodeStatement,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromStatement (statement As CodeStatement, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromStatement(System::CodeDom::CodeStatement ^ statement, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromStatement : System.CodeDom.CodeStatement * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromStatement (statement, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="statement" Type="System.CodeDom.CodeStatement" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="statement"><see cref="T:System.CodeDom.CodeStatement" />，包含要为其生成代码的 CodeDOM 元素。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 语句生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeStatement" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GenerateCodeFromType">
      <MemberSignature Language="C#" Value="public virtual void GenerateCodeFromType (System.CodeDom.CodeTypeDeclaration codeType, System.IO.TextWriter writer, System.CodeDom.Compiler.CodeGeneratorOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateCodeFromType(class System.CodeDom.CodeTypeDeclaration codeType, class System.IO.TextWriter writer, class System.CodeDom.Compiler.CodeGeneratorOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GenerateCodeFromType(System.CodeDom.CodeTypeDeclaration,System.IO.TextWriter,System.CodeDom.Compiler.CodeGeneratorOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateCodeFromType (codeType As CodeTypeDeclaration, writer As TextWriter, options As CodeGeneratorOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateCodeFromType(System::CodeDom::CodeTypeDeclaration ^ codeType, System::IO::TextWriter ^ writer, System::CodeDom::Compiler::CodeGeneratorOptions ^ options);" />
      <MemberSignature Language="F#" Value="abstract member GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit&#xA;override this.GenerateCodeFromType : System.CodeDom.CodeTypeDeclaration * System.IO.TextWriter * System.CodeDom.Compiler.CodeGeneratorOptions -&gt; unit" Usage="codeDomProvider.GenerateCodeFromType (codeType, writer, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeType" Type="System.CodeDom.CodeTypeDeclaration" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="writer" Type="System.IO.TextWriter" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.CodeDom.Compiler.CodeGeneratorOptions" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeType">一个 <see cref="T:System.CodeDom.CodeTypeDeclaration" /> 对象，指示要为其生成代码的类型。</param>
        <param name="writer">输出代码将被发送到的 <see cref="T:System.IO.TextWriter" />。</param>
        <param name="options"><see cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />，指示用于生成代码的选项。</param>
        <summary>为指定的代码文档对象模型 (CodeDOM) 类型声明生成代码，并使用指定的选项将代码发送到指定的文本编写器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="T:System.CodeDom.CodeTypeDeclaration" />
        <altmember cref="T:System.CodeDom.Compiler.CodeGeneratorOptions" />
      </Docs>
    </Member>
    <Member MemberName="GetAllCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo[] GetAllCompilerInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllCompilerInfo () As CompilerInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::CodeDom::Compiler::CompilerInfo ^&gt; ^ GetAllCompilerInfo();" />
      <MemberSignature Language="F#" Value="static member GetAllCompilerInfo : unit -&gt; System.CodeDom.Compiler.CompilerInfo[]" Usage="System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此计算机的语言提供程序和编译器配置设置。</summary>
        <returns>一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 类型的数组，表示所有配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.CodeDom.Compiler.CodeDomProvider.GetAllCompilerInfo%2A>使用方法可枚举计算机上的语言提供程序设置。  
  
> [!NOTE]
>  在中[ &lt;, 不会在 system.web&gt;元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)编译器配置节中指定 .NET Framework 提供的默认语言提供程序, 因此此方法返回[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]有关默认提供程序和配置文件中指定的信息的信息。  
  
   
  
## Examples  
 下面的代码示例枚举计算机上的语言提供程序, 并显示每个语言提供程序的配置和编译器设置。 此代码示例是为<xref:System.CodeDom.Compiler.CompilerInfo>类提供的更大示例的一部分。  
  
 [!code-cpp[CodeDom_CompilerInfo#8](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#8)]
 [!code-csharp[CodeDom_CompilerInfo#8](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#8)]
 [!code-vb[CodeDom_CompilerInfo#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">编译器和语言提供程序设置架构</related>
      </Docs>
    </Member>
    <Member MemberName="GetCompilerInfo">
      <MemberSignature Language="C#" Value="public static System.CodeDom.Compiler.CompilerInfo GetCompilerInfo (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.CodeDom.Compiler.CompilerInfo GetCompilerInfo(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompilerInfo (language As String) As CompilerInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::CodeDom::Compiler::CompilerInfo ^ GetCompilerInfo(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member GetCompilerInfo : string -&gt; System.CodeDom.Compiler.CompilerInfo" Usage="System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CompilerInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <summary>返回指定语言的语言提供程序和编译器配置设置。</summary>
        <returns>一个 <see cref="T:System.CodeDom.Compiler.CompilerInfo" /> 对象，由已配置的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现的设置填充。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 计算机配置文件中的[ &lt;&gt; system.object 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个<xref:System.CodeDom.Compiler.CodeDomProvider>实现的语言提供程序和编译器配置设置。 有关计算机配置文件的信息, 请参阅[配置应用](~/docs/framework/configure-apps/index.md)中的计算机配置文件部分。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>方法搜索指定语言名称的每个提供程序配置元素。 返回<xref:System.CodeDom.Compiler.CompilerInfo>的实例包含已配置的语言提供程序和编译器设置。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法检查是否至少有一个提供程序实现支持特定语言。 在将语言名称传递给之前<xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A> , 可以使用对<xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>其进行验证。 这会阻止在<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType> <xref:System.CodeDom.Compiler.CompilerInfo>访问不受支持的语言名称的实例时引发。  
  
 如果为输入语言名称配置了多个提供程序实现, <xref:System.CodeDom.Compiler.CodeDomProvider.GetCompilerInfo%2A>则将返回最后一个匹配提供程序配置元素中的设置。  
  
 语言名称不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定输入<xref:System.CodeDom.Compiler.CodeDomProvider>语言的实现, 并显示语言提供程序的配置设置。 此代码示例是为<xref:System.CodeDom.Compiler.CompilerInfo>类提供的更大示例的一部分。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException"><paramref name="language" /> 在此计算机上没有已配置的提供程序。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="language" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="T:System.CodeDom.Compiler.CompilerInfo" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">编译器和语言提供程序设置架构</related>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.TypeConverter GetConverter (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.ComponentModel.TypeConverter GetConverter(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetConverter(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::ComponentModel::TypeConverter ^ GetConverter(Type ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetConverter : Type -&gt; System.ComponentModel.TypeConverter&#xA;override this.GetConverter : Type -&gt; System.ComponentModel.TypeConverter" Usage="codeDomProvider.GetConverter type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.TypeConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">要为其检索类型转换器的对象类型。</param>
        <summary>获取指定数据类型的 <see cref="T:System.ComponentModel.TypeConverter" />。</summary>
        <returns>指定类型的 <see cref="T:System.ComponentModel.TypeConverter" />；如果无法找到指定类型的 <see cref="T:System.ComponentModel.TypeConverter" />，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生类可以重写此方法, 以便为特定的数据类型提供类型转换器的特定类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.TypeConverter" />
      </Docs>
    </Member>
    <Member MemberName="GetLanguageFromExtension">
      <MemberSignature Language="C#" Value="public static string GetLanguageFromExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetLanguageFromExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLanguageFromExtension (extension As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetLanguageFromExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member GetLanguageFromExtension : string -&gt; string" Usage="System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">文件扩展名。</param>
        <summary>返回与指定文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置节中所配置的那样。</summary>
        <returns>与文件扩展名关联的语言名称，如 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 编译器配置设置中所配置的那样。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 计算机配置文件 (machine.config) 中的[ &lt;&gt; system.object 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个<xref:System.CodeDom.Compiler.CodeDomProvider>实现的语言提供程序和编译器配置设置。 <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>方法在每个提供程序配置元素中搜索指定的文件扩展名。  
  
 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法检查是否至少有一个提供程序实现支持特定的文件扩展名。 在将文件扩展名传递到之前, <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>可以使用对其<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>进行验证。 这会<xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>阻止<xref:System.Configuration.ConfigurationException?displayProperty=nameWithType>为不受支持的文件扩展名引发。  
  
 如果提供程序实现支持输入文件扩展名, 并且为该提供程序配置了多个受支持的语言, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>则将返回该提供程序的第一个语言名称。 如果为输入文件扩展名配置了多个提供程序实现, <xref:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension%2A>则将返回最后一个匹配提供程序配置元素中的语言名称。  
  
 语言名称和文件扩展名不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入文件扩展名的实现并显示语言提供程序的配置设置。 此代码示例是为<xref:System.CodeDom.Compiler.CompilerInfo>类提供的更大示例的一部分。  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.ConfigurationException"><paramref name="extension" /> 在此计算机上没有已配置的语言提供程序。</exception>
        <exception cref="T:System.Configuration.ConfigurationErrorsException"><paramref name="extension" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">编译器和语言提供程序设置架构</related>
      </Docs>
    </Member>
    <Member MemberName="GetTypeOutput">
      <MemberSignature Language="C#" Value="public virtual string GetTypeOutput (System.CodeDom.CodeTypeReference type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetTypeOutput(class System.CodeDom.CodeTypeReference type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.GetTypeOutput(System.CodeDom.CodeTypeReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypeOutput (type As CodeTypeReference) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetTypeOutput(System::CodeDom::CodeTypeReference ^ type);" />
      <MemberSignature Language="F#" Value="abstract member GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string&#xA;override this.GetTypeOutput : System.CodeDom.CodeTypeReference -&gt; string" Usage="codeDomProvider.GetTypeOutput type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.CodeDom.CodeTypeReference" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">指示返回类型的 <see cref="T:System.CodeDom.CodeTypeReference" />。</param>
        <summary>获取由指定的 <see cref="T:System.CodeDom.CodeTypeReference" /> 指示的类型。</summary>
        <returns>指定类型的文本表示形式，针对此代码生成器生成代码时所用的语言进行了格式设置。 例如，在 Visual Basic 中，为 <see cref="T:System.CodeDom.CodeTypeReference" /> 类型传入 <see cref="T:System.Int32" /> 将返回“Integer”。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedExtension">
      <MemberSignature Language="C#" Value="public static bool IsDefinedExtension (string extension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedExtension(string extension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedExtension (extension As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedExtension(System::String ^ extension);" />
      <MemberSignature Language="F#" Value="static member IsDefinedExtension : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension extension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="extension" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="extension">文件扩展名。</param>
        <summary>测试文件扩展名是否在计算机上配置了关联的 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</summary>
        <returns>如果为指定的文件扩展名配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 计算机配置文件 (machine.config) 中的[ &lt;&gt; system.object 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个<xref:System.CodeDom.Compiler.CodeDomProvider>实现的语言提供程序和编译器配置设置。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedExtension%2A>方法在提供程序配置元素中搜索指定的文件扩展名。  
  
 文件扩展名不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定<xref:System.CodeDom.Compiler.CodeDomProvider>输入文件扩展名的实现并显示语言提供程序的配置设置。 此代码示例是为<xref:System.CodeDom.Compiler.CompilerInfo>类提供的更大示例的一部分。  
  
 [!code-cpp[CodeDom_CompilerInfo#5](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#5)]
 [!code-csharp[CodeDom_CompilerInfo#5](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#5)]
 [!code-vb[CodeDom_CompilerInfo#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="extension" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.GetLanguageFromExtension(System.String)" />
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">编译器和语言提供程序设置架构</related>
      </Docs>
    </Member>
    <Member MemberName="IsDefinedLanguage">
      <MemberSignature Language="C#" Value="public static bool IsDefinedLanguage (string language);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefinedLanguage(string language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsDefinedLanguage (language As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsDefinedLanguage(System::String ^ language);" />
      <MemberSignature Language="F#" Value="static member IsDefinedLanguage : string -&gt; bool" Usage="System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage language" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="language">语言名称。</param>
        <summary>测试某语言是否已在计算机上配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现。</summary>
        <returns>如果为指定语言配置了 <see cref="T:System.CodeDom.Compiler.CodeDomProvider" /> 实现，则为 <see langword="true" />；否则，为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 计算机配置文件 (machine.config) 中的[ &lt;&gt; system.object 元素](~/docs/framework/configure-apps/file-schema/compiler/system-codedom-element.md)包含计算机上每个<xref:System.CodeDom.Compiler.CodeDomProvider>实现的语言提供程序和编译器配置设置。 <xref:System.CodeDom.Compiler.CodeDomProvider.IsDefinedLanguage%2A>方法在提供程序配置元素中搜索指定的语言名称。  
  
 语言名称不区分大小写。  
  
   
  
## Examples  
 下面的代码示例确定输入<xref:System.CodeDom.Compiler.CodeDomProvider>语言的实现, 并显示语言提供程序的配置设置。 此代码示例是为<xref:System.CodeDom.Compiler.CompilerInfo>类提供的更大示例的一部分。  
  
 [!code-cpp[CodeDom_CompilerInfo#6](~/samples/snippets/cpp/VS_Snippets_CLR/CodeDom_CompilerInfo/CPP/source.cpp#6)]
 [!code-csharp[CodeDom_CompilerInfo#6](~/samples/snippets/csharp/VS_Snippets_CLR/CodeDom_CompilerInfo/CS/source.cs#6)]
 [!code-vb[CodeDom_CompilerInfo#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/CodeDom_CompilerInfo/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="language" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">完全信任直接调用方。 此成员不能由部分信任的代码使用。</permission>
        <altmember cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateProvider(System.String)" />
        <related type="Article" href="~/docs/framework/configure-apps/file-schema/compiler/index.md">编译器和语言提供程序设置架构</related>
      </Docs>
    </Member>
    <Member MemberName="IsValidIdentifier">
      <MemberSignature Language="C#" Value="public virtual bool IsValidIdentifier (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsValidIdentifier(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsValidIdentifier (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsValidIdentifier(System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsValidIdentifier : string -&gt; bool&#xA;override this.IsValidIdentifier : string -&gt; bool" Usage="codeDomProvider.IsValidIdentifier value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">要验证为一个有效标识符的值。</param>
        <summary>返回一个值，该值指示指定的值是否是当前语言的有效标识符。</summary>
        <returns>如果 <paramref name="value" /> 参数是有效标识符，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法测试标识符是否有效。 方法<xref:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier%2A>是特定于提供程序的。 对于一个提供程序有效的标识符可能对其他提供程序无效。 如果`value`包含 ASCII 字符范围之外的字符, 请检查可用于编译代码的所有语言的标识符。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>当在<see cref="M:System.CodeDom.Compiler.CodeDomProvider.IsValidIdentifier(System.String)" />派生类中重写时, 将方法设计<see langword="true" />为仅当值符合语言的规则并且不与关键字冲突时返回。  
  
如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
      </Docs>
    </Member>
    <Member MemberName="LanguageOptions">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.Compiler.LanguageOptions LanguageOptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.CodeDom.Compiler.LanguageOptions LanguageOptions" />
      <MemberSignature Language="DocId" Value="P:System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LanguageOptions As LanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::CodeDom::Compiler::LanguageOptions LanguageOptions { System::CodeDom::Compiler::LanguageOptions get(); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOptions : System.CodeDom.Compiler.LanguageOptions" Usage="System.CodeDom.Compiler.CodeDomProvider.LanguageOptions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.LanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取语言功能标识符。</summary>
        <value>指示语言的特殊功能的 <see cref="T:System.CodeDom.Compiler.LanguageOptions" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public virtual System.CodeDom.CodeCompileUnit Parse (System.IO.TextReader codeStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse(class System.IO.TextReader codeStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Parse(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Parse (codeStream As TextReader) As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::CodeDom::CodeCompileUnit ^ Parse(System::IO::TextReader ^ codeStream);" />
      <MemberSignature Language="F#" Value="abstract member Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit&#xA;override this.Parse : System.IO.TextReader -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomProvider.Parse codeStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codeStream" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="codeStream">用于读取待分析代码的 <see cref="T:System.IO.TextReader" /> 对象。</param>
        <summary>将从指定文本流读取的代码编译进 <see cref="T:System.CodeDom.CodeCompileUnit" />。</summary>
        <returns><see cref="T:System.CodeDom.CodeCompileUnit" />，包含已分析代码的表示形式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeParser>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateParser%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeParser>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateParser" />的方法在派生类中创建分析器, 以便与使用代码分析器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeParser" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码分析器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <altmember cref="T:System.IO.TextReader" />
      </Docs>
    </Member>
    <Member MemberName="Supports">
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport generatorSupport) cil managed" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport generatorSupport);" FrameworkAlternate="netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0" />
      <MemberSignature Language="C#" Value="public virtual bool Supports (System.CodeDom.Compiler.GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Supports(valuetype System.CodeDom.Compiler.GeneratorSupport supports) cil managed" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Supports(System::CodeDom::Compiler::GeneratorSupport supports);" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports generatorSupport" FrameworkAlternate="netframework-1.1;netcore-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Supports (supports As GeneratorSupport) As Boolean" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool&#xA;override this.Supports : System.CodeDom.Compiler.GeneratorSupport -&gt; bool" Usage="codeDomProvider.Supports supports" FrameworkAlternate="xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.CodeDom.Compiler.CodeDomProvider.Supports(System.CodeDom.Compiler.GeneratorSupport)" FrameworkAlternate="xamarinmac-3.0;netcore-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.CodeDom</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generatorSupport" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="supports" Type="System.CodeDom.Compiler.GeneratorSupport" Index="0" FrameworkAlternate="xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="generatorSupport">一个 <see cref="T:System.CodeDom.Compiler.GeneratorSupport" /> 对象，指示要验证的代码生成支持类型。</param>
        <param name="supports">To be added.</param>
        <summary>返回一个值，该值指示是否提供了指定的代码生成支持。</summary>
        <returns>如果提供了指定的代码生成支持，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以一次使用多个<xref:System.CodeDom.Compiler.GeneratorSupport>标志调用此方法, 通过将一组相应的功能标志与一个二元`OR`运算符 (&#124;) 相联接来测试一组功能。  
  
> [!NOTE]
>  在 .NET Framework 版本1.0 和1.1 中, 此方法由<xref:System.CodeDom.Compiler.ICodeGenerator>提供程序的<xref:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator%2A>方法返回的实现提供。 在版本2.0 中, 可以直接在代码提供程序上调用此方法, 即使代码提供程序未重写此方法。 如果代码提供程序不重写此方法, <xref:System.CodeDom.Compiler.ICodeGenerator>则由基类调用实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">此方法和 <see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" /> 方法均不在派生类中重写。</exception>
        <block subset="none" type="overrides"><para>如果重写此方法, 则不能调用基类的相应方法。 基类方法使用已过时<see cref="M:System.CodeDom.Compiler.CodeDomProvider.CreateGenerator" />的方法在派生类中创建一个生成器, 以便与使用代码生成器的预先存在的提供程序兼容。 然后, 基类方法调用<see cref="T:System.CodeDom.Compiler.ICodeGenerator" />实现中的等效方法来执行此函数。 <see cref="T:System.NotImplementedException" />如果从不使用代码生成器的代码提供程序调用基类方法, 则将收到。</para></block>
        <altmember cref="T:System.CodeDom.Compiler.GeneratorSupport" />
      </Docs>
    </Member>
  </Members>
</Type>
