<Type Name="WebPartManager" FullName="System.Web.UI.WebControls.WebParts.WebPartManager">
  <Metadata><Meta Name="ms.openlocfilehash" Value="301f51907edb77824b519dd87d773b1e3f2e9f22" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69394224" /></Metadata><TypeSignature Language="C#" Value="public class WebPartManager : System.Web.UI.Control, System.Web.UI.INamingContainer, System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit WebPartManager extends System.Web.UI.Control implements class System.Web.UI.INamingContainer, class System.Web.UI.WebControls.WebParts.IPersonalizable" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.WebPartManager" />
  <TypeSignature Language="VB.NET" Value="Public Class WebPartManager&#xA;Inherits Control&#xA;Implements INamingContainer, IPersonalizable" />
  <TypeSignature Language="C++ CLI" Value="public ref class WebPartManager : System::Web::UI::Control, System::Web::UI::INamingContainer, System::Web::UI::WebControls::WebParts::IPersonalizable" />
  <TypeSignature Language="F#" Value="type WebPartManager = class&#xA;    inherit Control&#xA;    interface INamingContainer&#xA;    interface IPersonalizable" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.Control</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.UI.INamingContainer</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.WebControls.WebParts.IPersonalizable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.NonVisualControl</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ParseChildren(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.PersistChildren(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.ViewStateModeById</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.WebControls.WebParts.WebPartManagerDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>用作 Web 部件控件集的中心类，管理所有的 Web 部件控件、功能和网页上发生的事件。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件充当 Web 部件应用程序的中心或控制中心。 在使用 Web 部件控件的每一页上都必须<xref:System.Web.UI.WebControls.WebParts.WebPartManager>有一个 (且仅有一个) 控件实例。 与 Web 部件应用程序的大多数方面一样, <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件仅适用于经过身份验证的用户。 此外, 其功能几乎完全适用于驻留在继承自<xref:System.Web.UI.WebControls.WebParts.WebZone>类 Web 部件区域中的服务器控件。 驻留在这些区域之外的页上的服务器控件的 Web 部件功能或与<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的交互可能非常小。  
  
 作为页面上 Web 部件功能的中心, <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件执行下表中所述的任务类型。  
  
|任务类别|控件的作用|  
|-------------------|---------------------------|  
|跟踪 Web 部件控件|跟踪页面上许多不同类型的控件, 这些控件提供 Web 部件功能, 包括<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、连接、区域等。|  
|添加和删除 Web 部件控件|提供用于在页上添加、删除和关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的方法。|  
|管理连接|在控件之间创建连接, 并监视连接以及添加和删除这些连接的过程。|  
|个性化控件和页面|使用户能够将控件移动到页面上的不同位置, 并启动用户可以在其中编辑控件外观、属性和行为的视图。 维护每个页面上的特定于用户的个性化设置。|  
|在不同的页面视图之间切换|在页面的不同专用视图之间切换页面, 以便用户可以执行某些任务, 如更改页面布局或编辑控件。|  
|引发 Web 部件生命周期事件|定义、引发并使开发人员能够处理 Web 部件控件的生命周期事件, 例如, 在添加、移动、连接或删除控件时。|  
|启用控件的导入和导出|导出包含<xref:System.Web.UI.WebControls.WebParts.WebPart>控件属性状态的 XML 流, 并允许用户导入文件, 以便于在其他页面或站点中个性化复杂控件。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类具有一组大的属性。 与跟踪其他<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的角色一致, 它具有多个属性, 这些属性可引用 Web 部件控件或其他特殊 Web 部件对象的集合。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>、 、、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>、 、和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性都<xref:System.Web.UI.WebControls.WebParts.WebPartManager>是控件用来进行跟踪的所有集合<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>管理任务。  
  
 另一组属性包含可自定义的警告, 这些警告适用于在 Web 部件应用程序中出现的某些方案。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>、、和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类将重写它的一些基继承属性, 这些属性由许多 Web 服务器控件使用。 其中包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性。  
  
 最后, 有一组属性可用于访问应用程序的当前状态。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性指示页面所在的当前显示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>属性指示是否允许控件呈现客户端脚本, 这在以下情况下适用: 用户可能具有具有不同功能的浏览器或已关闭脚本。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性用于引用包含对扩展性事例使用的大量重要 Web 部件方法的调用的实用工具类。 通过在单独的类 ( <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>类) 中隐藏对这些方法的调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager> , 可简化类的 API。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性提供对存储用户个性化设置并将该数据保存到永久存储的个性化对象的访问。 属性指示用户或应用程序当前选择的页上的控件。<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> 属性指示<xref:System.Web.UI.WebControls.WebParts.WebPart>控件上的自定义个性化设置数据是否已更改。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件包含五种内置显示模式或网页视图。 开发人员可以扩展此功能, 通过扩展<xref:System.Web.UI.WebControls.WebParts.WebZone>类<xref:System.Web.UI.WebControls.WebParts.ToolZone>或类等类型来创建自定义显示模式。 如果页面上存在对应于给定显示模式的适当类型的控件, 则用户可以将页面切换到各种显示模式。  
  
> [!NOTE]
>  可以扩展此功能, 以便用户可以切换到自定义显示模式, 而无需在页面上放置相应的区域。 但是, 默认行为是显示模式与区域相对应。  
  
 标准显示模式由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类中的公共字段表示。 下表汇总了字段及其引用的显示模式。 正如前文所述, 页面的当前显示模式始终在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性中引用, 在特定页面上可能出现的显示模式集 (给定页面上存在的区域类型) 包含<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>在属性中。  
  
|字段|显示模式详细信息|  
|-----------|--------------------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>|网页的普通用户视图;默认和最常见的显示模式。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>|用户可以重新排列或删除控件以更改页面布局的视图。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>|编辑用户界面 (UI) 变为可见的视图;用户可以编辑在正常浏览模式下可见控件的外观、属性和行为。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>|目录 UI 变为可见的视图;用户可以将控件从可用控件的目录添加到页面。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>|连接 UI 将在其中可见的视图;用户可以连接、管理或断开控件之间的连接。|  
  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还包含大量事件, 这些事件在 Web 部件页面和控件的生命周期内非常重要。 这些事件提供对 Web 部件控件的行为的精确编程控制。 大多数方法直接与<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (或放置在区域中<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>的其他服务器或用户控件) 相关, 以便它们能够作为<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 但有些事件涉及页面的状态或页面上的连接。 下表列出了可用的事件并汇总了其用途。  
  
> [!NOTE]
>  在下表中的所有情况下, "控件" 一<xref:System.Web.UI.WebControls.WebParts.WebPart>词是指位于区域中的控件或任何服务器控件, 并在运行时<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>使用对象进行包装。  
  
|事件|说明|  
|-----------|-----------------|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>|恰好在将控件添加到页面之前发生, 以验证它是否已获授权。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>|在页面上的所有连接都已激活之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>|恰好在激活页上的所有连接的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>|在页的当前显示模式更改之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>|恰好在更改页的显示模式的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>|在取消选定控件后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>|恰好在取消选择控件之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>|在将控件添加到区域之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>|恰好在将控件添加到区域的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>|在控件关闭 (从页中移除) 后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>|恰好在关闭控件的进程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>|在永久删除动态控件 (以编程方式创建或从目录中添加的控件) 的实例之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>|恰好在删除动态控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>|控件在其区域内移动或移动到另一个区域后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>|恰好在移动控件的进程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>|在为连接选择的两个控件已建立连接之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>|恰好在连接两个控件的过程之前发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>|在两个连接的控件断开连接之后发生。|  
|<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>|恰好在断开两个控件的连接过程之前发生。|  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有大量用于管理 Web 部件页面的方法。 此处未列出的一大组方法是其名称采用的形式为 On*事件*名称的方法。 这些方法通常会引发相关事件, 并为事件提供类型<xref:System.Web.UI.WebControls.WebParts.WebPartEventHandler>的处理程序。 这些方法中的大多数可由继承自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类的开发人员重写。 此外, 页开发人员还可以为与这些方法关联的事件提供自定义处理程序。 例如, 在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>发生事件的情况下, 页面开发人员可以`OnWebPartAdded`将属性添加到网页标记`<asp:webpartmanager>`中的元素, 然后将自定义方法名称分配给该属性, 以便为事件提供自定义处理。 特性对应<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>于方法, 而事件处理的基本模式适用于大多数 Web 部件事件及其关联方法。  
  
 此外, 该<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有特定于管理<xref:System.Web.UI.WebControls.WebParts.WebPart>控件 (和用作<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的服务器控件或用户控件) 的任务的方法。 这些方法包括<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>、 、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A> 、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>、 、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>、和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>。  
  
 另一组方法专用于连接。 其中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>包括、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A> 、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>、、 、、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>、和等方法。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>  
  
 最后, 一些<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法侧重于个性化设置功能。 它们包括 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>、<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 和 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>。  
  
 有关可<xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>通过属性访问的其他方法的详细信息, <xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals>请参阅类的文档。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的声明性和编程式使用。  
  
 此代码示例包含四个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页, 其中包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的自定义控件和一个`<asp:webpartmanager>`元素。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 用户控件具有一个下拉列表控件, 该控件在给定页面上存在的 Web 部件控件的情况下, 显示页面上可能的显示模式。 在此代码示例的网页中, 此用户控件刚好在页面标记中的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素下方声明, 并在网页顶部附近有一个`Register`指令来注册控件。 有关显示模式的详细信息以及此控件中源代码的说明, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/displaymodemenucs.ascx#6)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/DisplayModeMenuVB.ascx#6)]  
  
 网页的声明性标记包含`Register`用户控件和自定义控件的指令。 有一个`<asp:webpartmanager>`元素、一个`<asp:webpartzone>`元素包含自定义控件和一个`<asp:connectionszone>`元素。 该页还包含一些用于处理<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的与连接相关的事件的内联代码; 你可以在连接和断开连接控件时查看此代码的效果。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 请注意, 有一个名为`IZipCode`的接口, 此接口是`ZipCodeWebPart`在类中实现的。 此类具有一个名`ProvideIZipCode`为的特殊回调方法, 用作提供程序。 另一种名`WeatherWebPart`为的类型也是使用名为`GetIZipCode`的特殊方法实现的, 该方法使控件可以作为另一个控件的使用者。  
  
 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此代码示例假定已将源编译为程序集, 网页中的`Register`指令引用程序集名称。 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_SimpleConnection#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/ZipCodeComponent.vb#2)]  
  
 在浏览器中加载网页后, 请单击 "**显示模式**" 下拉列表控件, 然后选择 "**连接**", 将页面切换到连接模式。 连接模式使用`<asp:connectionszone>`元素使您能够在控件之间创建连接。 在连接模式下, 单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单, 然后单击 "**连接**"。 显示连接 UI 后, 单击 "**创建使用者的连接**" 链接。 出现包含下拉列表控件的单元格。 在下拉列表中选择 "**天气控制**", 然后单击 "**连接**" 以完成两个控件的连接。 单击 "**关闭**", 然后使用 "**显示模式**" 下拉列表将页面恢复到正常浏览模式。 您可以输入邮政编码, 并使用您输入的值更新使用者控件。 由于该`Personalizable`属性在源代码中标记有特性, 因此此属性值将在浏览器会话中保持不变, 从而保存用户输入的值。 `ZipCode` 更复杂的使用者控件可以采用邮政编码信息, 根据代码查找天气信息, 并将其显示给用户。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件设计为扩展。 由于这是 Web 部件应用程序的核心, 因此当你想要在 Web 部件控件集中扩展某些特定类型或控件时, 在许多情况下, 你还<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />必须扩展类, 因为它可能有一些需要进行的属性或方法 自定义类型在 Web 部件应用程序的上下文中工作。 Web 部件引用文档 (请参阅<see cref="N:System.Web.UI.WebControls.WebParts" />), 讨论如何扩展 Web 部件类型时, 通常会提到还需要执行哪些操作来<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />扩展类, 或者在代码示例中演示如何对其进行扩展。</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public WebPartManager ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; WebPartManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 构造函数初始化<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用的几个重要变量。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.%23ctor%2A> 一个直接影响所有 Web 部件页面的分配是默认页面显示模式设置为浏览模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>) 这一事实。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActivateConnections">
      <MemberSignature Language="C#" Value="protected virtual void ActivateConnections ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ActivateConnections() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ActivateConnections ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ActivateConnections();" />
      <MemberSignature Language="F#" Value="abstract member ActivateConnections : unit -&gt; unit&#xA;override this.ActivateConnections : unit -&gt; unit" Usage="webPartManager.ActivateConnections " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>激活网页上当前所有非活动连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>页的每个请求调用方法, 以激活和区域中的<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>其他服务器控件之间的现有连接。 在某些情况下, 例如, 如果要激活的连接中存在冲突, 则此方法将调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法以终止有问题的连接。 在断开连接过程<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>中, 会引发事件。 通常, 开发人员可以取消此事件, 但在这种情况下, 不能取消这种连接, 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件需要解决冲突, 才能完成激活连接的过程。 有关详细信息, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>请参阅事件。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart AddWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPart AddWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPart ^ AddWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="member this.AddWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.AddWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要添加至网页或在页上打开的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或服务器或用户控件）。</param>
        <param name="zone">向其添加 <paramref name="webPart" /> 的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，表示 <paramref name="webPart" /> 在 <paramref name="zone" /> 中占用的序号位置（相对于 <paramref name="zone" /> 中的其他控件）。</param>
        <summary>提供向网页添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的标准编程方法。</summary>
        <returns>添加到页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法用于将新的动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到页, 并重新打开先前在页中关闭的静态控件或动态控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> 调用方法添加新的控件时, 实际上会创建在`webPart`参数中引用的控件的副本。 为控件的副本生成新的 ID, 因此开发人员应引用<xref:System.Web.UI.WebControls.WebParts.WebPart>从方法返回的控件以获取新的 ID 值。 调用方法以重新打开先前关闭的控件时, 它将返回对`webPart`参数引用的控件的直接引用。  
  
> [!IMPORTANT]
>  应始终<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>使用方法, 而不是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A?displayProperty=nameWithType> <xref:System.Web.UI.ControlCollection.Add%2A>由属性引用的控件集合的方法, 以编程方式将控件添加<xref:System.Web.UI.WebControls.WebParts.WebPart>到页面, 因为使用<xref:System.Web.UI.ControlCollection.Add%2A>方法引发异常。 若要<xref:System.Web.UI.WebControls.WebParts.WebPart>添加一个不是控件的控件 (即, 在运行时将<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>使用控件进行包装的服务器控件), <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>则应首先调用方法以<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>创建该控件, 然后调用方法以添加控件。 有关此方法的演示, 请参阅 "示例" 部分。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>方法以编程方式将服务器控件添加到页中。 页面标记包含一个空`<asp:webpartzone>`元素和一个`<asp:webpartmanager>`元素。 第一次单击 "**添加日历**" 按钮时, 事件处理程序中的代码会<xref:System.Web.UI.WebControls.Calendar>创建一个控件, 并将其作为<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象添加到区域中, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A>并调用方法。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="zone" /> 没有在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的区域集合中注册。  
  
或 
 <paramref name="webPart" /> 已存在于 <paramref name="zone" /> 中。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> 的值小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="AuthorizeWebPart">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler AuthorizeWebPart" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AuthorizeWebPart As WebPartAuthorizationEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventHandler ^ AuthorizeWebPart;" />
      <MemberSignature Language="F#" Value="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " Usage="member this.AuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当调用 <see cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" /> 方法以确定 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件是否能够添加到页中时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 每当将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>控件添加到页面时,都会发生此事件。<xref:System.Web.UI.WebControls.WebParts.WebPart> 在许多常见情况下, 可以将控件添加到页面中。 有关这些内容的完整说明, 请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法的 "备注" 部分。 添加控件时, 必须对其进行检查, 以确定是否<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>已设置控件的属性, 如果是, 是否已授权控件添加到页中。  
  
 开发人员可以为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件创建事件处理程序, 以提供控件的筛选。 如果控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性值不符合事件处理程序代码中的条件, 则不会将该控件添加到页中。  
  
   
  
## Examples  
 下面的代码示例演示如何设置<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件的自定义事件处理程序, 该事件处理程序会自动覆盖默认<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法。  
  
 `mgr1_AuthorizeWebPart`方法中的代码检查页上的控件是否将其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>的属性值设置为`user` , 如果是, 则返回`true`, 这意味着它们将获得授权并添加到页中。 这假定默认方法是允许用户在用户个性化设置范围内查看页面中的控件。 但请注意, 在该示例中, 其中一个控件<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>的属性值设置为。 `admin` 开发人员可能会将此筛选器置于专用控件上, 此控件仅供管理用户查看。 此控件将在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件期间无法执行授权检查, 且不会显示。 请注意, 也将显示未设置属性的控件;假设它们不属于筛选方案, 因为未设置其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="AvailableTransformers">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection AvailableTransformers" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AvailableTransformers As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ AvailableTransformers { System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AvailableTransformers : System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象的集合，这些对象可用于在服务器控件之间创建 Web 部件连接。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.TransformerTypeCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers%2A>方法来创建集合。 默认情况下, 它从应用程序配置文件中读取可用的转换器。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178187(v=vs.100)">Web 部件连接概述</related>
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartConnecting (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartConnecting(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartConnecting(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartConnecting : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartConnecting webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正为其建立连接的控件。</param>
        <summary>开始连接两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 存在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法, 以便在不同的阶段中形成控制连接的过程, 使开发人员可以更好地控制连接过程。 方法执行一组初始检查以确保`webPart`处于可以合法形成连接的状态。 如果`webPart`通过所有检查, 则将其设置为当前选定的控件 ( <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>请参见属性), 连接进程可以继续。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 已关闭。  
  
- 或 - 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
- 或 - 
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <block subset="none" type="overrides"><para>需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件的开发人员可能希望在派生类中重写此方法。 一种方法是调用基方法, 然后添加一些附加的自定义处理;或者, 您可能希望完全自定义在控件之间启动连接的过程。 例如, 你可能想要在创建连接之前验证某些数据是否可用。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      </Docs>
    </Member>
    <Member MemberName="BeginWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void BeginWebPartEditing (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginWebPartEditing(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginWebPartEditing(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.BeginWebPartEditing : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.BeginWebPartEditing webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要编辑的控件。</param>
        <summary>开始 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的编辑过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法存在, 使得编辑控件的过程可以在不同的阶段完成, 使开发人员可以更好地控制进程。 方法执行一组初始检查以确保`webPart`处于可以编辑的状态。 如果`webPart`通过所有检查, 则将其设置为当前选定的控件 ( <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>请参见属性), 并且编辑过程可以继续。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">页上的当前显示模式不是 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 已关闭。  
  
或 
 <paramref name="webPart" /> 不是 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合的组成部分。  
  
- 或 - 
 <paramref name="webPart" /> 等于 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 控件。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="BrowseDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode BrowseDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BrowseDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ BrowseDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable BrowseDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示包含 Web 部件控件的页的默认显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字段引用由控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>创建<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>并包含的自定义对象。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode> 因为这是一个静态对象, 所以可以直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类引用它, 而无需控件的实例。  
  
 当包含 Web 部件控件的页面首次加载时, 默认情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>下它处于 (浏览模式)。 当用户只是在正常网页上浏览时, 该页面仍处于浏览模式。 如果用户想要对页面的布局、控件、外观或行为进行个性化设置, 则必须将页面切换为通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性提供的专用显示模式之一。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>字段。 此代码使用受支持的显示模式 (在本例中为 "浏览" 和 "设计") 填充下拉列表。 请注意, 在`Page_PreRender`方法中, 代码检查当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性是否设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>。 如果是这样`Label1` , 将显示, 如果`Label1`不可见, 将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/CS/wpmgrBrowseDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_BrowseDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_BrowseDisplayMode/VB/wpmgrBrowseDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后, 默认情况下处于浏览模式。 请注意页面上的标签, 指示你处于浏览模式。 使用下拉列表控件将页面切换到设计模式。 请注意, 由于`Page_PreRender`方法中的代码, 标签现在处于隐藏状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CanConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定它们是否能够被连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法用于确定是否可以连接两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A> 方法通常在调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法之前用作条件检查。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法在两个控件可以形成连接之前, 检查必须满足的条件数。 以下列表汇总了建立连接的主要标准。 如果满足所有这些条件 (以及其他一些内部条件), 该方法将返回`true`, 这意味着控件可以连接:  
  
-   提供程序和使用者控件不`null`能是, 并且它们必须包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性引用的控件的集合中。  
  
-   提供程序和使用者不能为同一个控件。 换句话说, <xref:System.Web.UI.WebControls.WebParts.WebPart>控件无法连接到自身。  
  
-   提供程序和使用者的`null`对象(连接点)不能为。<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint>  
  
-   提供程序和使用者无法关闭 (控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.IsClosed%2A>属性不能为`true`)。  
  
-   连接点控件的属性必须与使用者和提供者的控件类型匹配。<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.ControlType%2A>  
  
-   必须同时启用连接点 (其<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.GetEnabled%2A>方法必须同时返回`true`)。  
  
-   每个连接点不能尝试建立比它自己<xref:System.Web.UI.WebControls.WebParts.ConnectionPoint.AllowsMultipleConnections%2A>的属性中所指定内容更多的连接。  
  
-   如果连接不兼容的控件需要`null`对象(转换器),则它不能为。<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer> 但是, 如果控件已兼容, 则转换必须为`null`。  
  
-   转换器 (如果使用) 必须在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers%2A>集合中引用。  
  
-   转换器 (如果使用) 必须具有与提供程序和使用者兼容的接口, 以便它能够在两个控件之间转换数据。 使用者和提供程序的辅助接口也必须兼容。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <paramref name="consumer" /> 提供数据的控件。</param>
        <param name="providerConnectionPoint">使 <paramref name="provider" /> 能够参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />。</param>
        <param name="consumer">控件连接时从 <paramref name="provider" /> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="consumer" /> 可以参与连接。</param>
        <summary>当使用者和提供者控件有兼容接口且不需要 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象时，请检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 控件，以确定它们是否能够被连接。</summary>
        <returns>一个布尔值，指示是否能连接 <paramref name="provider" /> 和 <paramref name="consumer" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于`consumer`在两个`provider`控件都具有兼容的连接点<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>类型的情况下进行连接, 因此不需要对象。 您可能想要使用此方法来验证是否可以连接两个控件, 然后<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>再调用来创建编程连接。  
  
 此重载使用与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法重载相同的实现, 唯一的例外是此重载不需要转换器。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法。  
  
 此代码示例包含四个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页, 其中包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的自定义控件、 `<asp:webpartmanager>`一个元素, 以及一些使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>方法创建连接的事件处理代码。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 网页的声明性标记包含`Register`用户控件和自定义控件的指令。 有一个`<asp:webpartmanager>`元素、一个`<asp:webpartzone>`元素包含自定义控件和一个`<asp:connectionszone>`元素。 请注意, 在`Page_Load`方法中, 代码检查是否可以建立连接, 如果是, 则定义提供程序、使用者及其各自的连接点, 然后将新连接添加到由<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>引用的静态连接集属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 它包含一个接口和两个<xref:System.Web.UI.WebControls.WebParts.WebPart>自定义控件, 一个充当提供程序, 另一个作为使用者。 由于它们具有兼容的连接点 (这两个连接`IZipCode`点识别接口), 因此不需要使用转换器来建立连接。 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_StaticConnections#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/ZipCodeComponent.vb#2)]  
  
 在浏览器中加载网页后, 请单击 "**显示模式**" 下拉列表控件, 然后选择 "**连接**", 将页面切换到连接模式。 连接模式使用`<asp:connectionszone>`元素使您能够在控件之间创建连接。 在连接模式下, 单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单, 然后单击 "**连接**"。 连接用户界面 (UI) 出现后, 请注意, 连接已由`Page_Load`方法中包含的代码创建。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CanConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual bool CanConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool&#xA;override this.CanConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; bool" Usage="webPartManager.CanConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">在控件连接时为 <paramref name="consumer" /> 提供数据的控件。</param>
        <param name="providerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="provider" /> 可以参与连接。</param>
        <param name="consumer">控件连接时从 <paramref name="provider" /> 接收数据的控件。</param>
        <param name="consumerConnectionPoint">一个 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" />，它作为回调方法，以便 <paramref name="consumer" /> 可以参与连接。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它使不兼容的 <paramref name="provider" /> 和 <paramref name="consumer" /> 能够进行连接。</param>
        <summary>检查将参与连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，以确定这些控件是否能够连接，并使用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在不兼容的使用者和提供者之间创建连接。</summary>
        <returns>一个布尔值，它指示 <paramref name="provider" /> 和 <paramref name="consumer" /> 是否可以形成连接。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法用于连接`provider` , 并且`consumer`在两个控件都具有不兼容的连接点<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>类型时, 因此需要对象。 您可能想要使用此方法来验证是否可以连接两个控件, 然后<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>再调用来创建编程连接。  
  
 此重载使用与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法重载相同的实现, 唯一的例外是此重载需要转换器。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CatalogDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode CatalogDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CatalogDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ CatalogDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable CatalogDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于从控件目录向网页添加服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字段引用由控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>创建<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>并包含的自定义对象。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> 因为这是一个静态对象, 所以可以直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类引用它, 而无需控件的实例。  
  
 当用户想要将控件添加到页面时, 如果服务器控件的目录可用, 则可以将页面切换到<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode> (目录模式), 并显示目录用户界面 (UI)。 Web 部件目录的 UI 由<xref:System.Web.UI.WebControls.WebParts.CatalogZoneBase>区域控件提供。 开发人员在设计时将此区域添加到页面, 然后将服务器控件添加到区域, 以便用户能够在运行时将这些控件添加到页面中。 开发人员添加这些控件后, 目录模式将在页面上变为受支持的显示模式, 因为必要的控件可用于启用目录模式。  
  
 当用户将页面切换到目录模式时, 区域以及添加到其中的所有服务器控件都变为可见, 用户可以从目录中选择要添加到页面的控件, 或者从页面中删除控件。 将控件添加到页面后, 它们将以正常的浏览模式显示, 并更新页面。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>字段。 此代码使用页面支持的显示模式填充下拉列表, 在此示例中为 "浏览"、"设计" 和 "目录"。 由于在网页中有`<asp:CatalogZone>`元素及其子元素, 因此目录模式可用。 请注意, 在`Page_PreRender`方法中, 代码检查当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性是否设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>。 如果是这样`Label1` , 将显示, 如果`Label1`不可见, 将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/CS/wpmgrCatalogDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CatalogDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CatalogDisplayMode/VB/wpmgrCatalogDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后, 默认情况下处于浏览模式。 请注意, 页面上的标签处于隐藏状态。 使用下拉列表控件将页面切换到目录模式。 请注意, 由于`Page_PreRender`方法中的代码, 标签现在可见。 可以在目录中选择控件, 并将其添加到页面上两个区域中的任意一个。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CheckRenderClientScript">
      <MemberSignature Language="C#" Value="protected virtual bool CheckRenderClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool CheckRenderClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CheckRenderClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CheckRenderClientScript () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool CheckRenderClientScript();" />
      <MemberSignature Language="F#" Value="abstract member CheckRenderClientScript : unit -&gt; bool&#xA;override this.CheckRenderClientScript : unit -&gt; bool" Usage="webPartManager.CheckRenderClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查发出请求的浏览器的功能，并检查 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" /> 属性的值，以确定是否呈现客户端脚本。</summary>
        <returns>一个布尔值，指示是否呈现客户端脚本。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CloseProviderWarning">
      <MemberSignature Language="C#" Value="public virtual string CloseProviderWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CloseProviderWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property CloseProviderWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CloseProviderWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CloseProviderWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个警告，用户关闭在连接中充当其他控件的提供者的控件时，会显示该警告。</summary>
        <value>一个包含警告消息的字符串。 默认值是一条由 .NET Framework 提供的、特定于区域性的消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件时, 通常不会显示任何消息。 有关关闭控件的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法的详细信息, 请参阅方法。  
  
 但是, 当控件连接到其他控件并作为数据的提供程序时, 当用户尝试关闭控件时, 将显示默认警告消息。 消息告知用户提供程序控件即将关闭, 这意味着以使用者身份连接到此提供程序的控件将不再具有任何要使用的数据。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性使开发人员可以自定义向用户显示的警告消息。  
  
 如果页面开发人员将空或空字符串值分配给此属性, 则当用户关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>作为提供者的控件时, 将不会显示任何警告消息框。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性向用户显示自定义警告。  
  
 此代码示例包含四个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   一个网页, 其中包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的自定义控件和`<asp:webpartmanager>`一个元素。  
  
-   说明如何在浏览器中工作。  
  
 下面的代码仅包含示例的网页部分。 还需要为上述自定义控件提供自定义用户控件和源代码。 从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取这两个项。  
  
 以下网页代码演示了如何在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A> `<asp:webpartmanager>`元素中的声明性标记中将自定义警告消息分配给属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseProviderWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseProviderWarning/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 在浏览器中加载网页后, 请单击 "**显示模式**" 下拉列表控件, 然后选择 "**连接**", 将页面切换到连接模式。 连接模式使用`<asp:connectionszone>`元素使您能够在控件之间创建连接。 在连接模式下, 单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单, 然后单击 "**连接**"。 连接用户界面 (UI) 出现后, 单击 "**创建使用者的连接**" 链接。 出现包含下拉列表控件的单元格。 在下拉列表中选择 "**天气控制**", 然后单击 "**连接**" 完成两个控件的连接。 单击 "**关闭**", 然后使用 "**显示模式**" 下拉列表将页面恢复到正常浏览模式。 最后, 单击**邮政编码**控件的谓词菜单 (在本例中为提供程序控件), 然后选择 "**关闭**"。 随即显示您分配给该<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseProviderWarning%2A>属性的自定义消息。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CloseWebPart">
      <MemberSignature Language="C#" Value="public void CloseWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CloseWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CloseWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.CloseWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.CloseWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 中关闭的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件。</param>
        <summary>以不在网页上呈现，但可以重新打开的方式关闭 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPart>删除或其他服务器控件, 使其不会在最初包含它的网页上呈现。 将关闭的控件添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象中, 该对象维护对已关闭控件的引用, 并使控件可以还原到页面。 关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>的控件仍会出现在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性引用的集合中。  
  
 关闭控件不同于删除控件。 关闭的控件仍可还原到页面, 但已删除的控件实例将被永久删除且永远无法还原。 <xref:System.Web.UI.WebControls.WebParts.WebPart>无论或服务器控件是静态的 (在页的标记中声明) 还是动态的 (以编程方式或从 Web 部件目录中的用户添加), 都可以在页上关闭和重新打开。  
  
 通常, 用户可以通过单击<xref:System.Web.UI.WebControls.WebParts.WebPart>其谓词菜单并选择 "关闭" 谓词来关闭控件。 还可以通过直接调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>方法并向`webPart`其传递对的引用来关闭控件。  
  
 在<xref:System.Web.UI.WebControls.WebParts.WebPart>控件已关闭的页上, 如果开发人员声明一个`<asp:catalogzone>`元素, 并在其中添加一个`<asp:pagecatalogpart>`元素, 则它将为用户提供一个简单的用户界面 (UI), 使用户能够在运行时将关闭的控件还原到该页。 用户可以将页面切换到目录显示模式, 而关闭的控件将显示在页目录中。 用户可以选择 "已关闭" 的控件并将其添加回页面所需的任何位置, 然后将所选控件还原到页面并呈现为正常。  
  
 调用方法时, 它会引发几个<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件: <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>(如果有多个控件) 和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> (如果存在连接的控件)。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 通常, 开发人员可以取消这些事件, 但在某些情况下, 不可能取消这些事件。 有关详细信息, 请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件的文档。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> 方法。  
  
 此代码示例包含四个部分:  
  
-   允许您更改页面显示模式的用户控件。  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 此代码示例的第二部分是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此示例使用动态编译方法;因此, 此控件在网页顶部`Register`的指令中没有属性。`Assembly` 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_CloseWebPart#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/textdisplaywebpart.vb#3)]  
  
 此代码示例的第三部分是网页。 页面包含一个<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域, 其中声明了`<asp:pagecatalogpart>`元素。 这就是将包含已关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>控件并使用户能够将其添加回页面的内容。 方法直接调用方法来关闭自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件, 但用户也可以通过谓词菜单关闭控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A> `Button1_Click`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/CS/closeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_CloseWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CloseWebPart/VB/closeWebPartVB.aspx#1)]  
  
 在浏览器中加载页面后, 通过单击控件标题<xref:System.Web.UI.WebControls.WebParts.WebPart>中的谓词菜单 (箭头符号), 然后单击 "**关闭**", 关闭自定义控件。 现在, 通过在 "**显示模式**" 下拉列表控件中选择 "**目录**", 将页面更改为目录模式。 页面目录显示为关闭的控件。 选中关闭的控件旁边的复选框, 单击 "**添加**" 将其添加到页面, 然后单击 "**关闭**" 以将该页返回到浏览模式。 控件将还原到页面。 现在, 单击 "**关闭 WebPart** " 按钮, 此时将其关闭。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。  
  
- 或 - 
 <paramref name="webPart" /> 是共享控件，并已被另一个用户关闭。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowClose" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode ConnectDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ConnectDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ ConnectDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable ConnectDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于显示特殊用户界面 (UI) 以便用户管理 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字段引用由控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>创建<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>并包含的自定义对象。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode> 因为这是一个静态对象, 所以可以直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类引用它, 而无需控件的实例。  
  
 当用户想要管理网页上<xref:System.Web.UI.WebControls.WebParts.WebPart>的控件之间的连接时, <xref:System.Web.UI.WebControls.WebParts.ConnectionsZone>如果已在页面上声明了区域, 则可以将页面<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>切换到模式。 "连接" 显示模式显示用于管理连接的特殊 UI, 其中包括连接控件或断开连接的功能, 以及编辑现有连接的详细信息。  
  
 如果希望为用户提供管理 Web 部件控件集提供的 UI 的连接的功能, 则必须在页的标记中声明一个`<asp:connectionszone>`元素。 与其他类型的<xref:System.Web.UI.WebControls.WebParts.WebZone>区域的元素不同, 无需在此元素中添加任何其他标记; 只需自行声明元素。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>模式的用法。  
  
 此代码示例包含三个部分:  
  
-   一个源文件, 其中包含可形成连接的<xref:System.Web.UI.WebControls.WebParts.WebPart>接口和自定义控件。  
  
-   提供连接 UI 并演示如何<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>使用模式的网页。  
  
-   有关如何运行该示例的说明。  
  
 此代码示例的第一部分是一个源文件, 其中包含一个接口和两个自<xref:System.Web.UI.WebControls.WebParts.WebPart>定义控件, 这些控件设计为可以连接。 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此代码示例使用动态编译方法。 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_ConnectDisplayMode#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ZipCodeComponent.vb#2)]  
  
 该示例的第二部分是承载自定义控件的网页。 页面上的`<script>`服务器标记中有几种方法, 这些方法使用页面上可用的显示模式填充下拉列表。 用户可以从下拉列表中进行选择, 以更改页面的显示模式。 其中一种可用的显示模式是连接显示模式, 因为`<asp:connectionszone>`在页的标记中声明了元素。 请注意, 此元素不包含任何其他子元素;它只是为了为用户启用连接管理 UI。  
  
 在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>此示例中, 模式显示在两个位置。 首先, 在`Page_Init`方法中, 将连接显示模式添加到显示模式的下拉列表中, 因为代码会遍历<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性中引用的集合。 其次, `Page_PreRender`方法检查页上的当前显示模式, 如果当前模式为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>, 则在<xref:System.Web.UI.WebControls.Label>控件中显示一条消息。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/CS/ConnectDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectDisplayMode/VB/ConnectDisplayModeVB.aspx#1)]  
  
 在浏览器中加载页面后, 单击下拉列表, 然后选择 "**连接**", 将页面切换到 "连接" 显示模式。 请注意, 会显示一条消息, 告知你该页处于连接显示模式。 现在, 单击其中一个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的标题栏中的谓词菜单 (箭头符号), 然后在谓词菜单中单击 "**连接**"。 显示连接 UI 后, 单击该链接以创建连接。 使用 "连接" UI 中显示的下拉列表, 选择将参与连接的其他控件, 并单击 "**连接**" 按钮。 建立连接。 单击 "**关闭**" 按钮, 然后使用页面顶部的下拉列表返回页面以浏览显示模式。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="Connections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection Connections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ Connections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Connections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有当前连接的集合的引用。</summary>
        <value>包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" /> 对象的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性提供了一种方法来访问页面上的当前连接集。 集合本身是只读的, 并且想要从集合中操作特定连接的开发人员应使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>等方法。  
  
   
  
## Examples  
 下面的代码示例演示如何以声明方式和编程<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方式使用控件。  
  
 此代码示例包含四个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页, 其中包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的自定义控件和一个`<asp:webpartmanager>`元素。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 下面的代码仅包含示例的网页部分。 还需要为上述自定义控件提供自定义用户控件和源代码。 从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取这两个项。  
  
 以下网页代码演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>属性来获取页面上当前连接的计数。 请注意, 在`<script>` "标记" 部分中, 用于处理<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的两个事件的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Connections%2A>代码将访问属性以获取计数。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/CS/webpartmanagerConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SimpleConnection#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SimpleConnection/VB/webpartmanagerConnectionVB.aspx#1)]  
  
 在浏览器中加载网页后, 请单击 "**显示模式**" 下拉列表控件, 然后选择 "**连接**", 将页面切换到连接模式。 连接模式使用`<asp:connectionszone>`元素使您能够在控件之间创建连接。 在连接模式下, 单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单, 然后单击 "**连接**"。 显示连接用户界面 (UI) 后, 单击 "**创建使用者的连接**" 链接。 出现包含下拉列表控件的单元格。 在下拉列表中选择 "**天气控制**", 然后单击 "**连接**" 完成两个控件的连接。 单击 "**关闭**", 然后使用 "**显示模式**" 下拉列表将页面恢复到正常浏览模式。 请注意, 标签现在显示连接数以及<xref:System.Web.UI.WebControls.WebParts.WebPart>控件数。 如果你现在返回到连接模式并断开两个控件的连接, 则当你返回到浏览模式时, 应更新标签的内容, 并且不应建立任何连接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivated">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivated" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivated;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivated : EventHandler " Usage="member this.ConnectionsActivated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在页上的所有当前 Web 部件连接不仅已经连接，而且已经开始在每个连接所涉及的使用者控件和提供者控件之间共享数据之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在连接的生命周期中, 此事件在页面完成其加载过程之后发生。 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件也会在事件之后发生, 该事件只<xref:System.Web.UI.WebControls.WebParts.WebPart>指示特定连接所涉及的或服务器控件已成功连接。 如果页面上有多个连接, 则该<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>方法表示页面上的所有有效 Web 部件连接现在处于活动状态并且可以共享数据。 了解所有连接都是活动的, 开发人员可以执行任意数量的任务, 包括向用户通知所有连接的状态, 通知使用者控件处理和显示来自其提供程序的数据等。  
  
 此事件与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A>方法相关联, 该方法引发事件并允许开发人员为事件创建自定义处理程序。  
  
 页面开发人员可以为事件创建自定义处理程序, 方法`OnConnectionsActivated`是将属性`<asp:webpartmanager>`添加到页面中的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectionsActivating">
      <MemberSignature Language="C#" Value="public event EventHandler ConnectionsActivating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ConnectionsActivating" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ConnectionsActivating As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ConnectionsActivating;" />
      <MemberSignature Language="F#" Value="member this.ConnectionsActivating : EventHandler " Usage="member this.ConnectionsActivating : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在激活网页上所有已建立的 Web 部件连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在连接的生命周期中, 此事件在页面完成其加载过程之后, 就在调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>方法之前发生。 它与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件不同, 后者涉及到或其他服务器控件之间<xref:System.Web.UI.WebControls.WebParts.WebPart>的特定连接。 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>页面上的所有可能的连接都已连接并将要激活时, 会发生该事件。  
  
 事件与引发事件的方法相关联。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 要扩展可添加到页面的连接类型的控件开发人员可能会重写受保护<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A>的方法并激活其他类型的连接。  
  
 页面开发人员可以为事件创建自定义处理程序, 方法`OnConnectionsActivating`是将属性`<asp:webpartmanager>`添加到页面中的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectWebParts">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或其他能建立连接的服务器控件）之间创建一个连接。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法形成可以连接的任意两个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件之间的连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A> 在调用此方法创建连接之前, 您可能还需要在条件检查中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>调用方法, 以确保控件满足建立连接的要求。  
  
> [!NOTE]
>  还可以在两个不<xref:System.Web.UI.WebControls.WebParts.WebPart>是控件的服务器控件之间创建连接。 通常, 这两个控件必须是自定义服务器控件 (例如, 继承<xref:System.Web.UI.WebControls.WebControl>自或现有 ASP.NET 服务器控件的控件), 以便可以添加所需的成员。 这些控件还必须满足下面指定的要求。  
  
 两个控件之间的任何连接方案类型都必须满足以下要求才能进行连接:  
  
-   每个控件都位于<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>一个区域中 (不必是同一区域)。  
  
-   在 Web 部件控件集中实现时, 连接中的提供程序控件以公共方法的形式实现接口, 该方法充当提供程序的回调, 并在方法上`ConnectionProvider`具有元数据特性以将其标识为提供程序连接情况. 由于检索提供程序连接点的<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 方法是虚拟的,因此派生的控件不必使用相同的元数据特性。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>  
  
-   在 Web 部件控件集中实现时, 连接中的使用者控件还具有一种特殊方法, 使其能够获取对提供程序的回调方法中公开的接口的引用, 并且使用者`ConnectionConsumer`在用于将它标识为使用者连接点的方法。 由于检索使用者连接点的<xref:System.Web.UI.WebControls.WebParts.WebPartManager> 方法是虚拟的,因此派生的控件不必使用相同的元数据特性。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>  
  
-   回调方法必须兼容, 因为使用者可以使用提供程序的回调方法中提供的接口类型 (意味着使用者和提供者可以直接共享数据), 或者开发人员必须使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象来将提供程序中的数据转换为使用者可以使用的形式。  
  
    > [!IMPORTANT]
    >  如果不需要转换器, 请使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%29>方法重载。 如果需要转换器, 请使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%28System.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ProviderConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPart%2CSystem.Web.UI.WebControls.WebParts.ConsumerConnectionPoint%2CSystem.Web.UI.WebControls.WebParts.WebPartTransformer%29>方法重载。  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint);" />
      <MemberSignature Language="F#" Value="member this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责向另一个连接控件提供数据。</param>
        <param name="providerConnectionPoint">用作连接回调方法的方法。 与 Web 部件控件集中实现的一样，这是 <paramref name="provider" /> 中以 <see langword="ConnectionProvider" /> 元数据特性标记的一个公共方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件，负责接收来自 <paramref name="provider" /> 的数据，然后处理或显示接收到的数据。</param>
        <param name="consumerConnectionPoint">与 <paramref name="providerConnectionPoint" /> 连接的方法，它接收连接的数据。 与 Web 部件控件集中实现的一样，这是 <paramref name="consumer" /> 中以 <see langword="ConnectionConsumer" /> 元数据特性标记的一个公共方法。</param>
        <summary>只使用对控件的引用和控件所指定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象在两个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，包含连接所需的提供者和使用者的各种信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于在其连接点完全兼容的情况下连接控件, 以便在不使用<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>对象的情况下进行连接。 调用方法的此重载时, 它只是将调用传递给方法的其他重载版本, 并`null`为<xref:System.Web.UI.WebControls.WebParts.WebPartTransformer>需要对象的参数传递。  
  
 尝试以编程方式连接两个控件时, 可以在条件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>检查中使用方法来确定控件是否可以直接连接。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此方法以编程方式创建连接。 有关运行此示例所需的完整代码, 请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分。 从该示例中, 您将需要用户控件的源代码, 该源代码允许您更改页面上的显示模式, 以及两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的源代码。  
  
 接下来的两个控件的网页的代码如下所示。 页面顶部使用`Register`指令来声明用户控件和自定义控件。 然后, 在`<asp:webpartzone>`元素中以声明方式引用自定义控件。 处理`Button1_Click`方法的代码通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>使用方法在控件之间创建连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/CS/wpmgrConnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ConnectWebParts1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ConnectWebParts1/VB/wpmgrConnectWebPartsVB.aspx#1)]  
  
 在浏览器中加载页面后, 请单击 "**连接" WebPart 控件**按钮以建立连接。 然后, 您可以在文本框中输入一些数据, 然后单击 "**输入5位数字的邮政编码**" 按钮以演示控件已连接, 并且在第二个控件中输入的数据将在第二个控件中更新。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">动态集合的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件集合是只读的。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ConnectWebParts">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts (System.Web.UI.WebControls.WebParts.WebPart provider, System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPart consumer, System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, System.Web.UI.WebControls.WebParts.WebPartTransformer transformer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartConnection ConnectWebParts(class System.Web.UI.WebControls.WebParts.WebPart provider, class System.Web.UI.WebControls.WebParts.ProviderConnectionPoint providerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPart consumer, class System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint consumerConnectionPoint, class System.Web.UI.WebControls.WebParts.WebPartTransformer transformer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ProviderConnectionPoint,System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint,System.Web.UI.WebControls.WebParts.WebPartTransformer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartConnection ^ ConnectWebParts(System::Web::UI::WebControls::WebParts::WebPart ^ provider, System::Web::UI::WebControls::WebParts::ProviderConnectionPoint ^ providerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPart ^ consumer, System::Web::UI::WebControls::WebParts::ConsumerConnectionPoint ^ consumerConnectionPoint, System::Web::UI::WebControls::WebParts::WebPartTransformer ^ transformer);" />
      <MemberSignature Language="F#" Value="abstract member ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection&#xA;override this.ConnectWebParts : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ProviderConnectionPoint * System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint * System.Web.UI.WebControls.WebParts.WebPartTransformer -&gt; System.Web.UI.WebControls.WebParts.WebPartConnection" Usage="webPartManager.ConnectWebParts (provider, providerConnectionPoint, consumer, consumerConnectionPoint, transformer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="providerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <Parameter Name="consumer" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="consumerConnectionPoint" Type="System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <Parameter Name="transformer" Type="System.Web.UI.WebControls.WebParts.WebPartTransformer" />
      </Parameters>
      <Docs>
        <param name="provider">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，它的角色是为另一个连接的控件提供数据。</param>
        <param name="providerConnectionPoint"><paramref name="provider" /> 中的一个公共方法，它标有 <see langword="ConnectionProvider" /> 元数据特性，并用作连接的回调方法。</param>
        <param name="consumer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />，它担任从 <paramref name="provider" /> 或 <paramref name="transformer" /> 中接收数据然后对数据进行处理和显示的角色。</param>
        <param name="consumerConnectionPoint"><paramref name="consumer" /> 中的一个公共方法，它标有 <see langword="ConnectionConsumer" /> 元数据特性，并与 <paramref name="providerConnectionPoint" /> 连接以接收连接的数据。</param>
        <param name="transformer">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />，它通过将数据从 <paramref name="provider" /> 转换为 <paramref name="consumer" /> 可以处理的格式来实现两个控件之间的连接。</param>
        <summary>使用对两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的引用、它们的指定 <see cref="T:System.Web.UI.WebControls.WebParts.ConnectionPoint" /> 对象和一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" /> 对象在这两个控件之间创建连接。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />，它包含有关提供者、使用者以及连接所需的转换器的信息。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当控件的连接点不兼容时, 此重载用于连接控件。 实现不同于作为`consumer`其连接点的接口`provider`时, 会发生不兼容的情况。 转换器将数据转换为可理解`consumer`的类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">连接已在 <see cref="E:System.Web.UI.Control.PreRender" /> 中激活。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Connections" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartTransformer" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Controls As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::ControlCollection ^ Controls { System::Web::UI::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Web.UI.ControlCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含在网页的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中并由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件管理的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />、服务器或用户控件的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.ControlCollection" />，包含由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的所有控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性不引用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>由控件引用的其他控件, 如<xref:System.Web.UI.WebControls.WebParts.CatalogPart>各种区域控件、 <xref:System.Web.UI.WebControls.WebParts.EditorPart>控件和其他控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Controls%2A>  
  
 此属性由 Web 部件控件集使用, 在大多数开发环境中, 它不应从代码中调用。 出于此原因, 虽然属性是公共的, 但它在 IntelliSense 中是隐藏的。 要访问<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartManager>由控件管理的或其他服务器控件的集合的开发人员应使用其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CopyWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPart CopyWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart CopyWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ CopyWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.CopyWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.CopyWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要复制的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>由 Web 部件控件集用来创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的副本，以向网页中添加该控件。</summary>
        <returns>要添加到页中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能直接从<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>代码中调用方法。 此方法由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在内部调用, 作为向页面添加新的动态<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件的过程的一部分。 动态控件以编程方式或通过 Web 部件用户界面 (UI) 添加到页面, 例如, 用户从控件目录添加控件, 而不是静态控件 (直接在页面的标记中声明)。  
  
> [!NOTE]
>  如果开发人员希望使方法能够处理其他控件复制方案, 则可以在派生类中重写方法。 有关详细信息, 请参阅对继承者的说明部分。  
  
 添加新的动态控件时, 如果它是<xref:System.Web.UI.WebControls.WebParts.WebPart>控件, 则该<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法将返回控件的新实例。 如果要添加的控件是其他类型的服务器控件 (例如用户控件、自定义控件或 ASP.NET 控件), 则控件已由 Web 部件控件集通过<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象进行包装。 当方法遇到控件时, 它将返回<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件的一个新实例, 其中包含一个换行的子控件的新实例。 <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>当方法创建要返回的控件的新副本时, 它还会将所有属性的值重置为其默认值。 请注意, 如果想要保留可个性化属性的值并将其复制到新的控件实例, 还应调用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.CopyPersonalizationState%2A>方法。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CopyWebPart%2A>方法执行的最后一步是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID%2A>调用方法来获取控件的新 ID。  
  
> [!NOTE]
>  由于方法获取已复制控件的新 ID, 因此不应依赖于通过其原始 ID 添加到页的动态控件。 应改为引用由方法返回的控件的新实例。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>方法被声明为<see langword="virtual" /> , 以便开发人员可以<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />从类继承, 重写方法, 并提供可创建控件副本的其他方案。 例如, 方法可以选择以输入的形式接收已序列化为 XML 文件的控件。 方法可以反序列化 XML (如果存在), 然后调用基方法来处理现有事例并返回<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控件的新实例。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateAvailableTransformers">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.TransformerTypeCollection CreateAvailableTransformers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateAvailableTransformers" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAvailableTransformers () As TransformerTypeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::TransformerTypeCollection ^ CreateAvailableTransformers();" />
      <MemberSignature Language="F#" Value="abstract member CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection&#xA;override this.CreateAvailableTransformers : unit -&gt; System.Web.UI.WebControls.WebParts.TransformerTypeCollection" Usage="webPartManager.CreateAvailableTransformers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.TransformerTypeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>创建一组在网站配置文件中指定的转换器，并将它们添加到 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" /> 属性所引用的转换器的集合。</summary>
        <returns>网站的配置文件中指定的转换器的集合。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>可以重写此方法, 以添加应用程序可使用的附加转换器。 例如, 可以编写方法, 从 Web 服务检索可用转换器的列表。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.AvailableTransformers" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected override sealed System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateControlCollection" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function CreateControlCollection () As ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Web::UI::ControlCollection ^ CreateControlCollection();" />
      <MemberSignature Language="F#" Value="override this.CreateControlCollection : unit -&gt; System.Web.UI.ControlCollection" Usage="webPartManager.CreateControlCollection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有控件的集合。 此类不能被继承。</summary>
        <returns>一个 <see cref="T:System.Web.UI.ControlCollection" />，由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所管理的所有 Web 部件控件组成。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>由于此方法是受保护的, 因此它对从<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类继承的类可见, 但不能重写。</para></block>
      </Docs>
    </Member>
    <Member MemberName="CreateDisplayModes">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection CreateDisplayModes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDisplayModes () As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ CreateDisplayModes();" />
      <MemberSignature Language="F#" Value="abstract member CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection&#xA;override this.CreateDisplayModes : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="webPartManager.CreateDisplayModes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>为 Web 部件应用程序创建由所有可能的显示模式组成的显示模式集。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含所有受支持的显示模式。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法会创建所有可能的显示模式的列表, 而不只是特定页面上支持的显示模式。 有关支持的显示模式的详细信息, 请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。  
  
 默认情况下, Web 部件控件集会创建以下一组显示模式, 用于 Web 部件页:  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CatalogDisplayMode>  
  
-   <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>  
  
 开发人员可以创建自定义的显示模式, 无论是通过还是不附带派生<xref:System.Web.UI.WebControls.WebParts.WebZone>自或<xref:System.Web.UI.WebControls.WebParts.ToolZone>类的自定义区域。 若要创建自定义显示模式, 你必须从<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类继承, 若要在页面上将显示模式添加为受支持模式, 则必须<xref:System.Web.UI.WebControls.WebParts.WebPartManager>从类继承并重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>方法。  
  
 当您使用<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection.Add%2A>方法添加显示模式时, 应按照您希望它们显示在任何用户界面 (UI) 控件 (如<xref:System.Web.UI.WebControls.ListBox>控件) 中的顺序添加它们, 使用户能够在页面上显示可能的显示模式。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A> 方法。  
  
 此代码示例包含五个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   承载其他控件的网页。  
  
-   驻留在网页的某个<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域中的用户控件, 可用于在标签中输入和显示文本。  
  
-   包含两个控件的源代码文件。 一个是自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件, 另一个是要添加到<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>页面的默认显示模式的自定义对象。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 该示例的第二部分是网页。 它包含两<xref:System.Web.UI.WebControls.WebParts.WebPartZone>个控件: 用户控件和自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 请注意页面顶部的指令,以引用已编译控件的用户控件和命名空间。`Register`  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/createDisplayModeCS.aspx#1)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/createDisplayModeVB.aspx#1)]  
  
 该示例的第三部分是用户控件, 用于输入和显示文本。 它使用<xref:System.Web.UI.WebControls.MultiView>控件来创建用户界面的多个视图。 一个视图与`Button1`按钮一起显示, 另一个视图没有。 请注意, 在重`OnPreRender`写的方法中, 代码会检查页面当前是否处于自定义显示模式, 如果是, 则显示 "用户" 控件的第一个视图, 其中包含按钮。 如果页面不在自定义显示模式下, 例如, 如果页面处于浏览或设计模式, 则隐藏按钮。  
  
 [!code-aspx-csharp[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/TextDisplaycs.ascx#2)]
 [!code-aspx-vb[Webparts_WebPartManager_CreateDisplayModes#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/TextDisplayvb.ascx#2)]  
  
 该示例的第四部分是两个自定义类的源文件。 请注意, 自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>定义类将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes%2A>重写方法, 并首先调用基方法以添加所有默认的显示模式, 然后添加自定义显示模式。 自定义的显示模式类`InLineEditDisplayMode`只是从<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>继承, 它在构造函数中设置显示模式的名称, 并覆盖一些基属性以建立自定义显示的特征。  
  
 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/CS/CustomDisplayMode.cs#3)]
 [!code-vb[Webparts_WebPartManager_CreateDisplayModes#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_CreateDisplayModes/VB/CustomDisplayMode.vb#3)]  
  
 若要运行此代码示例, 请在浏览器中加载此页。 请注意, 页面目前处于浏览模式, 并且没有按钮可见。 使用 "**显示模式**" 下拉列表控件, 将页面更改为**内联编辑显示**模式, 请注意, 现在`Button1`按钮在较低用户控件中可见。 添加一些文本, 然后单击按钮以更新控件。 请注意, 页面显示将返回到浏览模式, 此时将显示您输入的文本, 并且该按钮再次隐藏, 因为该页面不再处于自定义显示模式。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：更改 Web 部件页上的显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicConnectionID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicConnectionID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicConnectionID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicConnectionID () As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicConnectionID();" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicConnectionID : unit -&gt; string&#xA;override this.CreateDynamicConnectionID : unit -&gt; string" Usage="webPartManager.CreateDynamicConnectionID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取一个唯一值，用于充当动态连接的 ID。</summary>
        <returns>一个包含连接的唯一 ID 的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID%2A>方法生成一个 GUID 值, 并将其转换为字符串, 作为连接的唯一 ID。 每次创建动态连接时都将调用方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类中重写此方法, 以更改实现以生成唯一 ID。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateDynamicWebPartID">
      <MemberSignature Language="C#" Value="protected virtual string CreateDynamicWebPartID (Type webPartType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string CreateDynamicWebPartID(class System.Type webPartType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicWebPartID(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateDynamicWebPartID (webPartType As Type) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ CreateDynamicWebPartID(Type ^ webPartType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDynamicWebPartID : Type -&gt; string&#xA;override this.CreateDynamicWebPartID : Type -&gt; string" Usage="webPartManager.CreateDynamicWebPartID webPartType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="webPartType">为其生成 ID 的控件的 <see cref="T:System.Type" />。</param>
        <summary>为动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件生成唯一 ID。</summary>
        <returns>一个字符串，包含控件的唯一 ID。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到网页时, 它们可以是静态的 (这意味着控件是在页标记中声明的) 或动态的 (也就是说, 它们是以编程方式添加的)。 在<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件创建要添加到页面的新动态控件的任何情况下, 它都会调用此方法来生成唯一 ID。  
  
 方法是虚拟的, 因此, 如果开发人员希望提供用于生成 ID 的自定义实现, 则可以重写此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartType" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreateErrorWebPart">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart (string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ErrorWebPart CreateErrorWebPart(string originalID, string originalTypeName, string originalPath, string genericWebPartID, string errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateErrorWebPart (originalID As String, originalTypeName As String, originalPath As String, genericWebPartID As String, errorMessage As String) As ErrorWebPart" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::ErrorWebPart ^ CreateErrorWebPart(System::String ^ originalID, System::String ^ originalTypeName, System::String ^ originalPath, System::String ^ genericWebPartID, System::String ^ errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart&#xA;override this.CreateErrorWebPart : string * string * string * string * string -&gt; System.Web.UI.WebControls.WebParts.ErrorWebPart" Usage="webPartManager.CreateErrorWebPart (originalID, originalTypeName, originalPath, genericWebPartID, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ErrorWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originalID" Type="System.String" />
        <Parameter Name="originalTypeName" Type="System.String" />
        <Parameter Name="originalPath" Type="System.String" />
        <Parameter Name="genericWebPartID" Type="System.String" />
        <Parameter Name="errorMessage" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="originalID">作为失败控件 ID 的字符串。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该 ID 为其子服务器控件的 ID。</param>
        <param name="originalTypeName">字符串，失败控件的 <see cref="T:System.Type" /> 名称。 如果失败涉及 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，则该类型名称是其子服务器控件的类型。</param>
        <param name="originalPath">包含用户控件路径的字符串（如果失败涉及包含子用户控件的 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />）。</param>
        <param name="genericWebPartID">返回 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> ID 的字符串（如果加载或创建控件的失败涉及该类型的控件）。</param>
        <param name="errorMessage">包含要在页中显示的错误消息的字符串。</param>
        <summary>当加载或创建动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的尝试因某种原因失败时，创建插入页中并向最终用户显示的特殊控件。</summary>
        <returns>插入页中以替代未能加载或创建的控件的 <see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当 Web 部件控件集尝试加载或创建动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件或服务器控件的实例时, 将调用方法,并且由于某种原因而失败。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A> 方法创建一个<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>对象, 向其分配错误消息并返回该对象。 将<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>插入控件来代替失败的控件, 并在页面上显示其错误消息。  
  
 不能直接从<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart%2A>代码中调用方法。 但是, 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类继承并扩展方法。 有关详细信息, 请参阅对继承者的说明部分。  
  
 最终用户可以在页中<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>使用控件, 就像是普通<xref:System.Web.UI.WebControls.WebParts.WebPart>控件一样。 若要删除错误消息, 可以通过单击关闭谓词关闭控件, 此时, 控件将添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>对象中, 就像任何其他关闭的控件一样。 如果最终用户删除<xref:System.Web.UI.WebControls.WebParts.ErrorWebPart>控件, 则无法加载的服务器控件也将从页中删除。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>如果要自定义在<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件中返回的信息, 可以<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateErrorWebPart(System.String,System.String,System.String,System.String,System.String)" />重写方法, 调用基方法, 为传递到基方法的参数分配不同的值, 然后返回生成的<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />控件。 例如, 如果您不希望最终用户看到<paramref name="originalPath" />值 (这会显示用户控件的虚拟目录路径), 则当您调用基方法时, 可以为该参数传递空字符串 ("")。  
  
你还可以通过从其继承来<see cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />自定义控件本身的行为。 例如, 你可能想要重写其<see cref="P:System.Web.UI.WebControls.WebParts.Part.Title" />或<see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AllowMinimize" />属性。</para></block>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ErrorWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="CreatePersonalization">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization CreatePersonalization() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreatePersonalization () As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ CreatePersonalization();" />
      <MemberSignature Language="F#" Value="abstract member CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization&#xA;override this.CreatePersonalization : unit -&gt; System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="webPartManager.CreatePersonalization " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回一个个性化设置对象，该对象包含当前网页的用户个性化设置数据。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />，包含用户的个性化设置数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization%2A>方法返回一个对象, 该对象包含并管理当前页的用户个性化设置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件管理此对象。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web 部件个性化概述</related>
      </Docs>
    </Member>
    <Member MemberName="CreateWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.GenericWebPart CreateWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::GenericWebPart ^ CreateWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="abstract member CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart&#xA;override this.CreateWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.CreateWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的服务器控件。</param>
        <summary>用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 对象包装一个不是 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的服务器控件，以使该控件能具有 Web 部件的功能。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，包装 <paramref name="control" /> 并使其功能与真正的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件一样。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法是启用服务器控件的主要机制, 这些服务器控件不<xref:System.Web.UI.WebControls.WebParts.WebPart>是控件与控件具有<xref:System.Web.UI.WebControls.WebParts.WebPart>相同的功能, 因此可完全参与 Web 部件的应用程序。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> 通过使用此方法, 开发人员大大扩展了在 Web 部件应用程序中可以使用的服务器控件数, 因为几乎任何类型的服务器控件 (标准 ASP.NET 控件、用户控件和自定义控件) 都可以使用。  
  
 该控件还在其他两个方案中使用此方法, 以将服务器<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件与对象进行包装。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 当用户使用<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控件将服务器控件添加到页面时, 如果导入的控件<xref:System.Web.UI.WebControls.WebParts.WebPart>不是控件, 将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>调用方法。 此外, 当服务器控件在网页上的<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域内以持久性格式声明时, 将为非<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的任何控件调用此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法。  
  
 以编程方式将服务器控件添加到区域时, 一种典型的方法是使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart%2A> , 将控件<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包装在对象中, 然后调用方法将控件添加到所有<xref:System.Web.UI.WebControls.WebParts.WebPart>页面上的控件, 由<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性引用。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A>方法。 在中<xref:System.Web.UI.WebControls.WebParts.GenericWebPart> <xref:System.Web.UI.WebControls.Calendar> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.CreateWebPart%2A> , 将调用方法, 以便在将控件添加到区域之前使用对象来包装控件。 `Button2_Click method`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>可以重写此方法以使用派生<see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />类, 而不是 Web 部件控件集提供的基类。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWarning">
      <MemberSignature Language="C#" Value="public virtual string DeleteWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DeleteWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DeleteWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ DeleteWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DeleteWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个自定义警告消息，当最终用户删除一个控件时，将显示该消息。</summary>
        <value>包含警告消息文本的字符串。 默认值是经本地化的警告消息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 用户删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件时, 通常会显示默认警告消息。 它会警告用户, 在删除控件的此实例时, 删除是永久性的。 页面开发人员可以向用户提供一种向页面添加控件的新实例 (例如通过<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的目录或通过某些编程方式) 的方法, 但已删除的控件的当前实例将被永久删除。 如果需要, 显示警告的对话框包含用户用于取消删除的按钮。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>属性使开发人员可以设置向用户显示的警告消息。  
  
 如果页面开发人员将空字符串 ("") 值分配到此属性, 则当用户删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件时, 不会显示任何警告消息对话框。  
  
> [!NOTE]
>  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A> 静态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和服务器控件的情况下不会显示属性。 静态控件是在网页的标记内<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>的区域中声明的服务器控件。 由于此类控件是静态的, 因此无法将其删除, 因此在这种情况下, 永远不会显示删除警告消息。 静态控件可以由用户关闭, 但会将已关闭的控件添加到页目录中, 用户可以将其添加回页面, 而不能恢复已删除的控件。  
  
   
  
## Examples  
 下面的代码示例演示如何以声明方式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>和编程方式使用属性。  
  
 此代码示例分为四个部分:  
  
-   允许您更改页面显示模式的用户控件。  
  
-   自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。  
  
-   网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 此代码示例的第二部分是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此示例使用动态编译方法;因此, 此控件在网页顶部`Register`的指令中没有属性。`Assembly` 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/textdisplaywebpart.cs#3)]
 [!code-vb[WebParts_WebPartManager_DeleteWarning#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/textdisplaywebpart.vb#3)]  
  
 此代码示例的第三部分是网页。 页面包含<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域, 其中自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件在区域中声明, 因此用户可以在运行时将其添加到页面中。 请注意, 只能从页中删除动态控件 (以编程方式或从此类的目录添加到页面的控件)。 静态控件 (在页标记中声明<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>的控件) 可以关闭, 但不能删除。 `<asp:webpartmanager>`元素<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>使用特性`DeleteWarning`声明属性的自定义值。 `Button1_Click` 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWarning%2A>为属性分配另一个自定义值。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/CS/deleteWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWarning#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWarning/VB/deleteWarningVB.aspx#1)]  
  
 在浏览器中加载页面后, 需要将<xref:System.Web.UI.WebControls.WebParts.WebPart>控件添加到页面。 使用 "**显示模式**" 下拉列表控件选择 "目录模式"。 当目录出现时, 选中自定义控件旁边的复选框, 单击 "**添加**" 将其添加到页面, 然后单击 "**关闭**" 以将该页返回到浏览模式。 控件可见后, 可以将其删除。 再次使用 "**显示模式**" 控件, 将页面切换到设计模式 (页面处于浏览模式时无法删除控件)。 单击<xref:System.Web.UI.WebControls.WebParts.WebPart>控件标题中的谓词菜单 (箭头符号), 然后选择 "**删除**"。 此时将显示您对`DeleteWarning`属性设置的警告。 单击“取消”。 现在, 单击标签为 "**更改删除警告**" 的按钮, 这将以编程方式更改属性值。 从控件上的谓词菜单中, 再次选择 "**删除**", 并注意到这次出现其他警告消息。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteWebPart">
      <MemberSignature Language="C#" Value="public void DeleteWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DeleteWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.DeleteWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DeleteWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要删除的服务器控件。</param>
        <summary>永久地从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的动态实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法从页中永久删除`webPart`由参数表示的控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 与已添加到<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>控件并可以添加回页的关闭控件不同, 已删除的控件实例永远无法添加回页。  
  
> [!NOTE]
>  按照 Web 部件控件集的实现, 用户删除动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的能力取决于用户以及控件添加到页面中的个性化设置范围。 如果在页处于共享范围中时添加控件 (由具有权限的用户), 则当该页处于用户范围中时, 不能由单个用户删除该控件。  
  
 只能删除动态控件。 动态控件以编程方式或从目录添加控件的用户添加到页面中。 静态控件按标记或持久性格式添加到页中。 由于声明性标记永久存在于标记中, 因此永远无法删除静态控件, 但可以关闭和重新打开静态控件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A> 方法。 第一次单击 "**添加日历**" 按钮时, 事件处理程序中的代码会<xref:System.Web.UI.WebControls.Calendar>创建一个控件, 并将其作为<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象添加到区域。 由于控件是以编程方式添加的, 因此它是一个动态控件, 因此可以将其删除。 当用户单击 "**删除日历**" 按钮时, 代码确保控件存在, 然后通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart%2A>方法将其删除。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/CS/wpmgDeleteWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DeleteWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DeleteWebPart/VB/wpmgDeleteWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsClosed" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsStatic" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DesignDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DesignDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DesignDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DesignDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable DesignDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示用于更改包含 Web 部件控件的网页布局的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字段引用由控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>创建<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>并包含的自定义对象。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> 因为这是一个静态对象, 所以可以直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类引用它, 而无需控件的实例。  
  
 当包含 Web 部件控件的页面首次加载时, 默认情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>下它处于 (浏览模式)。 如果用户想要通过将控件移到不同区域或在当前区域中来更改页面布局, 则必须先将页面切换到<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode> (设计模式)。 在设计模式下, 将显示各个区域的用户界面 (UI), 然后用户可以拖动控件来更改布局。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>字段。 此代码使用页面支持的显示模式 (在本例中为 "浏览" 和 "设计") 填充下拉列表。 请注意, 在`Page_PreRender`方法中, 代码检查当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性是否设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>。 如果是这样`Label1` , 将显示, 如果`Label1`不可见, 将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/CS/wpmgrDesignDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DesignDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DesignDisplayMode/VB/wpmgrDesignDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后, 默认情况下处于浏览模式。 请注意, 页面上的标签处于隐藏状态。 使用下拉列表控件将页面切换到设计模式。 请注意, 由于`Page_PreRender`方法中的代码, 标签现在可见。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebPart">
      <MemberSignature Language="C#" Value="protected virtual void DisconnectWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DisconnectWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DisconnectWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit&#xA;override this.DisconnectWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.DisconnectWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">要断开连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</param>
        <summary>移除要关闭或要从其所参与的连接中删除的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>控件在页上关闭或从页中删除时, 该方法由 Web 部件控件集进行内部调用。 在这种情况下, 将调用方法, 以将控件从任何连接 (其中包含为使用者或提供者) 中删除。 如果从任何连接中删除该控件, 则此方法还会<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>调用方法以结束涉及的`webPart`任何连接。  
  
 调用方法时, 它会<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>引发事件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 通常可以取消此事件, 但在两种情况下, 不能取消此事件。 当调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>方法时, 会在对页面的请求期间发生一种情况。 如果现有连接之间存在冲突, 则<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>将调用方法关闭其中一个冲突的连接, 在此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>实例中, 无法取消该事件, 因为必须解决冲突。  
  
 当当前连接的或服务器<xref:System.Web.UI.WebControls.WebParts.WebPart>控件关闭或删除时, 会发生另一种情况。 在这种情况下, 由于正在从页面中删除控件, 因此还需要终止其连接, 因此, 设计不能取消<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件以中断结束连接的过程。 有关详细信息，请参阅 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A> 方法。 通过使用两<xref:System.Web.UI.WebControls.WebParts.WebPart>个自定义控件, 可通过单击按钮在控件之间创建连接, 而使用另一个按钮可以断开控件的连接。 如果在页处于浏览模式并且控件已连接时关闭其中一个控件, 则该<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>方法的重写会断开关闭的控件的连接, 结束连接, 并显示一条消息。  
  
 此代码示例包含四个部分:  
  
-   用于更改显示模式的用户控件。  
  
-   包含自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的源文件。  
  
-   用于承载控件的网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 第二部分是包含两个要连接的自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的源代码的文件, 以及一个自定义<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件。 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此示例使用动态编译, 因此`Register`在网页顶部声明了引用这些组件的指令。 有关演示编译选项的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 在源代码中, 请注意`MyWebPartManager` <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>重写方法的继承的控件。 此方法检查页中的每个连接, 以查看关闭的控件是否参与连接, 如果是, 则调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法以终止连接。 这与<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件中的方法的基实现完全相同。 然后, 重写的方法通过将消息写入页面来自定义基实现。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意, 在顶部附近, 它`Register`包含<xref:System.Web.UI.WebControls.WebParts.WebPart>用控件注册用户控件和动态编译的程序集的指令。 此页具有两种主要方法。 方法在控件之间创建连接, `Button2_Click`而方法断开控件的连接。 `Button1_Click`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后, 单击 "**连接**" 按钮以连接控件。 然后单击其中一个控件中的谓词菜单 (控件标题中的向下箭头), 然后从谓词菜单中选择 "**关闭**"。 尝试关闭控件时, 将调用重写的方法, 连接将结束, 并且消息将写入页面。 如果要重置页面以还原关闭的控件并尝试其他选项, 请单击 "**重置用户状态**" 链接以删除个性化设置数据并还原页面的原始状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisconnectWebParts">
      <MemberSignature Language="C#" Value="public virtual void DisconnectWebParts (System.Web.UI.WebControls.WebParts.WebPartConnection connection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DisconnectWebParts(class System.Web.UI.WebControls.WebParts.WebPartConnection connection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DisconnectWebParts (connection As WebPartConnection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DisconnectWebParts(System::Web::UI::WebControls::WebParts::WebPartConnection ^ connection);" />
      <MemberSignature Language="F#" Value="abstract member DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit&#xA;override this.DisconnectWebParts : System.Web.UI.WebControls.WebParts.WebPartConnection -&gt; unit" Usage="webPartManager.DisconnectWebParts connection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="connection" Type="System.Web.UI.WebControls.WebParts.WebPartConnection" />
      </Parameters>
      <Docs>
        <param name="connection">表示服务器控件之间的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />。</param>
        <summary>执行断开网页中连接的服务器控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你向<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 其传递参数时,方法将执行结束或服务器控件之间的连接`connection`的整个过程。  
  
 当你在网页中放置`<asp:connectionszone>`元素时, 此方法用于断开控件的连接, 以提供用于管理连接的用户界面 (UI)。 当页处于 connect 显示模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectDisplayMode>) 并且存在当前连接时, 用户可以单击一个按钮, 该按钮<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>调用方法以结束连接。  
  
 如果要以编程方式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>断开控件连接, 而无需向页面`<asp:connectionszone>`添加元素, 也可以直接从代码调用方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A> 方法。 通过使用两<xref:System.Web.UI.WebControls.WebParts.WebPart>个自定义控件, 可通过单击按钮在控件之间创建连接, 而使用另一个按钮可以断开控件的连接。  
  
 此代码示例包含四个部分:  
  
-   用于更改显示模式的用户控件。  
  
-   包含自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的源文件。  
  
-   用于承载控件的网页。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 第二部分是一个文件, 其中包含两个要连接的<xref:System.Web.UI.WebControls.WebParts.WebPart>自定义控件的源代码。 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此示例使用动态编译, 因此`Register`在网页顶部声明了引用这些组件的指令。 有关演示编译选项的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_DisconnectWebParts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意, 在顶部附近, 它`Register`包含<xref:System.Web.UI.WebControls.WebParts.WebPart>用控件注册用户控件和动态编译的程序集的指令。 此页具有两种主要方法。 方法在控件之间创建连接, `Button2_Click`并且方法断开控件的连接。 `Button1_Click`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/CS/wpmgrDisconnectWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisconnectWebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisconnectWebParts/VB/wpmgrDisconnectWebPartsVB.aspx#1)]  
  
 加载页面后, 可以单击 "**连接**" 按钮连接控件。 如果在 "文本框" 控件中输入一些文本, 然后单击 "**输入**" 按钮, 则该文本将显示在连接的控件中 (如果控件已断开连接, 则不会显示)。 如果单击 "**断开连接**" 按钮, 控件将断开连接。 您可以通过使用 "**显示模式**" 下拉列表控件来验证控件的连接状态, 以将页面切换到**连接**模式。 完成此操作后, 单击其中一个控件的标题栏中的谓词菜单 (表示为箭头), 然后选择 "**连接**" 项。 显示连接 UI;它可用, 因为在页面中`<asp:connectionszone>`声明了一个元素。 你还可以通过此 UI 连接和断开控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="connection" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="connection" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 或 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 中。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 为只读。  
  
或 
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" /> 断开。  
  
或 
 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 为只读。  
  
或 
 <paramref name="connection" /> 已从 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" /> 断开。</exception>
        <block subset="none" type="overrides"><para>如果要更改断开<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />连接<see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />控件的默认实现, 可以重写方法。 如果确实要重写方法, 而只是想要向现有方法添加一些实现, 则可以在执行自己的代码之前调用基方法。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayMode DisplayMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property DisplayMode As WebPartDisplayMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ DisplayMode { System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ get(); void set(System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置包含 Web 部件控件的网页的活动显示模式。</summary>
        <value>确定页显示模式的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 包含 Web 部件控件的页始终处于多种可能的显示模式之一。 有关显示模式的详细信息, 请参阅[Web 部件页面显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>类创建网页的显示模式。 使用基类<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode> <xref:System.Web.UI.WebControls.WebParts.WebPartManager> , 控件可创建多个标准显示模式对象, 这些对象可用于包含 Web 部件控件的页上。 <xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>类概述中介绍了这些标准显示模式。  
  
 该<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还管理使用 Web 部件控件的页面的显示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>使用属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager> , 控件保留对页面上当前显示模式的引用。 还可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性将页面切换到不同的显示模式。 有关在使用 Web 部件控件的页上更改显示模式的示例, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 作为管理显示模式的一部分, 该<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件还提供与显示模式相关的事件和事件处理程序, 如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>方法和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>方法。 这些方法提供了一种机制, 用于自定义页面的行为, 甚至用于添加自定义显示模式。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>使用属性。 在浏览器中加载页面后, 可以使用页面底部附近的按钮来切换显示模式。 默认情况下, 在加载时, 该页处于浏览模式。 如果切换到设计模式, 则可以将服务器控件从一个区域拖动到另一个区域, 或在一个区域中排列两个控件。 如果切换到编辑模式, 则可以单击任一服务器控件标头中的谓词菜单, 选择 "**编辑**", 然后使用提供的编辑用户界面 (UI) 编辑控件。  
  
> [!NOTE]
>  在 Web 部件应用程序中切换显示模式很常见, 你可能希望在包含 Web 部件控件的所有页面上提供一致、可重复使用的方法来执行此操作。 有关更改显示模式并可在多页上重复使用的用户控件的示例, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/CS/wpmgrDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayMode/VB/wpmgrDisplayModevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象不是受支持的显示模式。  
  
或 
赋给该属性的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象已禁用。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：更改 Web 部件页上的显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler DisplayModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanged As WebPartDisplayModeEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventHandler ^ DisplayModeChanged;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " Usage="member this.DisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 Web 部件页上的当前显示模式更改之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序不可或缺的一部分。 当用户切换到网页上的不同显示模式时, 该页面通常会采用不同的外观, 这取决于新的显示模式的用途。 在显示模式发生更改后, 您可能希望在用户界面 (UI) 中进行某些更改, 如隐藏或显示某些控件、更改所选 UI 元素的外观等。  
  
> [!NOTE]
>  有关显示模式的详细信息, 请参阅[Web 部件页面显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 有关使用事件的详细信息, 请[参阅如何:在 Web 窗体应用程序](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)中使用事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModeChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler DisplayModeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DisplayModeChanging As WebPartDisplayModeCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventHandler ^ DisplayModeChanging;" />
      <MemberSignature Language="F#" Value="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " Usage="member this.DisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当用户单击网页上的谓词以启动不同显示模式之间的更改过程之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 显示模式是 Web 部件应用程序不可或缺的一部分。 当用户切换到网页上的不同显示模式时, 该页面通常会采用不同的外观, 这取决于新的显示模式的用途。 用户启动通过单击谓词更改为新的显示模式的过程后, 你可能想要在用户界面 (UI) 中进行某些更改, 方法是使用<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode%2A>属性确定新的显示模式, 然后更改各种 UI元素。 实现此目的的一种有用方法是重<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>写方法以自定义 UI。  
  
> [!NOTE]
>  有关显示模式的详细信息, 请参阅[Web 部件页面显示模式](https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4)。 有关使用事件的详细信息, 请[参阅如何:在 Web 窗体应用程序](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)中使用事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="DisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection DisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ DisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件关联的所有显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 控件关联的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性引用所有关联的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>显示模式, 这与属性不同, 后者只引用当前页上可用的 (受支持的) 显示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>  
  
 页面上始终支持两个提供的显示模式: "浏览" 和 "设计"。 仅当页面具有特定显示模式所需的相应类型的区域时, 才支持其他三种显示模式: "编辑"、"目录" 和 "连接"。 例如, 如果页不包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域, 则编辑显示模式将在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性引用的集合中显示, 但不会显示在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性引用的集合中。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A>属性。 该代码使用此属性来填充列表, 其中包含 Web 部件控件集中可用的所有显示模式, 甚至是当前页上不支持的显示模式。 在这种情况下, 目录和连接显示模式不受支持, 因为其相应的所需区域不在页面上。  
  
 其他三种显示模式--在页面上支持 "浏览"、"设计" 和 "编辑"。 支持编辑模式, 因为页面包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域, 并且始终支持浏览和设计模式。  
  
 在浏览器中加载页面后, 可以使用下拉列表控件将页面从浏览模式切换到设计模式, 然后切换到编辑模式。 在编辑模式下, 可以单击其中一个服务器控件标头中的下拉谓词菜单, 然后选择 "**编辑**" 以编辑控件。 请注意, 如果在下拉列表中选择 "**目录**" 或 "**连接**", 则会生成错误页。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/CS/wpmgrDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_DisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_DisplayModes/VB/wpmgrDisplayModesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDisplayModes" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
        <related type="Article" href="https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0">演练：更改 Web 部件页上的显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="DynamicConnections">
      <MemberSignature Language="C#" Value="protected internal System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection DynamicConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property DynamicConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ DynamicConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取网页上当前存在的所有动态连接的集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，其中包含对页上所有动态连接的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态连接是以编程方式创建的连接, 而不是静态的。 通过在 Web 窗体页的标记中声明静态连接来创建静态连接。 动态连接可通过编程方式或使用连接用户界面 (UI) 创建连接的用户形成。  
  
 尽管<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>该集合是只读的并且不能更改其内容, 但它提供了对每个动态连接对象的编程访问。  
  
> [!NOTE]
>  若要执行<xref:System.Web.UI.WebControls.WebParts.WebPart>诸如连接或断开控件等常见操作, 开发人员应使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类上的公共方法, 如<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>, 而不是尝试直接修改连接集合中的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DynamicConnections%2A>对象。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreateDynamicConnectionID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EditDisplayMode">
      <MemberSignature Language="C#" Value="public static readonly System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Web.UI.WebControls.WebParts.WebPartDisplayMode EditDisplayMode" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EditDisplayMode As WebPartDisplayMode " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Web::UI::WebControls::WebParts::WebPartDisplayMode ^ EditDisplayMode;" />
      <MemberSignature Language="F#" Value=" staticval mutable EditDisplayMode : System.Web.UI.WebControls.WebParts.WebPartDisplayMode" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>表示最终用户可在其中编辑和修改服务器控件的显示模式。 此字段为只读。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 字段引用由控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>创建<xref:System.Web.UI.WebControls.WebParts.WebPartDisplayMode>并包含的自定义对象。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> 因为这是一个静态对象, 所以可以直接通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类引用它, 而无需控件的实例。  
  
 当包含 Web 部件控件的页面首次加载时, 默认情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BrowseDisplayMode>下它处于 (浏览模式)。 当用户想要编辑或修改服务器控件时, 必须先将页面切换到<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode> (编辑模式)。 其次, 它们必须选择要编辑的特定服务器控件, 方法是单击该控件标题中谓词菜单上的 "编辑" 谓词。 控件处于编辑模式后, 将显示编辑用户界面 (UI) 以编辑选定的控件。  
  
 若要在页面上启用编辑模式, 页面必须包含至少一个<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域, 其中包含一个或多个所提供的编辑控件<xref:System.Web.UI.WebControls.WebParts.LayoutEditorPart> (例如控件) 或自定义编辑控件。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>字段。 此代码使用页面支持的显示模式填充下拉列表, 在本例中为 "浏览"、"设计" 和 "编辑"。 若要支持编辑, `<asp:EditorZone>`请在页面中提供一个元素。 请注意, 在`Page_PreRender`方法中, 代码检查当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayMode%2A>属性是否设置为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EditDisplayMode>。 如果是这样`Label1` , 将显示, 如果`Label1`不可见, 将隐藏。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/CS/wpmgrEditDisplayModecs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_EditDisplayMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_EditDisplayMode/VB/wpmgrEditDisplayModevb.aspx#1)]  
  
 在浏览器中加载页面后, 默认情况下处于浏览模式。 请注意, 页面上的标签处于隐藏状态。 使用下拉列表控件将页面切换到编辑模式。 请注意, 由于`Page_PreRender`方法中的代码, 标签现在可见。 单击其中一个控件的谓词菜单中的 "**编辑**" 谓词, 以启用对该特定控件的编辑。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="EnableClientScript">
      <MemberSignature Language="C#" Value="public virtual bool EnableClientScript { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property EnableClientScript As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableClientScript { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableClientScript : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，该值确定在包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的网页上是否启用了客户端脚本。</summary>
        <value>一个布尔值，指示页上是否可以运行客户端脚本。 默认值为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableClientScript%2A>属性为开发人员提供了一种禁用客户端脚本的方法。 出于安全目的, 您可能希望禁用客户端脚本, 或确保某个页面的所有用户都具有类似的用户体验, 即使他们使用不同的浏览器也是如此。  
  
 可以通过将`EnableClientScript`特性添加到网页上的<xref:System.Web.UI.WebControls.WebParts.WebPartManager>元素来禁用客户端脚本, 如以下声明性代码行所示:  
  
 `<asp:webpartmanager id="manager" runat="server"`  
  
 `EnableClientScript="false" />`  
  
 此外, 开发人员可以通过从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类继承并将默认值设置为来`false`消除此属性。  
  
 Web 部件控件集使用客户端脚本来提供一些客户端用户界面 (UI) 和个性化功能。 如果禁用客户端脚本, 则 Web 部件控件仍然有效, 但某些功能处于禁用状态。 禁用将控件拖放到不同区域的功能, 以及在控件标题栏的下拉谓词菜单中呈现谓词的功能 (谓词改为显示为控件标题栏中的链接)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public override bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property EnableTheming As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EnableTheming { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableTheming : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示网页启用了主题。</summary>
        <value>一个布尔值，指示是否启用了主题。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件重写基<xref:System.Web.UI.Control.EnableTheming%2A>属性, 以确保它`true`始终返回值。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 这样做是因为 Web 部件控件集需要使用主题来呈现 Web 部件控件, 这些控件是<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的子控件, 并构成网页的用户界面 (UI)。 例如, 主题用于呈现不同的区域以及驻留在区域中的控件, 包括各种类型的部件控件 (继承自<xref:System.Web.UI.WebControls.WebParts.Part>类的控件)、用户控件、ASP.NET 服务器控件和自定义服务器控件.  
  
 尽管重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EnableTheming%2A>的属性根据其基本属性实现为读/写属性, 但无法设置属性, 因为它的设计必须始终返回`true`值。 如果尝试设置该属性, <xref:System.NotSupportedException>则会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartConnecting">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartConnecting ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartConnecting() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartConnecting ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartConnecting();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartConnecting : unit -&gt; unit&#xA;override this.EndWebPartConnecting : unit -&gt; unit" Usage="webPartManager.EndWebPartConnecting " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件连接到另一个控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法完成将<xref:System.Web.UI.WebControls.WebParts.WebPart>控件连接到另一控件的过程。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 它与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting%2A>方法是对应的。  
  
 方法可确保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性引用的个性化对象是可修改的, 这是必需的, 因为构建连接本身就是一种个性化类型。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartConnecting%2A> 然后, 方法确保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>对象不`null`为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> , 最后调用方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件的开发人员可能希望在派生类中重写此方法。 一种方法是调用基方法, 然后添加一些附加的自定义处理, 或者您可能需要完全自定义完成控件之间的连接的整个过程。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartConnecting(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="EndWebPartEditing">
      <MemberSignature Language="C#" Value="public virtual void EndWebPartEditing ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWebPartEditing() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndWebPartEditing ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndWebPartEditing();" />
      <MemberSignature Language="F#" Value="abstract member EndWebPartEditing : unit -&gt; unit&#xA;override this.EndWebPartEditing : unit -&gt; unit" Usage="webPartManager.EndWebPartEditing " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>完成编辑 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>方法完成<xref:System.Web.UI.WebControls.WebParts.WebPart>编辑控件的过程。 它与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法是对应的。  
  
 方法可确保<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性引用的个性化对象是可修改的, 这是必需的, 因为编辑控件是需要进行个性化更改的进程。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A> 然后<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A> , 方法确保对象不`null`是, 以便当前选定<xref:System.Web.UI.WebControls.WebParts.WebPart>的控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>可以更改, 最后调用方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性所引用的控件为 <see langword="null" />。</exception>
        <block subset="none" type="overrides"><para>需要扩展<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件的开发人员可能希望在派生类中重写此方法。 一种方法是调用基方法, 然后添加一些附加的自定义处理, 或者您可能需要完全自定义完成控件编辑的整个过程。 例如, 在重写方法中, 你可以先调用基方法, 然后添加一些代码来确定进行了哪些编辑更改, 并显示返回给最终用户的更改列表作为确认。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ExportSensitiveDataWarning">
      <MemberSignature Language="C#" Value="public virtual string ExportSensitiveDataWarning { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ExportSensitiveDataWarning" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ExportSensitiveDataWarning As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ExportSensitiveDataWarning { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ExportSensitiveDataWarning : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在用户尝试从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件导出敏感状态数据时显示的警告消息的文本。</summary>
        <value>一个包含警告消息的字符串。 默认消息是由 .NET Framework 提供的、特定于区域性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当用户尝试从<xref:System.Web.UI.WebControls.WebParts.WebPart>控件中导出敏感状态数据时, 如果导出的任何数据来自源代码中标记为 "敏感" 的成员, 则会在消息框中向用户显示一条警告消息, 告诉他们正在导出敏感数据, 并提供取消导出的机会。 开发人员可以通过在成员上将`isSensitive` `[Personalizable]`属性的参数设置为来`true`将特定成员的数据标记为敏感数据。 有关此特性和参数的详细信息, 请参阅<xref:System.Web.UI.WebControls.WebParts.PersonalizableAttribute>类。  
  
> [!IMPORTANT]
>  使用 Web 部件的导出功能时, 敏感数据可能会导出到未经授权的用户。 有关如何防范此威胁的详细信息, 请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 每当用户尝试导出时, 都会显示默认消息。 但是, 通过将值分配给<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性, 可以提供自定义警告消息。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportSensitiveDataWarning%2A>属性的声明性用法。  
  
 以下网页的代码使用标准<xref:System.Web.UI.WebControls.BulletedList>控件, 并将其放在区域中。 控件将在运行时与<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件一起包装, 这样它就可以作为真正<xref:System.Web.UI.WebControls.WebParts.WebPart>的控件。 若要使控件可导出, `ExportMode`请将属性添加`<asp:bulletedlist>`到元素, 并将属性值设置为<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All>, 这意味着可以导出敏感数据和非敏感数据。 另请注意, 在`<asp:webpartmanager>`元素中`ExportSensitiveDataWarning` , 为属性分配自定义值。  
  
 请注意, 若要使代码示例正常运行, 必须在 web.config 文件中添加一个设置, 才能导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在部分中, 请确保有一个`<webParts>`元素的`enableExport`属性设置为`true`, 如以下标记所示。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/CS/wpmgrExportSensitiveWarningCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_ExportSensitiveData#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_ExportSensitiveData/VB/wpmgrExportSensitiveWarningVB.aspx#1)]  
  
 在浏览器中加载页面后, 单击包含链接的控件的标题栏中的谓词菜单 (由向下箭头表示)。 在谓词菜单中, 选择 "**导出**", 并注意出现带有自定义警告的消息框。 如果要继续导出, 请单击 **"确定**", 这将允许你使用有关控件的所有数据保存 XML 说明文件的本地副本。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ExportWebPart">
      <MemberSignature Language="C#" Value="public virtual void ExportWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExportWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExportWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit&#xA;override this.ExportWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Xml.XmlWriter -&gt; unit" Usage="webPartManager.ExportWebPart (webPart, writer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="webPart">将从中导出数据的控件。</param>
        <param name="writer">一个 <see cref="T:System.Xml.XmlWriter" />，它将导出的数据从 <paramref name="webPart" /> 写入 XML 说明文件。</param>
        <summary>创建包含服务器控件的状态和属性数据的 XML 说明文件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>将各种状态和属性数据从汇编`webPart`到 XML 文件中。 数据包括有关控件本身的信息, 包括其程序集、状态数据和属性数据。 启动导出的用户可将 XML 文件保存到本地计算机或网络上的磁盘。 然后, 其他用户可以将该描述文件导入到另一个页面或网站, 并将状态和属性数据应用到的另`webPart`一个实例。 这为用户提供了一种快速而方便的机制, 用于在服务器控件上共享和重用其设置, 还为开发人员提供了一种控制导出和导入控件的外观和行为的方法。  
  
 默认情况`webPart`下, 不导出上的属性。 若要允许导出属性, 必须在源代码中使用`[Personalizable]`属性对其进行标记。 通过将`isSensitive` `[Personalizable]`属性的参数设置为`true`, 还可以选择性地将可导出属性标记为包含敏感数据。 默认情况下`isSensitive` , `false`为。 开发人员可以将参数设置`true`为, 以指示数据是敏感的。  
  
 若要`webPart`允许导出, 开发人员可将其<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>属性值设置为<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.All> (包括所有可个性化的和敏感属性), 或<xref:System.Web.UI.WebControls.WebParts.WebPartExportMode.NonSensitiveData>设置为, 这将导出除敏感属性以外的所有内容.  
  
> [!IMPORTANT]
>  允许用户从控件中导出数据, 并将数据导入到其他控件中, 这会带来一些安全风险。 开发人员应使用上面所述的方法来保护敏感数据, 如果他们想避免完全公开数据的风险, 根本不应启用导出`webPart` 。 有关 Web 部件安全问题的详细信息, 请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。  
  
- 或 - 
 <paramref name="writer" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 中所引用的控件集合中。  
  
- 或 - 
<paramref name="webPart" /> 的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" /> 属性设置为值 <see cref="F:System.Web.UI.WebControls.WebParts.WebPartExportMode.None" />，该值表明对 <paramref name="webPart" /> 禁用导出。</exception>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.ExportMode" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保护 Web 部件页面</related>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public override void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Focus();" />
      <MemberSignature Language="F#" Value="override this.Focus : unit -&gt; unit" Usage="webPartManager.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>被重写以防止将焦点设置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件上，因为该控件没有用户界面 (UI)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法将重写基<xref:System.Web.UI.Control.Focus%2A?displayProperty=nameWithType>方法, 并在调用方调用方法时引发异常。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Focus%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager>由于控件没有 UI, 并且对用户从不可见, 因此它永远不允许对其自身设置焦点。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">调用方尝试调用 <see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.Focus" /> 方法，该方法在没有用户界面的控件中不受支持。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConsumerConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection GetConsumerConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ConsumerConnectionPointCollection ^ GetConsumerConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection&#xA;override this.GetConsumerConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" Usage="webPartManager.GetConsumerConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的使用者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" /> 对象的集合，这些对象可以作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的使用者。</summary>
        <returns>包含使用者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接始终只涉及两个控件, 一个充当数据的提供者, 另一个用作数据的使用者。 每个控件都必须具有一个或多个定义为连接点的方法。 对于使用者控件, 其连接点为<xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint>对象。 若要构建 Web 部件连接, 必须检索使用者连接点。  
  
 使用者必须始终至少有一个连接点才能建立连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>方法检查使用者控件并检索其所有连接点的集合。 <xref:System.Web.UI.WebControls.WebParts.WebPart>如果控件没有连接点, 则该方法返回一个空集合。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A> 方法。  
  
 此代码示例包含四个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页, 其中包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的自定义控件和一个`<asp:webpartmanager>`元素。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅主题[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 网页的声明性标记包含`Register`用户控件和自定义控件的指令。 有一个`<asp:webpartmanager>`元素、一个`<asp:webpartzone>`元素包含自定义控件和一个`<asp:connectionszone>`元素。 请注意, 在`Page_Load`方法中, 代码会检查连接是否已存在, 如果不存在, 则定义提供程序、使用者及其各自的连接点, 然后将新连接添加到由引用的静态连接集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。 请注意, <xref:System.Web.UI.WebControls.WebParts.ConsumerConnectionPointCollection>通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints%2A>使用方法检索的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>被传递给方法, 以确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取此代码以及用于编译该代码的说明。  
  
 在浏览器中加载网页后, 请单击 "**显示模式**" 下拉列表控件, 然后选择 "**连接**", 将页面切换到连接模式。 连接模式使用`<asp:connectionszone>`元素使您能够在控件之间创建连接。 在连接模式下, 单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单, 然后单击 "**连接**"。 连接用户界面 (UI) 出现后, 请注意, 连接已由`Page_Load`方法中包含的代码创建。 如果在后续浏览器会话中返回到此页, 则已建立此静态连接, 并且每次加载页面时都不需要重新创建此静态连接。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ConsumerConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentWebPartManager">
      <MemberSignature Language="C#" Value="public static System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.WebControls.WebParts.WebPartManager GetCurrentWebPartManager(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager(System.Web.UI.Page)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Web::UI::WebControls::WebParts::WebPartManager ^ GetCurrentWebPartManager(System::Web::UI::Page ^ page);" />
      <MemberSignature Language="F#" Value="static member GetCurrentWebPartManager : System.Web.UI.Page -&gt; System.Web.UI.WebControls.WebParts.WebPartManager" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager page" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 的实例的网页。</param>
        <summary>检索对页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的当前实例的引用。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />，引用该控件在页上的当前实例。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>要检索对当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的引用的上下文中, 方法非常有用。 常见的情况是, 如果您正在编写一个自定义控件, 而该控件在开发过程中无法识别, 则<xref:System.Web.UI.WebControls.WebParts.WebPartManager>其页上的控件的 ID 将是什么。  
  
> [!NOTE]
>  方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>是静态的, 因此可以直接调用, 而无需使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的实例。  
  
 Web 部件控件集中的某些控件 (如<xref:System.Web.UI.WebControls.WebParts.WebPart>控件) <xref:System.Web.UI.WebControls.WebParts.WebPart.WebPartManager%2A>具有可以检索对当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的引用的属性。 因此, 使用此类控件时, 应使用此属性来检索引用。  
  
 如果要在知道<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件 ID 的上下文 (例如在网页中编写内联代码) 中进行编码, 则使用其 ID 直接<xref:System.Web.UI.WebControls.WebParts.WebPartManager>引用控件是最简单且最有效的方法。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A> 方法。 该示例包含两个部分: 一个自定义服务器控件和一个承载控件的网页。  
  
 自定义<xref:System.Web.UI.WebControls.Label>控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetCurrentWebPartManager%2A>使用方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager>检索当前页上的控件的 id, 然后显示该 id。  
  
 [!code-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/MyManagerIDLabel.cs#2)]
 [!code-vb[WebParts_WebPartManager_GetCurrentWebPartManager#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/MyManagerIDLabel.vb#2)]  
  
 下面的代码示例提供了在<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域中承载控件的网页。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/CS/getCurrentWPManagerCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetCurrentWebPartManager#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetCurrentWebPartManager/VB/getcurrentWPManagervb.aspx#1)]  
  
 在浏览器中加载页面后, 请注意, 当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的 ID 显示在自定义<xref:System.Web.UI.WebControls.Label>控件中。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="page" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetDisplayTitle">
      <MemberSignature Language="C#" Value="protected internal virtual string GetDisplayTitle (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance string GetDisplayTitle(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetDisplayTitle(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::String ^ GetDisplayTitle(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string&#xA;override this.GetDisplayTitle : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetDisplayTitle webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">此方法返回其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值的控件。</param>
        <summary>获取一个字符串，其中包含 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的值。</summary>
        <returns>一个字符串，包含 <paramref name="webPart" /> 的计算得出的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" /> 值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 获取的<xref:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle%2A> `webPart`属性的计算值。 当开发人员不将值分配给<xref:System.Web.UI.WebControls.WebParts.Part.Title%2A> <xref:System.Web.UI.WebControls.WebParts.WebPart>控件的属性时, 此方法将生成要显示为标题的值。 "无标题" 控件的计算值包含一个追加到字符串的数字, 该数字指示控件在当前区域中的序列。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 不在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 集合中。</exception>
        <block subset="none" type="overrides"><para>可以重写此方法, 以更改如何计算默认显示标题。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.DisplayTitle" />
      </Docs>
    </Member>
    <Member MemberName="GetExportUrl">
      <MemberSignature Language="C#" Value="public string GetExportUrl (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetExportUrl(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetExportUrl(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.GetExportUrl : System.Web.UI.WebControls.WebParts.WebPart -&gt; string" Usage="webPartManager.GetExportUrl webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在导出的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />。</param>
        <summary>获取当用户尝试导出 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件时包含在请求中的相对虚拟路径和查询字符串。</summary>
        <returns>一个字符串，其中包含共同形成导出控件请求的相对虚拟路径和查询字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法返回的值是指向包含控件的页面的服务器位置的相对虚拟路径, 以及构成提交到服务器的导出请求的追加查询字符串值。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetExportUrl%2A>方法在允许提交请求之前对字符串进行编码, 以防止恶意脚本攻击。  
  
> [!NOTE]
>  有关保护 Web 部件应用程序安全的详细信息, 请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.WebControls.WebParts.GenericWebPart GetGenericWebPart(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart(System.Web.UI.Control)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::UI::WebControls::WebParts::GenericWebPart ^ GetGenericWebPart(System::Web::UI::Control ^ control);" />
      <MemberSignature Language="F#" Value="member this.GetGenericWebPart : System.Web.UI.Control -&gt; System.Web.UI.WebControls.WebParts.GenericWebPart" Usage="webPartManager.GetGenericWebPart control" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.GenericWebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">一个服务器控件，它存在于 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 中，并在运行时被包装为 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 的子控件。</param>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 控件的实例的引用，该实例包含一个服务器控件。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />，将 <paramref name="control" /> 包装为子控件。 如果 <paramref name="control" /> 未包含在 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 中，则此方法返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, 开发人员将两类控件置于区域中<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>以参与 Web 部件应用程序: <xref:System.Web.UI.WebControls.WebParts.WebPart>控件<xref:System.Web.UI.WebControls.WebParts.WebPart> (继承自基类的控件) 以及其他服务器控件 (可以是标准的)ASP.NET 控件、自定义控件或用户控件。 如果这些控件中有任何控件放在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>某个区域中, 它将采用<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的功能。 控件<xref:System.Web.UI.WebControls.WebParts.WebPart>在本质上是此功能, 但其他类型的服务器控件不具有此功能。 为了使其他服务器控件<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>在被放置在区域中时作为控件, <xref:System.Web.UI.WebControls.WebParts.GenericWebPart> ASP.NET 使用控件对它们进行包装。 由于控件是直接从类继承的, 因此它提供具有 true Web 部件功能的子控件。 <xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.GenericWebPart>  
  
 通常在运行时, 页开发人员可能希望获取对<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包含区域中的服务器控件之一的控件的引用。 方法使它们能够检索<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对控件的引用。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>  
  
   
  
## Examples  
 下面的代码示例演示<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法的用法。 此代码示例包含<xref:System.Web.UI.WebControls.Calendar> <xref:System.Web.UI.WebControls.WebParts.WebPartZone>在区域中声明的控件。 方法首先将<xref:System.Web.UI.WebControls.Calendar>控件的 ID 输出到标签<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A> , 然后使用方法检索对<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>包装日历的控件的引用。 `Button1_Click` <xref:System.Web.UI.WebControls.WebParts.GenericWebPart>控件的 id 以及其子控件的 id ( <xref:System.Web.UI.WebControls.Calendar>控件) 均打印到第二个标签。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/CS/getGenericWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_GetGenericWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_GetGenericWebPart/VB/getGenericWebPartVB.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="control" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="GetProviderConnectionPoints">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection GetProviderConnectionPoints(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::ProviderConnectionPointCollection ^ GetProviderConnectionPoints(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="abstract member GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection&#xA;override this.GetProviderConnectionPoints : System.Web.UI.WebControls.WebParts.WebPart -&gt; System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" Usage="webPartManager.GetProviderConnectionPoints webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">作为连接中的提供者的服务器控件。</param>
        <summary>检索 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" /> 对象的集合，这些对象可作为来自如下服务器控件的连接点：该服务器控件正在作为 Web 部件连接中的提供者。</summary>
        <returns>包含提供者中的所有连接点的 <see cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件连接始终只涉及两个控件, 一个充当数据的提供者, 另一个用作数据的使用者。 每个控件都必须具有一个或多个定义为连接点的方法。 对于提供程序控件, 其连接点为<xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint>对象。  
  
 提供程序必须始终至少有一个连接点才能建立连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>方法检查提供程序控件, 并检索其所有连接点的集合。 检索提供程序连接点是建立 Web 部件连接的必需步骤。  
  
   
  
## Examples  
 下面的代码示例演示如何使用 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A> 方法。  
  
 该示例包含四个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   一个网页, 其中包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的自定义控件和一个`<asp:webpartmanager>`元素。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   说明如何在浏览器中工作。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 网页的声明性标记包含`Register`用户控件和自定义控件的指令。 有一个`<asp:webpartmanager>`元素、一个`<asp:webpartzone>`元素包含自定义控件和一个`<asp:connectionszone>`元素。 请注意, 在`Page_Load`方法中, 代码会检查连接是否已存在, 如果不存在, 则定义提供程序、使用者及其各自的连接点, 然后将新连接添加到由引用的静态连接集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。 请注意, <xref:System.Web.UI.WebControls.WebParts.ProviderConnectionPointCollection>通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetProviderConnectionPoints%2A>使用方法检索的对象<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CanConnectWebParts%2A>被传递给方法, 以确定是否可以创建两个控件之间的连接。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 该示例的第三部分是控件的源代码。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取此代码以及用于编译该代码的说明。  
  
 在浏览器中加载网页后, 请单击 "**显示模式**" 下拉列表控件, 然后选择 "**连接**", 将页面切换到连接模式。 连接模式使用`<asp:connectionszone>`元素使您能够在控件之间创建连接。 在连接模式下, 单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单, 然后单击 "**连接**"。 连接用户界面 (UI) 出现后, 请注意, 连接已由`Page_Load`方法中包含的代码创建。 如果在后续浏览器会话中返回到此页, 则已建立此静态连接, 并且每次加载页面时都不需要重新创建此静态连接。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ProviderConnectionPoint" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.GetConsumerConnectionPoints(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="ImportWebPart">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.WebPart ImportWebPart (System.Xml.XmlReader reader, out string errorMessage);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.WebPart ImportWebPart(class System.Xml.XmlReader reader, [out] string&amp; errorMessage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart(System.Xml.XmlReader,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ImportWebPart (reader As XmlReader, ByRef errorMessage As String) As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::WebPart ^ ImportWebPart(System::Xml::XmlReader ^ reader, [Runtime::InteropServices::Out] System::String ^ % errorMessage);" />
      <MemberSignature Language="F#" Value="abstract member ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart&#xA;override this.ImportWebPart : System.Xml.XmlReader *  -&gt; System.Web.UI.WebControls.WebParts.WebPart" Usage="webPartManager.ImportWebPart (reader, errorMessage)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="errorMessage" Type="System.String" RefType="out" />
      </Parameters>
      <Docs>
        <param name="reader">一个 <see cref="T:System.Xml.XmlReader" />，它从导入的 XML 说明文件中读取状态和属性数据。</param>
        <param name="errorMessage">在导入过程中遇到错误时将向用户显示的 <see cref="T:System.String" />。</param>
        <summary>导入包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的状态和属性数据的 XML 说明文件，并将这些数据应用于控件。</summary>
        <returns>在导入的 XML 说明文件中引用的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" />（或由 <see cref="T:System.Web.UI.WebControls.WebParts.GenericWebPart" /> 包装并因此被视为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 的服务器控件）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>将导入<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A>由方法为服务器控件创建的 XML 说明文件。 它不是实际导入的服务器控件, 而只是包含有关控件的状态和属性数据的说明文件。 说明文件中引用的控件和程序集必须已在用户尝试导入说明文件的服务器上可用。  
  
 若要启用导入控件, 开发人员需要在启用<xref:System.Web.UI.WebControls.WebParts.CatalogZone>了导入的页面上添加一个控件。 在区域中, <xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>必须添加控件。 此控件提供一个文件对话框, 该对话框允许用户浏览并找到要导入的描述文件。  
  
 用户查找说明文件并开始导入后, 将通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法读取说明文件。 如果没有错误并且找到程序集和控件, 则将服务器控件添加到<xref:System.Web.UI.WebControls.WebParts.ImportCatalogPart>控件内的目录中, 并将说明文件中指定的各种属性和状态数据应用于控件。 然后, 用户可以选择控件, 并将其添加到页面中。  
  
> [!IMPORTANT]
>  与方法一样, 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ImportWebPart%2A>方法可能会导致安全风险。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart%2A> 由于它涉及到将数据导入到网站, 因此恶意用户可能会尝试将错误的数据甚至脚本代码插入到导入的描述文件中。 然后, 错误数据可能出现在页面或数据库中, 或者插入的脚本可以运行。 有关与导入说明文件相关的潜在风险的概述, 以及避免这些风险的方法, 请参阅[保护 Web 部件页面](https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.EndOfStreamException"><paramref name="reader" /> 未能读取文件。  
  
或 
 需要 <paramref name="reader" /> 来显示导入错误消息，但在文件中未找到。  
  
或 
 <paramref name="reader" /> 已到达文件末尾，但未找到包含导出数据的 XML 元素。</exception>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.ImportCatalogPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.ExportWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Xml.XmlWriter)" />
        <related type="Article" href="https://msdn.microsoft.com/library/8ada6210-ed00-4157-b3e9-a7e87e77caa2">保护 Web 部件页面</related>
      </Docs>
    </Member>
    <Member MemberName="Internals">
      <MemberSignature Language="C#" Value="protected System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartManagerInternals Internals" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Internals As WebPartManagerInternals" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ Internals { System::Web::UI::WebControls::WebParts::WebPartManagerInternals ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Internals : System.Web.UI.WebControls.WebParts.WebPartManagerInternals" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Internals" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartManagerInternals</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 类的引用，该类用于合并和拆分实际在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 类中实现的，但通常对控件开发人员很有用的一组方法。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" />，<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 通过它可引用已拆分为 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManagerInternals" /> 的各种方法。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性公开 api 以调入一<xref:System.Web.UI.WebControls.WebParts.WebPartManager>组方法, 这些方法主要用于扩展性情况。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>  
  
 使用这些内部方法的设计方式是通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Internals%2A>属性访问这些方法。 由于属性是受保护的, 因此只能通过<xref:System.Web.UI.WebControls.WebParts.WebPartManagerInternals> <xref:System.Web.UI.WebControls.WebParts.WebPartManager>从类继承来访问它并调用类的实例中的方法。  
  
> [!NOTE]
>  此属性在中的 IntelliSense 中[!INCLUDE[vsprvsext](~/includes/vsprvsext-md.md)]是隐藏的。 但是, 在派生<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类中, 你仍然可以访问属性及其各种成员。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsAuthorized">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定能否将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件添加到页中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Web 部件功能的一个灵活性, 就是在运行时将服务器控件添加到网页中。 在许多常见情况下, 可以添加服务器控件 (可以是自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、自定义服务器控件、用户控件或 ASP.NET 控件)。  
  
 在下面的常见方案中, Web 部件控件集尝试将服务器控件添加到页, 并<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>调用方法来授权它们:  
  
-   添加服务器控件时, 通过在<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域内的网页的标记中对其进行声明来添加服务器控件。  
  
-   以编程方式将服务器控件添加到区域。  
  
-   用户将服务器控件导入到 Web 部件的控件目录中。  
  
-   从个性化设置数据存储区加载现有服务器控件时。  
  
-   将服务器控件添加到<xref:System.Web.UI.WebControls.WebParts.DeclarativeCatalogPart>控件, 使其在服务器控件的目录中可用。  
  
 在添加控件的每个方案中, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>将调用方法以确保已满足所有授权条件, 以允许添加控件。 当控件获得授权时, 它将以正常方式添加 (如果没有筛选方案)。 当控件未获得授权时, Web 部件控件集可以通过多种方式进行响应, 具体取决于上下文。 控件集可以在无提示的情况下添加未经授权的部分 (如果无需通知用户), 它可以显示错误消息, 也可以将<xref:System.Web.UI.WebControls.WebParts.UnauthorizedWebPart>类的实例添加为占位符。 此占位符对象在页面上不可见, 但在页源代码中可见, 表示排除了未经授权的控件。  
  
 控制是否获得授权的决定是授权筛选器。 授权筛选器是 Web 部件控件集中的一项功能, 它使开发人员可以从页中排除不满足指定条件的任何控件。  
  
 若要创建筛选方案, 开发人员必须执行两项操作。 首先, 必须将字符串值 (值可以是任意值) 分配给它们计划<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>在方案中<xref:System.Web.UI.WebControls.WebParts.WebPart>使用的每个控件的属性。 它们还可以为不<xref:System.Web.UI.WebControls.WebParts.WebPart>是控件的其他类型的服务器控件分配此属性的值, 因为如果将这些控件放置在区域中<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase> , 则在运行时将<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>此类控件与控件一起包装, 并且此控件继承<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。  
  
 创建筛选方案的第二个必要步骤是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法, 或创建<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件的事件处理程序。 在这些方法中, 开发人员可以检查<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性, 如果该值指示控件不应获得授权, 开发人员可确保该<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> `false`方法返回值。  
  
> [!NOTE]
>  有关代码示例和如何使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法设置自定义筛选方案的说明, 请参阅方法重载主题。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public bool IsAuthorized (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAuthorized(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsAuthorized(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.IsAuthorized : System.Web.UI.WebControls.WebParts.WebPart -&gt; bool" Usage="webPartManager.IsAuthorized webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">正在接受授权检查的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <summary>执行确定控件是否被授权添加到页中的初始步骤。</summary>
        <returns>一个布尔值，指示能否将 <paramref name="webPart" /> 添加到页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法是 Web 部件控件集调用的初始方法, 以检查<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的授权。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> 它接受`webPart`作为参数, 并开始最终确定是否将控件添加到页面的进程。 需要确定给定控件是否已获得授权时, 直接从代码调用此方法。  
  
 此方法执行初始任务, 这些任务确定控件<xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.GenericWebPart>是从类继承还是从控件继承, 如果是, 则执行其包含的子控件的类型。 若要完成授权任务, 它将调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法。  
  
   
  
## Examples  
 下面的代码示例演示如何从代码中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>调用方法, 以确定是否有权将控件添加到页中。  
  
 此代码示例包含三个部分:  
  
-   重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager>方法的自定义控件。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>  
  
-   为<xref:System.Web.UI.WebControls.WebParts.WebPart>控件创建筛选器的网页。  
  
-   有关如何运行代码示例的说明。  
  
 此代码示例使用一个自<xref:System.Web.UI.WebControls.WebParts.WebPartManager>定义控件, 该<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>控件重写重载方法以提供对<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性的自定义处理。 此控件检查的属性值`admin`是否为, 如果值存在, 则授权控件。 如果控件具有不同的值, 则不会获得授权;不具有属性值的控件也会获得授权, 因为它们不是筛选方案的一部分。  
  
 若要运行此代码示例, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此代码示例使用动态编译方法。 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 此代码示例的第二部分创建可能排除控件的筛选器。 以下网页包含`<asp:webpartzone>`元素中的三个 ASP.NET 服务器控件。 请注意, 第一个和第二个<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>控件的属性设置为不同的值, 而第三个控件未分配属性。 此授权值可在运行时检查, 如果筛选器与开发人员设置的条件匹配, 则可以将控件添加到页面。 另请注意, 在`Page_Load`方法中, 代码<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Web.UI.WebControls.WebParts.WebPart%29>调用方法来确定每个控件是否获得授权, 如果是, 则设置每个控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 请注意, 若要使代码示例正常运行, 必须在 web.config 文件中添加一个设置, 以便导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在部分中, 请确保有一个`<webParts>`元素的`enableExport`属性设置为`true`, 如以下标记所示。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 在浏览器中加载页面后, 请注意, 将显示第一个控件, 因为它与重写的方法中的条件相匹配。 不会将第二个控件添加到页面中, 因为它已被筛选器排除。 还添加了第三个控件, 因为它没有设置其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。 请注意, 如果单击任一控件的标题栏中的谓词菜单图标, 则可以导出它们, 因为它们各自<xref:System.Web.UI.WebControls.WebParts.WebPart.ExportMode%2A>的属性值已分配。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>此方法是从代码中直接调用的。 如果要对授权过程进行更多的编程控制, 可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />重载方法。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsAuthorized">
      <MemberSignature Language="C#" Value="public virtual bool IsAuthorized (Type type, string path, string authorizationFilter, bool isShared);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAuthorized(class System.Type type, string path, string authorizationFilter, bool isShared) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized(System.Type,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAuthorized(Type ^ type, System::String ^ path, System::String ^ authorizationFilter, bool isShared);" />
      <MemberSignature Language="F#" Value="abstract member IsAuthorized : Type * string * string * bool -&gt; bool&#xA;override this.IsAuthorized : Type * string * string * bool -&gt; bool" Usage="webPartManager.IsAuthorized (type, path, authorizationFilter, isShared)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="authorizationFilter" Type="System.String" />
        <Parameter Name="isShared" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">被检查授权情况的控件的 <see cref="T:System.Type" />。</param>
        <param name="path">被授权的控件的源文件的相对应用程序路径（如果该控件为用户控件）。</param>
        <param name="authorizationFilter">赋予 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 属性的任意字符串值，用于授权是否可将控件添加至页中。</param>
        <param name="isShared">指示被检查授权情况的控件是否为共享控件，共享意味着它对应用程序的许多用户或所有用户可见，并且其 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.IsShared" /> 属性值设为 <see langword="true" />。</param>
        <summary>执行确定控件是否已经过授权可添加至页的最后步骤。</summary>
        <returns>一个布尔值，指示控件是否已经过授权可添加至页中。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>重载方法执行确定是否有权将控件添加到页中的最后一个步骤。 方法可确保`type`为有效类型, `path`且只有当要检查的控件是用户控件时才具有值。 然后, 它调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>引发事件的关键方法。  
  
   
  
## Examples  
 下面的代码示例演示如何重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>方法, 以确定是否有权将控件添加到页中。  
  
 第一步是创建可能排除控件的筛选器。 以下网页包含`<asp:webpartzone>`元素中的三个 ASP.NET 服务器控件。 请注意, 第一个和第二个<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>控件的属性设置为不同的值, 而第三个控件未分配属性。 此授权值可在运行时检查, 如果筛选器与开发人员设置的条件匹配, 则可以将控件添加到页面。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/IsAuthorizedCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsAuthorized#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/IsAuthorizedVB.aspx#1)]  
  
 第二步是重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29>方法, 并为授权筛选器创建自定义处理。 请注意, 代码首先检查属性是否具有值, 以便自动添加未分配<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性的任何控件。 如果控件具有筛选器, 则仅当筛选`true`器值`admin`等于时, 代码才会返回。 这说明了一种简单的机制, 可用于根据特定用户的角色向某些用户显示特定控件。 尽管使用角色的完整示例超出了本主题的范围, 但你可以使用与此代码示例中的重写方法相同的逻辑, 但你可以检查当前用户是否在与授权筛选器值匹配的角色中。, 然后仅为该用户添加控件。 这使您能够创建一些用户将看到所有控件的页面, 而其他用户将只看到选定的控件。 这就是使用角色检查筛选器的逻辑的方式:  
  
```vb  
If Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter) Then  
  return True  
Else  
  return False  
End If  
```  
  
```csharp  
if(Roles.IsUserInRole(Page.User.Identity.Name, authorizationFilter))  
    return true;  
else  
    return false;  
```  
  
 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此代码示例使用动态编译方法。 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/CS/MyManagerAuthorize.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsAuthorized#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsAuthorized/VB/MyManagerAuthorize.vb#2)]  
  
 在浏览器中加载页面后, 请注意, 将显示第一个控件, 因为它与重写的方法中的条件相匹配。 不会将第二个控件添加到页面, 因为它的筛选器值已排除。 添加第三个控件, 因为它没有设置其<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性。 如果在第二个控件上将属性值更改为与第一个控件的属性值相匹配, 然后再次运行该页, 则还将添加第二个控件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> 为用户控件，且 <paramref name="path" /> 为 <see langword="null" /> 或空字符串 ("")。  
  
- 或 - 
 <paramref name="type" /> 不是用户控件，且 <paramref name="path" /> 已赋值。</exception>
        <block subset="none" type="overrides"><para>如果要在检查授权时提供附加处理<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> , 可以通过从类继承来重写此方法。 你可能想要重写方法以检查<paramref name="authorizationFilter" />参数中的某些值, 并根据值返回一个布尔值, 该值确定是否将控件添加到页中。  
  
对于还希望检查授权筛选器并提供自定义处理的页开发人员, 可以选择在 .aspx 页或代码隐藏文件中执行此操作, 而无需从任何类继承。 可以在页中为<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" /> <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件的方法声明备用事件处理程序。 有关更多详细信息和示例, 请<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />参见方法。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="IsCustomPersonalizationStateDirty">
      <MemberSignature Language="C#" Value="protected virtual bool IsCustomPersonalizationStateDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsCustomPersonalizationStateDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsCustomPersonalizationStateDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCustomPersonalizationStateDirty : bool" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示是否已进行了个性化设置更改，这些更改影响 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件所控制的页级别个性化设置详细信息。</summary>
        <value>一个布尔值，指示是否已进行了个性化设置更改。 默认值为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件在内部使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>此属性来跟踪它所管理的任何页面级别的个性化设置数据是否已更改。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 当用户在页面级别执行各种个性化设置操作 (例如, 添加或删除<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、连接或断开控件、更改页的布局、移动控件和其他操作) 时, 个性化数据会发生更改。  
  
> [!NOTE]
>  用户还可以在控件级别执行个性化设置, 这意味着它们对特定控件进行个性化更改, 而更改只影响该控件。 例如, 将编辑该控件并更改其标题文本或其背景色。 控件级别的个性化设置不会影响<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件所跟踪的页级别的个性化设置数据, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>因此当发生控件级个性化时, `true`属性值不会更改为。  
  
 尽管方法是受保护的, 并且不能由调用方直接访问<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> , 但该属性可由调用方直接访问, 并返回此属性的值。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.PersonalizationState.IsDirty" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.PersonalizationState.SetDirty" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected internal override void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub LoadControlState (savedState As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void LoadControlState(System::Object ^ savedState);" />
      <MemberSignature Language="F#" Value="override this.LoadControlState : obj -&gt; unit" Usage="webPartManager.LoadControlState savedState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">包含要加载的保留的状态数据。</param>
        <summary>加载从前一个页请求保存并需要在后续请求上还原的控件状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法有助于还原应在页的回发之间保留的属性数据, 即使在<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`时也是如此。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadControlState%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="savedState" /> 不是有效的 <see cref="P:System.Web.UI.PageStatePersister.ControlState" />。</exception>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void LoadCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub LoadCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void LoadCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.LoadCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.LoadCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>存储由个性化对象传递给 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化数据，稍后会将其用于初始化过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法以<xref:System.Web.UI.WebControls.WebParts.PersonalizationDictionary>对象的形式提供保存的状态数据。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A> 此数据最终用于将个性化设置数据加载到 Web 部件控件中并执行其他初始化任务。  
  
> [!NOTE]
>  此方法由一系列方法调用, 此方法在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState%2A>方法最初请求关联<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>对象以向<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件提供个性化数据时开始。  
  
 不能直接从代码中调用此方法。 但是, 可以直接调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Load%2A>方法, 该方法本身会<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A>调用方法并返回个性化数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以在<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类中重写方法。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="MediumPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MediumPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MediumPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MediumPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MediumPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MediumPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MediumPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</summary>
        <value>仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Medium" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性返回的对象在类型反序列化过程中使用。<xref:System.Security.PermissionSet>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimalPermissionSet">
      <MemberSignature Language="C#" Value="protected virtual System.Security.PermissionSet MinimalPermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet MinimalPermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property MinimalPermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Security::PermissionSet ^ MinimalPermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimalPermissionSet : System.Security.PermissionSet" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.MinimalPermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</summary>
        <value>获取仅允许 <see cref="T:System.Security.PermissionSet" /> 权限和 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Execution" /> 权限的 <see cref="F:System.Web.AspNetHostingPermissionLevel.Minimal" /> 对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在导入过程中, 将使用此属性返回的对象来实现除类型反序列化之外的所有内容。<xref:System.Security.PermissionSet>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveWebPart">
      <MemberSignature Language="C#" Value="public virtual void MoveWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart, System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int zoneIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart, class System.Web.UI.WebControls.WebParts.WebPartZoneBase zone, int32 zoneIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart, System::Web::UI::WebControls::WebParts::WebPartZoneBase ^ zone, int zoneIndex);" />
      <MemberSignature Language="F#" Value="abstract member MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit&#xA;override this.MoveWebPart : System.Web.UI.WebControls.WebParts.WebPart * System.Web.UI.WebControls.WebParts.WebPartZoneBase * int -&gt; unit" Usage="webPartManager.MoveWebPart (webPart, zone, zoneIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
        <Parameter Name="zone" Type="System.Web.UI.WebControls.WebParts.WebPartZoneBase" />
        <Parameter Name="zoneIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="webPart">要移动的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件。</param>
        <param name="zone"><paramref name="webPart" /> 要移动到的目标 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</param>
        <param name="zoneIndex">一个整数，指示 <paramref name="webPart" /> 在 <paramref name="zone" /> 中相对于其他控件的索引。</param>
        <summary>将 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件从一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域移动到另一个区域，或移动到相同区域中的新位置。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用方法移动`webPart`到同一区域或不同区域中的新位置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 您可以直接从代码调用此方法, 并且在用户使用 Web 部件用户界面 (UI) 中的各种选项将控件移动到新位置时也会调用此方法。  
  
 必须满足`webPart`一些条件, 然后才能移动, 其中的大部分条件由本主题的 "例外" 部分中列出的项指示。 如果`webPart`不包含<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>在要开始的区域中, 则不能将其移动到区域中。  
  
 满足条件后, 将`webPart`发生以下操作序列:  
  
1.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 事件。  
  
2.  `webPart`将从其当前区域中删除 (如有必要), 并将其添加到其新区域或其当前区域内的新位置。  
  
3.  <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A> 方法引发 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved> 事件。  
  
4.  源区域和<xref:System.Web.UI.WebControls.WebParts.WebPart>目标区域中每个控件的都将重置, 以反映已移动的控件。 `zoneIndex`  
  
   
  
## Examples  
 下面的代码示例演示如何从代码中<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>直接调用方法, 以<xref:System.Web.UI.WebControls.WebParts.WebPart>将控件从一个区域移到另一个区域。  
  
 此代码示例包含三个部分:  
  
-   用于更改显示模式的用户控件。  
  
-   用于承载控件的网页。  
  
-   有关如何运行代码示例的说明。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的详细信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 该示例的第二部分是包含两个区域的网页, 其中每个区域包含两个服务器控件。 当用户单击页面上的 "**移动 WebPart** " 按钮时, `Button1_Click`方法中的代码会将一个控件从第一个区域移动到第二个区域中的新位置。 请注意, 代码优先必须调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.GetGenericWebPart%2A>方法以<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>检索包装`list1`控件的对象。 这是必需的, 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法的第一个参数<xref:System.Web.UI.WebControls.WebParts.WebPart>需要控件, 而`list1`是 ASP.NET 服务器控件。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/CS/MoveWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_MoveWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_MoveWebPart/VB/MoveWebPartVB.aspx#1)]  
  
 页面加载后, 请单击 "**移动" "Web 部件**" 按钮, 并注意包含链接的控件将移到第二个区域中的中间位置。 控件的这一移动是通过调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>方法以编程方式完成的。 你还可以使用 "**显示模式**" 下拉列表控件将页面切换到设计模式, 并且在设计模式下, 可以将控件拖动到不同的区域或其区域中的不同位置。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A>控件也会调用方法来处理此类用户启动的移动。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="webPart" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Controls" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
或 
 <paramref name="zone" /> 未包含在 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" /> 控件的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 集合中。  
  
- 或 - 
<paramref name="webPart" /> 控件的 <see cref="P:System.Web.UI.WebControls.WebParts.WebPart.Zone" /> 属性所引用的区域为 <see langword="null" />，意味着 <paramref name="webPart" /> 当前未包含在任何区域中。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPart" /> 或 <paramref name="zone" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="zoneIndex" /> 小于零。</exception>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnAuthorizeWebPart">
      <MemberSignature Language="C#" Value="protected virtual void OnAuthorizeWebPart (System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAuthorizeWebPart(class System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart(System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAuthorizeWebPart (e As WebPartAuthorizationEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAuthorizeWebPart(System::Web::UI::WebControls::WebParts::WebPartAuthorizationEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit&#xA;override this.OnAuthorizeWebPart : System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs -&gt; unit" Usage="webPartManager.OnAuthorizeWebPart e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" /> 事件并调用该事件的处理程序（如果存在）。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当检查<xref:System.Web.UI.WebControls.WebParts.WebPart>控件中是否有<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>要添加到页的授权时, 方法将调用方法。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A> 调用方法时, 它会<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>引发事件, 如果有事件的处理程序方法, 则会调用该处理程序。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>  
  
 授权<xref:System.Web.UI.WebControls.WebParts.WebPart>控制过程是一项重要的 Web 部件功能。 由控件添加到区域的每个<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件都将通过授权过程来确定是否可以添加控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 默认情况下, Web 部件控件集不提供任何筛选条件来阻止将控件添加到区域。 但控制集确实为开发人员提供了创建其自己的筛选条件所需的机制。 通过使用这些机制, 你可以创建自定义筛选方案。 例如, 你可以创建一个筛选器, 以便在用户为管理员角色的情况下, 在呈现页面时将某些控件添加到区域, 如果用户处于用户角色中, 则不会添加这些控件。  
  
 在授权过程中筛选控件的机制是控件上<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> <xref:System.Web.UI.WebControls.WebParts.WebPart>的属性、 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>和<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法以及控件上的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件。  
  
 若要创建筛选方案, 实质上有两个任务。 首先, 将字符串分配给要<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>筛选的每<xref:System.Web.UI.WebControls.WebParts.WebPart>个控件的属性。 这些字符串值可以是任意的, 但它们应该包含要筛选的条件。 例如, 如果希望仅当管理员用户正在查看页面时才将给定控件添加到区域, 则可以将的`admin`字符串值分配给该属性。 然后, 可以使用 ASP.NET 角色功能, 并将站点的所有用户添加到各种角色, 如管理员、管理人员和用户。 加载页面时, 筛选代码将检查用户所在的角色, 并将其与要检查的控件上的授权筛选器值进行比较, 如果 (例如) 用户处于管理员角色中, 并且已将控件的<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>值设置为`admin`, 则可以添加控件。  
  
 创建筛选方案的第二步是编写代码来检查控件上<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A> <xref:System.Web.UI.WebControls.WebParts.WebPart>的属性值, 并确定是否在将每个控件添加到其区域之前对其进行授权。 有两个选项可用于放置此筛选代码。 第一个选项是页面开发人员的首选选项。 您可以创建一个方法来直接在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>网页服务器脚本代码或代码分离文件中处理事件。 将方法与事件相关联, 方法是`OnAuthorizeWebPart`将属性添加到页面中<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的标记中, 如下面的示例标记代码所示。  
  
```  
<asp:webpartmanager id="manager1" runat="server"   
   OnAuthorizeWebPart="manager1_AuthorizeWebPart" />  
```  
  
 所有自定义方法都必须检查<xref:System.Web.UI.WebControls.WebParts.WebPart>每个控件的筛选条件, 然后根据结果, 为<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs>对象的<xref:System.Web.UI.WebControls.WebParts.WebPartAuthorizationEventArgs.IsAuthorized%2A>属性指定一个布尔值, 以指示<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是否可以已. "示例" 部分中的代码演示如何执行此操作。  
  
 用于放置筛选代码的第二个选项是从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类继承, 并重写方法以检查筛选条件。 可以重写的两个方法是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>或方法。 尽管这两种方法都可正常运行, 但在大多数情况下<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A> , 最好重写方法, 因为它为您提供了对整个授权过程的更<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>强的编程控制, 而方法只执行了一个特定的任务, 用于引发事件并检查处理程序。 有关<xref:System.Web.UI.WebControls.WebParts.WebPartManager> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%28System.Type%2CSystem.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType>重写方法的自定义类的代码示例, 请参见方法的重载。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized%2A>  
  
   
  
## Examples  
 下面的代码示例演示如何设置<xref:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart>事件的自定义事件处理程序, 以便处理程序可以为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnAuthorizeWebPart%2A>方法提供自定义筛选代码。 此示例是一种典型的方法, 供页面开发人员提供筛选方案和授权<xref:System.Web.UI.WebControls.WebParts.WebPart>要添加到页面的控件。  
  
 请注意`<asp:webpartmanager>` , 在网页中, 元素`OnAuthorizeWebPart`具有属性, 该属性具有分配给它的事件处理程序的名称。 方法检查页上的控件是否将其各自<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>的属性值设置为`admin` , 如果是, 则返回`true`, 这意味着将对其进行授权并将其添加到页面中。  
  
> [!NOTE]
>  请注意, 没有任何分配给该<xref:System.Web.UI.WebControls.WebParts.WebPart.AuthorizationFilter%2A>属性的值的控件也会添加, 因为它们被假定不是筛选方案的一部分。 这种方法在筛选方案中是一种常见的方法: 筛选某些控件, 而其他控件则不是, 因为假定这些控件可供所有用户使用。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/CS/AuthorizeWebPartCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_AuthorizeWebPart#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_AuthorizeWebPart/VB/AuthorizeWebPartVB.aspx#1)]  
  
 由于在角色中设置用户超出了本主题的范围, 此代码示例不检查筛选中的用户角色。 但是, 根据用户角色筛选控件的方案可能是此筛选功能的最常见用途之一。 如果在网站上拥有角色, 并且想要检查此方法中的用户角色以筛选控件, 则该方法将类似于下面的代码块 (与前面的代码示例中不使用角色的更简单方法不同)。  
  
```vb  
Protected Sub WebPartManager1_AuthorizeWebPart(ByVal sender _  
  As Object, ByVal e As WebPartAuthorizationEventArgs)  
  
  If String.IsNullOrEmpty(e.AuthorizationFilter) Then  
    If Roles.IsUserInRole(Page.User.Identity.Name, _  
      e.AuthorizationFilter) Then  
  
      e.IsAuthorized = True  
    Else  
      e.IsAuthorized = False  
    End If  
  End If  
  
End Sub  
```  
  
```csharp  
protected void mgr1_AuthorizeWebPart(object sender,   
  WebPartAuthorizationEventArgs e)  
{  
  if (!String.IsNullOrEmpty(e.AuthorizationFilter))  
  {  
    if(Roles.IsUserInRole(Page.User.Identity.Name, e.authorizationFilter))  
      e.IsAuthorized = true;  
    else  
      e.IsAuthorized = false;  
  }  
}  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.AuthorizeWebPart" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.IsAuthorized" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivated : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivated : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" /> 事件以指示已加载页及其控件，并且已激活页上的连接，可以开始共享数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法在页面完成<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated>加载过程后引发事件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated%2A> 方法提供了一种为事件添加处理程序的方法。  
  
 页面开发人员可以为事件添加自定义处理程序, 方法`OnConnectionsActivated`是将属性`<asp:webpartmanager>`添加到页面中的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以在<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivated(System.EventArgs)" />派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类中重写方法。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivated" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnConnectionsActivating">
      <MemberSignature Language="C#" Value="protected virtual void OnConnectionsActivating (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnConnectionsActivating(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnConnectionsActivating (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnConnectionsActivating(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnConnectionsActivating : EventArgs -&gt; unit&#xA;override this.OnConnectionsActivating : EventArgs -&gt; unit" Usage="webPartManager.OnConnectionsActivating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" /> 事件以指示已加载页及其控件，可以开始激活连接的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating>引发事件, 该事件为开发人员提供了一种机制, 用于以编程方式自定义激活连接的过程。  
  
 页面开发人员可以为事件添加自定义处理程序, 方法`OnConnectionsActivating`是将属性`<asp:webpartmanager>`添加到页面中的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以在<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnConnectionsActivating(System.EventArgs)" />派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类中重写方法。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectionsActivating" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanged (System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanged(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanged (e As WebPartDisplayModeEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanged(System::Web::UI::WebControls::WebParts::WebPartDisplayModeEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanged : System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs" />，包含与更改后的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上已完成从一种显示模式切换到另一种显示模式的过程。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged%2A>基窗体中的方法只<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanged>引发事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanged(System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs)" />方法。 例如, 在显示模式发生更改后, 您可能希望更改用户界面 (UI) 外观中的某些内容, 具体取决于<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeEventArgs.OldDisplayMode" />属性中包含的显示模式。 或者, 您可能希望隐藏某些内容, 或显示某个控件。  
  
重写方法时, 通常应调用基方法作为重写方法的最后一步, 以便先运行自定义代码, 最后引发事件, 这表示模式更改已完成。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnDisplayModeChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnDisplayModeChanging (System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDisplayModeChanging(class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDisplayModeChanging (e As WebPartDisplayModeCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDisplayModeChanging(System::Web::UI::WebControls::WebParts::WebPartDisplayModeCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit&#xA;override this.OnDisplayModeChanging : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs -&gt; unit" Usage="webPartManager.OnDisplayModeChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">一个 <see cref="T:System.EventArgs" />，包含与正在更改的显示模式相关联的事件数据。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging" /> 事件，以指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件在网页上正处于从一种显示模式切换到另一种显示模式的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging%2A>基窗体中的方法只<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModeChanging>引发事件。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>您可以重写<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnDisplayModeChanging(System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs)" />方法。 例如, 当显示模式正在更改时, 您可能需要检查新显示模式将是什么 (通过使用<see cref="P:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCancelEventArgs.NewDisplayMode" />属性), 并根据新的显示模式将在用户界面 (UI) 中更改某些内容。 如果有自定义的显示模式, 则在自定义模式要为新的显示模式时, 您可能希望使某些控件可见。  
  
重写此方法时, 通常应调用基方法作为重写方法的第一步, 以便引发事件以指示显示模式正在开始更改。 然后, 在实际显示新的显示模式之前, 您的自定义代码可以在用户界面 (UI) 中进行更改。</para></block>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnInit : EventArgs -&gt; unit" Usage="webPartManager.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.Init" /> 事件，该事件是 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件生命周期中的第一个事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法调用基方法 (该基方法为控件<xref:System.Web.UI.Control.Init>引发事件), 然后执行几个准备步骤, 如确保在页面上<xref:System.Web.UI.WebControls.WebParts.WebPartManager>只有一个控件实例, 并加载<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnInit%2A>个性化数据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">页上还有另一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件</exception>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal override void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnPreRender : EventArgs -&gt; unit" Usage="webPartManager.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.EventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.Control.PreRender" /> 事件，该事件恰好在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件被呈现在网页上之前发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法调用基方法 (该基方法<xref:System.Web.UI.Control.PreRender>引发控件的事件), 然后注册包含 Web 部件控件的页上所需的多个客户端脚本。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnPreRender%2A>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanged (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanged(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanged (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanged(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" /> 事件，该事件在新选择了某个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件或清除对它的选择之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>引发事件, 这通常是开发人员可能需要更改用户界面 (UI) 的外观的时间点。 例如, 当选择新<xref:System.Web.UI.WebControls.WebParts.WebPart>控件时, Web 部件控件集更改新选定控件的呈现方式。 清除控件的选定内容后, 呈现将恢复为正常。  
  
 用户选择特定<xref:System.Web.UI.WebControls.WebParts.WebPart>控件进行编辑后, 将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>调用方法。 当用户完成对控件的编辑并将其关闭时, 如果已清除该控件的选定内容, 将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>再次调用该方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>有几个与<see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />事件相关的选项, 使开发人员可以自定义在所选控件更改后发生的呈现。 在声明性代码中, <see langword="&lt;asp:webpartmanager&gt;" />可以在元素中<see langword="OnSelectedWebPartChanged" />设置特性, 并为其分配自定义方法的名称。 在自定义方法中, 可以在事件发生时修改所选控件的呈现。 另一种方法是从<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类继承并重写方法。 第三种方法是在区域级别自定义呈现;例如, 你可以从<see cref="T:System.Web.UI.WebControls.WebParts.EditorZoneBase" />类继承并重写其<see cref="M:System.Web.UI.WebControls.WebParts.EditorZoneBase.OnSelectedWebPartChanged(System.Object,System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />方法, 以自定义在编辑过程中选定和清除的控件的呈现。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnSelectedWebPartChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectedWebPartChanging (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectedWebPartChanging(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectedWebPartChanging (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectedWebPartChanging(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnSelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnSelectedWebPartChanging e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" /> 事件，该事件在更改当前选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法引发事件, 该事件在更改当前选定的<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的过程中发生。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件使用此方法和关联的事件, 以提供取消所选控件更改的进程的机会。 例如, 方法在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.BeginWebPartEditing%2A>方法中调用, 也<xref:System.Web.UI.WebControls.WebParts.WebPartManager.EndWebPartEditing%2A>在方法中调用, 以便提供取消进程的方法。 如果用户单击正在编辑的控件上的 cancel 谓词, 则不再选择该控件并且不会保存任何编辑更改, 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法可以取消编辑更改。  
  
> [!NOTE]
>  在开始和结束将<xref:System.Web.UI.WebControls.WebParts.WebPart>控件连接到另一控件的过程的方法中, 可通过类似方式调用方法, 以启用取消该进程。  
  
 页面开发人员可以通过在声明性页<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>标记中`OnSelectedWebPartChanging`将特性添加到`<asp:webpartmanager>`元素, 并为属性分配自定义方法的名称, 来为事件创建自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal override void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnUnload : EventArgs -&gt; unit" Usage="webPartManager.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">与控件的移除相关联的事件数据。</param>
        <summary>引发基 <see cref="E:System.Web.UI.Control.Unload" /> 事件，并从网页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 实例。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdded (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdded(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdded (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdded(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被添加到某个页之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在向页面<xref:System.Web.UI.WebControls.WebParts.WebPart>添加控件 (或添加到<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域的其他服务器控件) 的过程中, 将调用方法。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>  
  
 页面开发人员可以为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件创建自定义处理程序, 方法是`OnWebPartAdded`将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartAdding">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartAdding (System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartAdding(class System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartAdding (e As WebPartAddingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartAdding(System::Web::UI::WebControls::WebParts::WebPartAddingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit&#xA;override this.OnWebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartAdding e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" /> 事件，该事件将在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding>引发事件, 以指示控件正在添加。 方法还提供了用于取消添加过程的选项。 如果成功添加了控件, 则将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>出现以下事件。  
  
 页面开发人员可以为关联的事件提供自定义处理程序, `OnWebPartAdding`方法是将`<asp:webpartmanager>`属性添加到网页上的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类的<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />开发人员可以重写方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosed (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosed(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosed (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosed(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" /> 事件以表明控件已从页中移除。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>方法引发<xref:System.Web.UI.WebControls.WebParts.WebPart>事件, 以指示控件 (或其他服务器或用户控件) 在页上已成功关闭。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>  
  
 若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>某个控件, 请将其从页中移除, 使其不会呈现, 还会将其放在称为页目录的特殊保存对象中。 对应<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>于控件的页目录将维护对每个页面的已<xref:System.Web.UI.WebControls.WebParts.WebPart>关闭控件的引用。 如果控件在<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域内的某个页面上声明, 则用户可以将页面切换到目录显示模式, 然后再将其添加回页面。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>  
  
 方法为开发人员提供了为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件创建自定义处理程序的机会。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A> 页面开发人员可以为事件添加自定义处理程序, 方法`OnWebPartClosed`是将属性`<asp:webpartmanager>`添加到页面中的元素, 然后将自定义方法名称分配给该属性。 开发人员在此方法中可能执行的一项有用任务是: 显示占位符来代替关闭的控件, 并使用工具提示完成, 通知用户如何将控件添加回页面。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartClosing (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartClosing(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartClosing (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartClosing(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartClosing e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" /> 事件，该事件将在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>引发事件, 以指示控件正在关闭或已从页中删除。 方法还提供了取消关闭进程的选项。 如果已成功从页面中删除该控件, 则<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>将出现以下事件。  
  
 页面开发人员可以为关联的事件提供自定义处理程序, `OnWebPartClosing`方法是将`<asp:webpartmanager>`属性添加到网页上的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类的<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />开发人员可以重写方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleted">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleted (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleted(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleted (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleted(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" /> 事件，该事件在从页中永久删除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在从页面<xref:System.Web.UI.WebControls.WebParts.WebPart>删除控件 (或添加到<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域的其他服务器控件) 的过程中, 将调用方法。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>  
  
 页面开发人员可以为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件创建自定义处理程序, 方法是`OnWebPartDeleted`将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartDeleting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartDeleting (System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartDeleting(class System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartDeleting (e As WebPartCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartDeleting(System::Web::UI::WebControls::WebParts::WebPartCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit&#xA;override this.OnWebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartDeleting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" /> 事件，该事件指示动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中包含的服务器控件或用户控件）正处于被删除的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 只有动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件可以删除, 当控件被删除时, 该控件实例将从页中永久删除且无法还原。 动态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件是以编程方式添加的控件, 也可以是从 Web 部件目录中添加的控件, 而不是在网页标记中声明的静态控件。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>引发事件, 以指示控件从其区域中被永久删除。 方法还提供了取消删除过程的机会。 如果已成功从页面中删除该控件, 则<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>将出现以下事件。  
  
 页面开发人员可以为关联的事件提供自定义处理程序, `OnWebPartDeleting`方法是将`<asp:webpartmanager>`属性添加到网页上的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类的<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />开发人员可以重写方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoved">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoved (System.Web.UI.WebControls.WebParts.WebPartEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoved(class System.Web.UI.WebControls.WebParts.WebPartEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoved (e As WebPartEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoved(System::Web::UI::WebControls::WebParts::WebPartEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit&#xA;override this.OnWebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件已被移动到页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法在方法的最末尾<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>引发事件, 这可以确保在运行事件处理程序中的任何代码之前, 移动控件的过程已完成。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>  
  
 当控件在其当前区域内移动或移动到另一个区域时, 将引发事件,并且无论是以编程方式还是由用户拖动控件来完成移动都不重要。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>  
  
 页面开发人员可以为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件创建自定义处理程序, 方法是`OnWebPartMoved`将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartMoving">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartMoving (System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartMoving(class System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartMoving (e As WebPartMovingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartMoving(System::Web::UI::WebControls::WebParts::WebPartMovingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit&#xA;override this.OnWebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs -&gt; unit" Usage="webPartManager.OnWebPartMoving e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />、服务器控件或用户控件正处于移动过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法引发事件, 该事件在或其他服务器控件在其区域内移动或在另一个区域内移动时发生。 <xref:System.Web.UI.WebControls.WebParts.WebPart> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving> 方法还提供了取消移动过程的机会。 如果移动成功完成, 则将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>出现以下事件。  
  
 页面开发人员可以为关联的事件提供自定义处理程序, `OnWebPartMoving`方法是将`<asp:webpartmanager>`属性添加到网页上的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类的<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />开发人员可以重写方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间建立了连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts%2A>方法的最末尾引发其相应的事件, 这可确保在事件处理程序中的任何代码运行之前完成连接两个控件所需的步骤。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>  
  
 方法提供了对创建连接过程的编程控制, 关联的事件是更新用户界面 (UI) 或通知用户已建立连接的便利点。  
  
 页面开发人员可以为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件创建自定义处理程序, 方法是`OnWebPartsConnected`将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsConnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsConnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsConnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsConnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsConnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsConnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" /> 事件，该事件发生于在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域内包含的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件之间建立连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>引发事件, 该事件在两个控件尝试建立连接时发生。 方法提供了取消连接尝试的机会。 如果连接成功, 则<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>执行以下事件。  
  
 页面开发人员可以为关联的事件提供自定义处理程序, `OnWebPartsConnecting`方法是将`<asp:webpartmanager>`属性添加到网页上的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类的<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />开发人员可以重写方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnected">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnected (System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnected(class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnected (e As WebPartConnectionsEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnected(System::Web::UI::WebControls::WebParts::WebPartConnectionsEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" /> 事件，该事件在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>方法的最末尾引发其相应的事件, 该方法执行终止两个控件之间的连接的过程。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>  
  
 方法提供对结束连接的过程的编程控制, 使开发人员可以通知用户、更改用户界面 (UI) 或对应用程序进行其他更改。  
  
 页面开发人员可以为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件创建自定义处理程序, 方法是`OnWebPartsDisconnected`将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="OnWebPartsDisconnecting">
      <MemberSignature Language="C#" Value="protected virtual void OnWebPartsDisconnecting (System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnWebPartsDisconnecting(class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnWebPartsDisconnecting (e As WebPartConnectionsCancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnWebPartsDisconnecting(System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit&#xA;override this.OnWebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs -&gt; unit" Usage="webPartManager.OnWebPartsDisconnecting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">包含事件数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs" />。</param>
        <summary>引发 <see cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" /> 事件，该事件指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中的两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或服务器控件或用户控件正处于结束连接的过程中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> 方法<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>引发事件, 该事件在两个控件结束连接时发生。 方法提供了取消断开连接过程的机会。 如果成功删除连接, 则将<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>出现以下事件。  
  
 页面开发人员可以为关联的事件提供自定义处理程序, `OnWebPartsDisconnecting`方法是将`<asp:webpartmanager>`属性添加到网页上的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>创建派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类的<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />开发人员可以重写方法以自定义事件处理。</para></block>
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Personalization">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartPersonalization Personalization" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Personalization As WebPartPersonalization" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ Personalization { System::Web::UI::WebControls::WebParts::WebPartPersonalization ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Personalization : System.Web.UI.WebControls.WebParts.WebPartPersonalization" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Personalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.NotifyParentProperty(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartPersonalization</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对包含网页个性化设置数据的对象的引用。</summary>
        <value>包含个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性提供了一种方法, 通过<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization> <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件访问与页关联的对象。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A> 使用此属性, 你可以访问个性化对象的各种成员。 例如, 可以使用<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>方法将页的个性化设置范围从 "共享" 切换到 "用户" 范围, 反之亦然。 你还可以查看页面的当前个性化设置范围、是否甚至在页面上启用了个性化设置, 以及要将哪些提供程序用于个性化设置数据等。  
  
 请注意, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性引用的数据只是<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件所跟踪的页级别的个性化设置数据。 控件特定的个性化设置数据 (如控件上<xref:System.Web.UI.WebControls.WebParts.WebPart>可个性化属性的值) 不是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性的组成部分。  
  
> [!NOTE]
>  有关 Web 部件个性化的详细信息, 请参阅[Web 部件个性化概述](https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100))。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>使用属性。  
  
 以下网页允许用户进入编辑模式来编辑<xref:System.Web.UI.WebControls.Calendar>控件的某些方面。 "**切换范围**" 按钮将页面切换为 "用户" 或 "共享" 个性化设置范围。 每个 "**编辑模式**" 和 "**浏览" 模式**按钮都将页面切换到适当的显示模式。 请注意, 在`<script>`文件的标记部分, 处理事件的两个方法都<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>使用属性来访问基础对象的有用成员。 具体而言, 这些方法对<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ToggleScope%2A>通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Personalization%2A>属性访问<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Scope%2A>的对象使用方法和属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Personalization#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/CS/wpmgrPersonalizationCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Personalization#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Personalization/VB/wpmgrPersonalizationVB.aspx#1)]  
  
 若要运行该代码示例, 还必须使用户或用户能够对共享作用域中的页面进行个性化设置。 将一个项添加到`<system.web>`节中的 web.config 文件中, 该文件类似于下面的标记。  
  
```  
<webParts>  
  <personalization>  
    <authorization>  
      <allow  
        users="[Replace the text and brackets with a user name or   
           group.]"  
        roles="admin"   
        verbs="enterSharedScope"  />  
    </authorization>  
  </personalization>  
</webParts>   
```  
  
 在浏览器中加载页面后, 单击 "**切换范围**" 按钮, 此时会显示该页已共享。 单击 "**编辑模式**" 以更改显示模式, 单击可见控件上的谓词菜单, 然后从菜单中选择 "**编辑**"。 请注意, 将显示两个编辑控件的用户界面 (UI)。 现在, 单击 "**浏览" 模式**返回到正常浏览。 如果该页显示处于共享作用域中, 请再次单击 "**切换范围**" 以确保该页处于用户范围内。 接下来, 请执行相同的步骤来再次编辑控件, 但请注意, 在编辑 UI 中, <xref:System.Web.UI.WebControls.WebParts.BehaviorEditorPart>控件不会出现。 这是因为, 此控件仅在页位于共享个性化设置范围中时才起作用。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web 部件个性化概述</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScript">
      <MemberSignature Language="C#" Value="protected virtual void RegisterClientScript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RegisterClientScript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.RegisterClientScript" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RegisterClientScript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RegisterClientScript();" />
      <MemberSignature Language="F#" Value="abstract member RegisterClientScript : unit -&gt; unit&#xA;override this.RegisterClientScript : unit -&gt; unit" Usage="webPartManager.RegisterClientScript " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件能够发出用于各种个性化设置功能（例如，在网页中拖动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件）的客户端脚本。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="webPartManager.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">一个 <see cref="T:System.Web.UI.HtmlTextWriter" />，它接收控件的内容以写入页。</param>
        <summary>重写以防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件呈现任何内容。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected internal override object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function SaveControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Object ^ SaveControlState();" />
      <MemberSignature Language="F#" Value="override this.SaveControlState : unit -&gt; obj" Usage="webPartManager.SaveControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>保存 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的状态数据，以便在将来请求包含该控件的网页时可以还原这些数据。</summary>
        <returns>一个 <see cref="T:System.Object" />，它包含控件的已保存的状态数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法保存应在页回发之间保留的属性的状态数据, 即使在<xref:System.Web.UI.Control.EnableViewState%2A>属性设置为`false`时也是如此。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveControlState%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCustomPersonalizationState">
      <MemberSignature Language="C#" Value="protected virtual void SaveCustomPersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SaveCustomPersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SaveCustomPersonalizationState (state As PersonalizationDictionary)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SaveCustomPersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit&#xA;override this.SaveCustomPersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationDictionary -&gt; unit" Usage="webPartManager.SaveCustomPersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件维护的自定义个性化设置状态数据，以便重新加载该页时可以重新加载此数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A>方法在个性化设置过程中至关重要, 因为它可以存储个性化的用户设置以供将来浏览器会话和对页面的访问。 方法保存自定义个性化设置状态数据, 其中包含如下所示的项: <xref:System.Web.UI.WebControls.WebParts.WebPart>已添加到页面或从页面中删除的动态控件或服务器控件; 已移动到页面上的控件; 以及动态连接已创建或删除。  
  
 不能直接从代码中调用此方法。 但是, 可以调用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A>方法, 该方法本身会调用此方法来保存个性化设置数据。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员可以在派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类中重写此方法, 以自定义保存个性化设置数据的过程。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPart">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPart SelectedWebPart" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectedWebPart As WebPart" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPart ^ SelectedWebPart { System::Web::UI::WebControls::WebParts::WebPart ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPart</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对当前选择的用于编辑或用于创建与另一个控件的连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件的引用。</summary>
        <value>当前选择的用于编辑或建立连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart%2A>属性返回<xref:System.Web.UI.WebControls.WebParts.WebPart>对或其他服务器控件的引用, 此服务器控件当前已选定用于编辑或用于创建与其他控件的连接。  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件提供了几个有用的方法和事件来处理选择控件的过程。 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件恰好在选定控件后发生, 但在进行任何更改之前发生。 若要在选定控件后对其执行某些操作, 请重写<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法。 例如, 你可能想要更改已选中但尚未更改的控件的外观, 以直观地强调选择了哪个控件。  
  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged>事件恰好在选定控件更改后发生。 若要在控件发生更改后对其执行某些操作, 请重<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>写方法。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanged">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler SelectedWebPartChanged" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanged As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ SelectedWebPartChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.SelectedWebPartChanged : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在对一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的选择已经发生更改并被移动到网页上的另一个控件之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged%2A>方法结合使用, 以更改所选控件的用户界面 (UI)。 例如, 如果用户将页面切换为设计模式 (<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DesignDisplayMode>), 然后选择一个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件, 并将其拖动到新位置, 则通常更改所选控件的呈现 (例如, 通过更改其选择边框或背景。  
  
> [!NOTE]
>  有关使用事件的详细信息, 请[参阅如何:在 Web 窗体应用程序](~/docs/standard/events/how-to-consume-events-in-a-web-forms-application.md)中使用事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SelectedWebPartChanging">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler SelectedWebPartChanging" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectedWebPartChanging As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ SelectedWebPartChanging;" />
      <MemberSignature Language="F#" Value="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.SelectedWebPartChanging : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在更改网页上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件当前的选定状态的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件可与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>方法一起使用。 页面开发人员可以通过将`OnSelectedWebPartChanging`属性添加到页面中的`<asp:webpartmanager>`元素, 并将属性的值设置为将处理事件的自定义方法的名称, 在代码中创建事件处理程序。  
  
 此事件在开始或结束控件之间的连接的过程中, 以及在开始和结束控件编辑时引发。 有关详细信息, 请<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging%2A>参阅方法。  
  
 通常, 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>事件由于用户操作更改所选控件的直接结果而引发时, 可以取消该事件。 但是, 在某些情况下无法取消事件。 如果删除<xref:System.Web.UI.WebControls.WebParts.WebPartZone>了控件, 则该<xref:System.Web.UI.WebControls.WebParts.WebPart>控件所包含的控件必须全部关闭, 否则将会孤立。 在这种情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager>下, 控件<xref:System.Web.UI.WebControls.WebParts.WebPart>将关闭控件而不是用户, 并且它必须确定当前选择了哪个控件以及何时在不中断的情况下更改选择, 使其能够完成清除过程所有控件。 因此, 在这种<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPartChanging>情况下, 不能取消设计方法。 有关可取消的相关事件, 请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SetPersonalizationDirty">
      <MemberSignature Language="C#" Value="protected void SetPersonalizationDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetPersonalizationDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetPersonalizationDirty ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetPersonalizationDirty();" />
      <MemberSignature Language="F#" Value="member this.SetPersonalizationDirty : unit -&gt; unit" Usage="webPartManager.SetPersonalizationDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>设置一个标志，该标志指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化设置数据已更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>方法将设置一个标志, 该标志最终会导致 Web 部件控件集中的个性化设置组件保存更新的个性化数据。 有关可能导致<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件所跟踪的个性化设置数据发生更改的方案的详细信息, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>请参阅属性。  
  
 不能从代码中直接调用方法,并且不能重写,因为它由Web部件控件集在内部由Web部件个性化功能的一部分使用。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetPersonalizationDirty%2A>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>方法可由派生<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />类调用。 如果要自定义 Web 部件控件集的个性化组件, 并因此需要控制设置个性化数据标志的过程, 这将很有用。</para></block>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SetSelectedWebPart">
      <MemberSignature Language="C#" Value="protected void SetSelectedWebPart (System.Web.UI.WebControls.WebParts.WebPart webPart);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetSelectedWebPart(class System.Web.UI.WebControls.WebParts.WebPart webPart) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetSelectedWebPart(System::Web::UI::WebControls::WebParts::WebPart ^ webPart);" />
      <MemberSignature Language="F#" Value="member this.SetSelectedWebPart : System.Web.UI.WebControls.WebParts.WebPart -&gt; unit" Usage="webPartManager.SetSelectedWebPart webPart" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPart" Type="System.Web.UI.WebControls.WebParts.WebPart" />
      </Parameters>
      <Docs>
        <param name="webPart">已被选择的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</param>
        <summary>将 <see cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" /> 属性值设置为等于当前选定的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法在开始或结束对`webPart`参数指定的控件的处理过程中调用, 后者用于开始或结束包含`webPart`的连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>  
  
 在编辑进程和连接进程开始时, `webPart`是已选择要编辑的控件或用于输入连接的控件。  
  
 在编辑和连接进程结束时, `null`将传递<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SetSelectedWebPart%2A>到方法, 这将导致当前选定的控件不再处于选中状态。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanged(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnSelectedWebPartChanging(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.SelectedWebPart" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public override string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SkinID As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SkinID { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SkinID : string with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个空字符串 ("")，使 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件不能应用任何外观。</summary>
        <value>一个空字符串，该字符串防止 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件使用指定给它的外观。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性重写继承<xref:System.Web.UI.Control.SkinID%2A?displayProperty=nameWithType>的属性, 以防止<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件 (这是不可见的控件) 使用外观。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SkinID%2A> 属性的实现会阻止通过从`get`访问器返回空字符串来分配外观, 并且如果尝试`set`在访问器中设置值, 则总是引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试设置该属性值。</exception>
        <altmember cref="P:System.Web.UI.Control.SkinID" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="StaticConnections">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartConnectionCollection StaticConnections" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StaticConnections As WebPartConnectionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ StaticConnections { System::Web::UI::WebControls::WebParts::WebPartConnectionCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StaticConnections : System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.PersistenceMode(System.Web.UI.PersistenceMode.InnerProperty)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有定义为静态连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" /> 对象的集合的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartConnectionCollection" />，包含页上的所有静态连接。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>属性来跟踪和管理页上的所有静态连接。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A> 与动态连接相比, 静态连接无需在每次呈现页面时添加到页面中。  
  
 此属性引用的集合包含页上存在的所有静态连接, 无论它们是以编程方式创建, 还是通过页标记`<asp:webpartconnection>`中的元素指定的。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>使用属性。  
  
 此代码示例包含四个部分:  
  
-   使您能够在 Web 部件页上更改显示模式的用户控件。  
  
-   包含两个自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件和自定义接口的源代码文件。  
  
-   一个网页, 其中包含两个<xref:System.Web.UI.WebControls.WebParts.WebPart>可以连接的自定义控件和一个`<asp:webpartmanager>`元素。  
  
-   说明如何在浏览器中工作。  
  
 下面的代码仅包含示例的网页部分。 还需要从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取示例的前两个部分, 即自定义用户控件和自定义控件和接口的源代码。 本主题还介绍了用于编译<xref:System.Web.UI.WebControls.WebParts.WebPart>控件的选项。  
  
 此代码示例的第三部分是网页。 页的声明性标记包含`Register`用户控件和自定义控件的指令。 有一个`<asp:webpartmanager>`元素、一个`<asp:webpartzone>`元素包含自定义控件和一个`<asp:connectionszone>`元素。 请注意, 在`Page_Load`方法中, 代码会检查连接是否已存在, 如果不存在, 则定义提供程序、使用者及其各自的连接点, 然后将新连接添加到由引用的静态连接集<xref:System.Web.UI.WebControls.WebParts.WebPartManager.StaticConnections%2A>属性。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/CS/wpmgrStaticConnectionCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_StaticConnections#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_StaticConnections/VB/wpmgrStaticConnectionVB.aspx#1)]  
  
 在浏览器中加载网页后, 请单击 "**显示模式**" 下拉列表控件, 然后选择 "**连接**", 将页面切换到连接模式。 连接模式使用`<asp:connectionszone>`元素使您能够在控件之间创建连接。 在连接模式下, 单击**邮政编码**控件标题栏中的向下箭头以激活其谓词菜单, 然后单击 "**连接**"。 连接用户界面 (UI) 出现后, 请注意, 连接已由`Page_Load`方法中包含的代码创建。 如果在后续浏览器会话中返回到此页, 则已建立此静态连接, 并且每次加载页面时都不需要重新创建此静态连接。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.WebPartConnection" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="SupportedDisplayModes">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection SupportedDisplayModes" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportedDisplayModes As WebPartDisplayModeCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ SupportedDisplayModes { System::Web::UI::WebControls::WebParts::WebPartDisplayModeCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportedDisplayModes : System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取特定网页上所有可用显示模式的只读集合。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayModeCollection" />，包含特定网页上的可用 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartDisplayMode" /> 对象集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>给定页面上存在的区域控件类型的情况下, 属性仅包含页上实际可用的显示模式。  
  
> [!NOTE]
>  可以禁用显示模式; 当显示模式处于禁用状态时, 它不会添加到<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>集合中, 即使在页面上存在支持该显示模式的相应类型的区域时也是如此。  
  
 始终支持浏览模式和设计模式。 可能变化的显示模式包括编辑、目录和连接模式。 其中每个显示模式都与特定类型的<xref:System.Web.UI.WebControls.WebParts.ToolZone>控件相关联。 这就是在网页上存在一种特殊类型的区域, 导致将特定显示模式添加到<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性引用的集合。 例如, 如果网页包含<xref:System.Web.UI.WebControls.WebParts.EditorZone>区域, 而<xref:System.Web.UI.WebControls.WebParts.CatalogZone>不包含区域, 则编辑显示模式为该页面上支持的模式之一, 但不支持目录显示模式。  
  
> [!NOTE]
>  属性不同于属性, 后者引用包含当前<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件可用的所有显示模式的集合, 甚至包括在特定页上不支持的显示模式。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SupportedDisplayModes%2A>属性。 此代码使用此属性来填充列表, 该列表仅包含当前网页中可用的显示模式。  
  
 此页上有三种受支持的显示模式: "浏览"、"设计" 和 "编辑"。 前两个始终可用, 并且编辑模式在此代码示例中可用, 因为该页面包含一个<xref:System.Web.UI.WebControls.WebParts.EditorZone>控件。 不显示目录和连接显示模式, 因为其相应的区域不在此页上。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/CS/wpmgrSuppDisplayModescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_SupportedDisplayModes#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_SupportedDisplayModes/VB/wpmgrSuppDisplayModesvb.aspx#1)]  
  
 在浏览器中加载页面后, 可以使用下拉列表控件将页面从浏览模式切换到设计模式, 然后切换到编辑模式。 在编辑模式下, 可以单击其中一个服务器控件标头中的下拉谓词菜单, 然后选择 "**编辑**" 以编辑控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.DisplayModes" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
        <related type="Article" href="https://msdn.microsoft.com/library/cc106284-82dc-4770-98cb-673dbc4ed4c4">Web 部件页面显示模式</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty">
      <MemberSignature Language="C#" Value="bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsDirty As Boolean Implements IPersonalizable.IsDirty" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Web::UI::WebControls::WebParts::IPersonalizable::IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据是否已在网页上更改。</summary>
        <value>一个布尔值，指示个性化设置状态数据是否已更改。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性提供了一种方法, 供调用方确定<xref:System.Web.UI.WebControls.WebParts.WebPartManager>由控件管理的个性化设置状态数据是否已更改。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 当用户个性化页级别的详细信息 (例如, 通过更改页布局、创建或删除连接以及添加或删除控件) 时, 由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件管理的个性化设置数据会更改。 这是一个传递方法, 它将受保护<xref:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty%2A>属性的值返回给调用方, 而调用方无法直接访问该属性。  
  
> [!NOTE]
>  属性不指示可个性化属性值或影响各个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件外观的各个属性是否已更改。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A> 为每个控件单独跟踪控制级别的个性化设置。 属性仅指示位于页面级别并且<xref:System.Web.UI.WebControls.WebParts.WebPartManager>由控件管理的个性化设置数据是否已更改。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>  
  
 下面的列表描述了一些常见的个性化设置, 这些实例<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>将导致属性返回`true`值, 这指示该<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件具有一些更改的个性化设置数据:  
  
-   关闭页上<xref:System.Web.UI.WebControls.WebParts.WebPart>的静态控件 (或服务器控件或用户控件)。  
  
-   将关闭的静态<xref:System.Web.UI.WebControls.WebParts.WebPart>控件从页目录还原回页面。  
  
-   将控件移动到其区域内或移动到另一个区域。  
  
-   从<xref:System.Web.UI.WebControls.WebParts.WebPart>或服务器控件的目录添加控件, 或以编程方式添加控件。  
  
-   以编程方式或通过<xref:System.Web.UI.WebControls.WebParts.WebPart>使用连接用户界面 (UI) 创建两个控件之间的连接。  
  
-   以编程方式或通过<xref:System.Web.UI.WebControls.WebParts.WebPart>使用连接 UI 删除两个控件之间的连接。  
  
 若要访问此属性值, 必须将<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件实例<xref:System.Web.UI.WebControls.WebParts.IPersonalizable>强制转换为接口; 然后<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.IsDirty%2A> , 可以读取属性值。  
  
   
  
## Examples  
 下面的代码示例演示了<xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23IsDirty%2A>属性的简单用法, 以指示<xref:System.Web.UI.WebControls.WebParts.WebPartManager>导致控件的个性化设置数据更改的一些常见页面个性化设置实例。  
  
 此代码示例包含四个部分:  
  
-   允许您在包含 Web 部件控件的页上更改显示模式的用户控件。  
  
-   一个源文件, 其中包含两个可以连接的<xref:System.Web.UI.WebControls.WebParts.WebPart>自定义控件的代码和一个接口。  
  
-   承载所有控件的网页。  
  
-   对代码示例的工作方式的说明。  
  
 此代码示例的第一部分是用户控件, 用于更改显示模式。 你可以从<xref:System.Web.UI.WebControls.WebParts.WebPartManager>类概述的 "示例" 部分获取用户控件的源代码。 有关显示模式和用户控件工作方式的信息, 请参阅[演练:更改 Web 部件页](https://msdn.microsoft.com/library/24e42f74-82dc-4c13-8574-130398985fc0)上的显示模式。  
  
 该示例的第二部分是包含自定义控件和接口的源文件。 请注意, `ZipCodeWebPart` `ZipCodeWebPart`接口公开了一种方法, 在自定义控件中实现的此方法将用作回调方法, 以使能够充当连接方案中的`IZipCode`提供程序。 其他控件`WeatherWebPart`作为连接中的使用者控件, 它可以使用`ZipCodeWebPart`提供的特定接口。 在实际应用程序中`WeatherWebPart` , 可以从提供程序使用个性化的邮政编码值, 然后向用户提供图形天气信息。  
  
 要使代码示例运行, 必须编译此源代码。 可以显式编译该程序集, 并将生成的程序集放在网站的 Bin 文件夹或全局程序集缓存中。 或者, 你可以将源代码放在站点的 App_Code 文件夹中, 在此文件夹中, 它将在运行时动态编译。 此代码示例使用动态编译;因此, 请注意, `Register`网页顶部的此组件的指令只`TagPrefix`包含`Assembly`和`Namespace`属性, 但没有属性。 有关演示如何编译的演练, 请参阅[演练:开发和使用自定义 Web 服务器控件](https://msdn.microsoft.com/library/6d90782a-a1a4-45a6-b2d4-cf6362b83b08)。  
  
 [!code-csharp[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/ZipCodeComponent.cs#2)]
 [!code-vb[WebParts_WebPartManager_IsDirty#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/ZipCodeComponent.vb#2)]  
  
 此代码示例的第三部分是网页。 请注意, 它包含<xref:System.Web.UI.WebControls.WebParts.WebPartZone>两个区域, 其中第一个区域包含两<xref:System.Web.UI.WebControls.WebParts.WebPart>个自定义控件。 还有一个<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域, 其中包含用户可以添加到<xref:System.Web.UI.WebControls.Calendar>页面的标准控件。 `<asp:connectionszone>`元素提供了一个连接用户界面, 使用户能够在控件之间创建连接。 在方法中, 请注意, 它会检查个性化设置数据是否已更改, 如果已更改, 则更新的`Label1`文本。 `Page_PreRender`  
  
 [!code-aspx-csharp[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/CS/wpmgrIsDirtyCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_IsDirty#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_IsDirty/VB/wpmgrIsDirtyVB.aspx#1)]  
  
 在浏览器中加载页面后, 尝试创建本主题的 "备注" 部分中列出的一些方案, 这些方案将更改个性化数据。 进行各种更改时, 当更改涉及<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件所跟踪的个性化设置方案之一时, 会显示`Label1`控件的文本, 指示个性化设置数据已更改。 例如，你可以：  
  
-   单击 "**连接" Web 部件控件**按钮, 在控件之间创建连接。  
  
-   使用 "**显示模式**" 下拉列表控件将页面切换到目录模式, 然后将 "我的**日历**" 控件添加到第<xref:System.Web.UI.WebControls.WebParts.WebPartZone>二个区域。  
  
-   将页面更改回 "浏览" 模式, 在 "**我的日历**" 控件上单击谓词菜单 (在标题栏中显示箭头符号), 然后选择 "**关闭**" 以关闭它并将其添加到页面目录。  
  
-   将页面返回到目录模式, 然后将 "**我的日历**" 控件添加回页面。  
  
-   使用 "**显示模式**" 控件将页面切换到设计模式, 并通过将控件的一个或多个位置拖动到另一个区域, 或在同一区域中的其他位置来重新排列控件的布局。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.WebControls.WebParts.IPersonalizable" />
        <altmember cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.IsCustomPersonalizationStateDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Load">
      <MemberSignature Language="C#" Value="void IPersonalizable.Load (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Load (state As PersonalizationDictionary) Implements IPersonalizable.Load" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Load;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，它包含要加载的状态数据。</param>
        <summary>返回先前保存的需要加载到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的自定义个性化状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Load%2A?displayProperty=nameWithType>方法的实现, 该方法提供了一种方法, 使 Web 部件控件集直接访问受保护<xref:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState%2A?displayProperty=nameWithType>的方法。 调用此方法时, 它将存储由<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件管理的自定义个性化数据, 并且以前保存在永久性数据存储中以供以后在初始化过程中使用。  
  
> [!NOTE]
>  在大多数情况下, 页面和控件开发人员代码不需要调用此方法, 因为它主要由 Web 部件控件集用于检索个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员使用此方法的一种情况是, 他们要开发一个自定义的个性化框架, 用来代替 Web 部件控件集提供的个性化框架。 在这种情况下, 开发人员可以<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />从类继承并重<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />写方法以返回<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象的自定义实现。 自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象将在适当的时间调用<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Load(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法的实现以加载自定义个性化设置数据。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.LoadCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.WebControls.WebParts.IPersonalizable.Save">
      <MemberSignature Language="C#" Value="void IPersonalizable.Save (System.Web.UI.WebControls.WebParts.PersonalizationDictionary state);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(class System.Web.UI.WebControls.WebParts.PersonalizationDictionary state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
      <MemberSignature Language="VB.NET" Value="Sub Save (state As PersonalizationDictionary) Implements IPersonalizable.Save" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System::Web::UI::WebControls::WebParts::PersonalizationDictionary ^ state) = System::Web::UI::WebControls::WebParts::IPersonalizable::Save;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Web.UI.WebControls.WebParts.IPersonalizable.Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />
      </Parameters>
      <Docs>
        <param name="state">一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationDictionary" />，包含待保存的状态数据。</param>
        <summary>保存由 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件管理的自定义个性化设置状态数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法是<xref:System.Web.UI.WebControls.WebParts.IPersonalizable.Save%2A?displayProperty=nameWithType>方法的实现, 该方法提供了一种方法, 以便 Web 部件控件集直接访问受保护<xref:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState%2A?displayProperty=nameWithType>的方法。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.System%23Web%23UI%23WebControls%23WebParts%23IPersonalizable%23Save%2A> 调用此方法时, 它会将<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件管理的所有个性化数据保存到为 Web 部件应用程序配置的永久数据存储区。  
  
> [!NOTE]
>  在大多数情况下, 页面和控件开发人员代码不需要调用此方法, 因为它主要由 Web 部件控件集用于保存个性化设置数据的机制。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>开发人员使用此方法的一种情况是, 他们要开发一个自定义的个性化框架, 用来代替 Web 部件控件集提供的个性化框架。 在这种情况下, 开发人员可以<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />从类继承并重<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CreatePersonalization" />写方法以返回<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象的自定义实现。 自定义<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />对象将在适当的时间调用<see cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#Save(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />方法的实现以保存自定义个性化设置数据。</para></block>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.SaveCustomPersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationDictionary)" />
        <altmember cref="P:System.Web.UI.WebControls.WebParts.WebPartManager.System#Web#UI#WebControls#WebParts#IPersonalizable#IsDirty" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected override void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.WebPartManager.TrackViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub TrackViewState ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void TrackViewState();" />
      <MemberSignature Language="F#" Value="override this.TrackViewState : unit -&gt; unit" Usage="webPartManager.TrackViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将个性化设置状态数据应用到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件，调用基方法以便能够跟踪对控件视图状态数据的更改。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对视图状态数据的更改存储在<xref:System.Web.UI.StateBag>对象中, 并可通过控件的<xref:System.Web.UI.Control.ViewState%2A>属性进行访问。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值可使子控件可见。</summary>
        <value>一个布尔值，指示 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件及其子控件是否可见。 在所有情况下均为 <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件重写基<xref:System.Web.UI.Control.Visible%2A?displayProperty=nameWithType>属性, 以`true`始终为<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性返回值。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 即使控件本身不可见<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A> , 属性也需要设置为`true` , 以便默认情况下其所有子控件都可见。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager>  
  
 如果尝试设置<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Visible%2A>属性的值, 则它始终会生成错误, <xref:System.Web.UI.WebControls.WebParts.WebPartManager>因为控件已经重写基属性行为, 并阻止为属性赋值。  
  
 此属性在可视化设计器中不可绑定, 但在运行时是可绑定的。 有关详细信息，请参阅 <xref:System.ComponentModel.BindableAttribute>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">尝试向该属性指定一个值。</exception>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdded">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartAdded" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdded As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartAdded;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartAdded : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已被添加到 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域之后发生，以指示已成功添加了控件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件用于指示动态控件 (以编程方式添加的控件, 而不是在页标记中声明的控件) 已成功添加到区域。 与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded%2A>方法一起使用时, 事件为开发人员提供了一种方法来更新用户界面 (UI), 或通知用户已成功添加控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdded(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartAdding">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler WebPartAdding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartAdding As WebPartAddingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartAddingEventHandler ^ WebPartAdding;" />
      <MemberSignature Language="F#" Value="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " Usage="member this.WebPartAdding : System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartAddingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在向 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域添加动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 将控件添加到区域的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding%2A>过程开始后, 方法将引发事件。<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdding> 此事件提供在进程完成之前取消该过程的机会。 如果添加进程成功, 则此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded>事件。  
  
 页面开发人员可以通过将`OnWebPartAdding`属性添加到页面中的`<asp:webpartmanager>`元素, 并为属性分配自定义方法名称, 为事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartAdding(System.Web.UI.WebControls.WebParts.WebPartAddingEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.AddWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartAdded" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosed">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartClosed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosed As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartClosed;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartClosed : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件指示控件已成功关闭, 无论是由用户还是以编程方式。 若要关闭<xref:System.Web.UI.WebControls.WebParts.WebPart>某个控件, 请将其从页中移除, 使其不会呈现, 还会将其放在称为页目录的特殊保存对象中。 对应<xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>于控件的页目录将维护对每个页面的已<xref:System.Web.UI.WebControls.WebParts.WebPart>关闭控件的引用。 如果控件在<xref:System.Web.UI.WebControls.WebParts.CatalogZone>区域内的某个页面上声明, 则用户可以将页面切换到目录显示模式, 然后再将其添加回某个页面。 <xref:System.Web.UI.WebControls.WebParts.PageCatalogPart>  
  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed> 事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed%2A>与方法相关联, 这两个方法都引发事件并为其提供处理程序。  
  
 页面开发人员可以为事件添加自定义处理程序, 方法`OnWebPartClosed`是将属性`<asp:webpartmanager>`添加到页面中的元素, 然后将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosed(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartClosing">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartClosing" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartClosing As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartClosing;" />
      <MemberSignature Language="F#" Value="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartClosing : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从页中移除 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或服务器控件，或用户控件）的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当控件处于关闭控件的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing%2A>过程中时<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> <xref:System.Web.UI.WebControls.WebParts.WebPartManager> , 由方法引发事件。 如果移除控件成功, 则此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed>事件。  
  
 页面开发人员可以为事件提供自定义处理程序, 方法`OnWebPartClosed`是将属性`<asp:webpartmanager>`添加到页面中的元素, 并将自定义方法名称分配给该属性。  
  
 通常, 当用户<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing> <xref:System.Web.UI.WebControls.WebParts.WebPart>关闭控件的直接结果引发事件时, 可以取消该事件。 但是, 在某些情况下无法取消事件。 如果删除<xref:System.Web.UI.WebControls.WebParts.WebPartZone>了控件, 则该<xref:System.Web.UI.WebControls.WebParts.WebPart>控件所包含的控件必须全部关闭, 否则将会孤立。 在这种情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager>下, 控件<xref:System.Web.UI.WebControls.WebParts.WebPart>将关闭控件, 而不是用户。 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart%2A>调用方法以关闭<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>每个控件的过程中, 如果引发事件, 则无法取消事件 (通过设计), 因为<xref:System.Web.UI.WebControls.WebParts.WebPartManager>需要完成清除任务所有区域的控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartClosing(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosed" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.CloseWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleted">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartDeleted" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleted As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartDeleted;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartDeleted : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或其他服务器控件已从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域删除之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件可用于指示动态控件 (以编程方式添加的控件, 而不是在页标记中声明的) 已成功从区域中删除。 与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted%2A>方法一起使用时, 事件为开发人员提供了一种方法来更新用户界面 (UI), 或通知用户已成功删除控件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleted(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartDeleting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler WebPartDeleting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartDeleting As WebPartCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartCancelEventHandler ^ WebPartDeleting;" />
      <MemberSignature Language="F#" Value="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " Usage="member this.WebPartDeleting : System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在从 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中永久删除动态 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的实例的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleting>事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting%2A>由方法引发, 在删除动态控件 (以编程方式或通过 Web 部件用户界面由用户添加的控件) 的过程中。 事件提供了在进程完成之前取消进程的机会。 如果删除进程已成功完成, 则此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted>事件。  
  
 页面开发人员可以通过将`OnWebPartDeleting`属性添加到页面中的`<asp:webpartmanager>`元素, 并为属性分配自定义方法名称, 为事件提供自定义处理程序。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartDeleting(System.Web.UI.WebControls.WebParts.WebPartCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartDeleted" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DeleteWebPart(System.Web.UI.WebControls.WebParts.WebPart)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartMoved">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartEventHandler WebPartMoved" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoved As WebPartEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartEventHandler ^ WebPartMoved;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " Usage="member this.WebPartMoved : System.Web.UI.WebControls.WebParts.WebPartEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件已被移动到网页上的不同位置之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件适用于静态 (在网页的标记中声明) 和动态控件。 它与<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved%2A>方法相关联。 由于事件是在移动完成后引发的, 因此开发人员可以包含事件处理程序, 以向用户提供某些通知、某些验证或一些其他操作。 若要添加一个事件处理程序, 你可以`OnWebPartMoved`将一个属性`<asp:webpartmanager>`添加到页面中的元素, 并将自定义方法的名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoved(System.Web.UI.WebControls.WebParts.WebPartEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="WebPartMoving">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler WebPartMoving" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartMoving As WebPartMovingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartMovingEventHandler ^ WebPartMoving;" />
      <MemberSignature Language="F#" Value="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " Usage="member this.WebPartMoving : System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartMovingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在移动 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 区域中包含的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 或其他服务器控件的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当或其他服务器控件在其自己的区域内移动或移动到其他区域时, 将引发该<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件。 <xref:System.Web.UI.WebControls.WebParts.WebPart> 当用户拖动控件时, 以及当发生编程移动时, 会发生这种情况。  
  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoving>事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving%2A>由方法引发, 并提供在移动过程完成前取消该过程的机会。 如果移动完成并且控件置于新位置, 则此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved>事件。  
  
 页面开发人员可以为事件创建自定义处理程序, 方法`OnWebPartMoving`是将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartMoving(System.Web.UI.WebControls.WebParts.WebPartMovingEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartMoved" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.MoveWebPart(System.Web.UI.WebControls.WebParts.WebPart,System.Web.UI.WebControls.WebParts.WebPartZoneBase,System.Int32)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebParts">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartCollection WebParts { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartCollection WebParts" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WebParts As WebPartCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartCollection ^ WebParts { System::Web::UI::WebControls::WebParts::WebPartCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WebParts : System.Web.UI.WebControls.WebParts.WebPartCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.WebParts" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件所跟踪的所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" /> 控件的引用。</summary>
        <value>一个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartCollection" />，包含对一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件的引用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A> <xref:System.Web.UI.WebControls.WebParts.WebPart>属性来跟踪页面上区域中<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>包含的所有控件。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager> 尽管该集合是只读的, 但你可以通过集合<xref:System.Web.UI.WebControls.WebParts.WebPart>访问各个控件并以编程方式对其进行更改。  
  
> [!NOTE]
>  可以将<xref:System.Web.UI.WebControls.WebParts.WebPart>控件放置在<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域外的某个页面上, 这会导致控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager>不会被控件跟踪或在其<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>集合中被引用。 不过, 几乎不需要在区域外使用<xref:System.Web.UI.WebControls.WebParts.WebPart>控件, 因为它会丢失其 Web 部件功能, 并充当普通服务器控件。  
  
 可在区域中放置的任何类型的控件、自定义<xref:System.Web.UI.WebControls.WebParts.WebPart>控件、标准 ASP.NET 控件、用户控件或自定义服务器控件是否可在运行时视为<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 如果不<xref:System.Web.UI.WebControls.WebParts.WebPart>是控件的控件放置<xref:System.Web.UI.WebControls.WebParts.WebPartZone>在区域中, 则在运行时 ASP.NET 使用<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>对象包装控件, 使控件可以作为真正<xref:System.Web.UI.WebControls.WebParts.WebPart>的控件。 因此, 通过使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性<xref:System.Web.UI.WebControls.WebParts.WebPartManager> , 无论<xref:System.Web.UI.WebControls.WebParts.WebPart>是否从类派生, 控件都可以跟踪任意类型的服务器控件。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>使用属性来访问各个<xref:System.Web.UI.WebControls.WebParts.WebPart>控件。 请注意, 在该网页的声明性标记中, `<asp:webpartzone>`有两个标准 ASP.NET 服务器控件。 虽然这些不是从类继承<xref:System.Web.UI.WebControls.WebParts.WebPart>的, 但由于它们位于区域, 它们会在运行时<xref:System.Web.UI.WebControls.WebParts.GenericWebPart>用对象进行包装, 因此将包含在<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性引用的集合中。 你还可以在此<xref:System.Web.UI.WebControls.WebParts.WebPart>区域中添加自定义控件、用户控件或自定义服务器控件, 并以相同的方式处理它们。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_WebParts#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/CS/wpmgrWebPartsCS.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_WebParts#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_WebParts/VB/wpmgrWebPartsVB.aspx#1)]  
  
 请注意, 若要使代码示例正常运行, 必须在 web.config 文件中添加一个设置, 以便导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在部分中, 请确保有一个`<webParts>`元素的`enableExport`属性设置为`true`, 如以下标记所示。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 将页面加载到浏览器后, 如果单击 " **web 部件计数**" 按钮, 代码将使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebParts%2A>属性返回集合中的控件计数。 如果单击 "**隐藏日历标题**" 按钮, 则代码会更改日历, 使其仅使用边框而不是标题进行呈现。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsConnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsConnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsConnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或者服务器或用户控件）之间已建立特定连接之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected> 事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected%2A>与方法相关联。 此事件非常有用, 因为在知道连接完成后, 您可能希望通知用户事实, 甚至更改页面的用户界面 (UI)。 例如, 您可能希望显示一些图形图像, 该图像在两个控件之间建议成功连接, 或显示简短消息, 然后将页面显示模式改回为浏览模式。  
  
 页面开发人员可以通过将`OnWebPartsConnected`属性添加到页面中的`<asp:webpartmanager>`元素, 并为属性分配自定义方法名称, 将自定义事件处理程序与此事件相关联。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsConnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsConnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsConnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsConnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsConnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在创建 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 控件（或放置在 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域中的服务器控件或用户控件）之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnecting>事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting%2A>由方法引发, 并通知连接进程已开始 (例如, 用户已选择控件并单击了连接谓词), 但尚未完成。 事件提供了在连接完成前取消连接的机会。 如果连接成功完成, 则此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected>事件。  
  
 页面开发人员可以为事件添加自定义处理程序, 方法`OnWebPartsConnecting`是将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsConnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsConnected" />
        <altmember cref="Overload:System.Web.UI.WebControls.WebParts.WebPartManager.ConnectWebParts" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnected">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler WebPartsDisconnected" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnected As WebPartConnectionsEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsEventHandler ^ WebPartsDisconnected;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " Usage="member this.WebPartsDisconnected : System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在两个 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接已终止之后发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected> 事件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected%2A>与方法相关联。 此事件非常有用, 因为在知道连接终止后, 你可能希望通知用户, 在代码中执行一些清理操作, 或者在用户界面 (UI) 中进行其他更改。  
  
 页面开发人员可以通过将`OnWebPartsDisConnected`属性添加到页面中的`<asp:webpartmanager>`元素, 并为属性分配自定义方法名称, 将自定义事件处理程序与此事件相关联。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnected(System.Web.UI.WebControls.WebParts.WebPartConnectionsEventArgs)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="WebPartsDisconnecting">
      <MemberSignature Language="C#" Value="public event System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler WebPartsDisconnecting" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event WebPartsDisconnecting As WebPartConnectionsCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Web::UI::WebControls::WebParts::WebPartConnectionsCancelEventHandler ^ WebPartsDisconnecting;" />
      <MemberSignature Language="F#" Value="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " Usage="member this.WebPartsDisconnecting : System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在结束以前连接的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPart" /> 或服务器控件之间的连接的过程中发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件由方法引发, 它指示用户单击了<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts%2A>断开连接谓词, 或已调用方法。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting> 事件提供了一种方法, 可在连接完成前取消结束连接的过程。 如果连接成功结束, 则此事件后跟<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected>事件。  
  
 页面开发人员可以为事件添加自定义处理程序, 方法`OnWebPartsDisconnecting`是将属性`<asp:webpartmanager>`添加到元素, 并将自定义方法名称分配给该属性。  
  
 通常, 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件由于结束连接的用户操作的直接结果引发时, 可以取消该事件。 但是, 在某些情况下, 无法取消事件。 第一种情况是, 如果<xref:System.Web.UI.WebControls.WebParts.WebPartZone>删除控件, 则该<xref:System.Web.UI.WebControls.WebParts.WebPart>控件所包含的控件必须全部关闭, 否则将会孤立。 在这种情况<xref:System.Web.UI.WebControls.WebParts.WebPartManager>下, 控件<xref:System.Web.UI.WebControls.WebParts.WebPart>将关闭控件, 而不是用户, 并且它还必须能够在不中断的情况下终止任何连接的控件的连接, 使其能够完成清理和关闭过程所有控件。 因此, 在这种<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>情况下, 不能取消设计方法。 有关可取消的相关事件, 请参阅<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartClosing>事件。  
  
 不能取消<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>事件的第二种情况是<xref:System.Web.UI.WebControls.WebParts.WebPartManager.ActivateConnections%2A>调用方法 (例如, 在每次向页面发出请求时调用此方法), 而页面上的现有连接中存在某种类型的冲突。 例如, 用户可能会将 control x 连接到 control y, 但共享用户将 control x 连接到 control z, 但不允许 control x 建立多个连接。 在这种情况下, 将优先使用单个用户的连接设置, 并且该<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件通过<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>调用方法并结束 x 和 z 与特定用户之间的连接来解决冲突。 由于此断开连接对于解决冲突至关重要, 因此设计<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>该事件在此方案中不能取消。  
  
 不能取消<xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>方法的第三种情况是<xref:System.Web.UI.WebControls.WebParts.WebPart> : 当前连接的或服务器控件被删除或关闭。 由于控件确实要从页中移除, 因此, 删除其连接是一种合乎逻辑的必要性。 因此, 当<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件<xref:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebPart%2A>调用方法, <xref:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnecting>而该方法反过来引发事件时, 设计将无法取消事件。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.OnWebPartsDisconnecting(System.Web.UI.WebControls.WebParts.WebPartConnectionsCancelEventArgs)" />
        <altmember cref="E:System.Web.UI.WebControls.WebParts.WebPartManager.WebPartsDisconnected" />
        <altmember cref="M:System.Web.UI.WebControls.WebParts.WebPartManager.DisconnectWebParts(System.Web.UI.WebControls.WebParts.WebPartConnection)" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
      </Docs>
    </Member>
    <Member MemberName="Zones">
      <MemberSignature Language="C#" Value="public System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.WebControls.WebParts.WebPartZoneCollection Zones" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Zones As WebPartZoneCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ Zones { System::Web::UI::WebControls::WebParts::WebPartZoneCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Zones : System.Web.UI.WebControls.WebParts.WebPartZoneCollection" Usage="System.Web.UI.WebControls.WebParts.WebPartManager.Zones" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.WebPartZoneCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取对网页上所有 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" /> 区域的集合的引用。</summary>
        <value>引用一组 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneCollection" /> 区域的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartZoneBase" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 控件使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>属性来跟踪网页上的<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域。 <xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> 请注意, 属性不引用所有类型的区域;它仅引用派生自<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>类的区域, 包括<xref:System.Web.UI.WebControls.WebParts.WebPartZone>区域。  
  
 尽管属性引用的集合是只读的, 但你可以使用它来访问集合中的各个对象并以编程方式使用它们。  
  
   
  
## Examples  
 下面的代码示例演示如何以编程方式<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>使用属性访问单个<xref:System.Web.UI.WebControls.WebParts.WebPartZoneBase>区域控件。 请注意, 在网页的声明性标记中, 有两个`<asp:webpartzone>`元素, 每个元素都包含一个服务器控件。 在该页的<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A> `<script>`节中, 代码使用属性访问各个区域, 列出所有区域 id, 然后更改第二个区域的背景色。  
  
 [!code-aspx-csharp[WebParts_WebPartManager_Zones#1](~/samples/snippets/csharp/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/CS/wpmgrzonescs.aspx#1)]
 [!code-aspx-vb[WebParts_WebPartManager_Zones#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/WebParts_WebPartManager_Zones/VB/wpmgrzonesvb.aspx#1)]  
  
 请注意, 若要使代码示例正常运行, 必须在 web.config 文件中添加一个设置, 以便导出 Web 部件说明文件。 确保在此代码示例的网页所在的同一目录中有一个 web.config 文件。 在部分中, 请确保有一个`<webParts>`元素的`enableExport`属性设置为`true`, 如以下标记所示。 `<system.web>`  
  
 `<webParts enableExport="true">`  
  
 `...`  
  
 `</webParts>`  
  
 将页面加载到浏览器中后, 如果单击 "**列出区域 id** " 按钮, 代码将使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager.Zones%2A>属性列出集合中所有区域的 id。 如果单击 "**更改区域背景色**" 按钮, 则代码会更改第二个区域的背景色。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
