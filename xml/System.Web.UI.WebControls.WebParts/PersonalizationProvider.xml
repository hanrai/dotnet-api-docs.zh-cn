<Type Name="PersonalizationProvider" FullName="System.Web.UI.WebControls.WebParts.PersonalizationProvider">
  <Metadata><Meta Name="ms.openlocfilehash" Value="43d8d7b00883883629c9828d4f9138bcfdfb0f48" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69394992" /></Metadata><TypeSignature Language="C#" Value="public abstract class PersonalizationProvider : System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit PersonalizationProvider extends System.Configuration.Provider.ProviderBase" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class PersonalizationProvider&#xA;Inherits ProviderBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class PersonalizationProvider abstract : System::Configuration::Provider::ProviderBase" />
  <TypeSignature Language="F#" Value="type PersonalizationProvider = class&#xA;    inherit ProviderBase" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Configuration.Provider.ProviderBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>实现个性化设置提供程序的基本功能。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是定义个性化设置提供程序所需功能的抽象基类。 个性化设置提供程序代表<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例加载和存储个性化数据。  
  
 基类定义了许多方法的标准行为;只有那些专门处理基础数据存储区的方法才会标记为抽象。 这允许开发人员编写自定义提供程序以与特定数据存储区交互, 而无需重新实现<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类使用的标准功能。  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para>你可以从<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />派生并仅提供此类中定义的抽象方法的实现。 抽象方法专门介绍了如何在物理数据存储区中保存数据并将数据加载到数据存储管理。 自定义提供程序必须能够以区分<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />数据与<see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" />数据的方式来操作个性化设置信息。 此外, 提供程序还必须按页以及应用程序划分个性化数据。  
  
的<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" />实现与的<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />实现紧密耦合, 因为某些个性化设置提供程序方法返回<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />派生类的实例。 为了简化自定义提供程序的开发<see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> , 基类包含个性化设置逻辑的默认实现和直接<see cref="T:System.Web.UI.WebControls.WebParts.WebPartPersonalization" />由类使用的序列化/反序列化逻辑。 因此, 创作仅用于处理不同数据存储的自定义提供程序只需要实现以下抽象方法: 
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />-对于所提供的查询参数, 此方法需要能够计算数据库中个性化数据的行数。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />-给定路径和用户名, 此方法从数据库加载两个二进制大型对象 (Blob): 一个 BLOB 用于共享数据, 一个用于用户数据。 如果提供了用户名和路径, 则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件访问可提供用户名/路径信息的页面信息。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />-给定路径和用户名, 此方法会删除数据库中的相应行。 如果提供了用户名和路径, 则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件访问可提供用户名/路径信息的页面信息。  
  
-   <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />-给定路径和用户名, 此方法会将提供的 BLOB 保存到数据库。 如果提供了用户名和路径, 则不需要<see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />控件访问可提供用户名/路径信息的页面信息。  
  
在所有这些方法中, 如果只提供了路径, 则指示对该页的共享个性化数据进行操作。 如果路径和用户名都传递到方法, 则应对该页的用户个性化设置数据进行操作。 对于<see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />, 应始终加载指定路径的共享数据, 并且如果用户名不<see langword="null" />为, 还应加载该路径的用户个性化数据。  
  
所有其他抽象方法仅适用于管理应用程序, 在运行时, Web 部件基础结构不使用这些方法。 有关个性化设置提供程序的实现的示例, 请参见<see cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />类。</para></block>
    <altmember cref="T:System.Web.UI.WebControls.WebParts.SqlPersonalizationProvider" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/e0s9t4ck(v=vs.100)">ASP.NET Web 部件控件</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/z36h8be9(v=vs.100)">Web 部件个性化概述</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/784d8z92(v=vs.100)">演练：使用用户控件实现 Web 部件个性化设置</related>
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/ms178182(v=vs.100)">Web 部件个性化</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected PersonalizationProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; PersonalizationProvider();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationProvider" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 由于这是抽象类的构造函数, 因此必须重写此方法, 以创建从此类继承的类的实例。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public abstract string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Property ApplicationName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ ApplicationName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationName : string with get, set" Usage="System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在派生类中重写时，获取或设置为提供程序配置的应用程序的名称。</summary>
        <value>为个性化设置提供程序配置的应用程序。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果在配置文件中未指定应用程序名称, 而使用[providers 元素进行 webpart 的个性化设置 (ASP.NET 设置架构)](https://msdn.microsoft.com/library/51363b49-eafa-4b9c-b9d0-80086b385195)属性, 则使用<xref:System.Web.Hosting.HostingEnvironment.ApplicationVirtualPath%2A>属性的值。  
  
> [!CAUTION]
>  由于单个的默认个性化设置提供程序实例可用于<xref:System.Web.HttpApplication>对象所提供的所有请求, 因此可以同时执行多个请求, 每个请求都尝试<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>设置属性值。 对于<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>多个写入, 属性不是线程安全的, 并且<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>更改属性值可能会导致应用程序的多个用户产生意外行为。 建议你避免允许用户设置属性的<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>代码 (除非必需)。 例如, 在管理多个应用程序的个性化设置数据的管理应用程序中, 可能需要设置属性。<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ApplicationName%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSupportedUserCapabilities">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IList CreateSupportedUserCapabilities ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IList CreateSupportedUserCapabilities() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateSupportedUserCapabilities () As IList" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IList ^ CreateSupportedUserCapabilities();" />
      <MemberSignature Language="F#" Value="abstract member CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList&#xA;override this.CreateSupportedUserCapabilities : unit -&gt; System.Collections.IList" Usage="personalizationProvider.CreateSupportedUserCapabilities " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 对象的列表，这些对象表示 Web 部件控件集所使用的已知功能集。</summary>
        <returns>一个 <see cref="T:System.Collections.IList" />，它表示 Web 部件控件集所使用的已知功能集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 目前, 此方法返回一个包含两个功能的<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>列表<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>: 和。 这些是默认功能, 可在用于 web 部件的个性化设置元素[(ASP.NET 设置架构) 元素的 Authorization 元素](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434)中定义[](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09) , 该元素位于[Webpart 元素 (ASP.NET 设置架构)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)配置节。 如果选择实现自定义的个性化设置基础结构, 则可以重写此方法, 并定义自己的一组授权相关用户功能。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetermineInitialScope">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, System.Web.UI.WebControls.WebParts.PersonalizationState loadedState);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope DetermineInitialScope(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, class System.Web.UI.WebControls.WebParts.PersonalizationState loadedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineInitialScope(System.Web.UI.WebControls.WebParts.WebPartManager,System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationScope DetermineInitialScope(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::Web::UI::WebControls::WebParts::PersonalizationState ^ loadedState);" />
      <MemberSignature Language="F#" Value="abstract member DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope&#xA;override this.DetermineInitialScope : System.Web.UI.WebControls.WebParts.WebPartManager * System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; System.Web.UI.WebControls.WebParts.PersonalizationScope" Usage="personalizationProvider.DetermineInitialScope (webPartManager, loadedState)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="loadedState" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="loadedState">个性化设置状态信息。</param>
        <summary>确定初始个性化设置范围应为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 还是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围。</summary>
        <returns>一个 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />，它指示当前个性化设置范围是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 还是 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法确定当前范围是否应为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>或<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>, 在给定对某个<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的引用以及个性化设置生命周期内先前已加载的个性化设置状态信息时。 此信息由<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>实例用于后续的与个性化相关的任务。  
  
 以下规则用于确定个性化设置范围:  
  
-   范围最初假定为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>。  
  
-   如果当前正在执行的用户帐户未通过身份验证, 则将范围<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>设置为。  
  
-   如果当前正在执行的用户帐户已经过身份验证, 则其他处理按优先级顺序进行:  
  
    -   如果该页处于回发模式, 则页面请求包含之前的页面呈现的作用域信息。 如果该范围信息指示<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>使用了作用域, 则该作用域的计算结果为。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>  
  
    -   如果当前正在执行的页控制了从另一页传输到它的控件 (例如, 如果由于调用<xref:System.Web.HttpServerUtility.Transfer%2A>方法导致了控制传输, 则为; 请注意, 对于跨页面发送不会出现此特定检查), 如果之前执行页有一个<xref:System.Web.UI.WebControls.WebParts.WebPartManager>实例, 范围设置为上一个<xref:System.Web.UI.WebControls.WebParts.WebPartManager>实例中`Personalization.Scope`属性的值。  
  
    -   如果未满足上述条件, 则作用域的计算结果为当前<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.InitialScope%2A> <xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件的属性的值。  
  
 进行上一次计算后, 如果作用域的计算结果为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>范围, 则会进行以下处理:  
  
-   如果当前正在执行的用户帐户具有<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>该功能, 则作用域仍<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>设置为。  
  
-   如果当前正在执行的用户帐户没有该<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability>功能, 则将此作用域重置为。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>  
  
-   如果以前的所有范围评估的结果都<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>是, 则此结果将作为隐藏字段存储在当前正在执行的页上。 这是一种机制, 通过该机制, 页面可以在后续回发过程中重播作用域评估。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="DetermineUserCapabilities">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IDictionary DetermineUserCapabilities (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IDictionary DetermineUserCapabilities(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.DetermineUserCapabilities(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IDictionary ^ DetermineUserCapabilities(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary&#xA;override this.DetermineUserCapabilities : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; System.Collections.IDictionary" Usage="personalizationProvider.DetermineUserCapabilities webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <summary>返回一个包含 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 实例的字典，这些实例表示当前正在执行的用户帐户的与个性化设置相关的功能。</summary>
        <returns><see cref="T:System.Collections.IDictionary" />，如果用户帐户已经过身份验证，则包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartUserCapability" /> 实例，如果正在执行的用户帐户未经过身份验证，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法的默认实现使用[webpart (ASP.NET 设置架构) 的个性化元素](https://msdn.microsoft.com/library/3d77da55-73ce-46ce-97cf-7d2abcaada09)中的用于个性化设置的 authorization 元素中的信息 ( [ASP.NET 设置架构](https://msdn.microsoft.com/library/d190d4ff-1445-4ee1-88eb-9737c7aa1434))machine.config 或 web.config 文件中的[Webpart 元素 (ASP.NET 设置架构)](https://msdn.microsoft.com/library/90af5acc-5a80-4b39-bba7-74afd06b167c)配置节的元素, 以确定用户的授权功能。  
  
 字典中<xref:System.Collections.IList>的功能将是<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.CreateSupportedUserCapabilities%2A>方法返回的对象的成员<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.EnterSharedScopeUserCapability> , 当前<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.ModifyStateUserCapability>包含功能和功能。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。  
  
或 
与页关联的请求为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="FindState">
      <MemberSignature Language="C#" Value="public abstract System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int pageIndex, int pageSize, out int totalRecords);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection FindState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query, int32 pageIndex, int32 pageSize, [out] int32&amp; totalRecords) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.FindState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery,System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function FindState (scope As PersonalizationScope, query As PersonalizationStateQuery, pageIndex As Integer, pageSize As Integer, ByRef totalRecords As Integer) As PersonalizationStateInfoCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Web::UI::WebControls::WebParts::PersonalizationStateInfoCollection ^ FindState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query, int pageIndex, int pageSize, [Runtime::InteropServices::Out] int % totalRecords);" />
      <MemberSignature Language="F#" Value="abstract member FindState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery * int * int *  -&gt; System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" Usage="personalizationProvider.FindState (scope, query, pageIndex, pageSize, totalRecords)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
        <Parameter Name="pageIndex" Type="System.Int32" />
        <Parameter Name="pageSize" Type="System.Int32" />
        <Parameter Name="totalRecords" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="scope">具有要查询的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="query">包含查询的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />。 此值可为 <see langword="null" />。</param>
        <param name="pageIndex">查询的起始位置。</param>
        <param name="pageSize">要返回的记录数。</param>
        <param name="totalRecords">可用记录的总数。</param>
        <summary>在派生类中重写时，将根据范围和特定的查询参数返回一个集合，其中包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 派生对象。</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfoCollection" />，包含零个或零个以上 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo" /> 派生对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于查询个性化数据的管理方法的抽象定义。 派生实现应遵循如下所述的逻辑。  
  
 返回项的集合`pageIndex`受和`pageSize`参数的约束, 其中`pageSize`设置要返回的记录数, 并`pageIndex`设置要返回的记录。 例如, 值为`pageIndex` 0 并且为`pageSize` 25 时, 将返回前`pageIndex` 25 个匹配项, 而1和`pageSize` 25 的值将返回出现26-50。 如果要检索所有可用记录, 请将设置`pageIndex`为 0 <xref:System.Int32.MaxValue>, `pageSize`将设置为。  
  
 派生<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo>的对象按字母顺序返回, 并按其<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateInfo.Path%2A>和<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.Username%2A>属性值的组合进行排序, 两者都以升序进行排序。  
  
 此方法将查询通配符传递到基础数据存储区。 对通配符的支持当前依赖于每个提供程序如何处理星号 (*)、百分号 (%) 或下划线 (_) 等字符。  
  
 通常, 对于符合 SQL 标准的数据存储区, 可以在部分路径上执行通配符搜索, 通配符字符显示在<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性中搜索字符串文本的开头、末尾或中间。 例如, 若要查找以 "\~/vdir" 开头的所有路径, 则该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性将设置为 "\~/vdir%"。  
  
 同样, 在部分用户名上进行通配符搜索可能会在该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性的文本字符串中的任意位置显示通配符。 例如, 若要查找所有以 "john" 开头的用户名, 该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>参数将类似于 "john%"。  
  
 下面的查询约束适用:  
  
-   如果只`scope`提供了, 并且`query`是`null`或的所有属性`query`返回`null`或默认值, 则返回与指定`scope`参数匹配的所有记录。  
  
-   如果属性不`null`为, 则返回的记录也会根据与<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>该值匹配的路径进行筛选。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>  
  
-   如果属性不`null`为, 则还会根据与<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性值匹配的用户名来筛选返回的记录。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>  
  
-   如果该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性不<xref:System.DateTime.MaxValue>等于, 则返回的记录也将进行筛选, 以仅返回与非活动用户关联的那些记录。 比较包含<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>属性小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性的记录。  
  
 请注意, 此方法不会验证查询参数的组合。 例如, 代码可以请求一组与共享作用域中的特定用户名相关联的个性化设置状态记录。 由于用户名不与共享信息关联, 因此返回的集合将为空。  
  
 有可能返回非空集合的参数组合包括:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域与<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性的组合。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>将<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>范围与、 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性的任意或全部值组合在一起。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCountOfState">
      <MemberSignature Language="C#" Value="public abstract int GetCountOfState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCountOfState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, class System.Web.UI.WebControls.WebParts.PersonalizationStateQuery query) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.GetCountOfState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.Web.UI.WebControls.WebParts.PersonalizationStateQuery)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCountOfState (scope As PersonalizationScope, query As PersonalizationStateQuery) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetCountOfState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, System::Web::UI::WebControls::WebParts::PersonalizationStateQuery ^ query);" />
      <MemberSignature Language="F#" Value="abstract member GetCountOfState : System.Web.UI.WebControls.WebParts.PersonalizationScope * System.Web.UI.WebControls.WebParts.PersonalizationStateQuery -&gt; int" Usage="personalizationProvider.GetCountOfState (scope, query)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="query" Type="System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />
      </Parameters>
      <Docs>
        <param name="scope">要查询的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="query">包含查询的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery" />。 此值可为 <see langword="null" />。</param>
        <summary>在派生类中重写时，返回基础数据存储区中存在于指定范围内的行数。</summary>
        <returns>针对指定 <paramref name="scope" /> 参数的基础数据存储区的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于检索个性化设置数据计数的管理方法的抽象定义。 派生实现应遵循如下所述的逻辑。  
  
 此方法将查询通配符传递到基础数据存储区。 对通配符的支持当前依赖于每个提供程序如何处理星号 (*)、百分号 (%) 或下划线 (_) 等字符。  
  
 通常, 对于符合 SQL 标准的数据存储区, 可以在部分路径上执行通配符搜索, 通配符字符显示在<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性中搜索字符串文本的开头、末尾或中间。 例如, 若要查找以 "\~/vdir" 开头的所有路径, 则该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性将设置为 "\~/vdir%"。  
  
 同样, 在部分用户名上进行通配符搜索可能会在该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性的文本字符串中的任意位置显示通配符。 例如, 若要查找所有以 "john" 开头的用户名, 该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>参数将类似于 "john%"。  
  
 下面的查询约束适用:  
  
-   如果只`scope`提供了, 并且`query`是`null`或的所有属性`query`返回`null`了或默认值, 则将对与指定`scope`的参数匹配的所有记录进行计数。  
  
-   如果该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性不`null`为, 则还会根据与<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>该值匹配的路径来筛选计数记录。  
  
-   如果属性不`null`为, 则还会根据与<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>属性值匹配的用户名筛选计数记录。 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>  
  
-   如果该<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性不<xref:System.DateTime.MaxValue>等于, 则计数记录也会进行筛选, 以仅返回与非活动用户关联的那些记录。 比较包含<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>属性小于或等于<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性的记录。  
  
 请注意, 此方法不会验证查询参数的组合。 例如, 代码可以请求与共享作用域中的特定用户名相关联的个性化设置状态记录的计数。 由于用户名不与共享信息关联, 因此返回的计数将为零。  
  
 可能返回非零计数的参数组合包括:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>作用域与<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>属性的组合。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>将<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.PathToMatch%2A>范围与、 <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UsernameToMatch%2A>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>属性的任意或全部值组合在一起。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationBlobs">
      <MemberSignature Language="C#" Value="protected abstract void LoadPersonalizationBlobs (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, ref byte[] sharedDataBlob, ref byte[] userDataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadPersonalizationBlobs(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[]&amp; sharedDataBlob, unsigned int8[]&amp; userDataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[]@,System.Byte[]@)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void LoadPersonalizationBlobs(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ % sharedDataBlob, cli::array &lt;System::Byte&gt; ^ % userDataBlob);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationBlobs : System.Web.UI.WebControls.WebParts.WebPartManager * string * string *  *  -&gt; unit" Usage="personalizationProvider.LoadPersonalizationBlobs (webPartManager, path, userName, sharedDataBlob, userDataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="sharedDataBlob" Type="System.Byte[]" RefType="ref" />
        <Parameter Name="userDataBlob" Type="System.Byte[]" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作检索关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作检索关键字的个性化设置信息的用户名。</param>
        <param name="sharedDataBlob">为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared" /> 范围返回的数据。</param>
        <param name="userDataBlob">为 <see cref="F:System.Web.UI.WebControls.WebParts.PersonalizationScope.User" /> 范围返回的数据。</param>
        <summary>在派生类中重写时，从基础数据存储区加载原始个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生自<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>并实现此方法的类应`webPartManager`将、 `path`和`username`参数用作检索键。 无论数据存储在数据存储中的方式如何 (某些数据存储可能会执行某种类型的智能存储), 都必须在两个数组中以打包的字节集的形式返回个性化数据。 返回的数据必须符合以下规则:  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>范围的数据必须始终`sharedDataBlob`在参数中返回。  
  
-   根据键值, <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>将在`userDataBlob`参数中返回数据。 参数的非`null`值<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>指示还应检索数据。 `userName`  
  
 从<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>派生并实现此方法的个性化设置提供程序可以通过在一次往返中检索所有个性化数据来优化与其数据存储的交互, 而<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>不是在两个中检索和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>数据分离往返。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.WebControls.WebParts.PersonalizationState LoadPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, bool ignoreCurrentUser) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Web::UI::WebControls::WebParts::PersonalizationState ^ LoadPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, bool ignoreCurrentUser);" />
      <MemberSignature Language="F#" Value="abstract member LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState&#xA;override this.LoadPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager * bool -&gt; System.Web.UI.WebControls.WebParts.PersonalizationState" Usage="personalizationProvider.LoadPersonalizationState (webPartManager, ignoreCurrentUser)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.WebControls.WebParts.PersonalizationState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="ignoreCurrentUser" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="ignoreCurrentUser"><see cref="T:System.Boolean" />，指示是否应将用户名传递给个性化设置提供程序。</param>
        <summary>从基础数据存储区加载原始数据，并将该数据转换为 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" /> 对象。</summary>
        <returns><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含个性化设置数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类用于加载个性化设置数据的主入口点。 默认实现从基础数据存储区加载原始数据 (功能是在派生提供程序中实现的), 然后将原始数据转换为<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>实例。  
  
 如果参数为`true`, 则不会向<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationBlobs%2A>方法传递任何用户名。 `ignoreCurrentUser` 个性化设置提供程序可以选择将此解释为, 这意味着只应从<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>基础数据存储中检索具有范围的个性化设置状态。  
  
 当方法执行时, 它会<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState%2A>调用方法, 并且在加载状态时可能会发生三种类型的反序列化错误。 <xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization.Load%2A> 发生这些特定错误时, 不会引发异常, 并且会通过运行状况监视功能记录错误事件 (有关运行状况监视和访问其创建的日志的信息, 请参阅[ASP.NET Health Monitoring 概述](https://msdn.microsoft.com/library/e003f224-70fe-4cd8-a71a-2dc81e2d7e4c))。 以下三种情况会导致将反序列化错误事件写入日志:  
  
-   尝试反序列化使用字符串<xref:System.ComponentModel.TypeConverter>的属性类型失败。  
  
-   尝试反序列化使用二进制序列化的属性类型失败。  
  
-   尝试反序列化属性类型失败, 因为无法创建该类型的实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">与 <paramref name="webPartManager" /> 关联的页为 <see langword="null" />。  
  
- 或 - 
与页关联的请求为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void ResetPersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ResetPersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void ResetPersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string -&gt; unit" Usage="personalizationProvider.ResetPersonalizationBlob (webPartManager, path, userName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作数据存储区关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作数据存储区关键字的个性化设置信息的用户名。</param>
        <summary>在派生类中重写时，从基础数据存储区删除原始个性化设置数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生自<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider>并实现此方法的类应`webPartManager`使用、 `path`和`userName`参数作为存储密钥。 派生的实现必须修改数据存储, 以便有效地删除所提供的存储密钥的个性化数据。 派生实现取决于其物理实现方式。  
  
 派生的个性化设置提供程序必须能够以每页的方式区分个性化数据。 此外, 对于给定页面的状态, 个性化设置提供程序必须能够区分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>数据和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>范围数据。 如果提供了一个`null`非用户名, 则重置操作将应用于该<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>作用域; 否则, 重置操作将应用于<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>该作用域。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void ResetPersonalizationState (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetPersonalizationState(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetPersonalizationState(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager);" />
      <MemberSignature Language="F#" Value="abstract member ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit&#xA;override this.ResetPersonalizationState : System.Web.UI.WebControls.WebParts.WebPartManager -&gt; unit" Usage="personalizationProvider.ResetPersonalizationState webPartManager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <summary>将个性化设置数据重置到基础数据存储区。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类用于重置个性化数据的主入口点。 默认实现使用<xref:System.Web.UI.WebControls.WebParts.WebPartManager>控件来确定要重置的数据的路径和用户名。 然后, 默认实现将调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="webPartManager" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="webPartManager" /> 不与页相关联。  
  
- 或 - 
页不与正在进行的 <see cref="T:System.Web.HttpRequest" /> 关联。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public abstract int ResetState (System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetState(valuetype System.Web.UI.WebControls.WebParts.PersonalizationScope scope, string[] paths, string[] usernames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetState(System.Web.UI.WebControls.WebParts.PersonalizationScope,System.String[],System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetState (scope As PersonalizationScope, paths As String(), usernames As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetState(System::Web::UI::WebControls::WebParts::PersonalizationScope scope, cli::array &lt;System::String ^&gt; ^ paths, cli::array &lt;System::String ^&gt; ^ usernames);" />
      <MemberSignature Language="F#" Value="abstract member ResetState : System.Web.UI.WebControls.WebParts.PersonalizationScope * string[] * string[] -&gt; int" Usage="personalizationProvider.ResetState (scope, paths, usernames)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Web.UI.WebControls.WebParts.PersonalizationScope" />
        <Parameter Name="paths" Type="System.String[]" />
        <Parameter Name="usernames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="scope">要重置的个性化设置信息的 <see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationScope" />。 此值不能为 <see langword="null" />。</param>
        <param name="paths">要删除的个性化设置信息的路径。</param>
        <param name="usernames">要删除的个性化设置信息的用户名。</param>
        <summary>在派生类中重写时，根据指定的参数从基础数据存储区删除个性化设置状态。</summary>
        <returns>删除的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于删除个性化设置数据的管理方法的抽象定义。 派生实现应遵循如下所述的逻辑。  
  
 此方法不支持通配符搜索。 如果个性化设置提供程序公开了事务感知数据存储区中的数据, 则此方法应以单个原子事务的形式执行其操作。  
  
 仅允许以下参数组合:  
  
-   设置参数, 并将所有其他参数设置为`null`。 `scope` 此组合将删除与所指示`scope`的个性化设置范围关联的所有 Web 部件的个性化设置数据。  
  
-   设置`scope`了参数, `paths`且参数至少包含一个值。 此组合将删除所指示`scope`的个性化设置范围中的指定路径的所有 Web 部件的个性化设置数据。  
  
-   参数设置为<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> `usernames` , `paths`参数设置为, 仅包含一个值, 并且参数至少包含一个值。 `scope` 此组合将删除与中`usernames`包含的用户或用户关联的给定路径的所有用户个性化 Web 部件数据。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User> `null`参数设置为`usernames` , `paths`参数设置为, 并且参数至少包含一个值。 `scope` 此组合将删除与中`usernames`包含的用户或用户关联的所有路径中每个用户的个性化 Web 部件数据。  
  
 参数值的任何其他组合均无效, 并将引发<xref:System.ArgumentException>异常。 具体而言, 不允许使用以下两种组合:  
  
-   当`usernames`设置为`scope` 时<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>, 不能提供参数。  
  
-   参数不能包含多个项`null`。 `usernames` `paths`  
  
 各个`paths`数组`usernames`中包含的任何和参数值都必须满足下列验证规则。 如果任何参数数组成员的任何验证规则都失败, <xref:System.ArgumentException>则会引发异常。 验证规则如下:  
  
-   `null`不允许使用值。  
  
-   不允许使用空字符串 ("")。 在执行空字符串检查之前, 应剪裁参数。  
  
-   `usernames`参数不能包含逗号 (,)。  
  
-   对于 SQL 数据库, `paths`参数的长度不能超过256个字符。  
  
-   对于 SQL 数据库, `usernames`参数的长度不能超过256个字符。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetUserState">
      <MemberSignature Language="C#" Value="public abstract int ResetUserState (string path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ResetUserState(string path, valuetype System.DateTime userInactiveSinceDate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetUserState(System.String,System.DateTime)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ResetUserState (path As String, userInactiveSinceDate As DateTime) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int ResetUserState(System::String ^ path, DateTime userInactiveSinceDate);" />
      <MemberSignature Language="F#" Value="abstract member ResetUserState : string * DateTime -&gt; int" Usage="personalizationProvider.ResetUserState (path, userInactiveSinceDate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userInactiveSinceDate" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">要删除的个性化设置数据的路径。 此值可以为 <see langword="null" />，但不能为空字符串 ("")。</param>
        <param name="userInactiveSinceDate">日期，指示网站用户上次更改个性化设置数据的时间。</param>
        <summary>在派生类中重写时，根据指定的参数从基础数据存储区删除 Web 部件个性化设置数据。</summary>
        <returns>从基础数据存储区中删除的行数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于删除个性化设置数据的管理方法的抽象定义。 请注意, 此方法仅影响用户个性化数据, 而不影响共享数据。  
  
 派生实现应遵循如下所述的逻辑:  
  
-   `path`参数不能包含通配符。  
  
-   如果提供程序公开了事务感知数据存储区中的数据, 则此方法应在单个原子事务中执行其操作。  
  
-   如果参数不为`null`, 则仅删除与关联的`path`每用户个性化设置记录。 `path`  
  
-   只有自`userInactiveSinceDate`参数中指示的日期后, 与被视为非活动状态的用户关联的每用户个性化设置记录将被删除。 具体而言, 将<xref:System.Web.UI.WebControls.WebParts.UserPersonalizationStateInfo.LastActivityDate%2A>删除小于或<xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A>等于的记录。  
  
-   如果同时提供了这两个参数, 则将删除匹配这两个约束的记录。  
  
-   参数可以是`null`。 `path`  
  
-   `path`参数不能为空字符串。 在执行此检查之前, 应进行剪裁。  
  
-   <xref:System.Web.UI.WebControls.WebParts.PersonalizationStateQuery.UserInactiveSinceDate%2A> 属性不能为 `null`。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationBlob">
      <MemberSignature Language="C#" Value="protected abstract void SavePersonalizationBlob (System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, byte[] dataBlob);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SavePersonalizationBlob(class System.Web.UI.WebControls.WebParts.WebPartManager webPartManager, string path, string userName, unsigned int8[] dataBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob(System.Web.UI.WebControls.WebParts.WebPartManager,System.String,System.String,System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void SavePersonalizationBlob(System::Web::UI::WebControls::WebParts::WebPartManager ^ webPartManager, System::String ^ path, System::String ^ userName, cli::array &lt;System::Byte&gt; ^ dataBlob);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationBlob : System.Web.UI.WebControls.WebParts.WebPartManager * string * string * byte[] -&gt; unit" Usage="personalizationProvider.SavePersonalizationBlob (webPartManager, path, userName, dataBlob)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="webPartManager" Type="System.Web.UI.WebControls.WebParts.WebPartManager" />
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="dataBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="webPartManager">管理个性化设置数据的 <see cref="T:System.Web.UI.WebControls.WebParts.WebPartManager" />。</param>
        <param name="path">要用作数据存储区关键字的个性化设置信息的路径。</param>
        <param name="userName">要用作关键字的个性化设置信息的用户名。</param>
        <param name="dataBlob">要保存的数据的字节数组。</param>
        <summary>在派生类中重写时，将原始个性化设置数据保存到基础数据存储区中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是用于将原始个性化设置数据保存到基础数据存储区的方法的抽象定义。  
  
 派生实现应使用`webPartManager`、 `path`和`userName`参数作为存储密钥。 派生的个性化设置提供程序必须能够以每页的方式区分个性化数据。 此外, 对于给定页面的状态, 提供程序必须能够区分<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>和<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>作用域。 如果提供了非`null`用户名, `dataBlob`则参数在<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.User>范围内; 否则, 该`dataBlob`参数将被视为在<xref:System.Web.UI.WebControls.WebParts.PersonalizationScope.Shared>范围内。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePersonalizationState">
      <MemberSignature Language="C#" Value="public virtual void SavePersonalizationState (System.Web.UI.WebControls.WebParts.PersonalizationState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SavePersonalizationState(class System.Web.UI.WebControls.WebParts.PersonalizationState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationState(System.Web.UI.WebControls.WebParts.PersonalizationState)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SavePersonalizationState (state As PersonalizationState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SavePersonalizationState(System::Web::UI::WebControls::WebParts::PersonalizationState ^ state);" />
      <MemberSignature Language="F#" Value="abstract member SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit&#xA;override this.SavePersonalizationState : System.Web.UI.WebControls.WebParts.PersonalizationState -&gt; unit" Usage="personalizationProvider.SavePersonalizationState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Web.UI.WebControls.WebParts.PersonalizationState" />
      </Parameters>
      <Docs>
        <param name="state"><see cref="T:System.Web.UI.WebControls.WebParts.PersonalizationState" />，包含要保存的个性化设置数据。</param>
        <summary>将个性化设置数据保存到数据存储区中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法是<xref:System.Web.UI.WebControls.WebParts.WebPartPersonalization>类用于保存个性化设置数据的主入口点。  
  
 此方法的默认实现使用的内部实现<xref:System.Web.UI.WebControls.WebParts.PersonalizationState>的方法将个性化设置数据打包到字节数组中。 如果此打包的结果创建一个空字节数组 (因为属性提取导致没有个性化数据), 则默认实现将调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.ResetPersonalizationBlob%2A>方法。 否则, 默认实现将调用<xref:System.Web.UI.WebControls.WebParts.PersonalizationProvider.SavePersonalizationBlob%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="state" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">正在保存的 <paramref name="state" /> 对象与 <see cref="M:System.Web.UI.WebControls.WebParts.PersonalizationProvider.LoadPersonalizationState(System.Web.UI.WebControls.WebParts.WebPartManager,System.Boolean)" /> 方法返回的 <paramref name="state" /> 对象类型不同。</exception>
      </Docs>
    </Member>
  </Members>
</Type>
