<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="f75554677d02911e50eb9fd8f01bf1fa8551ab83" /><Meta Name="ms.sourcegitcommit" Value="08fc3691deb7adaf0dfd751b9d9d0b23a3d3a7b8" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/09/2019" /><Meta Name="ms.locfileid" Value="68903807" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示一个程序集，它是一个可重用、无版本冲突并且可自我描述的公共语言运行时应用程序构建基块。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly>使用类加载程序集、浏览程序集的元数据和构成部分、发现程序集中包含的类型以及创建这些类型的实例。  
  
 若要获取表示当前<xref:System.Reflection.Assembly>加载到应用程序域中的程序集 (例如, 简单项目的默认应用程序域) 的对象数组, 请<xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType>使用方法。  
  
 为了动态加载程序集, <xref:System.Reflection.Assembly>类提供以下静态方法 (`Shared` Visual Basic 中的方法)。 将程序集加载到发生加载操作的应用程序域中。  
  
-   加载程序集的建议方法是使用<xref:System.AppDomain.Load%2A>方法, 该方法标识要由其显示名称 (例如 "b77a5c561934e089, Version = 2.0.0.0, Culture = 中立, PublicKeyToken =") 加载的程序集。 该程序集的搜索遵循[运行时如何定位程序集](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)中所述的规则。  
  
-   使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> 和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法, 可以加载用于反射的程序集, 但不能加载用于执行的程序集。 例如, 可通过在32位平台上运行的代码来检查面向64位平台的程序集。  
  
-   对于<xref:System.Reflection.Assembly.LoadFile%2A>程序<xref:System.Reflection.Assembly.LoadFrom%2A>集必须按路径进行标识的罕见方案, 提供了和方法。  
  
 若要获取<xref:System.Reflection.Assembly>当前正在执行的程序集的对象, <xref:System.Reflection.Assembly.GetExecutingAssembly%2A>请使用方法。  
  
 <xref:System.Reflection.Assembly>类的许多成员提供有关程序集的信息。 例如:  
  
-   方法返回一个<xref:System.Reflection.AssemblyName>对象, 该对象提供对程序集显示名称的各个部分的访问。 <xref:System.Reflection.Assembly.GetName%2A>  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A>方法列出应用于程序集的特性。  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A>方法提供对程序集清单中的文件的访问。  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A>方法提供程序集清单中资源的名称。  
  
 <xref:System.Reflection.Assembly.GetTypes%2A>方法列出程序集中的所有类型。 <xref:System.Reflection.Assembly.GetExportedTypes%2A>方法列出对程序集外部的调用方可见的类型。 <xref:System.Reflection.Assembly.GetType%2A>方法可用于在程序集中搜索特定类型。 <xref:System.Reflection.Assembly.CreateInstance%2A>方法可用于在程序集中搜索和创建类型的实例。  
  
 有关程序集的详细信息, 请参阅[应用程序域](~/docs/framework/app-domains/application-domains.md)主题中的 "应用程序域和程序集" 一节。  
  
   
  
## Examples  
 下面的代码示例演示如何获取当前正在执行的程序集、创建该程序集中包含的类型的实例, 以及使用后期绑定调用类型的方法之一。 为此, 该代码示例定义了一个名为`Example`的类, 其中包含`SampleMethod`一个名为的方法。 类的构造函数接受一个整数, 该整数用于计算方法的返回值。  
  
 此代码示例还演示了如何使用<xref:System.Reflection.Assembly.GetName%2A>方法<xref:System.Reflection.AssemblyName>获取可用于分析程序集的全名的对象。 该示例显示程序集的版本号、 <xref:System.Reflection.Assembly.CodeBase%2A>属性<xref:System.Reflection.Assembly.EntryPoint%2A>和属性。  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">完全信任继承者。 此类不能由部分受信任的代码继承。</permission>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">应用程序域</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Reflection.Assembly" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数在<xref:System.Reflection.Assembly>对象的构造过程中由派生类调用。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取最初指定的程序集的位置，例如，在 <see cref="T:System.Reflection.AssemblyName" /> 对象中指定的位置。</summary>
        <value>程序集的位置（按照最初的指定）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取已加载清单包含文件的绝对路径, 请<xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType>改用属性。  
  
 如果程序集是以字节数组的形式加载的, 则使用采用<xref:System.Reflection.Assembly.Load%2A>字节数组的方法重载时, 此属性返回方法调用方的位置, 而不是已加载的程序集的位置。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Reflection.Assembly.CodeBase%2A>属性。  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此程序集中查找某个类型，然后使用系统激活器创建它的实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要查找类型的 <see cref="P:System.Type.FullName" />。</param>
        <summary>使用区分大小写的搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</summary>
        <returns>使用无参数构造函数创建的指定类型的实例；如果未找到 <paramref name="typeName" />，则为 <see langword="null" />。 该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <see cref="T:System.Reflection.BindingFlags" /> 设置为 <see langword="Public" /> 或 <see langword="Instance" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果运行时<xref:System.Reflection.Assembly>在实例中找`typeName`不到, 则返回`null` , 而不是引发异常。 出现这种情况的原因可能是:  
  
-   尚未指定类型的完全限定名称。  
  
-   已指定完全限定的类型名称, 但其大小写与类型的<xref:System.Type.FullName%2A?displayProperty=nameWithType>属性的大小写不匹配。 对于类型的完整名称不区分`typeName`大小写的比较, 请<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>调用`ignoreCase`重载, 并为参数`true`指定。  
  
-   当前<xref:System.Reflection.Assembly>实例中不存在该类型。  
  
   
  
## Examples  
 下面的示例定义了`Person`一个类, 并<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>调用了方法对其进行实例化。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。  
  
或 
当前程序集已加载到仅反射上下文中。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。  
  
- 或 - 
当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
或 
 <paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要查找类型的 <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</param>
        <summary>使用可选的区分大小写搜索，从此程序集中查找指定的类型，然后使用系统激活器创建它的实例。</summary>
        <returns>使用无参数构造函数创建的指定类型的实例；如果未找到 <paramref name="typeName" />，则为 <see langword="null" />。 该类型使用默认联编程序解析，而无需指定区域性或激活属性，并将 <see cref="T:System.Reflection.BindingFlags" /> 设置为 <see langword="Public" /> 或 <see langword="Instance" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果运行时<xref:System.Reflection.Assembly>在实例中找`typeName`不到, 则返回`null` , 而不是引发异常。 出现这种情况的原因可能是:  
  
-   尚未指定类型的完全限定名称。  
  
-   当前<xref:System.Reflection.Assembly>实例中不存在该类型。  
  
   
  
## Examples  
 下面的示例定义了`Person`一个类。 然后, 它调用<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>方法对其进行实例化, 但由于`typeName`参数的大小写与类型的<xref:System.Type.FullName%2A>属性的大小写不匹配, 因此`null`该方法返回。 当示例将同一字符串传递到<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>重载, 并指定该比较应区分大小写时`Person` , 将找到该类, 并且`Person`已成功实例化对象。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。  
  
- 或 - 
当前程序集已加载到仅反射上下文中。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。  
  
- 或 - 
当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
或 
 <paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="activationAttributes" Type="System.Object[]" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="typeName">要查找类型的 <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</param>
        <param name="bindingAttr">影响执行搜索的方式的位掩码。 此值是 <see cref="T:System.Reflection.BindingFlags" />中的位标志的组合。</param>
        <param name="binder">一个对象，它启用绑定、对参数类型的强制、对成员的调用，以及通过反射对 <see langword="MemberInfo" /> 对象的检索。 如果 <paramref name="binder" /> 为 <see langword="null" />，则使用默认联编程序。</param>
        <param name="args">包含要传递给构造函数的自变量的数组。 此参数数组在数量、顺序和类型方面必须与要调用的构造函数的参数匹配。 如果需要无参数构造函数，则 <paramref name="args" /> 必须是空数组或 <see langword="null" />。</param>
        <param name="culture">用于控制类型强制的 <see langword="CultureInfo" /> 的实例。 如果这是 <see langword="null" />，则使用当前线程的 <see langword="CultureInfo" /> 。 （例如，这对于将表示 1000 的 <see langword="String" /> 转换为 <see langword="Double" /> 值是必需的，因为不同的区域性以不同的方式表示 1000。）</param>
        <param name="activationAttributes">包含一个或多个可以参与激活的特性的数组。 通常，为包含单个 <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> 对象的数组，该对象指定激活远程对象所需的 URL。  此参数与客户端激活的对象相关。 客户端激活是一项传统技术，保留用于向后兼容，但不建议用于新的开发。 应改用 Windows Communication Foundation 来开发分布式应用程序。</param>
        <summary>使用可选的区分大小写搜索并具有指定的区域性、参数和绑定及激活特性，从此程序集中查找指定的类型，并使用系统激活器创建它的实例。</summary>
        <returns>如果未找到 <see langword="null" />，则为指定的类型实例或 <paramref name="typeName" />。 所提供的参数用于解析类型，以及绑定用于创建实例的构造函数。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> 为空字符串 ("") 或以空字符开头的字符串。  
  
或 
当前程序集已加载到仅反射上下文中。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.MissingMethodException">未找到匹配的构造函数。</exception>
        <exception cref="T:System.NotSupportedException">非空激活属性数组被传递给不是继承自 <see cref="T:System.MarshalByRefObject" /> 的类型。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="typeName" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="typeName" /> 所需的从属程序集已找到，但无法加载。  
  
或 
当前程序集被加载到仅反射上下文中，并且 <paramref name="typeName" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="typeName" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
或 
 <paramref name="typeName" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">创建委托的实例。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="typeName" Type="System.String" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyName">程序集的显示名称。</param>
        <param name="typeName">类型的全名。</param>
        <summary>创建由类型的程序集的显示名称限定的类型的名称。</summary>
        <returns>由程序集的显示名称限定的类型的完整名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的字符串的格式为:  
  
 \<FullTypeName >, \<AssemblyDisplayName >  
  
 有关<xref:System.Reflection.AssemblyName>程序集显示名称的格式的说明, 请参阅。  
  
 若要在公共语言运行时的版本中适应更改, 请使用此方法, 而不是自己构造限定名称。  有关限定的程序集名称的信息<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>, 请参阅。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含此程序集自定义属性的集合。</summary>
        <value>包含此程序集自定义属性的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取定义在此程序集中的类型的集合。</summary>
        <value>定义在此程序集中的类型的集合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.TypeInfo> <xref:System.Type>属性相当<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>于方法,<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>只不过属性返回对象的集合, 并且方法返回对象的数组。 <xref:System.Reflection.Assembly.DefinedTypes%2A> <xref:System.Reflection.Assembly.DefinedTypes%2A>  
  
 返回的数组包括嵌套类型。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此程序集的入口点。</summary>
        <value>表示此程序集入口点的对象。 如果没有找到入口点（例如，此程序集是一个 DLL），则返回 <see langword="null" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o">与该实例进行比较的对象。</param>
        <summary>确定此程序集和指定的对象是否相等。</summary>
        <returns>如果 <see langword="true" /> 与此实例相等，则为 <paramref name="o" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法执行引用相等性测试, 以确定当前的实例和`o`是否相等。 <xref:System.Reflection.Assembly.Equals%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 URI，包括表示基本代码的转义符。</summary>
        <value>带有转义符的 URI。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此程序集的证据。</summary>
        <value>此程序集的证据。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</summary>
        <value>此程序集中定义的公共类型的集合，这些公共类型在程序集外可见。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取程序集的显示名称。</summary>
        <value>程序集的显示名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关<xref:System.Reflection.AssemblyName>程序集显示名称的格式的说明, 请参阅。  
  
> [!NOTE]
>  建议不要编写自己的代码来分析显示名称。 而是将显示名称传递到<xref:System.Reflection.AssemblyName.%23ctor%2A>构造函数, 该构造函数对其进行分析, 并填充新<xref:System.Reflection.AssemblyName>的相应字段。  
  
 在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。 不过, 由于兼容性原因, 它不包含在由<xref:System.Reflection.Assembly.FullName%2A>属性返回的字符串中。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例检索当前正在执行的程序集的显示名称, <xref:System.Int32>以及包含该类型的程序集的显示名称 (`int` C# `Integer`在中为 Visual Basic)。  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">指定完全限定的类型名称</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">一个对象，该对象表示将返回的程序集中的类型。</param>
        <summary>获取在其中定义指定类型的当前加载的程序集。</summary>
        <returns>在其中定义指定类型的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用此方法等效于检索<xref:System.Type.Assembly?displayProperty=nameWithType>属性的值。 但是, <xref:System.Type.Assembly?displayProperty=nameWithType>属性通常提供优异的性能。  
  
 若要调用此方法, 必须具有一个<xref:System.Type>对象, 这意味着必须已加载定义该类的程序集。  
  
   
  
## Examples  
 下面的示例将检索包含该<xref:System.Int32>类型的程序集, 并显示其名称和文件位置。  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回方法（该方法调用当前正在执行的方法）的 <see cref="T:System.Reflection.Assembly" />。</summary>
        <returns>方法（该方法调用当前正在执行的方法）的 <see langword="Assembly" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果调用<xref:System.Reflection.Assembly.GetCallingAssembly%2A>方法的方法是由实时 (JIT) 编译器以内联方式展开的, 或者如果其调用方展开内联, 则<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返回的程序集可能会意外变化。 例如, 请考虑以下方法和程序集:  
  
-   程序`M1`集`A1` 调用<xref:System.Reflection.Assembly.GetCallingAssembly%2A>中的方法。  
  
-   程序`M2`集`A2` 调用`M1`中的方法。  
  
-   程序`M3`集`A3` 调用`M2`中的方法。  
  
 如果`M1`未内联, <xref:System.Reflection.Assembly.GetCallingAssembly%2A>则返回`A2`。 内联后, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> `M1`将返回`A3`。 同样, 如果`M2`未内联, <xref:System.Reflection.Assembly.GetCallingAssembly%2A>则返回`A2`。 内联后, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> `M2`将返回`A3`。  
  
 `M1`当作为的尾`M2`调用执行时, 或作为的尾调用`M3`执行`M2`时, 也会发生此效果。 可以通过将<xref:System.Reflection.Assembly.GetCallingAssembly%2A> <xref:System.Runtime.CompilerServices.MethodImplAttribute>特性应用于标志来阻止 JIT 编译器内联调用的方法, 但没有用于阻止尾调用的类似机制。 <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType>  
  
   
  
## Examples  
 下面的示例获取当前方法的调用程序集。  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取此程序集的自定义属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inherit">对于 <see cref="T:System.Reflection.Assembly" /> 类型的对象，将忽略此参数。</param>
        <summary>获取此程序集的所有自定义属性。</summary>
        <returns>包含此程序集自定义属性的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现相应<xref:System.Reflection.ICustomAttributeProvider>的接口方法。 因此, 必须`inherit`指定参数, 即使该参数被忽略。  
  
 伪属性指示在属性存在时必须设置的核心元数据的位数。 与扩展类型的元数据的自定义特性不同, 与类型一起保存时, 伪特性会修改类型的元数据, 然后被丢弃。 某些生成的位无法使用现有的反射 Api 进行访问。  
  
 下表总结了反射中可用的位的不同伪属性和访问器。  
  
|伪特性|元数据位|反射访问器|  
|-----------------------|-------------------|-------------------------|  
|Sub|CorPInvokeMap<br /><br /> DLL 名称|对于普通方法/全局方法特性, 没有适用于 PInvokeMap 的访问器。<br /><br /> 没有 DLL 名称的访问器。|  
|GuidAttribute|存储为实际的自定义属性。|作为真实的自定义属性进行访问。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo. GetMethodImplementationFlags ()|  
|MarshalAsAttribute|各种位。|无访问器。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|GetMethodImplementationFlags ()。OLE<br /><br /> ConstructorInfo. GetMethodImplementationFlags ()。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 类打包。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 无访问器。|  
|FieldOffsetAttribute|字段偏移量。|无访问器。|  
|AssemblyLoadAttribute|CorAssemblyFlags|无取值函数或枚举器。|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">要为其返回自定义属性的类型。</param>
        <param name="inherit">对于 <see cref="T:System.Reflection.Assembly" /> 类型的对象，将忽略此参数。</param>
        <summary>获取按类型指定的此程序集的自定义属性。</summary>
        <returns>一个数组，它包含由 <paramref name="attributeType" /> 指定的此程序集的自定义属性。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法实现相应<xref:System.Reflection.ICustomAttributeProvider>的接口方法。 因此, 必须`inherit`指定参数, 即使该参数被忽略。  
  
 伪属性指示在属性存在时必须设置的核心元数据的位数。 与扩展类型的元数据的自定义特性不同, 与类型一起保存时, 伪特性会修改类型的元数据, 然后被丢弃。 某些生成的位无法使用现有的反射 Api 进行访问。  
  
 下表总结了反射中可用的位的不同伪属性和访问器。  
  
|伪特性|元数据位|反射访问器|  
|-----------------------|-------------------|-------------------------|  
|Sub|CorPInvokeMap<br /><br /> DLL 名称|对于普通方法/全局方法特性, 没有适用于 PInvokeMap 的访问器。<br /><br /> 没有 DLL 名称的访问器。|  
|GuidAttribute|存储为实际的自定义属性。|作为真实的自定义属性进行访问。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo. GetMethodImplementationFlags ()|  
|MarshalAsAttribute|各种位。|无访问器。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|GetMethodImplementationFlags ()。OLE<br /><br /> ConstructorInfo. GetMethodImplementationFlags ()。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> 类打包。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> 无访问器。|  
|FieldOffsetAttribute|字段偏移量。|无访问器。|  
|AssemblyLoadAttribute|CorAssemblyFlags|无取值函数或枚举器。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> 不是运行时类型。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回有关已应用于当前 <see cref="T:System.Reflection.Assembly" />（表示为 <see cref="T:System.Reflection.CustomAttributeData" /> 对象）的特性的信息。</summary>
        <returns><see cref="T:System.Reflection.CustomAttributeData" /> 对象的泛型列表，这些对象表示有关已应用于当前程序集的特性的数据。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果自定义属性本身是在加载到仅反射上下文中的代码中定义的, 则使用此方法在仅反射上下文中检查代码的自定义属性。 在这<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>种<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>情况下, 不能使用像和这样的方法, 因为它们会创建特性的实例。 仅反射上下文中的代码无法执行。 有关详细信息和示例代码, 请参阅<xref:System.Reflection.CustomAttributeData>类。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取默认应用程序域中的进程可执行文件。 在其他的应用程序域中，这是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 执行的第一个可执行文件。</summary>
        <returns>程序集是默认应用程序域中的进程可执行文件，或是由 <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> 执行的第一个可执行文件。 当从非托管代码调用时可返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Reflection.Assembly.GetEntryAssembly%2A>托管程序集`null`已从非托管应用程序加载时, 该方法可以返回。 例如, 如果非托管应用程序创建用编写的 COM 组件的实例C#, 则从<xref:System.Reflection.Assembly.GetEntryAssembly%2A> C#组件对方法的调用将返回 null, 因为进程的入口点是非托管代码而不是托管代码件.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取包含当前执行的代码的程序集。</summary>
        <returns>包含当前执行的代码的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 出于性能方面的原因, 只有在设计时不知道当前正在执行的程序集时, 才应调用此方法。 检索<xref:System.Reflection.Assembly>表示当前程序集的对象的建议方法是<xref:System.Type.Assembly%2A?displayProperty=nameWithType>使用在程序集中找到的类型的属性, 如下面的示例所示。  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 若要获取包含调用当前正在执行的代码的方法的程序集, <xref:System.Reflection.Assembly.GetCallingAssembly%2A>请使用。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Type.Assembly%2A?displayProperty=nameWithType>属性, 基于该程序集中包含的类型获取当前正在执行的程序集。 它还会调用<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>方法, 以显示该方法<xref:System.Reflection.Assembly>返回一个表示同一程序集的对象。  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集中定义的公共类型，这些公共类型在程序集外可见。</summary>
        <returns>一个数组，表示此程序集中定义并在程序集外可见的类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅在程序集外可见的类型为公共类型和嵌套在其他公共类型中的公共类型。  
  
   
  
## Examples  
 下面的代码示例定义了多个具有不同访问级别的类, 并<xref:System.Reflection.Assembly.GetExportedTypes%2A>调用显示从程序集外部可见的类。  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">程序集是动态程序集。</exception>
        <exception cref="T:System.IO.FileNotFoundException">无法加载从属程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">指定文件的名称。 不包括文件的路径。</param>
        <summary>获取此程序集清单的文件表中指定文件的 <see cref="T:System.IO.FileStream" />。</summary>
        <returns>包含指定文件的流，如果找不到文件则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于公用和专用资源文件。  
  
 不`name`应包含文件的路径。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> 不是有效的程序集。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径和读取指定的文件。 关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> : 和<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取程序集清单文件表中的文件。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取程序集清单文件表中的文件。</summary>
        <returns>包含这些文件的流数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于公用和专用资源文件。  
  
 此重载等效于调用<xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29>重载和指定。 `false`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件。</exception>
        <exception cref="T:System.BadImageFormatException">文件不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
        <summary>获取程序集清单的文件表中的文件，指定是否包括资源模块。</summary>
        <returns>包含这些文件的流数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于公用和专用资源文件。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到文件。</exception>
        <exception cref="T:System.BadImageFormatException">文件不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此实例的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取作为此程序集的一部分的所有加载模块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取作为此程序集的一部分的所有加载模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
        <summary>获取属于此程序集的所有已加载模块，同时指定是否包括资源模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">区分大小写的资源名称。</param>
        <summary>返回关于给定资源如何保持的信息。</summary>
        <returns>用关于资源拓扑的信息填充的对象；如果未找到资源，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 仅当资源对调用方可见或调用方具有<xref:System.Security.Permissions.ReflectionPermission>时, 才返回资源信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceName" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="resourceName" /> 参数为空字符串 ("")。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回此程序集中的所有资源的名称。</summary>
        <returns>包含所有资源名称的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您可以使用此方法返回的数组中的每个资源名称, 如下所示:  
  
-   可以将资源名称传递给<xref:System.Reflection.Assembly.GetManifestResourceInfo%2A>方法, 以获取有关资源的其他信息。  
  
-   如果该名称标识一个二进制 .resources 文件, 则可以删除其 .resources 文件扩展名, 并将其传递给<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType>构造函数以实例化资源管理器。  
  
-   可以将资源名称传递给<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法, 以<xref:System.IO.Stream>检索<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>可传递给构造函数的对象。  
  
-   可以将资源名称传递给<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>方法, 以<xref:System.IO.Stream>检索<xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>可传递给构造函数的对象。  
  
 仅当资源对调用方可见或调用方具有<xref:System.Security.Permissions.ReflectionPermission>时, 才返回资源信息。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从此程序集加载指定的清单资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">所请求的清单资源的名称（区分大小写）。</param>
        <summary>从此程序集加载指定的清单资源。</summary>
        <returns>如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 清单资源是在编译时嵌入到程序集中的资源 (如图像文件)。 有关清单资源的详细信息, 请参阅 MSDN Library 中的[Microsoft .NET Framework 资源基础知识](https://go.microsoft.com/fwlink/?LinkId=204554)。  
  
 仅当资源对调用方可见或调用方具有<xref:System.Security.Permissions.ReflectionPermission>时, 才返回资源信息。  
  
> [!NOTE]
>  如果访问另`null`一个程序集中的私有资源并且调用方不具有<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志, 则此方法返回。  
  
 如果程序集清单列出一个资源文件, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A>则即使<xref:System.IO.Stream>此时无法在磁盘上找到资源文件, 也会返回一个对象。 如果找不到资源文件, 则将生成<xref:System.IO.Stream>的对象传递<xref:System.Resources.ResourceReader>给构造函数会<xref:System.ArgumentException>导致。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> 不是有效的程序集。</exception>
        <exception cref="T:System.NotImplementedException">资源的长度大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">程序集清单</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="name" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">其命名空间用于确定清单资源名的范围的类型。</param>
        <param name="name">所请求的清单资源的名称（区分大小写）。</param>
        <summary>从此程序集加载指定清单资源，清单资源的范围由指定类型的命名空间确定。</summary>
        <returns>如果在编译期间没有指定任何资源，或者资源对调用方不可见，则为清单资源或者为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如, 如果为指定的`type`全名为 "MyNameSpace. MyClasses" 且`name`为 "Net", 则此方法重载将搜索名为 "MyNameSpace.Net" 的资源。  
  
 清单资源是在编译时嵌入到程序集中的资源 (如图像文件)。 有关清单资源的详细信息, 请参阅 MSDN Library 中的[Microsoft .NET Framework 资源基础知识](https://go.microsoft.com/fwlink/?LinkId=204554)。  
  
 仅当资源对调用方可见或调用方具有<xref:System.Security.Permissions.ReflectionPermission>时, 才返回资源信息。  
  
> [!NOTE]
>  如果访问另`null`一个程序集中的私有资源并且调用方不具有<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>标志, 则此方法返回。  
  
 如果程序集清单列出一个资源文件, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A>则即使<xref:System.IO.Stream>此时无法在磁盘上找到资源文件, 也会返回一个对象。 如果找不到资源文件, 则将生成<xref:System.IO.Stream>的对象传递<xref:System.Resources.ResourceReader>给构造函数会<xref:System.ArgumentException>导致。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> 不是有效的程序集。</exception>
        <exception cref="T:System.NotImplementedException">资源的长度大于 <see cref="F:System.Int64.MaxValue" />。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。 关联的枚举:<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">程序集清单</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">请求的模块的名称。</param>
        <summary>获取此程序集中的指定模块。</summary>
        <returns>所请求的模块，若未找到该模块则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于文件名。  
  
 命名空间中`Reflection.Emit`的类发出动态模块的范围名称。 范围名称可以由<xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType>属性确定。 传递所需`Assembly.GetModule`的模块类型。 例如, 如果你想要包含程序集清单的模块, 请将模块的范围名称传递给`GetModule`。 否则, 传递模块的文件名。 由一个`Load`具有 byte [] 参数的方法加载的程序集只有一个模块, 这是清单模块。 始终使用作用域名称查找这些模块。  
  
 可以使用<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>从特定模块中检索类型。 对`Module.GetType`包含清单的模块调用将不会启动整个程序集的搜索。 若要从程序集中检索某一类型, 而不考虑它所在的模块, 则<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>必须调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="name" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> 不是有效的程序集。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取作为此程序集的一部分的所有模块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取作为此程序集的一部分的所有模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于公用和专用资源文件。  
  
> [!NOTE]
>  必须用文件扩展名发出模块。  
  
   
  
## Examples  
 下面的示例显示返回的数组中包含程序集清单的模块的名称。  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">要加载的模块未指定文件扩展名。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><see langword="true" /> 则包括资源模块；否则，为 <see langword="false" />。</param>
        <summary>获取属于此程序集的所有模块，同时指定是否包括资源模块。</summary>
        <returns>模块的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法适用于公用和专用资源文件。  
  
> [!NOTE]
>  必须用文件扩展名发出模块。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />。</summary>
        <returns>包含此程序集的完全分析的显示名称的对象。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问程序集的路径。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="copiedName">如果为 <see langword="true" />，则将 <see cref="P:System.Reflection.Assembly.CodeBase" /> 设置为程序集被影像复制后的位置；如果为 <see langword="false" />，则将 <see cref="P:System.Reflection.Assembly.CodeBase" /> 设置为原位置。</param>
        <summary>获取此程序集的 <see cref="T:System.Reflection.AssemblyName" />，并按 <paramref name="copiedName" /> 指定的那样设置基本代码。</summary>
        <returns>包含此程序集的完全分析的显示名称的对象。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问程序集的路径。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="info">用序列化信息填充的对象。</param>
        <param name="context">序列化的目标上下文。</param>
        <summary>获取序列化信息，其中包含重新实例化此程序集所需的所有数据。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="info" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集引用的所有程序集的 <see cref="T:System.Reflection.AssemblyName" /> 对象。</summary>
        <returns>包含此程序集引用的所有程序集的完全分析的显示名称的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  从开始<xref:System.Reflection.AssemblyName> <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> , 此方法返回的对象的属性为, 如果引用的程序集没有哈希算法, 或者所引用程序集的哈希算法不是[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]由<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>枚举标识。 在以前版本的 .NET Framework 中, 此<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>情况下<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType>返回了属性。  
  
   
  
## Examples  
 下面的代码示例演示如何调用<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A>方法。 此代码示例是为<xref:System.Reflection.Assembly>类提供的更大示例的一部分。  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取附属程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">指定的区域性。</param>
        <summary>获取指定区域性的附属程序集。</summary>
        <returns>指定的附属程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附属程序集包含本地化资源, 这与主应用程序程序集不同, 后者包含为作为默认或非特定区域性的单个区域性提供的非本地化可执行代码和资源。  
  
 调用此方法以使用您的当前程序集版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到该程序集。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了具有匹配文件名的附属程序集，但 <see langword="CultureInfo" /> 与所指定的不匹配。</exception>
        <exception cref="T:System.BadImageFormatException">附属程序集不是有效的程序集。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="version" Type="System.Version" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">指定的区域性。</param>
        <param name="version">附属程序集的版本。</param>
        <summary>获取指定区域性的附属程序集的指定版本。</summary>
        <returns>指定的附属程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 附属程序集包含本地化资源, 这与主应用程序程序集不同, 后者包含为作为默认或非特定区域性的单个区域性提供的非本地化可执行代码和资源。  
  
 <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29>调用重载以使用当前程序集版本。  
  
 如果`version` 为`null`, 则在对资源和主程序集进行签名时使用当前程序集版本。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">找到了具有匹配的文件名的附属程序集，但 <see langword="CultureInfo" /> 或版本与所指定的不匹配。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到该程序集。</exception>
        <exception cref="T:System.BadImageFormatException">附属程序集不是有效的程序集。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取表示指定类型的 <see cref="T:System.Type" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">类型的全名。</param>
        <summary>获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象。</summary>
        <returns>表示指定类的对象，若未找到该类则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只搜索当前程序集实例。 `name`参数包括命名空间, 但不包括程序集。 若要搜索类型的其他程序集, 请<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>使用方法重载, 该重载可以选择包含程序集显示名称作为类型名称的一部分。  
  
> [!NOTE]
>  如果已将该类型转发给另一个程序集, 则此方法仍将返回该程序集。 有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
   
  
## Examples  
 下面的示例`Transportation`在命名空间`MeansOfTransportation`中定义一个抽象类。 它调用<xref:System.Reflection.Assembly.GetType%28System.String%29>方法来检索其<xref:System.Type>对象, 调用<xref:System.Type.GetProperties%2A?displayProperty=nameWithType>方法以获取<xref:System.Reflection.PropertyInfo>对象的数组, 这些对象表示该类型的属性, 然后显示有关该类型的抽象属性的信息。 请注意, 对<xref:System.Reflection.Assembly.GetType%28System.String%29>方法的调用使用类型的完全限定名称 (即其命名空间及其类型名称)。  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 无效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>
          <paramref name="name" /> 所需的从属程序集已找到，但无法加载。  
  
- 或 - 
当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
或 
 <paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">类型的全名。</param>
        <param name="throwOnError"><see langword="true" /> 表示在找不到该类型时引发异常；<see langword="false" /> 则表示返回 <see langword="null" />。</param>
        <summary>获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象，并选择在找不到该类型时引发异常。</summary>
        <returns>表示指定类的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只搜索当前程序集实例。 `name`参数包括命名空间, 但不包括程序集。 若要搜索类型的其他程序集, 请<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>使用方法重载, 该重载可以选择包含程序集显示名称作为类型名称的一部分。  
  
> [!NOTE]
>  如果已将该类型转发给另一个程序集, 则此方法仍将返回该程序集。 有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 `throwOnError`参数只影响找不到该类型时所发生的情况。 它不会影响可能引发的任何其他异常。 特别是, 如果找到该类型但无法加载, 则<xref:System.TypeLoadException> `throwOnError`即使为`false`, 也可能引发该类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 无效。  
  
或 
<paramref name="name" /> 的长度超过 1024 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 为 <see langword="true" />，且找不到此类型。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="name" /> 所需的从属程序集已找到，但无法加载。  
  
- 或 - 
当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
或 
 <paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">类型的全名。</param>
        <param name="throwOnError"><see langword="true" /> 表示在找不到该类型时引发异常；<see langword="false" /> 则表示返回 <see langword="null" />。</param>
        <param name="ignoreCase">如果为 <see langword="true" />，则忽略类型名的大小写；否则，为 <see langword="false" />。</param>
        <summary>获取程序集实例中具有指定名称的 <see cref="T:System.Type" /> 对象，带有忽略大小写和在找不到该类型时引发异常的选项。</summary>
        <returns>表示指定类的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法只搜索当前程序集实例。 `name`参数包括命名空间, 但不包括程序集。 若要搜索类型的其他程序集, 请<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>使用方法重载, 该重载可以选择包含程序集显示名称作为类型名称的一部分。  
  
> [!NOTE]
>  如果已将该类型转发给另一个程序集, 则此方法仍将返回该程序集。 有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 `throwOnError`参数只影响找不到该类型时所发生的情况。 它不会影响可能引发的任何其他异常。 特别是, 如果找到该类型但无法加载, 则<xref:System.TypeLoadException> `throwOnError`即使为`false`, 也可能引发该类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 无效。  
  
- 或 - 
<paramref name="name" /> 的长度超过 1024 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> 为 <see langword="true" />，且找不到此类型。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="name" /> 所需的从属程序集无法找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="name" /> 所需的从属程序集已找到，但无法加载。  
  
或 
当前程序集被加载到仅反射上下文中，并且 <paramref name="name" /> 所需的从属程序集未预先加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="name" /> 需要一个从属程序集，但该文件不是有效的程序集。  
  
或 
 <paramref name="name" /> 需要一个从属程序集，该程序集已针对比当前加载的版本更高的运行时版本进行了编译。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>获取此程序集中定义的类型。</summary>
        <returns>一个数组，包含此程序集中定义的所有类型。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返回的数组包括嵌套类型。  
  
 如果对程序集调用<xref:System.Reflection.ReflectionTypeLoadException> 方法,并且该程序集中的类型依赖于尚未加载的程序集中的类型(例如,如果它是从第二个程序集中的类型派生的),则会引发。<xref:System.Reflection.Assembly.GetTypes%2A> 例如, 如果第一个程序集是用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>或<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法加载的, 并且第二个程序集未加载, 则可能会发生这种情况。 如果在调用<xref:System.Reflection.Assembly.Load%2A> <xref:System.Reflection.Assembly.GetTypes%2A>方法时找不到第二<xref:System.Reflection.Assembly.LoadFile%2A>个程序集, 则使用和方法加载的程序集也会发生这种情况。  
  
> [!NOTE]
>  如果类型已转发给另一个程序集, 则它不会包含在返回的数组中。 有关类型转发的信息, 请参阅[公共语言运行时中的类型转发](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)。  
  
 若要检索<xref:System.Reflection.TypeInfo>对象的集合而不是<xref:System.Type>对象的数组, 请使用<xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType>属性。  
  
   
  
## Examples  
 下面的示例显示指定程序集中某一类型的方法的参数。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">该程序集包含一个或多个无法加载的类型。 此异常的 <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> 属性返回的数组针对已加载的每个类型包含一个 <see cref="T:System.Type" /> 对象，针对无法加载的每个类型包含一个 <see langword="null" />，而 <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> 属性针对无法加载的每个类型包含一个异常。</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示程序集是否是从全局程序集缓存加载的。</summary>
        <value>如果程序集是从全局程序集缓存加载的，则为<see langword="true" /> ；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于加载程序集的主机上下文。</summary>
        <value>一个 <see cref="T:System.Int64" /> 值，指示用于加载程序集的主机上下文（如果有）。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取表示公共语言运行时 (CLR) 的版本的字符串，该信息保存在包含清单的文件中。</summary>
        <value>CLR 版本的文件夹名。 这不是完整路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例如, .NET Framework 版本1.1 的值为1.1.4322。 该版本的二进制文件将位于%windir%\Microsoft.NET\Framework\v1.1.4322. 路径中。  
  
 默认情况下<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> , 设置为用于生成程序集的 CLR 版本。 但在编译时, 它可能已设置为另一个值。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此程序集是否保留在可回收的 <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> 中。</summary>
        <value><see langword="true" />如果此程序集保存在可回收<see cref="T:System.Runtime.Loader.AssemblyLoadContext" />的中, <see langword="false" />则为; 否则为。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 有关详细信息, 请参阅[如何在 .Net Core 中使用和调试程序集 unloadability](~/docs/standard/assembly/unloadability-howto.md)。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="attributeType">要为此程序集检查的属性类型。</param>
        <param name="inherit">对于该类型的对象，将忽略此参数。</param>
        <summary>指示指定的属性是否已应用于该程序集。</summary>
        <returns>如果已将该属性应用于程序集，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例将<xref:System.Reflection.AssemblyTitleAttribute>特性应用于程序集, 然后使用<xref:System.Reflection.Assembly.IsDefined%2A>指示是否应用了该特性。 它还测试了未应用的属性。  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="attributeType" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="attributeType" /> 使用的类型无效。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前程序集是否是通过使用反射发出在当前进程中动态生成的。</summary>
        <value>如果当前程序集是在当前进程中动态生成的，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 动态程序集由派生类<xref:System.Reflection.Emit.AssemblyBuilder>表示。  
  
 将动态程序集保存到磁盘时, 保存的程序集不是动态的。 如果将保存的程序集加载到另一个应用程序域或<xref:System.Reflection.Assembly.IsDynamic%2A>进程中`false`, 则属性将返回。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前程序集是否是以完全信任方式加载的。</summary>
        <value>如果当前程序集是以完全信任方式加载的，则为 <see langword="true" />，否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法加载的程序集的信任级别与调用程序集的信任级别相同。 若要从具有应用程序域的信任级别的字节数组加载程序集, 请使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法重载。 若要详细了解如何将证据用于采用字节数组的<xref:System.Reflection.Assembly.Load%2A>方法重载, <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>请参阅方法重载。  
  
 对C++可执行文件进行<xref:System.BadImageFormatException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位`.reloc`地址或部分所造成的。 若要保留`.reloc` C++可执行文件的地址, 请`/fixed:no`指定链接的时间。  
  
 请注意, 此方法重载始终使用自己<xref:System.Reflection.Assembly>的映射创建一个新的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要加载的程序集的对象。</param>
        <summary>在给定程序集的 <see cref="T:System.Reflection.AssemblyName" /> 的情况下，加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>如果`assemblyRef`指定完整的程序集名称并且与该简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记, 则会引发。 加载程序不会继续探测与简单名称匹配的其他程序集。 从 .NET Framework 4 开始, 因为在默认情况下禁用了远程程序集中的代码执行<xref:System.IO.FileLoadException> , 如果`assemblyRef`指定远程程序集, 也会引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。     
  
> [!NOTE]
>  不要使用<xref:System.Reflection.AssemblyName> <xref:System.Reflection.AssemblyName.CodeBase%2A>只带有属性集的。 属性不提供程序集标识的任何元素 (如名称或版本), 因此, 不会按照按标识规则加载规则进行加载, 这与<xref:System.Reflection.Assembly.Load%2A>方法一样。 <xref:System.Reflection.AssemblyName.CodeBase%2A> 而是使用加载 "规则" 加载程序集。 有关使用加载源上下文的缺点的信息, 请参阅<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> [程序集加载](~/docs/framework/deployment/best-practices-for-assembly-loading.md)的方法重载或最佳做法。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
-   使用<xref:System.Reflection.Assembly.Load%2A> 不<xref:System.Security.Policy.Evidence>带参数的方法时, 将使用加载程序提供的证据加载程序集。  
  
-   <xref:System.Reflection.Assembly.Load%2A> 使用<xref:System.Security.Policy.Evidence>带参数的方法时, 会合并证据部分。 作为参数提供给<xref:System.Reflection.Assembly.Load%2A>方法的证据将取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载通用对象文件格式 (COFF) 图像时, 将从调用程序集继承证据。 这适用于 .NET Framework 版本 1.1 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中, 当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载 COFF 图像时, 会结合证据。 `Zone`和从调用程序集继承`Hash`而来,并且从COFF程序集获取。`StrongName` `Url` `Site`  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法并<xref:System.Security.Policy.Evidence>加载 COFF 图像时, 仅使用提供的证据。 将忽略调用程序集和 COFF 图像的证据。  
  
 对C++可执行文件进行<xref:System.BadImageFormatException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位`.reloc`地址或部分所造成的。 若要保留`.reloc` C++可执行文件的地址, 请`/fixed:no`指定链接的时间。  
  
> [!NOTE]
>  如果同时设置<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>了属性<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>和属性, 则第一次尝试加载程序集时将使用显示名称 (包括版本、区域性等<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> , 由属性返回)。 如果找不到该文件, <xref:System.Reflection.AssemblyName.CodeBase%2A>则将使用来搜索该程序集。 如果使用<xref:System.Reflection.AssemblyName.CodeBase%2A>找到程序集, 则会将显示名称与程序集匹配。 如果匹配失败, <xref:System.IO.FileLoadException>则会引发。  
  
   
  
## Examples  
 下面的示例实例化<xref:System.Reflection.AssemblyName>一个对象并使用它来`sysglobal.dll`加载程序集。 然后, 该示例显示程序集的公共类型的全名。  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.IO.IOException" />。  
  
</para>
          </block>  
  
 无法加载已找到的文件。

- 或 -

<paramref name="assemblyRef" /> 指定远程程序集，但在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> 不是有效的程序集。 或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。 关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以 "file://" 开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">运行时如何定位程序集</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集名称的长格式。</param>
        <summary>通过给定程序集的长格式名称加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 程序集名称的长格式包含其简单名称 (如 System .dll 程序集的 "System") 及其版本、区域性、公钥标记, 还可以是其处理器体系结构。 它对应于程序集的<xref:System.Reflection.Assembly.FullName%2A>属性。 下面的示例演示如何使用长名称加载 .NET Framework 4 的系统 .dll 程序集。  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException>如果`assemblyString`指定完整的程序集名称, 并且与该简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记, 则会引发。 加载程序不会继续探测与简单名称匹配的其他程序集。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
-   使用<xref:System.Reflection.Assembly.Load%2A> 不<xref:System.Security.Policy.Evidence>带参数的方法时, 将使用加载程序提供的证据加载程序集。  
  
-   <xref:System.Reflection.Assembly.Load%2A> 使用<xref:System.Security.Policy.Evidence>带参数的方法时, 会合并证据部分。 作为参数提供给<xref:System.Reflection.Assembly.Load%2A>方法的证据将取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载通用对象文件格式 (COFF) 图像时, 将从调用程序集继承证据。 这适用于 .NET Framework 版本 1.1 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中, 当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载 COFF 图像时, 会结合证据。 `Zone`和从调用程序集继承`Hash`而来,并且从COFF程序集获取。`StrongName` `Url` `Site`  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法并<xref:System.Security.Policy.Evidence>加载 COFF 图像时, 仅使用提供的证据。 将忽略调用程序集和 COFF 图像的证据。  
  
 对C++可执行文件进行<xref:System.BadImageFormatException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位`.reloc`地址或部分所造成的。 若要保留`.reloc` C++可执行文件的地址, 请`/fixed:no`指定链接的时间。  
  
 在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。 例如, "ProcessorArchitecture = msil"。 但是, 指定程序集名称的建议方法是创建一个<xref:System.Reflection.AssemblyName>对象并将其传递给该<xref:System.Reflection.Assembly.Load%2A>方法的适当重载。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
   
  
## Examples  
 下面的示例在给定程序集的完全限定名称的情况下加载程序集, 并列出指定程序集中包含的所有类型。 若要运行此代码示例, 必须提供完全限定的程序集名称。 有关如何获取完全限定的程序集名称的信息, 请参阅[程序集名称](~/docs/framework/app-domains/assembly-names.md)。  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyString" /> 是一个长度为零的字符串。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">运行时如何定位程序集</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <param name="rawSymbolStore">包含表示程序集符号的原始字节的字节数组。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可以选择包括程序集的符号。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法加载的程序集的信任级别与调用程序集的信任级别相同。 若要从具有应用程序域的信任级别的字节数组加载程序集, 请使用<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>方法重载。 若要详细了解如何将证据用于采用字节数组的<xref:System.Reflection.Assembly.Load%2A>方法重载, <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>请参阅方法重载。  
  
 对C++可执行文件进行<xref:System.BadImageFormatException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位`.reloc`地址或部分所造成的。 若要保留`.reloc` C++可执行文件的地址, 请`/fixed:no`指定链接的时间。  
  
 请注意, 此方法重载始终使用自己<xref:System.Reflection.Assembly>的映射创建一个新的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">描述要加载的程序集的对象。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>在给定程序集的 <see cref="T:System.Reflection.AssemblyName" /> 的情况下，加载程序集。 使用提供的证据将该程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>如果`assemblyRef`指定完整的程序集名称, 并且与该简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记, 则会引发。 加载程序不会继续探测与简单名称匹配的其他程序集。  从 .NET Framework 4 开始, 因为在默认情况下禁用了远程程序集中的代码执行<xref:System.IO.FileLoadException> , 如果`assemblyRef`指定远程程序集, 也会引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。   
  
> [!NOTE]
>  不要使用<xref:System.Reflection.AssemblyName> <xref:System.Reflection.AssemblyName.CodeBase%2A>只带有属性集的。 属性不提供程序集标识的任何元素 (如名称或版本), 因此, 不会按照按标识规则加载规则进行加载, 这与<xref:System.Reflection.Assembly.Load%2A>方法一样。 <xref:System.Reflection.AssemblyName.CodeBase%2A> 而是使用加载 "规则" 加载程序集。 有关使用加载源上下文的缺点的信息, 请参阅<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> [程序集加载](~/docs/framework/deployment/best-practices-for-assembly-loading.md)的方法重载或最佳做法。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
-   使用<xref:System.Reflection.Assembly.Load%2A> 不<xref:System.Security.Policy.Evidence>带参数的方法时, 将使用加载程序提供的证据加载程序集。  
  
-   <xref:System.Reflection.Assembly.Load%2A> 使用<xref:System.Security.Policy.Evidence>带参数的方法时, 会合并证据部分。 作为参数提供给<xref:System.Reflection.Assembly.Load%2A>方法的证据将取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载通用对象文件格式 (COFF) 图像时, 将从调用程序集继承证据。 这适用于 .NET Framework 版本 1.1 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中, 当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载 COFF 图像时, 会结合证据。 `Zone`和从调用程序集继承`Hash`而来,并且从COFF程序集获取。`StrongName` `Url` `Site`  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法并<xref:System.Security.Policy.Evidence>加载 COFF 图像时, 仅使用提供的证据。 将忽略调用程序集和 COFF 图像的证据。  
  
 对C++可执行文件进行<xref:System.BadImageFormatException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位`.reloc`地址或部分所造成的。 若要保留`.reloc` C++可执行文件的地址, 请`/fixed:no`指定链接的时间。  
  
> [!NOTE]
>  如果同时设置<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>了属性<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>和属性, 则第一次尝试加载程序集时将使用显示名称 (包括版本、区域性等<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> , 由属性返回)。 如果找不到该文件, <xref:System.Reflection.AssemblyName.CodeBase%2A>则将使用来搜索该程序集。 如果使用<xref:System.Reflection.AssemblyName.CodeBase%2A>找到程序集, 则会将显示名称与程序集匹配。 如果匹配失败, <xref:System.IO.FileLoadException>则会引发。  
  
 如果对同一程序<xref:System.Reflection.Assembly.Load%2A>集多次调用方法, 但指定了不同的证据, 则公共语言运行时将不会<xref:System.IO.FileLoadException>引发, 因为不同证据规范的相等性和完整性无法已. 第一次成功的证据是使用的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyRef" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyRef" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyRef" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyRef" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。

或

<paramref name="assemblyRef" /> 指定远程程序集，但在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。 关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以 "file://" 开头的 URI。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">运行时如何定位程序集</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集的显示名称。</param>
        <param name="assemblySecurity">用于加载程序集的证据。</param>
        <summary>通过给定的程序集的显示名称来加载程序集，使用提供的证据将程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>如果`assemblyString`指定完整的程序集名称, 并且与该简单名称匹配的第一个程序集具有不同的版本、区域性或公钥标记, 则会引发。 加载程序不会继续探测与简单名称匹配的其他程序集。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
-   使用<xref:System.Reflection.Assembly.Load%2A> 不<xref:System.Security.Policy.Evidence>带参数的方法时, 将使用加载程序提供的证据加载程序集。  
  
-   <xref:System.Reflection.Assembly.Load%2A> 使用<xref:System.Security.Policy.Evidence>带参数的方法时, 会合并证据部分。 作为参数提供给<xref:System.Reflection.Assembly.Load%2A>方法的证据将取代加载程序提供的证据。  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载通用对象文件格式 (COFF) 图像时, 将从调用程序集继承证据。 这适用于 .NET Framework 版本 1.1 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中, 当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载 COFF 图像时, 会结合证据。 `Zone`和从调用程序集继承`Hash`而来,并且从COFF程序集获取。`StrongName` `Url` `Site`  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法并<xref:System.Security.Policy.Evidence>加载 COFF 图像时, 仅使用提供的证据。 将忽略调用程序集和 COFF 图像的证据。  
  
 对C++可执行文件进行<xref:System.BadImageFormatException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位`.reloc`地址或部分所造成的。 若要保留`.reloc` C++可执行文件的地址, 请`/fixed:no`指定链接的时间。  
  
 如果在同一程序集上多次调用此方法但指定了不同的证据, 则公共语言运行时不会引发<xref:System.IO.FileLoadException> , 因为不能确定不同证据规范的相等性和完整性。 第一次成功的证据是使用的证据。  
  
 在 .NET Framework 版本2.0 中, 处理器体系结构添加到程序集标识, 并可指定为程序集名称字符串的一部分。 例如, "ProcessorArchitecture = msil"。 但是, 指定程序集名称的建议方法是创建一个<xref:System.Reflection.AssemblyName>对象并将其传递给该<xref:System.Reflection.Assembly.Load%2A>方法的适当重载。 请参阅 <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。  
  
 - 或 -  
  
 一个程序集或模块用两个不同的证据加载了两次。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">运行时如何定位程序集</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <param name="rawSymbolStore">包含表示程序集符号的原始字节的字节数组。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括程序集的符号和证据。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用提供的证据将该程序集加载到调用方的域中。 还会加载表示程序集符号的原始字节。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
-   使用<xref:System.Reflection.Assembly.Load%2A> 不<xref:System.Security.Policy.Evidence>带参数的方法时, 将使用加载程序提供的证据加载程序集。  
  
-   <xref:System.Reflection.Assembly.Load%2A> 使用<xref:System.Security.Policy.Evidence>带参数的方法时, 会合并证据部分。 作为参数提供给<xref:System.Reflection.Assembly.Load%2A>方法的证据将取代加载程序提供的证据。  
  
-   如果使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载 COFF 图像, 则会从调用程序集继承证据。 这适用于 .NET Framework 版本 1.1 Service Pack 1 (SP1) 和后续版本。  
  
    > [!NOTE]
    >  在不带 SP1 的 .NET Framework 版本1.0 和版本1.1 中, 当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法重载加载 COFF 图像时, 会结合证据。 `Zone`和从调用程序集继承`Hash`而来,并且从COFF程序集获取。`StrongName` `Url` `Site`  
  
-   当你使用<xref:System.Reflection.Assembly.Load%2A> `Byte[]`带参数的方法并<xref:System.Security.Policy.Evidence>加载 COFF 图像时, 仅使用提供的证据。 将忽略调用程序集和 COFF 图像的证据。  
  
 对C++可执行文件进行<xref:System.BadImageFormatException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位`.reloc`地址或部分所造成的。 若要保留`.reloc` C++可执行文件的地址, 请`/fixed:no`指定链接的时间。  
  
 如果对同一程序集\]调用 [\<, Byte x:% 2a > 方法, 但指定了另一种证据, 则公共语言<xref:System.IO.FileLoadException>运行时将不会引发, 因为无法确定不同证据规范的相等性和完整性。 第一次成功的证据是使用的证据。  
  
 请注意, 此方法重载始终使用自己<xref:System.Reflection.Assembly>的映射创建一个新的对象。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据加载了两次。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> 不是 <see langword="null" />。  默认情况下，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中未启用旧版 CAS 策略；如果未启用，则 <paramref name="securityEvidence" /> 必须为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供证据的能力。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />。 安全操作: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="1" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" Index="2" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <param name="rawSymbolStore">包含表示程序集符号的原始字节的字节数组。</param>
        <param name="securityContextSource">安全上下文的源。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像的程序集，此映像包含一个已发出的程序集，并且还可选择包括符号和指定安全上下文的源。 此程序集将会加载到调用方的应用程序域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用安全上下文的指定源将程序集加载到调用方的应用程序域中。 如果`rawSymbolStore`指定了, 则还会加载表示程序集符号的原始字节。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> 不是有效的程序集。  
  
- 或 - 
 <paramref name="rawAssembly" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="securityContextSource" /> 的值不是枚举值之一。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载程序集文件的内容。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path">要加载的文件的完全限定路径。</param>
        <summary>加载指定路径上的程序集文件的内容。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.LoadFile%2A>使用方法加载和检查具有相同标识但位于不同路径中的程序集。 <xref:System.Reflection.Assembly.LoadFile%2A>不会将文件加载到加载源上下文中, 并且不会使用加载路径解析依赖项, 因为<xref:System.Reflection.Assembly.LoadFrom%2A>方法会。 <xref:System.Reflection.Assembly.LoadFile%2A>在这种受限情况下非常<xref:System.Reflection.Assembly.LoadFrom%2A>有用, 因为不能用于加载具有相同标识但路径不同的程序集; 它只加载第一个这样的程序集。  

从 .NET Framework 4 开始, 如果`path`指定远程位置中的程序集, 则默认情况下将禁用程序集加载`LoadFile` , 并且该<xref:System.IO.FileLoadException>方法将引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。

或

在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> 参数为空字符串 ("") 或不存在。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="path" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。 关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="path">程序集文件的完全限定路径。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>通过给定的程序集的路径来加载程序集，使用提供的证据将程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.LoadFile%2A>使用方法加载和检查具有相同标识但位于不同路径中的程序集。 <xref:System.Reflection.Assembly.LoadFile%2A>不会将文件加载到<xref:System.Reflection.Assembly.LoadFrom%2A>上下文中, 并且不会使用加载路径解析依赖项, 正<xref:System.Reflection.Assembly.LoadFrom%2A>如方法所做的那样。 <xref:System.Reflection.Assembly.LoadFile%2A>在这种受限情况下非常<xref:System.Reflection.Assembly.LoadFrom%2A>有用, 因为不能用于加载具有相同标识但路径不同的程序集; 它只加载第一个这样的程序集。  

从 .NET Framework 4 开始, 如果`path`指定远程位置中的程序集, 则默认情况下将禁用程序集加载`LoadFile` , 并且该<xref:System.IO.FileLoadException>方法将引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="path" /> 参数不是绝对路径。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="path" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="path" /> 参数为空字符串 ("") 或不存在。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。

- 或 -

在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="path" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="path" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="securityEvidence" /> 不是 <see langword="null" />。 默认情况下，[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 中未启用旧版 CAS 策略；如果未启用，则 <paramref name="securityEvidence" /> 必须为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于从文件或目录读取的访问权限, 以及用于访问路径本身中的信息的。 关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

从 .NET Framework 4 开始, 在默认情况下禁用从远程位置加载的程序集中执行代码的功能, 并且对`LoadFrom`方法的调用将<xref:System.IO.FileLoadException>引发。 若要加载程序集并执行其代码, 你必须:

- 为程序集显式创建沙盒。 （请参阅[如何：在沙盒](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md)中运行部分受信任的代码。)

- 通过将`enabled` `true` [ `<loadFromRemoteSources>`配置元素](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)的属性设置为, 在完全信任环境中运行程序集的代码。 有关详细信息, 请参阅[ `<loadFromRemoteSources>`配置元素](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)一文。

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <summary>已知程序集的文件名或路径，加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用没有转义符的 URI。 此方法为 URI 中的所有无效字符提供转义符。  
  
> [!NOTE]
>  文件传输协议 (FTP) 不受支持。 如果为提供的`assemblyFile` URI 是 FTP 地址, 则不会加载该程序集。 不引发异常。  
  
 `assemblyFile`可以是当前目录的绝对或相对路径, 并且程序集将加载到调用方的域中。  
  
 可以将程序集加载到三个上下文中的一个, 也可以在没有上下文的情况下加载:  
  
-   如果承载运行时, 或在应用程序域的<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>中, 则加载上下文包含探测发现的程序集。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载自上下文包含的程序集, 用户为其提供的路径未包含在通过探测搜索的目录中。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。 

    从 .NET Framework 4 开始, 如果的 URI `assemblyFile`指定远程位置, 则默认情况下将禁用程序集加载, 并且该`LoadFrom`方法将<xref:System.IO.FileLoadException>引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。    
  
-   仅反射上下文包含用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法加载的程序集; 这些上下文中的代码无法执行。  
  
-   如果用户生成或找到了该程序集, 则该程序集不在任何上下文中。 这适用于使用<xref:System.Reflection.Assembly.Load%2A>方法重载加载的程序集, 该方法用于指定包含程序集的字节数组以及使用反射发出而不保存到磁盘的暂时性动态程序集。  
  
 加载源上下文允许从探测中未包含的路径加载程序集, 并且还允许查找并加载该路径上的依赖项, 因为路径信息由上下文维护。  
  
 此<xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集, 则加载尝试将失败。 对程序集进行反序列化时可能会发生这种情况。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且探测路径包含具有相同标识但位置不同的程序集<xref:System.InvalidCastException>, 则可能会出现、 <xref:System.MissingMethodException>或其他意外行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果的本机映像存在`assemblyFile`, 则不使用该映像。 无法将程序集加载为非特定域。  
  
-   在 .NET Framework 版本1.0 和1.1 中, 不会应用策略。  
  
   
  
## Examples  
 下面的示例在给定程序集的文件名或路径的情况下加载该程序集。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。

或

在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称超过系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取以 "file://" 开头的 URI。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以 "file://" 开头的 URI。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>在给定程序集的文件名或路径并提供安全证据的情况下，加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用没有转义符的 URI。 此方法为 URI 中的所有无效字符提供转义符。  
  
> [!NOTE]
>  文件传输协议 (FTP) 不受支持。 如果为提供的`assemblyFile` URI 是 FTP 地址, 则不会加载该程序集。 不引发异常。  
  
 `assemblyFile`可以是当前目录的绝对或相对路径, 并且程序集将加载到调用方的域中。  
  
 可以将程序集加载到三个上下文中的一个, 也可以在没有上下文的情况下加载:  
  
-   如果承载运行时, 或在应用程序域的<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>中, 则加载上下文包含探测发现的程序集。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载自上下文包含的程序集, 用户为其提供的路径未包含在通过探测搜索的目录中。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。

    从 .NET Framework 4 开始, 如果的 URI `assemblyFile`指定远程位置, 则默认情况下将禁用程序集加载, 并且该`LoadFrom`方法将<xref:System.IO.FileLoadException>引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。    
  
-   仅反射上下文包含用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法加载的程序集; 这些上下文中的代码无法执行。  
  
-   如果用户生成或找到了该程序集, 则该程序集不在任何上下文中。 这适用于使用<xref:System.Reflection.Assembly.Load%2A>方法重载加载的程序集, 该方法用于指定包含程序集的字节数组以及使用反射发出而不保存到磁盘的暂时性动态程序集。  
  
 加载源上下文允许从探测中未包含的路径加载程序集, 并且还允许查找并加载该路径上的依赖项, 因为路径信息由上下文维护。  
  
 此<xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集, 则加载尝试将失败。 对程序集进行反序列化时，可能发生这种情况。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且探测路径包含具有相同标识但位置不同的程序集<xref:System.InvalidCastException>, 则可能会出现、 <xref:System.MissingMethodException>或其他意外行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果的本机映像存在`assemblyFile`, 则不使用该映像。 无法将程序集加载为非特定域。  
  
-   在 .NET Framework 版本1.0 和1.1 中, 不会应用策略。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
-   使用<xref:System.Reflection.Assembly.LoadFrom%2A> 不<xref:System.Security.Policy.Evidence>带参数的方法时, 将使用加载程序提供的证据加载程序集。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 使用<xref:System.Security.Policy.Evidence>带参数的方法时, 会合并证据部分。 作为参数提供给<xref:System.Reflection.Assembly.LoadFrom%2A>方法的证据将取代加载程序提供的证据。  
  
-   如果在同一程序集上多次调用此方法但指定了不同的证据, 则公共语言运行时不会引发<xref:System.IO.FileLoadException> , 因为不能确定不同证据规范的相等性和完整性。 第一次成功的证据是使用的证据。  
  
-   如果将<xref:System.Reflection.Assembly.LoadFrom%2A>方法`Byte[]`与参数一起使用来加载通用对象文件格式 (COFF) 图像, 则会结合证据。 `Zone`和从调用程序集继承`Hash`而来,并且从COFF程序集获取。`StrongName` `Url` `Site`  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A> `Byte[]`带参数的方法并<xref:System.Security.Policy.Evidence>加载 COFF 图像时, 仅使用提供的证据。 将忽略调用程序集和 COFF 图像的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。  
  
或 
<paramref name="securityEvidence" /> 是明确的，但被确定为无效。

或

在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称超过系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取以 "file://" 开头的 URI。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以 "file://" 开头的 URI。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <param name="hashValue">计算所得的哈希代码的值。</param>
        <param name="hashAlgorithm">用于对文件进行哈希处理并生成强名称的哈希算法。</param>
        <summary>通过给定程序集文件名或路径、哈希值及哈希算法来加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用没有转义符的 URI。 此方法为 URI 中的所有无效字符提供转义符。  
  
> [!NOTE]
>  文件传输协议 (FTP) 不受支持。 如果为提供的`assemblyFile` URI 是 FTP 地址, 则不会加载该程序集。 不引发异常。  
  
 `assemblyFile`可以是当前目录的绝对或相对路径, 并且程序集将加载到调用方的域中。  
  
 可以将程序集加载到三个上下文中的一个, 也可以在没有上下文的情况下加载:  
  
-   加载上下文包含探测发现的程序集: 在全局程序集缓存中, 如果承载运行时, 则在主机程序集存储区中<xref:System.AppDomainSetup.ApplicationBase%2A> , <xref:System.AppDomainSetup.PrivateBinPath%2A>或者在应用程序域的和中。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载内容上下文包含用户为其提供的路径未包含在探测中的程序集。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。  

    从 .NET Framework 4 开始, 如果的 URI `assemblyFile`指定远程位置, 则默认情况下将禁用程序集加载, 并且该`LoadFrom`方法将<xref:System.IO.FileLoadException>引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。    
  
-   仅反射上下文包含用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法加载的程序集; 这些上下文中的代码无法执行。  
  
-   如果用户生成或找到了该程序集, 则该程序集不在任何上下文中。 这适用于使用<xref:System.Reflection.Assembly.Load%2A>方法重载加载的程序集, 该方法用于指定包含程序集的字节数组以及使用反射发出而不保存到磁盘的暂时性动态程序集。  
  
 加载源上下文允许从探测中未包含的路径加载程序集, 并且还允许查找和加载该路径上的依赖项, 因为路径信息由上下文维护。  
  
 此<xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集, 则加载尝试将失败。 对程序集进行反序列化时，可能发生这种情况。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且探测路径包含具有相同标识但位置不同的程序集<xref:System.InvalidCastException>, 则可能会出现、 <xref:System.MissingMethodException>或其他意外行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果的本机映像存在`assemblyFile`, 则不使用该映像。 程序集不能以非特定于域的方式加载。  
  
 该程序集与加载程序所提供的证据一起加载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。

- 或 -

在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
或 
 <paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.Security.SecurityException">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称超过系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取以 "file://" 开头的 URI。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以 "file://" 开头的 URI。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <param name="hashValue">计算所得的哈希代码的值。</param>
        <param name="hashAlgorithm">用于对文件进行哈希处理并生成强名称的哈希算法。</param>
        <summary>通过给定程序集文件名或路径、安全证据、哈希值及哈希算法来加载程序集。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`参数必须引用没有转义符的 URI。 此方法为 URI 中的所有无效字符提供转义符。  
  
> [!NOTE]
>  文件传输协议 (FTP) 不受支持。 如果为提供的`assemblyFile` URI 是 FTP 地址, 则不会加载该程序集。 不引发异常。  
  
 `assemblyFile`可以是当前目录的绝对或相对路径, 并且程序集将加载到调用方的域中。  
  
 可以将程序集加载到三个上下文中的一个, 也可以在没有上下文的情况下加载:  
  
-   如果承载运行时, 或在应用程序域的<xref:System.AppDomainSetup.ApplicationBase%2A>和<xref:System.AppDomainSetup.PrivateBinPath%2A>中, 则加载上下文包含探测发现的程序集。 <xref:System.Reflection.Assembly.Load%2A> 方法的大多数重载都将程序集加载到此上下文中。  
  
-   加载自上下文包含的程序集, 用户为其提供的路径未包含在通过探测搜索的目录中。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A> 和 <xref:System.AppDomain.ExecuteAssembly%2A> 都是通过路径加载的方法的示例。  

    从 .NET Framework 4 开始, 如果的 URI `assemblyFile`指定远程位置, 则默认情况下将禁用程序集加载, 并且该`LoadFrom`方法将<xref:System.IO.FileLoadException>引发。 若要启用从远程位置加载的代码的执行, 可以使用[`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)配置元素。    
  
-   仅反射上下文包含用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>和<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>方法加载的程序集; 这些上下文中的代码无法执行。  
  
-   如果用户生成或找到了该程序集, 则该程序集不在任何上下文中。 这适用于使用<xref:System.Reflection.Assembly.Load%2A>方法重载加载的程序集, 该方法用于指定包含程序集的字节数组以及使用反射发出而不保存到磁盘的暂时性动态程序集。  
  
 加载源上下文允许从探测中未包含的路径加载程序集, 并且还允许查找并加载该路径上的依赖项, 因为路径信息由上下文维护。  
  
 此<xref:System.Reflection.Assembly.LoadFrom%2A>方法具有以下缺点。 请考虑改用 <xref:System.Reflection.Assembly.Load%2A>。  
  
-   如果已加载一个具有相同标识的程序集，则即使指定了不同的路径，<xref:System.Reflection.Assembly.LoadFrom%2A> 仍返回已加载的程序集。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且稍后加载上下文中的程序集尝试按显示名称加载同一程序集, 则加载尝试将失败。 对程序集进行反序列化时，可能发生这种情况。  
  
-   如果使用<xref:System.Reflection.Assembly.LoadFrom%2A>加载程序集, 并且探测路径包含具有相同标识但位置不同的程序集<xref:System.InvalidCastException>, 则可能会出现、 <xref:System.MissingMethodException>或其他意外行为。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 需要对指定路径的 <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> 和 <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType> 或 <xref:System.Net.WebPermission>。  
  
-   如果的本机映像存在`assemblyFile`, 则不使用该映像。 无法将程序集加载为非特定域。  
  
-   在 .NET Framework 版本1.0 和1.1 中, 不会应用策略。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
-   使用<xref:System.Reflection.Assembly.LoadFrom%2A> 不<xref:System.Security.Policy.Evidence>带参数的方法时, 将使用加载程序提供的证据加载程序集。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> 使用<xref:System.Security.Policy.Evidence>带参数的方法时, 会合并证据部分。 作为参数提供给<xref:System.Reflection.Assembly.LoadFrom%2A>方法的证据将取代加载程序提供的证据。  
  
-   如果在同一程序集上多次调用此方法但指定了不同的证据, 则公共语言运行时不会引发<xref:System.IO.FileLoadException> , 因为不能确定不同证据规范的相等性和完整性。 第一次成功的证据是使用的证据。  
  
-   如果将<xref:System.Reflection.Assembly.LoadFrom%2A>方法`Byte[]`与参数一起使用来加载通用对象文件格式 (COFF) 图像, 则会结合证据。 `Zone`和从调用程序集继承`Hash`而来,并且从COFF程序集获取。`StrongName` `Url` `Site`  
  
-   当你使用<xref:System.Reflection.Assembly.LoadFrom%2A> `Byte[]`带参数的方法并<xref:System.Security.Policy.Evidence>加载 COFF 图像时, 仅使用提供的证据。 将忽略调用程序集和 COFF 图像的证据。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。  
  
- 或 - 
<paramref name="securityEvidence" /> 是明确的，但被确定为无效。

或

在远程程序集中执行代码的功能已禁用。 请参阅 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集 ；例如 64 位进程中的 32 位程序集。 有关详细信息，请参阅异常主题。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称超过系统定义的最大长度。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取以 "file://" 开头的 URI。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以 "file://" 开头的 URI。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>加载此程序集的内部模块。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="moduleName">模块的名称。 此字符串必须与程序集清单中的文件名对应。</param>
        <param name="rawModule">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。</summary>
        <returns>加载的模块。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="moduleName" /> 或 <paramref name="rawModule" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> 与此程序集清单中的文件条目不匹配。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> 不是有效的模块。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供证据。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawModule" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="moduleName">模块的名称。 此字符串必须与程序集清单中的文件名对应。</param>
        <param name="rawModule">基于 COFF 映像的字节数组，该数组包含发送的模块或资源。</param>
        <param name="rawSymbolStore">一个字节数组，包含表示模块符号的原始字节。 如果这是一个资源文件，则必须为 <see langword="null" />。</param>
        <summary>加载带有基于通用对象文件格式 (COFF) 的映像（包含已发出的模块）或资源文件的模块（该模块相对于此程序集是内部的）。 还加载表示此模块的符号的原始字节。</summary>
        <returns>加载的模块。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="moduleName" /> 或 <paramref name="rawModule" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="moduleName" /> 与此程序集清单中的文件条目不匹配。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawModule" /> 不是有效的模块。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">提供证据。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>方法的重载已过时, 已保留以实现向后兼容性。 未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="partialName">程序集的显示名称。</param>
        <summary>使用部分名称从应用程序目录或从全局程序集缓存加载程序集。</summary>
        <returns>加载的程序集。 如果未找到 <paramref name="partialName" />，此方法将返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  此<xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29>方法已过时, 已保留, 以实现向后兼容性。 未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 使用此方法加载程序集的应用程序将受到这些程序集升级的影响。 因此, 请不要使用此方法;重新设计应用程序以使用<xref:System.Reflection.Assembly.Load%28System.String%29>方法重载<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>或方法重载。  
  
 此方法首先调用<xref:System.Reflection.Assembly.Load%2A>。 如果未找到该程序集, 则此方法将从具有相同简单名称和最高版本号的全局程序集缓存返回程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="partialName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="partialName" /> 是用更高的版本编译的。</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="partialName">程序集的显示名称。</param>
        <param name="securityEvidence">用于加载程序集的证据。</param>
        <summary>使用部分名称从应用程序目录或从全局程序集缓存加载程序集。 使用提供的证据将该程序集加载到调用方的域中。</summary>
        <returns>加载的程序集。 如果未找到 <paramref name="partialName" />，此方法将返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  此<xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29>方法已过时, 已保留, 以实现向后兼容性。 未过时的替代项为 <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。  
  
 证据是输入安全策略决策的一组信息（如代码可授予哪些权限）。  
  
 使用此方法加载程序集的应用程序将受到这些程序集升级的影响。 因此, 请不要使用此方法;重新设计应用程序以使用<xref:System.Reflection.Assembly.Load%2A>方法<xref:System.Reflection.Assembly.LoadFrom%2A>或方法。  
  
 此方法首先调用<xref:System.Reflection.Assembly.Load%2A>。 如果未找到该程序集, 则此方法将从具有相同简单名称和最高版本号的全局程序集缓存返回程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">一个程序集或模块用两个不同的证据集加载了两次。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="partialName" /> 参数为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="partialName" /> 是用更高的版本编译的。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于调用非托管代码和加载包含证据的程序集。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含清单的已加载文件的完整路径或 UNC 位置。</summary>
        <value>包含清单的已加载文件的位置。 如果已加载文件使用了影像复制，则该位置是该文件被影像复制后的位置。 如果从字节数组加载程序集（如使用 <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> 方法重载时），则返回值为空字符串 ("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要在文件已进行卷影复制之前获取位置, 请使用<xref:System.Reflection.Assembly.CodeBase%2A>属性。  
  
   
  
## Examples  
 下面的示例显示了包含清单的已加载文件的位置。  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">当前的程序集是动态程序集，由 <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> 对象表示。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于访问路径。 关联的枚举:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">卷影复制程序集</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含当前程序集清单的模块。</summary>
        <value>包含程序集清单的模块。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当公共语言运行时类加载程序不能通过正常方法解析对程序集的内部模块的引用时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件为回调提供一个机会来查找并加载模块本身并返回它。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取包含此程序集中模块的集合。</summary>
        <value>包含此程序集中模块的集合。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">要与 <paramref name="right" /> 进行比较的程序集。</param>
        <param name="right">要与 <paramref name="left" /> 进行比较的程序集。</param>
        <summary>指示两个 <see cref="T:System.Reflection.Assembly" /> 对象是否相等。</summary>
        <returns>如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left">要与 <paramref name="right" /> 进行比较的程序集。</param>
        <param name="right">要与 <paramref name="left" /> 进行比较的程序集。</param>
        <summary>指示两个 <see cref="T:System.Reflection.Assembly" /> 对象是否不相等。</summary>
        <returns>如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前程序集的授予集。</summary>
        <value>当前程序集的授予集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>对象可以包含敏感信息, 如路径。 因此, 访问这些对象需要完全信任。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取 <see cref="T:System.Boolean" /> 值，该值指示此程序集是否被加载到只反射上下文中。</summary>
        <value>如果程序集被加载到只反射上下文而不是执行上下文中，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>方法将程序集加载到仅反射上下文中, 则无法在程序集中执行代码。 若要执行代码, 必须将程序集加载到执行上下文中。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将程序集加载到只反射上下文中，在只反射上下文中可以检查但不能执行程序集。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">字节数组，它是包含已发出程序集的基于 COFF 的映像。</param>
        <summary>加载来自基于通用对象文件格式 (COFF) 的映像的程序集，该映像包含已发出的程序集。 程序集被加载到调用方的应用程序域的只反射上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能执行加载到仅反射上下文中的程序集的代码。 若要执行代码, 还必须使用<xref:System.Reflection.Assembly.Load%2A>方法将程序集加载到执行上下文中。  
  
 仅反射上下文与其他上下文没有区别。 只能通过卸载应用程序域来卸载加载到上下文中的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="rawAssembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="rawAssembly" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="rawAssembly" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载 <paramref name="rawAssembly" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyString">程序集的显示名称，由 <see cref="P:System.Reflection.AssemblyName.FullName" /> 属性返回。</param>
        <summary>将给定显示名称的程序集加载到只反射上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖项不会自动加载到仅反射上下文中。  
  
 不能执行加载到仅反射上下文中的程序集的代码。 若要执行代码, 还必须使用<xref:System.Reflection.Assembly.Load%2A>方法将程序集加载到执行上下文中。  
  
 是否将特定的权限授予程序集是基于证据的。 程序集和安全证据合并的规则如下所示:  
  
> [!NOTE]
>  在中编译的可执行C++文件上进行<xref:System.IO.FileLoadException>反射可能会引发。 这很可能是由于C++编译器从可执行文件中去除重定位地址或 .reloc 部分所致。 若要保留 .reloc 地址, 请指定`/fixed:no`链接的时间。  
  
 仅反射上下文与其他上下文没有区别。 只能通过卸载应用程序域来卸载加载到上下文中的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyString" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyString" /> 为空字符串 ("")。</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="assemblyString" /> 未找到。</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyString" /> 已找到，但无法加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyString" /> 不是有效的程序集。  
  
- 或 - 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyString" /> 是用更高的版本编译的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的路径。</param>
        <summary>将给定路径的程序集加载到只反射上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依赖项不会自动加载到仅反射上下文中。 若要自动加载依赖关系, <xref:System.AppDomain.ReflectionOnlyAssemblyResolve>请处理事件, 并在事件处理程序中加载依赖关系。  
  
 不能执行已加载到仅反射上下文中的程序集的代码。 若要执行该代码, 请加载具有<xref:System.Reflection.Assembly.LoadFile%2A>方法的程序集。  
  
 `assemblyFile`参数必须引用没有转义符的 URI。 此方法为 URI 中的所有无效字符提供转义符。  
  
 为指定`assemblyFile`的路径是相对于当前目录的路径。 将程序集加载到调用方的域中。  
  
 仅反射上下文与其他上下文没有区别。 只能通过卸载应用程序域来卸载加载到上下文中的程序集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件扩展名。</exception>
        <exception cref="T:System.IO.FileLoadException"><paramref name="assemblyFile" /> 已找到，但无法加载。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
当前加载的是公共语言运行时 2.0 版或更高版本，而 <paramref name="assemblyFile" /> 是用更高的版本编译的。</exception>
        <exception cref="T:System.Security.SecurityException">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称超过系统定义的最大长度。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> 为空字符串 ("")。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于读取以 "file://" 开头的 URI。 关联的枚举<see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">用于读取不以 "file://" 开头的 URI。</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示公共语言运行时 (CLR) 对此程序集强制执行的安全规则集。</summary>
        <value>CLR 对此程序集强制执行的安全规则集。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, 使用编译的程序集[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]具有[2 级](~/docs/framework/misc/security-transparent-code-level-2.md)透明度, 但您可以改为将其显式设为[1 级](~/docs/framework/misc/security-transparent-code-level-1.md)。 使用早期版本的 .NET Framework 编译的程序集具有1级透明度。  
  
 请参阅[安全更改](~/docs/framework/security/security-changes.md)。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">安全透明的代码</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4 中的安全更改</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
        <Parameter Name="inherit" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回当前实例的类型。</summary>
        <returns>表示 <see cref="T:System.Reflection.Assembly" /> 类型的对象。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回程序集的全名，即所谓的显示名称。</summary>
        <returns>程序集的全名；如果不能确定程序集的全名，则为类名。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">包含程序集清单的文件的名称或路径。</param>
        <summary>绕过某些安全检查，将程序集加载到加载源上下文中。</summary>
        <returns>加载的程序集。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法加载操作系统已标记为已从 Web 加载的本地程序集 (例如, 从 Internet 或 intranet 下载的临时文件)。 在[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]之前, 此类程序集会自动加载到沙盒应用程序域中。 从开始, 以完全信任方式加载它们。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]  
  
 作为使用此方法的替代方法, 可以在应用程序配置文件中应用[ &lt;y&gt;元素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)。 这会导致公共语言运行时恢复到的[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]安全策略。  
  
> [!CAUTION]
>  如果使用上述任一解决方案, 则必须确保以完全信任方式加载`assemblyFile`是安全的。  
  
 有关加载上下文的讨论, 包括加载源上下文, 请参阅<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>方法重载。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assemblyFile" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">未找到 <paramref name="assemblyFile" />，或者你正在试图加载的模块未指定文件名扩展。</exception>
        <exception cref="T:System.IO.FileLoadException">无法加载已找到的文件。</exception>
        <exception cref="T:System.BadImageFormatException"><paramref name="assemblyFile" /> 不是有效的程序集。  
  
或 
 <paramref name="assemblyFile" /> 使用高于当前所加载版本的公共语言运行时版本编译而成。</exception>
        <exception cref="T:System.Security.SecurityException">指定了不以“file://”开头的基本代码，且没有所需的 <see cref="T:System.Net.WebPermission" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assemblyFile" /> 参数为空字符串 ("")。</exception>
        <exception cref="T:System.IO.PathTooLongException">程序集名称超过系统定义的最大长度。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
      </Docs>
    </Member>
  </Members>
</Type>