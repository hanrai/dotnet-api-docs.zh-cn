<Type Name="FieldInfo" FullName="System.Reflection.FieldInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ccc465bda75447c56ca25e390ec1cc2c96dd5ff6" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69353194" /></Metadata><TypeSignature Language="C#" Value="public abstract class FieldInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._FieldInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit FieldInfo extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._FieldInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.FieldInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class FieldInfo&#xA;Inherits MemberInfo&#xA;Implements _FieldInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class FieldInfo abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_FieldInfo" />
  <TypeSignature Language="F#" Value="type FieldInfo = class&#xA;    inherit MemberInfo&#xA;    interface _FieldInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._FieldInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._FieldInfo))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="23e13-101">发现字段的属性并提供对字段元数据的访问权限。</span><span class="sxs-lookup"><span data-stu-id="23e13-101">Discovers the attributes of a field and provides access to field metadata.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-102">字段信息是从元数据获取的。</span><span class="sxs-lookup"><span data-stu-id="23e13-102">The field information is obtained from metadata.</span></span> <span data-ttu-id="23e13-103"><xref:System.Reflection.FieldInfo>类没有公共构造函数。</span><span class="sxs-lookup"><span data-stu-id="23e13-103">The <xref:System.Reflection.FieldInfo> class does not have a public constructor.</span></span> <span data-ttu-id="23e13-104"><xref:System.Reflection.FieldInfo>对象是通过调用<xref:System.Type.GetFields%2A> `Type`对象的或<xref:System.Type.GetField%2A>方法获取的。</span><span class="sxs-lookup"><span data-stu-id="23e13-104"><xref:System.Reflection.FieldInfo> objects are obtained by calling either the <xref:System.Type.GetFields%2A> or <xref:System.Type.GetField%2A> method of a `Type` object.</span></span>  
  
 <span data-ttu-id="23e13-105">字段是在类中定义的变量。</span><span class="sxs-lookup"><span data-stu-id="23e13-105">Fields are variables defined in the class.</span></span> <span data-ttu-id="23e13-106"><xref:System.Reflection.FieldInfo>提供对类中字段的元数据的访问, 并为字段提供动态集和获取功能。</span><span class="sxs-lookup"><span data-stu-id="23e13-106"><xref:System.Reflection.FieldInfo> provides access to the metadata for a field within a class and provides dynamic set and get functionality for the field.</span></span> <span data-ttu-id="23e13-107">类不会加载到内存中, 直到对对象调用 invoke 或 get。</span><span class="sxs-lookup"><span data-stu-id="23e13-107">The class is not loaded into memory until invoke or get is called on the object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-108">下面的示例使用<xref:System.Type.GetFields%2A?displayProperty=nameWithType>方法获取<xref:System.Reflection.FieldInfo>类中与字段相关的信息, 然后显示字段属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-108">The following example uses the <xref:System.Type.GetFields%2A?displayProperty=nameWithType> method to get the field-related information from the <xref:System.Reflection.FieldInfo> class, and then displays field attributes.</span></span>  
  
 [!code-cpp[FieldInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo/CPP/fieldinfo.cpp#1)]
 [!code-csharp[FieldInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo/CS/fieldinfo.cs#1)]
 [!code-vb[FieldInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo/VB/fieldinfo.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="23e13-109">完全信任继承者。</span><span class="sxs-lookup"><span data-stu-id="23e13-109">for full trust for inheritors.</span></span> <span data-ttu-id="23e13-110">此类不能由部分信任的代码继承。</span><span class="sxs-lookup"><span data-stu-id="23e13-110">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="23e13-111">此类型是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="23e13-111">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="23e13-112">当从 <see cref="T:System.Reflection.FieldInfo" /> 继承时，必须重写下面的成员：<see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" /> 和 <see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-112">When you inherit from <see cref="T:System.Reflection.FieldInfo" />, you must override the following members: <see cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" /> and <see cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />.</span></span></para></block>
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected FieldInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; FieldInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="23e13-113">初始化 <see langword="FieldInfo" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="23e13-113">Initializes a new instance of the <see langword="FieldInfo" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-114">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-114">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-115">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-115">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.FieldAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As FieldAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::FieldAttributes Attributes { System::Reflection::FieldAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.FieldAttributes" Usage="System.Reflection.FieldInfo.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-116">获取与此字段关联的特性。</span><span class="sxs-lookup"><span data-stu-id="23e13-116">Gets the attributes associated with this field.</span></span></summary>
        <value><span data-ttu-id="23e13-117">此字段的 <see langword="FieldAttributes" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-117">The <see langword="FieldAttributes" /> for this field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-118">所有成员都具有一组属性, 这些属性是相对于特定类型的成员定义的。</span><span class="sxs-lookup"><span data-stu-id="23e13-118">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span> <span data-ttu-id="23e13-119">`FieldAttributes`通知用户此字段是否为私有字段、静态字段等。</span><span class="sxs-lookup"><span data-stu-id="23e13-119">`FieldAttributes` informs the user whether this field is the private field, a static field, and so on.</span></span>  
  
 <span data-ttu-id="23e13-120">若要获取`Attributes`属性, 请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="23e13-120">To get the `Attributes` property, first get the class `Type`.</span></span> <span data-ttu-id="23e13-121">`Type`从中`FieldInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="23e13-121">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="23e13-122">`FieldInfo`从中`Attributes`获取。</span><span class="sxs-lookup"><span data-stu-id="23e13-122">From the `FieldInfo`, get the `Attributes`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-123">下面的代码示例生成三个字段并显示它们的字段属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-123">The following code example builds three fields and displays their field attributes.</span></span> <span data-ttu-id="23e13-124">值可以包含多个属性 (如`Public`和`Literal`), 如第三个字段中所示。 `FieldAttributes`</span><span class="sxs-lookup"><span data-stu-id="23e13-124">A `FieldAttributes` value can contain more than one attribute, such as both `Public` and `Literal`, as shown in the third field.</span></span>  
  
 [!code-cpp[Classic FieldAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic FieldAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="fieldInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="23e13-125">与此实例进行比较的对象，或为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-125">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="23e13-126">返回一个值，该值指示此实例是否与指定的对象相等。</span><span class="sxs-lookup"><span data-stu-id="23e13-126">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="23e13-127">如果 <see langword="true" /> 等于此实例的类型和值，则为 <paramref name="obj" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-127"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeFieldHandle FieldHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeFieldHandle FieldHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.FieldHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FieldHandle As RuntimeFieldHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeFieldHandle FieldHandle { RuntimeFieldHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldHandle : RuntimeFieldHandle" Usage="System.Reflection.FieldInfo.FieldHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.FieldHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeFieldHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-128">获取 <see langword="RuntimeFieldHandle" />，它是字段的内部元数据表示形式的句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-128">Gets a <see langword="RuntimeFieldHandle" />, which is a handle to the internal metadata representation of a field.</span></span></summary>
        <value><span data-ttu-id="23e13-129">某个字段的内部元数据表示形式的句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-129">A handle to the internal metadata representation of a field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-130">句柄仅在获取它们的 appdomain 中有效。</span><span class="sxs-lookup"><span data-stu-id="23e13-130">The handles are valid only in the appdomain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-131">下面的示例检索 MyField 字段信息并显示与该字段句柄关联的字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-131">The following example retrieves MyClass.MyField field information and displays the field associated with the field handle.</span></span>  
  
 [!code-cpp[FieldInfo_FieldHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_FieldHandle/CPP/fieldinfo_fieldhandle.cpp#1)]
 [!code-csharp[FieldInfo_FieldHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_FieldHandle/CS/fieldinfo_fieldhandle.cs#1)]
 [!code-vb[FieldInfo_FieldHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_FieldHandle/VB/fieldinfo_fieldhandle.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FieldType">
      <MemberSignature Language="C#" Value="public abstract Type FieldType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type FieldType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.FieldType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FieldType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ FieldType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FieldType : Type" Usage="System.Reflection.FieldInfo.FieldType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.FieldType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-132">获取此字段对象的类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-132">Gets the type of this field object.</span></span></summary>
        <value><span data-ttu-id="23e13-133">此字段对象的类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-133">The type of this field object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-134">类型为某种基元数据类型, 如`String`、 `Boolean`或`GUID`。</span><span class="sxs-lookup"><span data-stu-id="23e13-134">The type is some primitive data type, such as `String`, `Boolean`, or `GUID`.</span></span>  
  
 <span data-ttu-id="23e13-135">若要获取`FieldType`属性, 请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="23e13-135">To get the `FieldType` property, first get the class `Type`.</span></span> <span data-ttu-id="23e13-136">`Type`从中`FieldInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="23e13-136">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="23e13-137">`FieldInfo`从中`FieldType`获取值。</span><span class="sxs-lookup"><span data-stu-id="23e13-137">From the `FieldInfo`, get the `FieldType` value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-138">下面的示例创建一个字段, 获取其类型和<xref:System.Reflection.FieldInfo>, 并显示其<xref:System.Reflection.FieldInfo.FieldType%2A>。</span><span class="sxs-lookup"><span data-stu-id="23e13-138">The following example creates a field, gets its type and <xref:System.Reflection.FieldInfo>, and displays its <xref:System.Reflection.FieldInfo.FieldType%2A>.</span></span>  
  
 [!code-cpp[Classic FieldInfo.FieldType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.FieldType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.FieldType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.FieldType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFieldFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="23e13-139">获取由句柄表示的字段的 <see cref="T:System.Reflection.FieldInfo" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-139">Gets a <see cref="T:System.Reflection.FieldInfo" /> for the field represented by a handle.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFieldFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetFieldFromHandle(valuetype System.RuntimeFieldHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFieldFromHandle (handle As RuntimeFieldHandle) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetFieldFromHandle(RuntimeFieldHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetFieldFromHandle : RuntimeFieldHandle -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.FieldInfo.GetFieldFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="23e13-140"><see cref="T:System.RuntimeFieldHandle" /> 结构，它包含字段的内部元数据表示形式的句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-140">A <see cref="T:System.RuntimeFieldHandle" /> structure that contains the handle to the internal metadata representation of a field.</span></span></param>
        <summary><span data-ttu-id="23e13-141">获取由指定句柄表示的字段的 <see cref="T:System.Reflection.FieldInfo" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-141">Gets a <see cref="T:System.Reflection.FieldInfo" /> for the field represented by the specified handle.</span></span></summary>
        <returns><span data-ttu-id="23e13-142"><see cref="T:System.Reflection.FieldInfo" /> 对象，表示由 <paramref name="handle" /> 指定的字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-142">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field specified by <paramref name="handle" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-143">句柄仅在获取它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="23e13-143">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-144">下面的<xref:System.Type.GetFields%2A?displayProperty=nameWithType>代码示例使用方法获取<xref:System.Reflection.FieldInfo>类型的字段的对象, 获取<xref:System.RuntimeFieldHandle>每个字段的结构, 然后使用此重载的<xref:System.Reflection.FieldInfo> <xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A>此重载检索句柄中的对象。方法。</span><span class="sxs-lookup"><span data-stu-id="23e13-144">The following code example uses the <xref:System.Type.GetFields%2A?displayProperty=nameWithType> method to get <xref:System.Reflection.FieldInfo> objects for the fields of a type, gets a <xref:System.RuntimeFieldHandle> structure for each field, and then retrieves the <xref:System.Reflection.FieldInfo> objects from the handles using this overload of the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%2A> method.</span></span>  
  
 [!code-cpp[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/CPP/fieldinfo_getfieldfromhandle.cpp#1)]
 [!code-csharp[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/CS/fieldinfo_getfieldfromhandle.cs#1)]
 [!code-vb[FieldInfo_GetFieldFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle/VB/fieldinfo_getfieldfromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="23e13-145"><paramref name="handle" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="23e13-145"><paramref name="handle" /> is invalid.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-146">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-146">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-147">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-147">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFieldFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetFieldFromHandle (RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetFieldFromHandle(valuetype System.RuntimeFieldHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetFieldFromHandle(System.RuntimeFieldHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFieldFromHandle (handle As RuntimeFieldHandle, declaringType As RuntimeTypeHandle) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::FieldInfo ^ GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="F#" Value="static member GetFieldFromHandle : RuntimeFieldHandle * RuntimeTypeHandle -&gt; System.Reflection.FieldInfo" Usage="System.Reflection.FieldInfo.GetFieldFromHandle (handle, declaringType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeFieldHandle" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="23e13-148"><see cref="T:System.RuntimeFieldHandle" /> 结构，它包含字段的内部元数据表示形式的句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-148">A <see cref="T:System.RuntimeFieldHandle" /> structure that contains the handle to the internal metadata representation of a field.</span></span></param>
        <param name="declaringType"><span data-ttu-id="23e13-149"><see cref="T:System.RuntimeTypeHandle" /> 结构，它包含定义该字段的泛型类型的句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-149">A <see cref="T:System.RuntimeTypeHandle" /> structure that contains the handle to the generic type that defines the field.</span></span></param>
        <summary><span data-ttu-id="23e13-150">获取由指定句柄表示的指定泛型类型字段的 <see cref="T:System.Reflection.FieldInfo" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-150">Gets a <see cref="T:System.Reflection.FieldInfo" /> for the field represented by the specified handle, for the specified generic type.</span></span></summary>
        <returns><span data-ttu-id="23e13-151"><see cref="T:System.Reflection.FieldInfo" /> 对象，表示由 <paramref name="handle" /> 指定的字段，该字段的类型为 <paramref name="declaringType" /> 指定的泛型类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-151">A <see cref="T:System.Reflection.FieldInfo" /> object representing the field specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-152">句柄仅在获取它们的应用程序域中有效。</span><span class="sxs-lookup"><span data-stu-id="23e13-152">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="23e13-153">建议的做法是, `declaringType`应始终是`handle`属于的构造类型的运行时类型句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-153">The recommended practice is that `declaringType` should always be the runtime type handle of the constructed type that `handle` belongs to.</span></span> <span data-ttu-id="23e13-154">也就是说`handle` , 如果是`MyType(Of Integer)` `MyType<int>`属于 (在 Visual Basic 中`MyType<int>`) 的字段的运行时字段句柄, `declaringType`则是的运行时类型句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-154">That is, if `handle` is a runtime field handle for a field that belongs to `MyType<int>` (`MyType(Of Integer)` in Visual Basic), `declaringType` is the runtime type handle for `MyType<int>`.</span></span> <span data-ttu-id="23e13-155">除非运行时字段句柄表示泛型类型定义上的字段, 否则不要使用泛型类型定义的运行时类型句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-155">Do not use the runtime type handle of the generic type definition, unless the runtime field handle represents a field on the generic type definition.</span></span>  
  
 <span data-ttu-id="23e13-156">在某些情况下, 实现是兼容的。</span><span class="sxs-lookup"><span data-stu-id="23e13-156">Implementations are compatible in some cases.</span></span> <span data-ttu-id="23e13-157">例如, 通过使用泛型类型参数的引用类型, 从特定的泛型类型定义构造的所有类型都共享一个实现。</span><span class="sxs-lookup"><span data-stu-id="23e13-157">For example, a single implementation is shared by all types that are constructed from a particular generic type definition by using reference types for the generic type arguments.</span></span> <span data-ttu-id="23e13-158">例如`MyType<string>` `MyType<ArrayList>` ,、和都共享同一实现。 `MyType<object>`</span><span class="sxs-lookup"><span data-stu-id="23e13-158">For example, `MyType<string>`, `MyType<object>`, and `MyType<ArrayList>` all share the same implementation.</span></span> <span data-ttu-id="23e13-159">在这种情况下<xref:System.Reflection.FieldInfo> , 返回的对象表示类型上的一个字段, `declaringType`该字段指定, 而不考虑的`handle`原始源。</span><span class="sxs-lookup"><span data-stu-id="23e13-159">In this situation, the <xref:System.Reflection.FieldInfo> object that is returned represents a field on the type that `declaringType` specifies, regardless of the original source of `handle`.</span></span> <span data-ttu-id="23e13-160">不建议这样做, 因为它仅在构造类型的泛型类型参数是引用类型时才起作用。</span><span class="sxs-lookup"><span data-stu-id="23e13-160">This practice is not recommended, because it works only if the generic type arguments of the constructed type are reference types.</span></span>  
  
 <span data-ttu-id="23e13-161">如果泛型参数是值类型, 则构造类型的运行时类型句柄与构造中的运行时字段句柄不兼容, 该构造的引用类型在相同的泛型参数位置中, 或者在该位置具有不同的值类型.</span><span class="sxs-lookup"><span data-stu-id="23e13-161">If a generic argument is a value type, the runtime type handle of the constructed type is not compatible with runtime field handles from constructions that have a reference type in the same generic parameter position, or that have a different value type in that position.</span></span> <span data-ttu-id="23e13-162">在这种情况下, 使用<xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%2CSystem.RuntimeTypeHandle%29?displayProperty=nameWithType>重载的唯一方法是`declaringType`确保是`handle`属于的构造类型的运行时类型句柄。</span><span class="sxs-lookup"><span data-stu-id="23e13-162">In that case, the only way to use the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%2CSystem.RuntimeTypeHandle%29?displayProperty=nameWithType> overload is to ensure that `declaringType` is the runtime type handle for the constructed type that `handle` belongs to.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-163">下面的示例演示如何检索<xref:System.Reflection.FieldInfo>构造的泛型类中的字段的对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-163">The following example shows how to retrieve <xref:System.Reflection.FieldInfo> objects for fields on constructed generic classes.</span></span> <span data-ttu-id="23e13-164">该示例`Test<T>`使用类型`TestField``Test(Of T)` 为`T`的单个字段定义泛型类型 (在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="23e13-164">The example defines the generic type `Test<T>` (`Test(Of T)` in Visual Basic) with a single field named `TestField`, of type `T`.</span></span> <span data-ttu-id="23e13-165">该<xref:System.RuntimeFieldHandle>示例获取<xref:System.RuntimeTypeHandle>的`T`是, 对于为<xref:System.String>, 则显示以下内容:</span><span class="sxs-lookup"><span data-stu-id="23e13-165">The example gets the <xref:System.RuntimeFieldHandle> and <xref:System.RuntimeTypeHandle> for the case where `T` is <xref:System.String>, and demonstrates the following:</span></span>  
  
-   <span data-ttu-id="23e13-166">如果<xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29>使用方法重载, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="23e13-166">An exception is thrown if the <xref:System.Reflection.FieldInfo.GetFieldFromHandle%28System.RuntimeFieldHandle%29> method overload is used.</span></span> <span data-ttu-id="23e13-167">即使字段不属于类型`T`, 也是如此。</span><span class="sxs-lookup"><span data-stu-id="23e13-167">This is true even if the field is not of type `T`.</span></span>  
  
-   <span data-ttu-id="23e13-168">如果运行时类型句柄来自与运行时字段句柄相同的构造 (在`Test<string>`本例中为),则检索成功。<xref:System.Reflection.FieldInfo></span><span class="sxs-lookup"><span data-stu-id="23e13-168">A <xref:System.Reflection.FieldInfo> is retrieved successfully if the runtime type handle is from the same construction as the runtime field handle, in this case `Test<string>`.</span></span>  
  
-   <span data-ttu-id="23e13-169">如果运行时类型句柄来自兼容的构造, 在这种`Test<object>`情况下<xref:System.Reflection.FieldInfo> , 将检索兼容构造中的字段的。</span><span class="sxs-lookup"><span data-stu-id="23e13-169">If the runtime type handle is from a compatible construction, in this case `Test<object>`, a <xref:System.Reflection.FieldInfo> for the field on the compatible construction is retrieved.</span></span>  
  
-   <span data-ttu-id="23e13-170">如果运行时类型句柄不来自兼容的构造, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="23e13-170">If the runtime type handle is not from a compatible construction, an exception is thrown.</span></span> <span data-ttu-id="23e13-171">在这种情况下, 将为`T`指定一个值类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-171">In this case, a value type is specified for `T`.</span></span>  
  
 [!code-csharp[FieldInfo_GetFieldFromHandle2#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle2/cs/source.cs#1)]
 [!code-vb[FieldInfo_GetFieldFromHandle2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetFieldFromHandle2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="23e13-172"><paramref name="handle" /> 无效。</span><span class="sxs-lookup"><span data-stu-id="23e13-172"><paramref name="handle" /> is invalid.</span></span>  
  
<span data-ttu-id="23e13-173">或</span><span class="sxs-lookup"><span data-stu-id="23e13-173">-or-</span></span> 
 <span data-ttu-id="23e13-174"><paramref name="declaringType" /> 与 <paramref name="handle" /> 不兼容。</span><span class="sxs-lookup"><span data-stu-id="23e13-174"><paramref name="declaringType" /> is not compatible with <paramref name="handle" />.</span></span> <span data-ttu-id="23e13-175">例如，<paramref name="declaringType" /> 是泛型类型定义的运行时类型句柄，且 <paramref name="handle" /> 来自于构造类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-175">For example, <paramref name="declaringType" /> is the runtime type handle of the generic type definition, and <paramref name="handle" /> comes from a constructed type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-176">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-176">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-177">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-177">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="fieldInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="23e13-178">返回此实例的哈希代码。</span><span class="sxs-lookup"><span data-stu-id="23e13-178">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="23e13-179">32 位有符号整数哈希代码。</span><span class="sxs-lookup"><span data-stu-id="23e13-179">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOptionalCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetOptionalCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetOptionalCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetOptionalCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOptionalCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetOptionalCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetOptionalCustomModifiers : unit -&gt; Type[]&#xA;override this.GetOptionalCustomModifiers : unit -&gt; Type[]" Usage="fieldInfo.GetOptionalCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="23e13-180">获取一个类型数组，这些类型标识字段的可选自定义修饰符。</span><span class="sxs-lookup"><span data-stu-id="23e13-180">Gets an array of types that identify the optional custom modifiers of the field.</span></span></summary>
        <returns><span data-ttu-id="23e13-181"><see cref="T:System.Type" /> 对象的数组，这些对象标识当前字段的可选自定义修饰符（例如 <see cref="T:System.Runtime.CompilerServices.IsConst" />）。</span><span class="sxs-lookup"><span data-stu-id="23e13-181">An array of <see cref="T:System.Type" /> objects that identify the optional custom modifiers of the current field, such as <see cref="T:System.Runtime.CompilerServices.IsConst" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-182">为托管<xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A>编译器的设计器提供和方法。<xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A></span><span class="sxs-lookup"><span data-stu-id="23e13-182">The <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> and <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> methods are provided for designers of managed compilers.</span></span> <span data-ttu-id="23e13-183">有关自定义修饰符的详细信息, <xref:System.Runtime.CompilerServices.IsBoxed>请参阅和 ECMA Partition <xref:System.Runtime.CompilerServices> II 文档中的命名空间和元数据规范中的相关类。</span><span class="sxs-lookup"><span data-stu-id="23e13-183">For more information on custom modifiers, see <xref:System.Runtime.CompilerServices.IsBoxed> and related classes in the <xref:System.Runtime.CompilerServices> namespace and the metadata specification in the ECMA Partition II documentation.</span></span> <span data-ttu-id="23e13-184">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="23e13-184">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawConstantValue">
      <MemberSignature Language="C#" Value="public virtual object GetRawConstantValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetRawConstantValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetRawConstantValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRawConstantValue () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetRawConstantValue();" />
      <MemberSignature Language="F#" Value="abstract member GetRawConstantValue : unit -&gt; obj&#xA;override this.GetRawConstantValue : unit -&gt; obj" Usage="fieldInfo.GetRawConstantValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="23e13-185">由编译器返回与字段关联的文本值。</span><span class="sxs-lookup"><span data-stu-id="23e13-185">Returns a literal value associated with the field by a compiler.</span></span></summary>
        <returns><span data-ttu-id="23e13-186">一个 <see cref="T:System.Object" />，它包含与此字段关联的文本值。</span><span class="sxs-lookup"><span data-stu-id="23e13-186">An <see cref="T:System.Object" /> that contains the literal value associated with the field.</span></span> <span data-ttu-id="23e13-187">如果文本值是一个元素值为零的类类型，则返回值为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-187">If the literal value is a class type with an element value of zero, the return value is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-188">此方法是为托管编译器和代码分析器的设计器提供的。</span><span class="sxs-lookup"><span data-stu-id="23e13-188">This method is provided for designers of managed compilers and code analyzers.</span></span>  
  
 <span data-ttu-id="23e13-189">此方法可用于执行上下文和仅反射上下文中。</span><span class="sxs-lookup"><span data-stu-id="23e13-189">This method can be used in both the execution context and the reflection-only context.</span></span>  
  
 <span data-ttu-id="23e13-190">在非托管元数据中, 常量表用于存储字段、参数和属性的常量值。</span><span class="sxs-lookup"><span data-stu-id="23e13-190">In unmanaged metadata, the Constant table is used to store constant values for fields, parameters, and properties.</span></span> <span data-ttu-id="23e13-191">常数信息不会直接影响运行时行为。</span><span class="sxs-lookup"><span data-stu-id="23e13-191">Constant information does not directly influence runtime behavior.</span></span> <span data-ttu-id="23e13-192">导入元数据时, 编译器会在编译时检查此信息。</span><span class="sxs-lookup"><span data-stu-id="23e13-192">Compilers inspect this information, at compile time, when importing metadata.</span></span> <span data-ttu-id="23e13-193">如果使用, 则常数的值嵌入到编译器发出的 Microsoft 中间语言 (MSIL) 流中。</span><span class="sxs-lookup"><span data-stu-id="23e13-193">If used, the value of a constant is embedded in the Microsoft intermediate language (MSIL) stream the compiler emits.</span></span> <span data-ttu-id="23e13-194">在运行时, 不能使用 MSIL 指令来访问常量表。</span><span class="sxs-lookup"><span data-stu-id="23e13-194">There are no MSIL instructions that can be used to access the Constant table at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-195">有关常量值和常量表的详细信息, 请参阅 ECMA Partition II 文档。</span><span class="sxs-lookup"><span data-stu-id="23e13-195">For more information on constant values and the Constant table, see the ECMA Partition II documentation.</span></span> <span data-ttu-id="23e13-196">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="23e13-196">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="23e13-197">非托管元数据中的常数表不包含当前字段的常数值。</span><span class="sxs-lookup"><span data-stu-id="23e13-197">The Constant table in unmanaged metadata does not contain a constant value for the current field.</span></span></exception>
        <exception cref="T:System.FormatException"><span data-ttu-id="23e13-198">值的类型不是公共语言规范 (CLS) 许可的类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-198">The type of the value is not one of the types permitted by the Common Language Specification (CLS).</span></span> <span data-ttu-id="23e13-199">请参阅“ECMA 分区 II 规范元数据逻辑格式：其他结构、签名中使用的元素类型”。</span><span class="sxs-lookup"><span data-stu-id="23e13-199">See the ECMA Partition II specification Metadata Logical Format: Other Structures, Element Types used in Signatures.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="23e13-200">未设置该字段的常数值。</span><span class="sxs-lookup"><span data-stu-id="23e13-200">The constant value for the field is not set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequiredCustomModifiers">
      <MemberSignature Language="C#" Value="public virtual Type[] GetRequiredCustomModifiers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetRequiredCustomModifiers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetRequiredCustomModifiers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetRequiredCustomModifiers () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetRequiredCustomModifiers();" />
      <MemberSignature Language="F#" Value="abstract member GetRequiredCustomModifiers : unit -&gt; Type[]&#xA;override this.GetRequiredCustomModifiers : unit -&gt; Type[]" Usage="fieldInfo.GetRequiredCustomModifiers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="23e13-201">获取一个类型数组，这些类型标识属性所需的自定义修饰符。</span><span class="sxs-lookup"><span data-stu-id="23e13-201">Gets an array of types that identify the required custom modifiers of the property.</span></span></summary>
        <returns><span data-ttu-id="23e13-202"><see cref="T:System.Type" /> 对象的数组，这些对象标识当前属性所必需的自定义修饰符（例如 <see cref="T:System.Runtime.CompilerServices.IsConst" /> 或 <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />）。</span><span class="sxs-lookup"><span data-stu-id="23e13-202">An array of <see cref="T:System.Type" /> objects that identify the required custom modifiers of the current property, such as <see cref="T:System.Runtime.CompilerServices.IsConst" /> or <see cref="T:System.Runtime.CompilerServices.IsImplicitlyDereferenced" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-203">为托管<xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A>编译器的设计器提供和方法。<xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A></span><span class="sxs-lookup"><span data-stu-id="23e13-203">The <xref:System.Reflection.FieldInfo.GetOptionalCustomModifiers%2A> and <xref:System.Reflection.FieldInfo.GetRequiredCustomModifiers%2A> methods are provided for designers of managed compilers.</span></span> <span data-ttu-id="23e13-204">有关自定义修饰符的详细信息, <xref:System.Runtime.CompilerServices.IsBoxed>请参阅和 ECMA Partition <xref:System.Runtime.CompilerServices> II 文档中的命名空间和元数据规范中的相关类。</span><span class="sxs-lookup"><span data-stu-id="23e13-204">For more information on custom modifiers, see <xref:System.Runtime.CompilerServices.IsBoxed> and related classes in the <xref:System.Runtime.CompilerServices> namespace and the metadata specification in the ECMA Partition II documentation.</span></span> <span data-ttu-id="23e13-205">可联机获取该文档；请参阅 MSDN 上的 [ECMA C# 和公共语言基础结构标准](https://go.microsoft.com/fwlink/?LinkID=99212)和 Ecma International 网站上的[标准 ECMA-335 - 公共语言基础结构 (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552)。</span><span class="sxs-lookup"><span data-stu-id="23e13-205">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="fieldInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public abstract object GetValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ GetValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member GetValue : obj -&gt; obj" Usage="fieldInfo.GetValue obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetValue(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="23e13-206">将返回其字段值的对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-206">The object whose field value will be returned.</span></span></param>
        <summary><span data-ttu-id="23e13-207">当在派生类中重写时，返回给定对象支持的字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-207">When overridden in a derived class, returns the value of a field supported by a given object.</span></span></summary>
        <returns><span data-ttu-id="23e13-208">一个对象，包含此实例反映的字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-208">An object containing the value of the field reflected by this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-209">如果该字段为静态, `obj`则忽略。</span><span class="sxs-lookup"><span data-stu-id="23e13-209">If the field is static, `obj` is ignored.</span></span> <span data-ttu-id="23e13-210">对于非静态字段, `obj`应为继承或声明该字段的类的实例。</span><span class="sxs-lookup"><span data-stu-id="23e13-210">For non-static fields, `obj` should be an instance of a class that inherits or declares the field.</span></span> <span data-ttu-id="23e13-211">请注意, 的返回类型`GetValue`是`Object`。</span><span class="sxs-lookup"><span data-stu-id="23e13-211">Note that the return type of `GetValue` is `Object`.</span></span> <span data-ttu-id="23e13-212">例如, 如果该字段包含布尔基元值, 则返回一个具有相应`Object`布尔值的实例。</span><span class="sxs-lookup"><span data-stu-id="23e13-212">For example, if the field holds a Boolean primitive value, an instance of `Object` with the appropriate Boolean value is returned.</span></span> <span data-ttu-id="23e13-213">返回该值之前, `GetValue`请检查用户是否具有访问权限。</span><span class="sxs-lookup"><span data-stu-id="23e13-213">Before returning the value, `GetValue` checks to see if the user has access permission.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-214">对于完全受信任的代码, 将忽略访问限制。</span><span class="sxs-lookup"><span data-stu-id="23e13-214">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="23e13-215">也就是说, 只要代码完全受信任, 就可以通过反射访问和调用私有构造函数、方法、字段和属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-215">That is, private constructors, methods, fields, and properties can be accessed and invoked through reflection whenever the code is fully trusted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-216">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少.</span><span class="sxs-lookup"><span data-stu-id="23e13-216">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="23e13-217">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="23e13-217">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="23e13-218">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="23e13-218">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-219">下面的示例使用<xref:System.Reflection.FieldInfo.GetValue%2A>方法检索静态字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-219">The following example uses the <xref:System.Reflection.FieldInfo.GetValue%2A> method to retrieve the value of a static field.</span></span> <span data-ttu-id="23e13-220">请注意, `obj`参数的值为`null`。</span><span class="sxs-lookup"><span data-stu-id="23e13-220">Note that the value of the `obj` argument is `null`.</span></span>  
  
 [!code-cpp[getfldval#1](~/samples/snippets/cpp/VS_Snippets_CLR/GetFldVal/CPP/getfldval.cpp#1)]
 [!code-csharp[getfldval#1](~/samples/snippets/csharp/VS_Snippets_CLR/GetFldVal/CS/getfldval.cs#1)]
 [!code-vb[getfldval#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/GetFldVal/VB/getfldval.vb#1)]  
  
 <span data-ttu-id="23e13-221">下面<xref:System.Reflection.FieldInfo>的示例检索表示`FieldsClass`类型字段的对象的数组<xref:System.Reflection.FieldInfo.GetValue%2A> , 然后调用以`fieldsInst`显示对象的每个字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-221">The following example retrieves an array of <xref:System.Reflection.FieldInfo> objects that represents the fields of the `FieldsClass` type, and then calls the <xref:System.Reflection.FieldInfo.GetValue%2A> to display the value of each field for the `fieldsInst` object.</span></span>  
  
 [!code-cpp[FieldInfo_GetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_GetValue/CPP/fieldinfo_getvalue.cpp#1)]
 [!code-csharp[FieldInfo_GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_GetValue/CS/fieldinfo_getvalue.cs#1)]
 [!code-vb[FieldInfo_GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_GetValue/VB/fieldinfo_getvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="23e13-222">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获 <see cref="T:System.Exception" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-222">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="23e13-223">该字段是非静态的，并且 <paramref name="obj" /> 是 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-223">The field is non-static and <paramref name="obj" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="23e13-224">字段被标记为文本，但该字段不具有一个可被接受的文本类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-224">A field is marked literal, but the field does not have one of the accepted literal types.</span></span></exception>
        <exception cref="T:System.FieldAccessException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="23e13-225">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.MemberAccessException" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-225">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="23e13-226">调用方没有权限来访问此字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-226">The caller does not have permission to access this field.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="23e13-227">该方法既不由 <paramref name="obj" /> 的类声明也不由其继承。</span><span class="sxs-lookup"><span data-stu-id="23e13-227">The method is neither declared nor inherited by the class of <paramref name="obj" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-228">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-228">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-229">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-229">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetValueDirect">
      <MemberSignature Language="C#" Value="public virtual object GetValueDirect (TypedReference obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetValueDirect(valuetype System.TypedReference obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.GetValueDirect(System.TypedReference)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueDirect (obj As TypedReference) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetValueDirect(TypedReference obj);" />
      <MemberSignature Language="F#" Value="abstract member GetValueDirect : TypedReference -&gt; obj&#xA;override this.GetValueDirect : TypedReference -&gt; obj" Usage="fieldInfo.GetValueDirect obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetValueDirect(System.TypedReference)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.TypedReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="23e13-230"><see cref="T:System.TypedReference" /> 结构，封装指向某个位置的托管指针和可能存储在该位置的类型的运行时表示形式。</span><span class="sxs-lookup"><span data-stu-id="23e13-230">A <see cref="T:System.TypedReference" /> structure that encapsulates a managed pointer to a location and a runtime representation of the type that might be stored at that location.</span></span></param>
        <summary><span data-ttu-id="23e13-231">返回给定对象所支持的字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-231">Returns the value of a field supported by a given object.</span></span></summary>
        <returns><span data-ttu-id="23e13-232">包含字段值的 <see langword="Object" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-232">An <see langword="Object" /> containing a field value.</span></span></returns>
        <remarks>To be added.</remarks>
        <altCompliant cref="M:System.Reflection.FieldInfo.GetValue(System.Object)" />
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="23e13-233">调用方需要公共语言规范 (CLS) 的替代项，但改为调用此方法。</span><span class="sxs-lookup"><span data-stu-id="23e13-233">The caller requires the Common Language Specification (CLS) alternative, but called this method instead.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-234">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-234">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-235">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-235">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAssembly : bool" Usage="System.Reflection.FieldInfo.IsAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-236">获取一个值，该值指示此字段的潜在可见性是否由 <see cref="F:System.Reflection.FieldAttributes.Assembly" /> 描述；也就是说，此字段只对同一程序集中的其他类型可见，而对该程序集以外的派生类型则不可见。</span><span class="sxs-lookup"><span data-stu-id="23e13-236">Gets a value indicating whether the potential visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.Assembly" />; that is, the field is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span></span></summary>
        <value><span data-ttu-id="23e13-237">如果此字段的可见性由 <see cref="F:System.Reflection.FieldAttributes.Assembly" /> 准确描述，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-237"><see langword="true" /> if the visibility of this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.Assembly" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-238">字段的实际可见性受到其类型的可见性的限制。</span><span class="sxs-lookup"><span data-stu-id="23e13-238">The actual visibility of a field is limited by the visibility of its type.</span></span> <span data-ttu-id="23e13-239"><xref:System.Reflection.FieldInfo.IsAssembly%2A> 属性`true`可能适用于字段, 但如果它是私有嵌套类型的字段, 则该字段在包含类型外不可见。</span><span class="sxs-lookup"><span data-stu-id="23e13-239">The <xref:System.Reflection.FieldInfo.IsAssembly%2A> property might be `true` for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="23e13-240"><xref:System.Reflection.FieldAttributes.Assembly?displayProperty=nameWithType>如果唯一的可见性修饰符为`internal` (`Friend`在 Visual Basic 中), 则完全描述字段的可见性。</span><span class="sxs-lookup"><span data-stu-id="23e13-240">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="23e13-241">此`false`属性<xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>用于`protected internal`中C#的字段 (`Protected Friend`在 Visual Basic 中, `protected public`在中C++为); 使用属性来标识此类字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-241">This property is `false` for fields that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property to identify such fields.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-242">下面的代码示例定义具有不同级别的可见性的字段, <xref:System.Reflection.FieldInfo.IsAssembly%2A>并显示它们的、 <xref:System.Reflection.FieldInfo.IsFamily%2A>、 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>和<xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A>属性的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-242">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-243">Visual Basic 和C#语言不能使用<xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType>可见性定义字段; 该访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="23e13-243">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamily : bool" Usage="System.Reflection.FieldInfo.IsFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-244">获取一个值，该值指示此字段的可见性是否由 <see cref="F:System.Reflection.FieldAttributes.Family" /> 描述；也就是说，此字段仅在其类和派生类内可见。</span><span class="sxs-lookup"><span data-stu-id="23e13-244">Gets a value indicating whether the visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.Family" />; that is, the field is visible only within its class and derived classes.</span></span></summary>
        <value><span data-ttu-id="23e13-245">如果对此字段的访问由 <see cref="F:System.Reflection.FieldAttributes.Family" /> 准确描述，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-245"><see langword="true" /> if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.Family" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-246"><xref:System.Reflection.FieldAttributes.Family?displayProperty=nameWithType>如果唯一的可见性修饰符为`protected`, 则完全描述字段的可见性。</span><span class="sxs-lookup"><span data-stu-id="23e13-246">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="23e13-247">此`false`属性<xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>用于`protected internal`中C#的字段 (`Protected Friend`在 Visual Basic 中, `protected public`在中C++为); 使用属性来标识此类字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-247">This property is `false` for fields that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property to identify such fields.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-248">下面的代码示例定义具有不同级别的可见性的字段, <xref:System.Reflection.FieldInfo.IsAssembly%2A>并显示它们的、 <xref:System.Reflection.FieldInfo.IsFamily%2A>、 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>和<xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A>属性的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-248">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-249">Visual Basic 和C#语言不能使用<xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType>可见性定义字段; 该访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="23e13-249">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Type" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyAndAssembly : bool" Usage="System.Reflection.FieldInfo.IsFamilyAndAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-250">获取一个值，该值指示此字段的可见性是否由 <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" /> 描述；也就是说，可从派生类访问此字段，但仅当这些派生类在同一程序集中时。</span><span class="sxs-lookup"><span data-stu-id="23e13-250">Gets a value indicating whether the visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />; that is, the field can be accessed from derived classes, but only if they are in the same assembly.</span></span></summary>
        <value><span data-ttu-id="23e13-251">如果对此字段的访问由 <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" /> 准确描述，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-251"><see langword="true" /> if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-252">如果字段具有<xref:System.Reflection.FieldAttributes.FamANDAssem>级别可见性, 则可以从派生类中也位于同一程序集, 但不是从任何其他类型的任何成员中调用它。</span><span class="sxs-lookup"><span data-stu-id="23e13-252">If a field has <xref:System.Reflection.FieldAttributes.FamANDAssem> level visibility, it can be called from any member in a derived class that is also in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="23e13-253"><xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType>如果可见性`protected private`修饰符在中C++, 则会严格描述字段的可见性。</span><span class="sxs-lookup"><span data-stu-id="23e13-253">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="23e13-254">具有此可见性的字段不能在 Visual Basic C#或中定义。</span><span class="sxs-lookup"><span data-stu-id="23e13-254">Fields with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-255">下面的代码示例定义具有不同级别的可见性的字段, <xref:System.Reflection.FieldInfo.IsAssembly%2A>并显示它们的、 <xref:System.Reflection.FieldInfo.IsFamily%2A>、 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>和<xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A>属性的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-255">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-256">Visual Basic 和C#语言不能使用<xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType>可见性定义字段; 该访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="23e13-256">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFamilyOrAssembly : bool" Usage="System.Reflection.FieldInfo.IsFamilyOrAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-257">获取一个值，该值指示此字段的潜在可见性是否由 <see cref="F:System.Reflection.FieldAttributes.FamORAssem" /> 描述；也就是说，可通过派生类（无论其位置如何）和同一程序集中的类访问此字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-257">Gets a value indicating whether the potential visibility of this field is described by <see cref="F:System.Reflection.FieldAttributes.FamORAssem" />; that is, the field can be accessed by derived classes wherever they are, and by classes in the same assembly.</span></span></summary>
        <value><span data-ttu-id="23e13-258">如果对此字段的访问由 <see cref="F:System.Reflection.FieldAttributes.FamORAssem" /> 准确描述，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-258"><see langword="true" /> if access to this field is exactly described by <see cref="F:System.Reflection.FieldAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-259">如果字段具有<xref:System.Reflection.FieldAttributes.FamORAssem>级别可见性, 则可以从派生类中的任何成员或同一程序集中的任何成员 (而不是任何其他类型) 调用它。</span><span class="sxs-lookup"><span data-stu-id="23e13-259">If a field has <xref:System.Reflection.FieldAttributes.FamORAssem> level visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="23e13-260">字段的实际可见性受到其类型的可见性的限制。</span><span class="sxs-lookup"><span data-stu-id="23e13-260">The actual visibility of a field is limited by the visibility of its type.</span></span> <span data-ttu-id="23e13-261"><xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> 属性`true`可能适用于字段, 但如果它是私有嵌套类型的字段, 则该字段在包含类型外不可见。</span><span class="sxs-lookup"><span data-stu-id="23e13-261">The <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A> property might be `true` for a field, but if it is a field of a private nested type then the field is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="23e13-262"><xref:System.Reflection.FieldAttributes.FamORAssem?displayProperty=nameWithType>如果可见性修饰符处于C# `Protected Friend` `protected internal` C++中 (Visual Basic中为),则完全描述字段的可见性。`protected public`</span><span class="sxs-lookup"><span data-stu-id="23e13-262">The visibility of a field is exactly described by <xref:System.Reflection.FieldAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-263">下面的代码示例定义具有不同级别的可见性的字段, <xref:System.Reflection.FieldInfo.IsAssembly%2A>并显示它们的、 <xref:System.Reflection.FieldInfo.IsFamily%2A>、 <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>和<xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A>属性的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-263">The following code example defines fields with varying levels of visibility, and displays the values of their <xref:System.Reflection.FieldInfo.IsAssembly%2A>, <xref:System.Reflection.FieldInfo.IsFamily%2A>, <xref:System.Reflection.FieldInfo.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.FieldInfo.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-264">Visual Basic 和C#语言不能使用<xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType>可见性定义字段; 该访问级别仅出现在C++示例中。</span><span class="sxs-lookup"><span data-stu-id="23e13-264">The Visual Basic and C# languages cannot define fields with <xref:System.Reflection.FieldAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="P:System.Reflection.FieldInfo.IsAssembly" />
        <altmember cref="P:System.Reflection.FieldInfo.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsInitOnly">
      <MemberSignature Language="C#" Value="public bool IsInitOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsInitOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInitOnly : bool" Usage="System.Reflection.FieldInfo.IsInitOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsInitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-265">获取一个值，通过该值指示此字段是否只能在构造函数的主体中设置。</span><span class="sxs-lookup"><span data-stu-id="23e13-265">Gets a value indicating whether the field can only be set in the body of the constructor.</span></span></summary>
        <value><span data-ttu-id="23e13-266">如果字段设置了 <see langword="true" /> 属性，则为 <see langword="InitOnly" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-266"><see langword="true" /> if the field has the <see langword="InitOnly" /> attribute set; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-267">如果返回的值为`true`, 则字段只能初始化, 此后为只读。</span><span class="sxs-lookup"><span data-stu-id="23e13-267">If the returned value is `true`, the field can only be initialized, and is read-only thereafter.</span></span>  
  
 <span data-ttu-id="23e13-268">若要获取`IsInitOnly`属性, 请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="23e13-268">To get the `IsInitOnly` property, first get the class `Type`.</span></span> <span data-ttu-id="23e13-269">`Type`从中`FieldInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="23e13-269">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="23e13-270">`FieldInfo`从中`IsInitOnly`获取属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-270">From the `FieldInfo`, get the `IsInitOnly` property.</span></span> <span data-ttu-id="23e13-271">若要访问非公共字段<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> , 请<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>在`GetField`方法中与或<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>两者结合使用。</span><span class="sxs-lookup"><span data-stu-id="23e13-271">To access a non-public field, combine <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> with either or both of <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in the `GetField` method.</span></span>  
  
 <span data-ttu-id="23e13-272">设置`IsInitOnly` 属性<xref:System.Reflection.FieldAttributes.InitOnly?displayProperty=nameWithType>时, 设置属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-272">The `IsInitOnly` property is set when the <xref:System.Reflection.FieldAttributes.InitOnly?displayProperty=nameWithType> attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-273">在下面的示例中, 创建了两个字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-273">In the following example, two fields are created.</span></span> <span data-ttu-id="23e13-274">第二个字段是只读的, 没有 set 访问器, 且`IsInitOnly`设置为。 `true`</span><span class="sxs-lookup"><span data-stu-id="23e13-274">The second field is read-only, having no set accessor, and `IsInitOnly` is set to `true`.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsInitOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsInitOnly Example/VB/source.vb#1)]  
  
 <span data-ttu-id="23e13-275">此代码生成以下输出：</span><span class="sxs-lookup"><span data-stu-id="23e13-275">This code produces the following output:</span></span>  
  
 <span data-ttu-id="23e13-276">Reflection.FieldInfo</span><span class="sxs-lookup"><span data-stu-id="23e13-276">Reflection.FieldInfo</span></span>  
  
 <span data-ttu-id="23e13-277">Myfielda-已修改, IsInitOnly = False</span><span class="sxs-lookup"><span data-stu-id="23e13-277">Myfielda - A- modified, IsInitOnly = False</span></span>  
  
 <span data-ttu-id="23e13-278">Myfieldb-B readonly field, IsInitOnly = True</span><span class="sxs-lookup"><span data-stu-id="23e13-278">Myfieldb - B readonly field, IsInitOnly = True</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="IsLiteral">
      <MemberSignature Language="C#" Value="public bool IsLiteral { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLiteral" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsLiteral" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLiteral As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLiteral { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLiteral : bool" Usage="System.Reflection.FieldInfo.IsLiteral" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsLiteral</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-279">获取一个值，通过该值指示该值是否在编译时写入并且不能更改。</span><span class="sxs-lookup"><span data-stu-id="23e13-279">Gets a value indicating whether the value is written at compile time and cannot be changed.</span></span></summary>
        <value><span data-ttu-id="23e13-280">如果字段设置了 <see langword="true" /> 属性，则为 <see langword="Literal" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-280"><see langword="true" /> if the field has the <see langword="Literal" /> attribute set; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-281">设置`IsLiteral` 属性`FieldAttributes.Literal`时, 设置属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-281">The `IsLiteral` property is set when the `FieldAttributes.Literal` attribute is set.</span></span> <span data-ttu-id="23e13-282">如果设置此属性, 则不能更改该字段, 并且该字段是常量。</span><span class="sxs-lookup"><span data-stu-id="23e13-282">If this attribute is set, the field cannot be changed and is constant.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotSerialized">
      <MemberSignature Language="C#" Value="public bool IsNotSerialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotSerialized" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsNotSerialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotSerialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotSerialized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotSerialized : bool" Usage="System.Reflection.FieldInfo.IsNotSerialized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsNotSerialized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-283">获取一个值，通过该值指示此字段是否有 <see langword="NotSerialized" /> 特性。</span><span class="sxs-lookup"><span data-stu-id="23e13-283">Gets a value indicating whether this field has the <see langword="NotSerialized" /> attribute.</span></span></summary>
        <value><span data-ttu-id="23e13-284">如果字段设置了 <see langword="true" /> 属性，则为 <see langword="NotSerialized" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-284"><see langword="true" /> if the field has the <see langword="NotSerialized" /> attribute set; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-285">如果`IsNotSerialized` 字段标记`true`有标志,则该属性返回。`FieldAttributes.NotSerialized`</span><span class="sxs-lookup"><span data-stu-id="23e13-285">The `IsNotSerialized` property returns `true` when the field is marked with the `FieldAttributes.NotSerialized` flag.</span></span> <span data-ttu-id="23e13-286">如果对字段设置了此标志, 则指示在类型为远程时不需要序列化该字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-286">When this flag is set on a field, it indicates that the field does not have to be serialized when the type is remoted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-287">下面的示例获取 MyClass 字段的字段信息, 确定是否可以序列化这些字段并显示结果。</span><span class="sxs-lookup"><span data-stu-id="23e13-287">The following example gets the field information of the fields of MyClass, determines if the fields can be serialized, and displays the results.</span></span>  
  
 [!code-cpp[FieldInfo_IsNotSerialized#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsNotSerialized/CPP/fieldinfo_isnotserialized.cpp#1)]
 [!code-csharp[FieldInfo_IsNotSerialized#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsNotSerialized/CS/fieldinfo_isnotserialized.cs#1)]
 [!code-vb[FieldInfo_IsNotSerialized#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsNotSerialized/VB/fieldinfo_isnotserialized.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPinvokeImpl">
      <MemberSignature Language="C#" Value="public bool IsPinvokeImpl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPinvokeImpl" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPinvokeImpl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPinvokeImpl As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPinvokeImpl { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPinvokeImpl : bool" Usage="System.Reflection.FieldInfo.IsPinvokeImpl" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPinvokeImpl</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-288">获取一个值，该值指示是否已在 <see cref="T:System.Reflection.FieldAttributes" /> 中设置相应的 <see langword="PinvokeImpl" /> 特性。</span><span class="sxs-lookup"><span data-stu-id="23e13-288">Gets a value indicating whether the corresponding <see langword="PinvokeImpl" /> attribute is set in <see cref="T:System.Reflection.FieldAttributes" />.</span></span></summary>
        <value><span data-ttu-id="23e13-289">如果在 <see cref="T:System.Reflection.FieldAttributes" /> 中设置了 <see langword="true" /> 特性，则为 <see langword="PinvokeImpl" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-289"><see langword="true" /> if the <see langword="PinvokeImpl" /> attribute is set in <see cref="T:System.Reflection.FieldAttributes" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="23e13-290">下面的示例创建一个类, 并显示该字段的名称<xref:System.Reflection.FieldInfo.IsPinvokeImpl%2A> 、字段和属性值。</span><span class="sxs-lookup"><span data-stu-id="23e13-290">The following example creates a class and displays the name, field and <xref:System.Reflection.FieldInfo.IsPinvokeImpl%2A> property value of the field.</span></span>  
  
 [!code-cpp[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/CPP/fieldinfo_ispinvokeimpl.cpp#1)]
 [!code-csharp[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/CS/fieldinfo_ispinvokeimpl.cs#1)]
 [!code-vb[FieldInfo_IsPInvokeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsPInvokeImpl/VB/fieldinfo_ispinvokeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrivate : bool" Usage="System.Reflection.FieldInfo.IsPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-291">获取一个值，通过该值指示此字段是否为私有字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-291">Gets a value indicating whether the field is private.</span></span></summary>
        <value><span data-ttu-id="23e13-292">如果此字段为私有字段，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-292"><see langword="true" /> if the field is private; otherwise; <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-293">只能通过成员函数访问私有字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-293">Private fields are accessible only from member functions.</span></span>  
  
 <span data-ttu-id="23e13-294">设置`IsPrivate` 属性`FieldAttributes.Private`时, 设置属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-294">The `IsPrivate` property is set when the `FieldAttributes.Private` attribute is set.</span></span>  
  
 <span data-ttu-id="23e13-295">若要获取`IsPrivate`属性, 请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="23e13-295">To get the `IsPrivate` property, first get the class `Type`.</span></span> <span data-ttu-id="23e13-296">`Type`从中`FieldInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="23e13-296">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="23e13-297">`FieldInfo`从中`IsPrivate`获取属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-297">From the `FieldInfo`, get the `IsPrivate` property.</span></span> <span data-ttu-id="23e13-298">若要访问非公共字段, 请`BindingFlags`在`GetField`方法中将设置为`Static` , `Instance`并将或设置为`NonPublic`或。</span><span class="sxs-lookup"><span data-stu-id="23e13-298">To access a non-public field, set the `BindingFlags` to `NonPublic`, and either `Static` or `Instance` in the `GetField` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-299">下面的示例返回一个值, 该值指示类的字段是否是私有的。</span><span class="sxs-lookup"><span data-stu-id="23e13-299">The following example returns a value indicating whether or not the field of the class is private.</span></span>  
  
 [!code-cpp[FieldInfo_IsPrivate#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsPrivate/CPP/fieldinfo_isprivate.cpp#1)]
 [!code-csharp[FieldInfo_IsPrivate#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsPrivate/CS/fieldinfo_isprivate.cs#1)]
 [!code-vb[FieldInfo_IsPrivate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsPrivate/VB/fieldinfo_isprivate.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Reflection.FieldInfo.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-300">获取一个值，通过该值指示此字段是否为公共字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-300">Gets a value indicating whether the field is public.</span></span></summary>
        <value><span data-ttu-id="23e13-301">如果此字段为公共字段，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-301"><see langword="true" /> if this field is public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-302">公共字段在其对应类可见的任何位置都是可访问的。</span><span class="sxs-lookup"><span data-stu-id="23e13-302">Public fields are accessible everywhere their corresponding classes are visible.</span></span>  
  
 <span data-ttu-id="23e13-303">设置`IsPublic` 属性`FieldAttributes.Public`时, 设置属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-303">The `IsPublic` property is set when the `FieldAttributes.Public` attribute is set.</span></span>  
  
 <span data-ttu-id="23e13-304">若要获取`IsPublic`属性, 请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="23e13-304">To get the `IsPublic` property, first get the class `Type`.</span></span> <span data-ttu-id="23e13-305">`Type`从中`FieldInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="23e13-305">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="23e13-306">`FieldInfo`从中`IsPublic`获取属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-306">From the `FieldInfo`, get the `IsPublic` property.</span></span> <span data-ttu-id="23e13-307">如果此字段不是公共的, 则它是受保护的, 无法轻松访问。</span><span class="sxs-lookup"><span data-stu-id="23e13-307">If the field is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="23e13-308">若要访问非公共字段, 请`BindingFlags`将`NonPublic`设置为, `BindingFlags.Instance`指定`BindingFlags.Static`或, 并将此用于`GetField`方法。</span><span class="sxs-lookup"><span data-stu-id="23e13-308">To access a nonpublic field, set the `BindingFlags` to `NonPublic`, specify either `BindingFlags.Instance` or `BindingFlags.Static`, and use this for the `GetField` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-309">下面的示例返回一个值, 该值指示类的字段是公共的还是私有的。</span><span class="sxs-lookup"><span data-stu-id="23e13-309">The following example returns a value indicating whether or not the field of the class is public or private.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Reflection.FieldInfo.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-310">获取一个值，该值指示当前字段在当前信任级别上是安全关键的还是安全可靠关键的。</span><span class="sxs-lookup"><span data-stu-id="23e13-310">Gets a value that indicates whether the current field is security-critical or security-safe-critical at the current trust level.</span></span></summary>
        <value><span data-ttu-id="23e13-311">如果当前字段在当前信任级别上是安全关键的或安全可靠关键的，则为 <see langword="true" />；如果它是透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-311"><see langword="true" /> if the current field is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-312"><xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>、和属性<xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告字段的透明度级别。 <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="23e13-312">The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="23e13-313">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="23e13-313">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="23e13-314">安全级别</span><span class="sxs-lookup"><span data-stu-id="23e13-314">Security level</span></span>|<span data-ttu-id="23e13-315">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="23e13-315">IsSecurityCritical</span></span>|<span data-ttu-id="23e13-316">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="23e13-316">IsSecuritySafeCritical</span></span>|<span data-ttu-id="23e13-317">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="23e13-317">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="23e13-318">严重</span><span class="sxs-lookup"><span data-stu-id="23e13-318">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="23e13-319">安全关键</span><span class="sxs-lookup"><span data-stu-id="23e13-319">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="23e13-320">透明</span><span class="sxs-lookup"><span data-stu-id="23e13-320">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="23e13-321">使用这些属性比检查程序集及其类型和成员的安全批注、检查当前的信任级别以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="23e13-321">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="23e13-322">对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="23e13-322">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="23e13-323">如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="23e13-323">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="23e13-324">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="23e13-324">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="23e13-325">仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="23e13-325">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="23e13-326">相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="23e13-326">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="23e13-327">您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="23e13-327">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="23e13-328">有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="23e13-328">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="23e13-329">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="23e13-329">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-330">获取一个值，该值指示当前字段在当前信任级别上是否是安全可靠关键的。</span><span class="sxs-lookup"><span data-stu-id="23e13-330">Gets a value that indicates whether the current field is security-safe-critical at the current trust level.</span></span></summary>
        <value><span data-ttu-id="23e13-331">如果当前字段在当前信任级别上是安全可靠关键的，则为 <see langword="true" />；如果它是安全关键的或透明的，则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-331"><see langword="true" /> if the current field is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-332"><xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>、和属性<xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告字段的透明度级别。 <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="23e13-332">The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="23e13-333">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="23e13-333">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="23e13-334">安全级别</span><span class="sxs-lookup"><span data-stu-id="23e13-334">Security level</span></span>|<span data-ttu-id="23e13-335">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="23e13-335">IsSecurityCritical</span></span>|<span data-ttu-id="23e13-336">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="23e13-336">IsSecuritySafeCritical</span></span>|<span data-ttu-id="23e13-337">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="23e13-337">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="23e13-338">严重</span><span class="sxs-lookup"><span data-stu-id="23e13-338">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="23e13-339">安全关键</span><span class="sxs-lookup"><span data-stu-id="23e13-339">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="23e13-340">透明</span><span class="sxs-lookup"><span data-stu-id="23e13-340">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="23e13-341">使用这些属性比检查程序集及其类型和成员的安全批注、检查当前的信任级别以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="23e13-341">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="23e13-342">对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="23e13-342">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="23e13-343">如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="23e13-343">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="23e13-344">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="23e13-344">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="23e13-345">仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="23e13-345">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="23e13-346">相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="23e13-346">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="23e13-347">您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="23e13-347">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="23e13-348">有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="23e13-348">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="23e13-349">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="23e13-349">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Reflection.FieldInfo.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-350">获取一个值，该值指示当前字段在当前信任级别上是否是透明的。</span><span class="sxs-lookup"><span data-stu-id="23e13-350">Gets a value that indicates whether the current field is transparent at the current trust level.</span></span></summary>
        <value><span data-ttu-id="23e13-351">如果该字段在当前信任级别上是安全透明的，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-351"><see langword="true" /> if the field is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-352"><xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>、和属性<xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A>按公共语言运行时 (CLR) 确定的, 在其当前信任级别上报告字段的透明度级别。 <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A></span><span class="sxs-lookup"><span data-stu-id="23e13-352">The <xref:System.Reflection.FieldInfo.IsSecurityCritical%2A>, <xref:System.Reflection.FieldInfo.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.FieldInfo.IsSecurityTransparent%2A> properties report the transparency level of the field at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="23e13-353">下表显示了这些属性的组合:</span><span class="sxs-lookup"><span data-stu-id="23e13-353">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="23e13-354">安全级别</span><span class="sxs-lookup"><span data-stu-id="23e13-354">Security level</span></span>|<span data-ttu-id="23e13-355">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="23e13-355">IsSecurityCritical</span></span>|<span data-ttu-id="23e13-356">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="23e13-356">IsSecuritySafeCritical</span></span>|<span data-ttu-id="23e13-357">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="23e13-357">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="23e13-358">严重</span><span class="sxs-lookup"><span data-stu-id="23e13-358">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="23e13-359">安全关键</span><span class="sxs-lookup"><span data-stu-id="23e13-359">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="23e13-360">透明</span><span class="sxs-lookup"><span data-stu-id="23e13-360">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="23e13-361">使用这些属性比检查程序集及其类型和成员的安全批注、检查当前的信任级别以及尝试复制运行时的规则要简单得多。</span><span class="sxs-lookup"><span data-stu-id="23e13-361">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="23e13-362">对于部分信任的程序集, 此属性的值取决于程序集的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="23e13-362">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="23e13-363">如果将程序集加载到部分受信任的应用程序域中 (例如, 在沙盒应用程序域中), 则运行时将忽略程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="23e13-363">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="23e13-364">程序集及其所有类型都被视为透明。</span><span class="sxs-lookup"><span data-stu-id="23e13-364">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="23e13-365">仅当程序集加载到完全受信任的应用程序域中时 (例如, 在桌面应用程序的默认应用程序域中), 运行时才会注意到部分信任程序集的安全注释。</span><span class="sxs-lookup"><span data-stu-id="23e13-365">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="23e13-366">相反, 受信任的程序集 (即安装在全局程序集缓存中的强名称程序集) 始终以完全信任方式加载, 而不考虑应用程序域的信任级别, 因此, 其当前信任级别始终是完全受信任的。</span><span class="sxs-lookup"><span data-stu-id="23e13-366">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="23e13-367">您可以使用<xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType>和<xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>属性来确定程序集和应用程序域的当前信任级别。</span><span class="sxs-lookup"><span data-stu-id="23e13-367">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="23e13-368">有关反射和透明度的详细信息, 请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。</span><span class="sxs-lookup"><span data-stu-id="23e13-368">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="23e13-369">有关透明度的信息, 请参阅[安全更改](~/docs/framework/security/security-changes.md)。</span><span class="sxs-lookup"><span data-stu-id="23e13-369">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.FieldInfo.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.FieldInfo.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.FieldInfo.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-370">获取一个值，该值指示是否已在 <see cref="T:System.Reflection.FieldAttributes" /> 枚举数中设置相应的 <see langword="SpecialName" /> 特性。</span><span class="sxs-lookup"><span data-stu-id="23e13-370">Gets a value indicating whether the corresponding <see langword="SpecialName" /> attribute is set in the <see cref="T:System.Reflection.FieldAttributes" /> enumerator.</span></span></summary>
        <value><span data-ttu-id="23e13-371">如果在 <see cref="T:System.Reflection.FieldAttributes" /> 中设置了 <see langword="true" /> 特性，则为 <see langword="SpecialName" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-371"><see langword="true" /> if the <see langword="SpecialName" /> attribute is set in <see cref="T:System.Reflection.FieldAttributes" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-372">以或开头的名称包含下划线字符 (_)、属性访问器和运算符重载方法是可能需要某些编译器特殊处理的名称的示例。</span><span class="sxs-lookup"><span data-stu-id="23e13-372">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of names that might require special treatment by some compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-373">下面的示例返回一个值, 该值指示类中的字段是否包含 SpecialName 属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-373">The following example returns a value indicating whether or not the fields in the class contain a SpecialName attribute.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStatic : bool" Usage="System.Reflection.FieldInfo.IsStatic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-374">获取一个值，通过该值指示此字段是否为静态字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-374">Gets a value indicating whether the field is static.</span></span></summary>
        <value><span data-ttu-id="23e13-375">如果此字段为静态字段，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-375"><see langword="true" /> if this field is static; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-376">当某个字段为静态时, 该字段的一个副本将由该类型的所有实例共享。</span><span class="sxs-lookup"><span data-stu-id="23e13-376">When a field is static, one copy of the field is shared by all instances of the type.</span></span>  
  
 <span data-ttu-id="23e13-377">设置`IsStatic` 属性`FieldAttributes.Static`时, 设置属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-377">The `IsStatic` property is set when the `FieldAttributes.Static` attribute is set.</span></span>  
  
 <span data-ttu-id="23e13-378">若要获取`IsStatic`属性, 请首先获取类`Type`。</span><span class="sxs-lookup"><span data-stu-id="23e13-378">To get the `IsStatic` property, first get the class `Type`.</span></span> <span data-ttu-id="23e13-379">`Type`从中`FieldInfo`获取。</span><span class="sxs-lookup"><span data-stu-id="23e13-379">From the `Type`, get the `FieldInfo`.</span></span> <span data-ttu-id="23e13-380">`FieldInfo`从中`IsStatic`获取属性。</span><span class="sxs-lookup"><span data-stu-id="23e13-380">From the `FieldInfo`, get the `IsStatic` property.</span></span> <span data-ttu-id="23e13-381">若要访问非公共字段, 请在`BindingFlags` `GetField`方法中`NonPublic`将设置为, 并将可访问`Instance`性`Static`设置为或。</span><span class="sxs-lookup"><span data-stu-id="23e13-381">To access a non-public field, set the `BindingFlags` to `NonPublic` in the `GetField` method and set the accessibility to `Instance` or `Static`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-382">下面的示例确定指定的字段是否为静态, 并显示结果。</span><span class="sxs-lookup"><span data-stu-id="23e13-382">The following example determines whether the specified field is static and displays the result.</span></span>  
  
 [!code-cpp[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.IsStatic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.IsStatic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="23e13-383">此代码生成以下输出：</span><span class="sxs-lookup"><span data-stu-id="23e13-383">This code produces the following output:</span></span>  
  
 <span data-ttu-id="23e13-384">Reflection.FieldInfo</span><span class="sxs-lookup"><span data-stu-id="23e13-384">Reflection.FieldInfo</span></span>  
  
 <span data-ttu-id="23e13-385">Myfielda-专用字段;IsStatic-False</span><span class="sxs-lookup"><span data-stu-id="23e13-385">Myfielda - A private field; IsStatic - False</span></span>  
  
 <span data-ttu-id="23e13-386">Myfieldb-B 静态字段;IsStatic-True</span><span class="sxs-lookup"><span data-stu-id="23e13-386">Myfieldb - B static field; IsStatic - True</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldAttributes" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.FieldInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.FieldInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._FieldInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="23e13-387">获取 <see cref="T:System.Reflection.MemberTypes" /> 值，该值指示此成员是字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-387">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a field.</span></span></summary>
        <value><span data-ttu-id="23e13-388"><see cref="T:System.Reflection.MemberTypes" /> 值指示此成员是字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-388">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a field.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-389">此属性将<xref:System.Reflection.MemberInfo.MemberType%2A>重写。</span><span class="sxs-lookup"><span data-stu-id="23e13-389">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A>.</span></span> <span data-ttu-id="23e13-390">因此, 在<xref:System.Reflection.MemberInfo>检查一组对象时 (例如, <xref:System.Type.GetMembers%2A>返回<xref:System.Reflection.MemberInfo.MemberType%2A>的数组), 属性仅在给定成员<xref:System.Reflection.MemberTypes.Field?displayProperty=nameWithType>为字段时返回。</span><span class="sxs-lookup"><span data-stu-id="23e13-390">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.Field?displayProperty=nameWithType> only when a given member is a field.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-391">下面的示例确定指定的成员是否为字段并显示结果。</span><span class="sxs-lookup"><span data-stu-id="23e13-391">The following example determines whether the specified member is a field and displays the result.</span></span>  
  
 [!code-cpp[Classic FieldInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FieldInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic FieldInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FieldInfo.MemberType Example/VB/source.vb#1)]  
  
 <span data-ttu-id="23e13-392">此代码生成以下输出：</span><span class="sxs-lookup"><span data-stu-id="23e13-392">This code produces the following output:</span></span>  
  
 <span data-ttu-id="23e13-393">Reflection.FieldInfo</span><span class="sxs-lookup"><span data-stu-id="23e13-393">Reflection.FieldInfo</span></span>  
  
 <span data-ttu-id="23e13-394">Myfield-专用字段;MemberType 是一个字段</span><span class="sxs-lookup"><span data-stu-id="23e13-394">Myfield.field - a private field; MemberType is a Field</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.FieldInfo left, class System.Reflection.FieldInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.op_Equality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As FieldInfo, right As FieldInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::FieldInfo ^ left, System::Reflection::FieldInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.FieldInfo * System.Reflection.FieldInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.FieldInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.FieldInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="23e13-395">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-395">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="23e13-396">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-396">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="23e13-397">指示两个 <see cref="T:System.Reflection.FieldInfo" /> 对象是否相等。</span><span class="sxs-lookup"><span data-stu-id="23e13-397">Indicates whether two <see cref="T:System.Reflection.FieldInfo" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="23e13-398">如果 <see langword="true" /> 等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-398"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.FieldInfo left, class System.Reflection.FieldInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.op_Inequality(System.Reflection.FieldInfo,System.Reflection.FieldInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As FieldInfo, right As FieldInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::FieldInfo ^ left, System::Reflection::FieldInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.FieldInfo * System.Reflection.FieldInfo -&gt; bool" Usage="System.Reflection.FieldInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.FieldInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="right" Type="System.Reflection.FieldInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="23e13-399">要比较的第一个对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-399">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="23e13-400">要比较的第二个对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-400">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="23e13-401">指示两个 <see cref="T:System.Reflection.FieldInfo" /> 对象是否不相等。</span><span class="sxs-lookup"><span data-stu-id="23e13-401">Indicates whether two <see cref="T:System.Reflection.FieldInfo" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="23e13-402">如果 <see langword="true" /> 不等于 <paramref name="left" />，则为 <paramref name="right" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-402"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="23e13-403">将给定对象的字段值设置为给定值。</span><span class="sxs-lookup"><span data-stu-id="23e13-403">Sets the value of the field for the given object to the given value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (obj As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValue(System::Object ^ obj, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj -&gt; unit&#xA;override this.SetValue : obj * obj -&gt; unit" Usage="fieldInfo.SetValue (obj, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValue(System.Object,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="23e13-404">将设置其字段值的对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-404">The object whose field value will be set.</span></span></param>
        <param name="value"><span data-ttu-id="23e13-405">要分配给字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-405">The value to assign to the field.</span></span></param>
        <summary><span data-ttu-id="23e13-406">设置给定对象支持的字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-406">Sets the value of the field supported by the given object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-407">此方法将分配`value`给此实例在对象`obj`上反映的字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-407">This method will assign `value` to the field reflected by this instance on object `obj`.</span></span> <span data-ttu-id="23e13-408">如果该字段为静态, `obj`则将被忽略。</span><span class="sxs-lookup"><span data-stu-id="23e13-408">If the field is static, `obj` will be ignored.</span></span> <span data-ttu-id="23e13-409">对于非静态字段, `obj`应为继承或声明该字段的类的实例。</span><span class="sxs-lookup"><span data-stu-id="23e13-409">For non-static fields, `obj` should be an instance of a class that inherits or declares the field.</span></span> <span data-ttu-id="23e13-410">新值作为`Object`传递。</span><span class="sxs-lookup"><span data-stu-id="23e13-410">The new value is passed as an `Object`.</span></span> <span data-ttu-id="23e13-411">例如, 如果该字段的类型为布尔值, 则会传递`Object`一个具有适当布尔值的实例。</span><span class="sxs-lookup"><span data-stu-id="23e13-411">For example, if the field's type is Boolean, an instance of `Object` with the appropriate Boolean value is passed.</span></span> <span data-ttu-id="23e13-412">设置该值之前, `SetValue`请检查用户是否具有访问权限。</span><span class="sxs-lookup"><span data-stu-id="23e13-412">Before setting the value, `SetValue` checks to see if the user has access permission.</span></span> <span data-ttu-id="23e13-413">这最后一种方法是调用以下`SetValue`方法的便捷方法。</span><span class="sxs-lookup"><span data-stu-id="23e13-413">This final method is a convenience method for calling the following `SetValue` method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-414">完全受信任的代码具有使用反射访问和调用私有构造函数、方法、字段和属性所需的权限。</span><span class="sxs-lookup"><span data-stu-id="23e13-414">Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-415">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少.</span><span class="sxs-lookup"><span data-stu-id="23e13-415">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="23e13-416">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="23e13-416">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="23e13-417">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="23e13-417">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="23e13-418">下面的示例设置字段的值, 获取并显示值, 修改字段并显示结果。</span><span class="sxs-lookup"><span data-stu-id="23e13-418">The following example sets the value of a field, gets and displays the value, modifies the field, and displays the result.</span></span>  
  
 [!code-cpp[FieldInfo_SetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_SetValue/CPP/fieldinfo_setvalue.cpp#1)]
 [!code-csharp[FieldInfo_SetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_SetValue/CS/fieldinfo_setvalue.cs#1)]
 [!code-vb[FieldInfo_SetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_SetValue/VB/fieldinfo_setvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FieldAccessException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="23e13-419">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.MemberAccessException" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-419">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="23e13-420">调用方没有权限来访问此字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-420">The caller does not have permission to access this field.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="23e13-421">在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获 <see cref="T:System.Exception" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-421">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch <see cref="T:System.Exception" /> instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="23e13-422"><paramref name="obj" /> 参数是 <see langword="null" /> 且该字段为实例字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-422">The <paramref name="obj" /> parameter is <see langword="null" /> and the field is an instance field.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="23e13-423">对象上不存在该字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-423">The field does not exist on the object.</span></span>  
  
<span data-ttu-id="23e13-424">或</span><span class="sxs-lookup"><span data-stu-id="23e13-424">-or-</span></span> 
<span data-ttu-id="23e13-425"><paramref name="value" /> 参数不能转换且不能存储在字段中。</span><span class="sxs-lookup"><span data-stu-id="23e13-425">The <paramref name="value" /> parameter cannot be converted and stored in the field.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-426">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-426">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-427">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-427">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="23e13-428">用于更新仅限初始字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-428">for updating init-only fields.</span></span> <span data-ttu-id="23e13-429">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-429">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public abstract void SetValue (object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValue(object obj, object value, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void SetValue(System::Object ^ obj, System::Object ^ value, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member SetValue : obj * obj * System.Reflection.BindingFlags * System.Reflection.Binder * System.Globalization.CultureInfo -&gt; unit" Usage="fieldInfo.SetValue (obj, value, invokeAttr, binder, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="23e13-430">将设置其字段值的对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-430">The object whose field value will be set.</span></span></param>
        <param name="value"><span data-ttu-id="23e13-431">要分配给字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-431">The value to assign to the field.</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="23e13-432">指定所需的绑定类型（例如，<see langword="Binder.CreateInstance" /> 或 <see langword="Binder.ExactBinding" />）的 <see langword="Binder" /> 的字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-432">A field of <see langword="Binder" /> that specifies the type of binding that is desired (for example, <see langword="Binder.CreateInstance" /> or <see langword="Binder.ExactBinding" />).</span></span></param>
        <param name="binder"><span data-ttu-id="23e13-433">启用绑定、 强制自变量类型和成员通过反射调用的属性集。</span><span class="sxs-lookup"><span data-stu-id="23e13-433">A set of properties that enables the binding, coercion of argument types, and invocation of members through reflection.</span></span> <span data-ttu-id="23e13-434">如果 <paramref name="binder" /> 为 <see langword="null" />，则使用 <see langword="Binder.DefaultBinding" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-434">If <paramref name="binder" /> is <see langword="null" />, then <see langword="Binder.DefaultBinding" /> is used.</span></span></param>
        <param name="culture"><span data-ttu-id="23e13-435">特定区域性的软件首选项。</span><span class="sxs-lookup"><span data-stu-id="23e13-435">The software preferences of a particular culture.</span></span></param>
        <summary><span data-ttu-id="23e13-436">在派生类中被重写时，设置给定对象支持的字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-436">When overridden in a derived class, sets the value of the field supported by the given object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-437">此方法将分配`value`给在上`obj`由此实例反映的字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-437">This method will assign `value` to the field reflected by this instance on `obj`.</span></span> <span data-ttu-id="23e13-438">如果该字段为静态, `obj`则将被忽略。</span><span class="sxs-lookup"><span data-stu-id="23e13-438">If the field is static, `obj` will be ignored.</span></span> <span data-ttu-id="23e13-439">对于非静态字段, `obj`应为继承或声明该字段的类的实例。</span><span class="sxs-lookup"><span data-stu-id="23e13-439">For non-static fields, `obj` should be an instance of a class that inherits or declares the field.</span></span> <span data-ttu-id="23e13-440">新值作为`Object`传递。</span><span class="sxs-lookup"><span data-stu-id="23e13-440">The new value is passed as an `Object`.</span></span> <span data-ttu-id="23e13-441">例如, 如果该字段的类型为`Boolean`, 则会传递具有相应布尔值的的`Object`实例。</span><span class="sxs-lookup"><span data-stu-id="23e13-441">For example, if the field's type is `Boolean`, an instance of `Object` with the appropriate Boolean value is passed.</span></span> <span data-ttu-id="23e13-442">设置该值之前, `SetValue`请检查用户是否具有访问权限。</span><span class="sxs-lookup"><span data-stu-id="23e13-442">Before setting the value, `SetValue` checks to see if the user has access permission.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-443">完全受信任的代码具有使用反射访问和调用私有构造函数、方法、字段和属性所需的权限。</span><span class="sxs-lookup"><span data-stu-id="23e13-443">Fully trusted code has the permissions that are needed to access and invoke private constructors, methods, fields, and properties using reflection.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="23e13-444">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少.</span><span class="sxs-lookup"><span data-stu-id="23e13-444">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="23e13-445">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="23e13-445">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="23e13-446">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="23e13-446">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FieldAccessException"><span data-ttu-id="23e13-447">调用方没有权限来访问此字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-447">The caller does not have permission to access this field.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="23e13-448"><paramref name="obj" /> 参数是 <see langword="null" /> 且该字段为实例字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-448">The <paramref name="obj" /> parameter is <see langword="null" /> and the field is an instance field.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="23e13-449">对象上不存在该字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-449">The field does not exist on the object.</span></span>  
  
<span data-ttu-id="23e13-450">或</span><span class="sxs-lookup"><span data-stu-id="23e13-450">-or-</span></span> 
<span data-ttu-id="23e13-451"><paramref name="value" /> 参数不能转换且不能存储在字段中。</span><span class="sxs-lookup"><span data-stu-id="23e13-451">The <paramref name="value" /> parameter cannot be converted and stored in the field.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-452">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-452">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-453">关联的枚举<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />:。</span><span class="sxs-lookup"><span data-stu-id="23e13-453">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="23e13-454">用于更新仅限初始字段。</span><span class="sxs-lookup"><span data-stu-id="23e13-454">for updating init-only fields.</span></span> <span data-ttu-id="23e13-455">关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-455">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetValueDirect">
      <MemberSignature Language="C#" Value="public virtual void SetValueDirect (TypedReference obj, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetValueDirect(valuetype System.TypedReference obj, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.SetValueDirect(System.TypedReference,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub SetValueDirect (obj As TypedReference, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetValueDirect(TypedReference obj, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member SetValueDirect : TypedReference * obj -&gt; unit&#xA;override this.SetValueDirect : TypedReference * obj -&gt; unit" Usage="fieldInfo.SetValueDirect (obj, value)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.SetValueDirect(System.TypedReference,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.TypedReference" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="23e13-456">一个 <see cref="T:System.TypedReference" /> 结构，该结构封装指向某位置的托管指针以及该位置可存储的类型的运行时表示形式。</span><span class="sxs-lookup"><span data-stu-id="23e13-456">A <see cref="T:System.TypedReference" /> structure that encapsulates a managed pointer to a location and a runtime representation of the type that can be stored at that location.</span></span></param>
        <param name="value"><span data-ttu-id="23e13-457">要分配给字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-457">The value to assign to the field.</span></span></param>
        <summary><span data-ttu-id="23e13-458">设置给定对象支持的字段的值。</span><span class="sxs-lookup"><span data-stu-id="23e13-458">Sets the value of the field supported by the given object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="23e13-459">从开始<xref:System.Security.Permissions.ReflectionPermission> <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> , 如果调用方已获得标志并且非公共成员的授予集限制为调用方的授予集或子集, 则可以使用此方法访问非公共成员。 [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]缺少.</span><span class="sxs-lookup"><span data-stu-id="23e13-459">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="23e13-460">(请参阅[反射的安全注意事项](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)。)</span><span class="sxs-lookup"><span data-stu-id="23e13-460">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="23e13-461">若要使用此功能，应用程序应为 [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] 或更高版本。</span><span class="sxs-lookup"><span data-stu-id="23e13-461">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Globalization.CultureInfo)" />
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="23e13-462">调用方需要公共语言规范 (CLS) 的替代项，但改为调用此方法。</span><span class="sxs-lookup"><span data-stu-id="23e13-462">The caller requires the Common Language Specification (CLS) alternative, but called this method instead.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="23e13-463">当通过诸如<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />等机制后期绑定调用时。</span><span class="sxs-lookup"><span data-stu-id="23e13-463">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="23e13-464">关联枚举：<see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />。</span><span class="sxs-lookup"><span data-stu-id="23e13-464">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _FieldInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_FieldInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="23e13-465">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="23e13-465">Reserved for future use.</span></span> <span data-ttu-id="23e13-466">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="23e13-466">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="23e13-467">要映射的名称的传入数组。</span><span class="sxs-lookup"><span data-stu-id="23e13-467">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="23e13-468">要映射的名称的计数。</span><span class="sxs-lookup"><span data-stu-id="23e13-468">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="23e13-469">要在其中解释名称的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="23e13-469">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="23e13-470">调用方分配的数组，用于接收与名称对应的 ID。</span><span class="sxs-lookup"><span data-stu-id="23e13-470">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="23e13-471">将一组名称映射为对应的一组调度标识符。</span><span class="sxs-lookup"><span data-stu-id="23e13-471">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-472">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="23e13-472">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="23e13-473">有关`IDispatch::GetIDsOfNames`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="23e13-473">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="23e13-474">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="23e13-474">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetType">
      <MemberSignature Language="C#" Value="Type _FieldInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._FieldInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _FieldInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._FieldInfo.GetType() = System::Runtime::InteropServices::_FieldInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="23e13-475">获取表示 <see cref="T:System.Type" /> 类型的 <see cref="T:System.Reflection.FieldInfo" /> 对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-475">Gets a <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.FieldInfo" /> type.</span></span></summary>
        <returns><span data-ttu-id="23e13-476">一个 <see cref="T:System.Type" /> 对象，表示 <see cref="T:System.Reflection.FieldInfo" /> 类型。</span><span class="sxs-lookup"><span data-stu-id="23e13-476">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.FieldInfo" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _FieldInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_FieldInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="23e13-477">要返回的类型信息。</span><span class="sxs-lookup"><span data-stu-id="23e13-477">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="23e13-478">类型信息的区域设置标识符。</span><span class="sxs-lookup"><span data-stu-id="23e13-478">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="23e13-479">接收一个指针，指向请求的类型信息对象。</span><span class="sxs-lookup"><span data-stu-id="23e13-479">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="23e13-480">检索对象的类型信息，然后可以使用该信息获取接口的类型信息。</span><span class="sxs-lookup"><span data-stu-id="23e13-480">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-481">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="23e13-481">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="23e13-482">有关`IDispatch::GetTypeInfo`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="23e13-482">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="23e13-483">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="23e13-483">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _FieldInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _FieldInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_FieldInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="23e13-484">指向一个位置，该位置接收对象提供的类型信息接口的数量。</span><span class="sxs-lookup"><span data-stu-id="23e13-484">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="23e13-485">检索对象提供的类型信息接口的数量（0 或 1）。</span><span class="sxs-lookup"><span data-stu-id="23e13-485">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-486">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="23e13-486">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="23e13-487">有关`IDispatch::GetTypeInfoCount`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="23e13-487">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="23e13-488">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="23e13-488">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._FieldInfo.Invoke">
      <MemberSignature Language="C#" Value="void _FieldInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._FieldInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.FieldInfo.System#Runtime#InteropServices#_FieldInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _FieldInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._FieldInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_FieldInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._FieldInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="23e13-489">标识成员。</span><span class="sxs-lookup"><span data-stu-id="23e13-489">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="23e13-490">留待将来使用。</span><span class="sxs-lookup"><span data-stu-id="23e13-490">Reserved for future use.</span></span> <span data-ttu-id="23e13-491">必须为 IID_NULL。</span><span class="sxs-lookup"><span data-stu-id="23e13-491">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="23e13-492">要在其中解释自变量的区域设置上下文。</span><span class="sxs-lookup"><span data-stu-id="23e13-492">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="23e13-493">描述调用的上下文的标志。</span><span class="sxs-lookup"><span data-stu-id="23e13-493">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="23e13-494">指向一个结构的指针，该结构包含一个参数数组、一个命名参数的 DISPID 参数数组和数组中元素数的计数。</span><span class="sxs-lookup"><span data-stu-id="23e13-494">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="23e13-495">指向要存储结果的位置的指针。</span><span class="sxs-lookup"><span data-stu-id="23e13-495">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="23e13-496">指向一个包含异常信息的结构的指针。</span><span class="sxs-lookup"><span data-stu-id="23e13-496">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="23e13-497">第一个出错参数的索引。</span><span class="sxs-lookup"><span data-stu-id="23e13-497">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="23e13-498">提供对某一对象公开的属性和方法的访问。</span><span class="sxs-lookup"><span data-stu-id="23e13-498">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="23e13-499">此方法用于从非托管代码访问托管类, 不应从托管代码调用。</span><span class="sxs-lookup"><span data-stu-id="23e13-499">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="23e13-500">有关`IDispatch::Invoke`的详细信息, 请参阅 MSDN library。</span><span class="sxs-lookup"><span data-stu-id="23e13-500">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="23e13-501">不支持使用 COM <c>IDispatch</c> 接口的后期绑定访问。</span><span class="sxs-lookup"><span data-stu-id="23e13-501">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
