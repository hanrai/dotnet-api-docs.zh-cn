<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5e030aa8a8801c2db61e3fbd8cbc521c6e064615" /><Meta Name="ms.sourcegitcommit" Value="2767b5903996fbd7e2b81eda1114dfc9d0d9db63" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="05/02/2019" /><Meta Name="ms.locfileid" Value="65016207" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供 <see langword="static" /> 方法和属性以管理应用程序，例如启动和停止应用程序、处理 Windows 消息的方法和获取应用程序信息的属性。 此类不能被继承。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application>类具有启动和停止应用程序和线程以及处理 Windows 消息的方法, 如下所示:  
  
-   <xref:System.Windows.Forms.Application.Run%2A>在当前线程上启动应用程序消息循环, 并根据需要使窗体可见。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A>或<xref:System.Windows.Forms.Application.ExitThread%2A>停止消息循环。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A>当程序处于循环中时处理消息。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A>将消息筛选器添加到应用程序消息泵以监视 Windows 消息。  
  
-   <xref:System.Windows.Forms.IMessageFilter>允许在调用事件处理程序之前停止引发事件或执行特殊操作。  
  
 此类具有<xref:System.Windows.Forms.Application.CurrentCulture%2A>和<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A>属性, 可获取或设置当前线程的区域性信息。  
  
 不能创建此类的实例。  
  
   
  
## Examples  
 下面的代码示例在窗体上的列表框中列出了数字。 每次单击`button1`时, 应用程序都会向列表中添加一个编号。  
  
 方法调用<xref:System.Windows.Forms.Application.Run%2A>以启动应用程序, `listBox1`该应用程序将创建窗体`button1`和。 `Main` 用户单击`button1`时`button1_Click` , 方法会显示<xref:System.Windows.Forms.MessageBox>。 如果用户单击`No` <xref:System.Windows.Forms.MessageBox>, 则该`button1_Click`方法将向列表中添加一个数字。 如果用户单击`Yes`, 应用程序将调用<xref:System.Windows.Forms.Application.Exit%2A>来处理队列中的所有剩余消息, 然后退出。  
  
> [!NOTE]
>  在部分信任<xref:System.Windows.Forms.Application.Exit%2A>环境中对的调用将失败。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">要安装的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 接口的实现。</param>
        <summary>添加消息筛选器以便在向目标传送 Windows 消息时监视这些消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用消息筛选器可防止引发特定事件, 或在将事件传递给事件处理程序之前对其执行特殊操作。 消息筛选器对于特定线程是唯一的。  
  
 若要防止消息被调度, `value`传递给此方法的参数实例必须用代码来重写该<xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>方法以处理消息。 该方法必须返回 `false`。  
  
> [!CAUTION]
>  将消息筛选器添加到应用程序的消息泵会降低性能。  
  
   
  
## Examples  
 下面的代码示例创建一个名`TestMessageFilter`为的消息筛选器。 此筛选器阻止与鼠标左键相关的所有消息。 使用消息筛选器之前, 必须提供<xref:System.Windows.Forms.IMessageFilter>接口的实现。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">供直接调用方调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示调用方能否退出该应用程序的值。</summary>
        <value>如果调用方能够退出该应用程序，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果从 Web `false`浏览器中承载的<xref:System.Windows.Forms.Control>调用, 则此属性返回。 因此, <xref:System.Windows.Forms.Control>不能<xref:System.Windows.Forms.Application>退出。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在应用程序即将关闭时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 必须将事件处理程序附加到`ApplicationExit`事件, 才能在应用程序停止运行之前执行未处理的所需任务。 可以关闭此应用程序打开的文件, 也可以释放垃圾回收未回收的对象。  
  
 由于这是一个静态事件, 因此必须将`ApplicationExit`任何附加到此事件的事件处理程序分离到事件处理程序中。 如果不分离这些处理程序, 它们将保持附加到事件, 并继续消耗内存。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体并在两个窗体关闭时退出应用程序。 当应用程序启动和退出时, 将记住每个窗体的位置。 此示例演示如何使用`ApplicationExit`事件来了解何时应将窗体位置保存到文件中, 以及`FileStream`何时应关闭窗体位置。  
  
 类`MyApplicationContext` 从<xref:System.Windows.Forms.ApplicationContext>继承, 并在每个窗体关闭时保持跟踪, 并在两个窗体关闭时进行跟踪, 并在两个窗体都关闭时 类在每个窗体关闭时记住其位置。 `ApplicationExit`事件发生时, 类会将用户的每个的位置写入文件。 窗体位置数据存储在名`appdata.txt`为的文件中, 该文件在<xref:System.Windows.Forms.Application.UserAppDataPath%2A>由确定的位置创建。 方法调用`Application.Run(context)`来启动给定的<xref:System.Windows.Forms.ApplicationContext>应用程序。 `Main`  
  
 此代码摘自<xref:System.Windows.Forms.ApplicationContext>类概述中所示的示例。 有关<xref:System.Windows.Forms.ApplicationContext>完整的代码清单, 请参阅。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取所有用户共享的应用程序数据的路径。</summary>
        <value>所有用户共享的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路径不存在, 则将使用以下格式创建一个路径:  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>首先查看包含主可执行文件的程序集是否具有`AssemblyInformationalVersion`其属性。 如果该属性存在, 则用于<xref:System.Windows.Forms.Application.ProductVersion%2A>和。 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A> 如果此属性不存在, 则这两个属性将改用可执行文件的版本。  
  
 该路径将有所不同, 具体取决于是否使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]部署 Windows 窗体应用程序。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序存储在每个用户的应用程序缓存中的 c:\documents and 和\\设置*用户名*目录中。 有关详细信息, 请参阅[在 ClickOnce 应用程序中访问本地数据和远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取所有用户共享的应用程序数据的注册表项。</summary>
        <value>一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示所有用户共享的应用程序数据的注册表项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该键不存在, 则将采用以下格式创建它:  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的公司名称。</summary>
        <value>公司名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性, 并在文本框中显示其值。 该示例要求`textBox1`已置于窗体上。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的区域性信息。</summary>
        <value>一个 <see cref="T:System.Globalization.CultureInfo" />，它代表当前线程的区域性信息。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性, 并在文本框中显示其值。 该示例要求`textBox1`已置于窗体上。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">适用于所有 windows 设置此属性。 关联的枚举:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当前线程的当前输入语言。</summary>
        <value>一个 <see cref="T:System.Windows.Forms.InputLanguage" />，它代表当前线程的当前输入语言。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性, 并在文本框中显示其值。 该示例要求`textBox1`已置于窗体上。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">供直接调用方调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>处理当前在消息队列中的所有 Windows 消息。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 运行 Windows 窗体时, 它将创建新的窗体, 然后将等待事件处理。 每次窗体处理一个事件时, 它都会处理与该事件关联的所有代码。 所有其他事件都在队列中等待。 当代码处理事件时, 应用程序不会响应。 例如, 如果将另一窗口拖到顶部, 则窗口不会重新绘制。  
  
 如果在代码<xref:System.Windows.Forms.Application.DoEvents%2A>中调用, 则应用程序可以处理其他事件。 例如, 如果你有一个将数据添加到<xref:System.Windows.Forms.ListBox>并添加<xref:System.Windows.Forms.Application.DoEvents%2A>到你的代码中的窗体, 则在将另一窗口拖到窗体上时, 窗体将重新绘制。 如果从代码<xref:System.Windows.Forms.Application.DoEvents%2A>中删除, 则窗体将不会重新绘制, 直到按钮的 click 事件处理程序执行完毕。 有关消息传递的详细信息, 请参阅[中的用户输入 Windows 窗体](~/docs/framework/winforms/user-input-in-windows-forms.md)。  
  
 与 Visual Basic 6.0 不同, <xref:System.Windows.Forms.Application.DoEvents%2A>方法不会<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>调用方法。  
  
 通常, 在循环中使用此方法来处理消息。  
  
> [!CAUTION]
>  调用此方法将导致在处理所有等待窗口消息时暂停当前线程。 如果消息导致触发事件, 则可能会执行应用程序代码的其他区域。 这可能导致应用程序出现难以调试的意外行为。 如果执行的操作或计算需要较长时间, 则通常更愿意在新线程上执行这些操作。 有关异步编程的详细信息, 请参阅[异步编程模型 (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)。  
  
   
  
## Examples  
 下面的代码示例演示如何使用<xref:System.Windows.Forms.Application.DoEvents%2A>方法。 当示例运行时, 用户可以从中<xref:System.Windows.Forms.OpenFileDialog>选择图形文件。 选择的文件将显示在窗体中。 <xref:System.Windows.Forms.Application.DoEvents%2A>方法为打开的每个图形文件强制重绘窗体。 若要运行此示例, 请将以下代码粘贴到包含<xref:System.Windows.Forms.PictureBox>名`PictureBox1` <xref:System.Windows.Forms.OpenFileDialog>为的、名`OpenFileDialog1`为的和名为`fileButton`的按钮的窗体中。 从窗体`InitializeOpenFileDialog`的构造函数或`Load`方法调用和方法。`InitializePictureBox`  
  
> [!NOTE]
>  在 Visual Studio 中, 如果您通过<xref:System.Windows.Forms.OpenFileDialog>使用拖动操作将添加到您的窗体中, 则您必须通过`InitializeOpenFileDialog`删除<xref:System.Windows.Forms.OpenFileDialog>创建的新实例的行来修改以下方法。  
  
 该示例还<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType>要求将<xref:System.Windows.Forms.Button>控件的事件<xref:System.Windows.Forms.OpenFileDialog>和<xref:System.Windows.Forms.FileDialog.FileOk>的事件连接到示例中定义的事件处理程序。 当示例运行时, 单击按钮即可显示该对话框。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>启用应用程序的可视样式。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法为应用程序启用视觉样式。 视觉样式是指构成操作系统主题的颜色、字体和其他视觉对象。 如果控件和操作系统支持视觉样式, 控件将用视觉样式绘制。 若要产生效果, <xref:System.Windows.Forms.Application.EnableVisualStyles>必须先调用, 然后才能在应用程序中创建任何控件<xref:System.Windows.Forms.Application.EnableVisualStyles> ; 通常, 是`Main`函数中的第一行。 调用<xref:System.Windows.Forms.Application.EnableVisualStyles>时, 不需要单独的清单即可启用视觉样式。  
  
> [!NOTE]
>  在 .NET Framework 2.0 之前, `FlatStyle`某些控件 (如派生自<xref:System.Windows.Forms.ButtonBase>的控件) 的属性必须设置为<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType> , 以便用视觉样式绘制控件。 在用 .NET Framework 2.0 编写的应用程序中, 不再需要此项。  
  
> [!NOTE]
>  此方法对 Internet Explorer 中承载的控件不起作用。  
  
   
  
## Examples  
 下面的代码示例演示如何<xref:System.Windows.Forms.Application.EnableVisualStyles%2A> `Main`在函数中调用, 以便为应用程序启用视觉样式。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序即将进入模式状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因为这是一个静态事件, 所以必须在释放应用程序时分离事件处理程序, 否则会导致内存泄漏。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中, 事件处理程序报告<xref:System.Windows.Forms.Application.EnterThreadModal>事件的发生。 此报表可帮助你了解何时发生事件, 并可帮助你进行调试。 若要报告多个事件或频繁发生的事件, 请考虑<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>将<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>消息替换为多行或将<xref:System.Windows.Forms.TextBox>其追加到多行。  
  
 若要运行示例代码, 请将其粘贴到 Windows 窗体中, 并确保事件处理程序与<xref:System.Windows.Forms.Application.EnterThreadModal>事件相关联。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />侦听事件的权限。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取启动了应用程序的可执行文件的路径，包括可执行文件的名称。</summary>
        <value>启动了应用程序的可执行文件的路径和可执行文件的名称。  
  
取决于是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署 Windows 窗体应用程序，此路径将会不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序存储在每个用户的应用程序缓存中的 c:\documents and 和\\设置*用户名*目录中。 有关详细信息, 请参阅[在 ClickOnce 应用程序中访问本地数据和远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取路径。 关联的枚举:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A>方法在所有线程上停止所有正在运行的消息循环, 并关闭应用程序的所有窗口。 此方法并不一定强制退出应用程序。 方法通常从消息循环中调用, 并强制<xref:System.Windows.Forms.Application.Run%2A>返回。 <xref:System.Windows.Forms.Application.Exit%2A> 若要仅退出当前线程的消息循环, 请调用<xref:System.Windows.Forms.Application.ExitThread%2A>。  
  
 <xref:System.Windows.Forms.Application.Exit%2A>引发以下事件并执行关联的条件操作:  
  
-   每<xref:System.Windows.Forms.Form.FormClosing> 个<xref:System.Windows.Forms.Application.OpenForms%2A>由属性表示的窗体都将引发一个事件。 可以通过将其<xref:System.ComponentModel.CancelEventArgs.Cancel%2A> <xref:System.Windows.Forms.FormClosingEventArgs>参数的属性设置为来`true`取消此事件。  
  
-   如果有一个或多个处理程序取消了该事件<xref:System.Windows.Forms.Application.Exit%2A> , 则返回而不执行进一步操作。 否则, <xref:System.Windows.Forms.Form.FormClosed>会为每个打开的窗体引发事件, 并关闭所有正在运行的消息循环和窗体。  
  
> [!NOTE]
>  方法不会<xref:System.Windows.Forms.Form.Closed>引发和<xref:System.Windows.Forms.Form.Closing>事件, 这些事件在中已过时[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]。 <xref:System.Windows.Forms.Application.Exit%2A>  
  
   
  
## Examples  
 下面的代码示例在窗体上的列表框中列出了数字。 每次单击`button1`时, 应用程序都会向列表中添加一个编号。  
  
 方法调用<xref:System.Windows.Forms.Application.Run%2A>以启动应用程序, 该应用程序将创建窗`listBox1`体、 `button1`和。 `Main` 用户单击`button1`时, 该`button1_Click`方法会向列表<xref:System.Windows.Forms.MessageBox>框中添加一个到三个数字, 并显示。 如果用户单击上的 "否<xref:System.Windows.Forms.MessageBox>", `button1_Click`则该方法将向列表中添加另一个数字。 如果用户单击 **"是"**, 应用程序<xref:System.Windows.Forms.Application.Exit%2A>将调用来处理队列中所有剩余的消息, 然后退出。  
  
 该示例要求`listBox1`并`button1`已经实例化并将其放置在窗体上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">供直接调用方调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">返回应用程序中的任何 <see cref="T:System.Windows.Forms.Form" /> 是否已取消退出。</param>
        <summary>通知所有消息泵必须终止，并且在处理了消息以后关闭所有应用程序窗口。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">用于终止正在运行的应用程序线程的权限。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>退出当前线程上的消息循环，并关闭该线程上的所有窗口。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法退出当前线程的消息循环。 此方法导致调用<xref:System.Windows.Forms.Application.Run%2A>当前线程返回。 若要退出整个应用程序, <xref:System.Windows.Forms.Application.Exit%2A>请调用。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">供直接调用方调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">要筛选的 Windows 事件消息。</param>
        <summary>对窗口消息运行任何筛选器，并返回修改后的消息的副本。</summary>
        <returns>如果已处理筛选，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HighDpiMode">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.HighDpiMode HighDpiMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.HighDpiMode HighDpiMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.HighDpiMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HighDpiMode As HighDpiMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::HighDpiMode HighDpiMode { System::Windows::Forms::HighDpiMode get(); };" />
      <MemberSignature Language="F#" Value="member this.HighDpiMode : System.Windows.Forms.HighDpiMode" Usage="System.Windows.Forms.Application.HighDpiMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HighDpiMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序完成处理并即将进入空闲状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果你具有在线程进入空闲状态之前必须执行的任务, 请将其附加到此事件。  
  
> [!CAUTION]
>  因为这是一个静态事件, 所以必须在释放应用程序时分离事件处理程序, 否则会导致内存泄漏。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中, 事件处理程序报告<xref:System.Windows.Forms.Application.Idle>事件的发生。 此报表可帮助你了解何时发生事件, 并可帮助你进行调试。 若要报告多个事件或频繁发生的事件, 请考虑<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>将<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>消息替换为多行或将<xref:System.Windows.Forms.TextBox>其追加到多行。  
  
 若要运行示例代码, 请将其粘贴到 Windows 窗体中, 并确保事件处理程序与<xref:System.Windows.Forms.Application.Idle>事件相关联。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当应用程序即将退出模式状态时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  因为这是一个静态事件, 所以必须在释放应用程序时分离事件处理程序, 否则会导致内存泄漏。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中, 事件处理程序报告<xref:System.Windows.Forms.Application.LeaveThreadModal>事件的发生。 此报表可帮助你了解何时发生事件, 并可帮助你进行调试。 若要报告多个事件或频繁发生的事件, 请考虑<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>将<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>消息替换为多行或将<xref:System.Windows.Forms.TextBox>其追加到多行。  
  
 若要运行示例代码, 请将其粘贴到 Windows 窗体中, 并确保事件处理程序与<xref:System.Windows.Forms.Application.LeaveThreadModal>事件相关联。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取本地、非漫游用户的应用程序数据的路径。</summary>
        <value>本地、非漫游用户的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 本地用户是其用户配置文件存储在用户登录的系统上的用户。 如果路径不存在, 则将使用以下格式创建一个路径:  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 典型的基路径为 "c:\documents and"\\和 "Settings*username*\Local Settings\Application Data"。 但是, 如果使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]部署 Windows 窗体应用程序, 则此路径将有所不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]创建独立于所有其他应用程序的应用程序数据目录。 有关详细信息, 请参阅[在 ClickOnce 应用程序中访问本地数据和远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体并在两个窗体关闭时退出应用程序。 当应用程序启动和退出时, 将记住每个窗体的位置。 尽管此示例演示如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>属性来存储用户的应用程序数据<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A> , 但可以改为使用。  
  
 `MyApplicationContext`类从<xref:System.Windows.Forms.ApplicationContext>继承, 并在每个窗体关闭时保持跟踪, 并在两个窗体关闭时保持跟踪, 并在两个窗体均 类存储用户的每个窗体的位置。 窗体位置数据存储在名`Appdata.txt`为的文件中, 该文件在<xref:System.Windows.Forms.Application.UserAppDataPath%2A>由确定的位置创建。 方法调用`Application.Run(context)`来启动给定的<xref:System.Windows.Forms.ApplicationContext>应用程序。 `Main`  
  
 此代码摘自<xref:System.Windows.Forms.ApplicationContext>类概述中所示的示例。 为了简洁起见, 不显示某些代码。 有关<xref:System.Windows.Forms.ApplicationContext>完整的代码清单, 请参阅。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指示该线程上是否存在消息循环的值。</summary>
        <value>如果存在消息循环，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在其他环境 (例如非托管应用程序) 中承载 Windows 窗体时, 此属性`false`将始终返回。 如果<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>宿主环境仍具有活动消息循环, 请使用来指示 Windows 窗体。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>初始化当前线程上的 OLE。</summary>
        <returns><see cref="T:System.Threading.ApartmentState" /> 值之一。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用需要 OLE 的任何`Microsoft.Win32`方法之前调用此方法。 <xref:System.Windows.Forms.Application.OleRequired%2A>首先检查是否已在当前线程上初始化 OLE。 如果不是, 则它初始化 OLE 的线程。  
  
> [!NOTE]
>  除非线程直接调用 OLE 方法, 否则不需要调用此方法。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">一个 <see cref="T:System.Exception" />，它代表所引发的异常。</param>
        <summary>引发 <see cref="E:System.Windows.Forms.Application.ThreadException" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用<xref:System.Windows.Forms.Application.OnThreadException%2A>会引发将暂停应用程序处理的异常。  
  
 <xref:System.Windows.Forms.Application> 类<xref:System.Windows.Forms.Application.ThreadException>有事件。 您可以将事件处理程序附加到此事件, 以执行未经处理的异常所需的任何自定义处理。 如果不附加事件处理程序, <xref:System.Windows.Forms.Application.OnThreadException%2A>则将执行默认行为, 这涉及显示一个对话框, 以通知用户出现错误。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A>仅为在 Windows 窗体拥有的线程上发生的未经处理的异常实现默认异常行为。 其他线程上的未处理异常由<xref:System.AppDomain.UnhandledException>事件处理。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取为应用程序所有的已打开窗体的集合。</summary>
        <value>包含属于此应用程序的所有当前打开窗体的 <see cref="T:System.Windows.Forms.FormCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A>属性表示应用程序拥有的窗体的只读集合。 可以按索引位置或<xref:System.Windows.Forms.Control.Name%2A> <xref:System.Windows.Forms.Form>的来搜索此集合。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">调用方必须有权访问所有窗口, 如<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />枚举的值所定义。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的产品名称。</summary>
        <value>产品名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName`从包含当前应用程序的主窗体的程序集的元数据中获取。 您可以通过在程序集<xref:System.Reflection.AssemblyProductAttribute>清单中进行设置来设置它。 有关详细信息，请参阅[程序集清单](~/docs/framework/app-domains/assembly-manifest.md)。  
  
   
  
## Examples  
 下面的代码示例获取此属性, 并在文本框中显示其值。 该示例要求`textBox1`已置于窗体上。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取与该应用程序关联的产品版本。</summary>
        <value>产品版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 版本号通常显示为*主编号*。*次版本号*。*内部版本号*。*专用部件号*。 可以通过设置程序集清单中的程序集版本来显式设置它。 有关详细信息，请参阅[程序集清单](~/docs/framework/app-domains/assembly-manifest.md)。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A>首先查看包含主可执行文件的程序集是否具有`AssemblyInformationalVersion`其属性。 如果该属性存在, 则用于<xref:System.Windows.Forms.Application.ProductVersion%2A>和。 <xref:System.Windows.Forms.Application.CommonAppDataPath%2A> 如果此属性不存在, 则这两个属性将改用可执行文件的版本。  
  
   
  
## Examples  
 下面的代码示例获取此属性, 并在文本框中显示其值。 该示例要求`textBox1`已置于窗体上。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">要传递给 <see cref="T:System.EventArgs" /> 事件的 <see cref="E:System.Windows.Forms.Application.Idle" /> 对象。</param>
        <summary>在宿主方案中引发 <see cref="E:System.Windows.Forms.Application.Idle" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在其他环境 (例如非托管应用程序) 中承载 Windows 窗体时使用此方法。 当宿主应用<xref:System.Windows.Forms.Application.RaiseIdle%2A>程序进入空闲状态时, 应调用。 这样, 在用户不与应用程序交互时, 某些 Windows 窗体控件和组件就可以执行重要的后台工作。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">当 Windows 窗体需要检查承载环境是否仍在发送消息时，所要调用的方法。</param>
        <summary>注册一个回调以检查消息循环是否正在宿主环境中运行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在其他环境 (例如非托管应用程序) 中承载 Windows 窗体时使用此方法。 在托管环境中, <xref:System.Windows.Forms.Application.MessageLoop%2A>如果 Windows 窗体不处理消息, 则该属性将始终返回 false。 如果宿主环境仍在处理消息, 请使用此回调来告知 Windows 窗体。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">要从应用程序移除的 <see cref="T:System.Windows.Forms.IMessageFilter" /> 的实现。</param>
        <summary>从应用程序的消息泵移除一个消息筛选器。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当你不再想要在调度 Windows 消息之前捕获它们时, 可以删除消息筛选器。  
  
   
  
## Examples  
 使用消息筛选器之前, 必须提供<xref:System.Windows.Forms.IMessageFilter>接口的实现。 下面的类创建一个名`TestMessageFilter`为的消息筛选器。 此筛选器阻止与鼠标左键相关的所有消息。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定当前应用程序是否使用可视样式绘制控件的值。</summary>
        <value>如果在应用程序窗口的工作区为控件启用了可视样式，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要绘制自定义控件, 请使用此属性来决定是绘制具有还是不具有视觉样式的控件, 使其外观与应用程序中的其他控件保持一致。  
  
 下表显示了返回<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A> `true`时必须存在的四个条件。  
  
|条件|说明|  
|---------------|-----------------|  
|操作系统支持视觉样式|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。|  
|用户已在操作系统中启用视觉样式|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> 类的 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> 属性。|  
|在应用程序中启用视觉样式|可以通过调用 <xref:System.Windows.Forms.Application.EnableVisualStyles> 方法或使用指定用 ComCtl32.dll 版本 6 或更高版本绘制控件的应用程序清单来启用应用程序中的视觉样式。|  
|正在使用视觉样式来绘制应用程序窗口的工作区|若要单独验证这种情况，请使用 <xref:System.Windows.Forms.Application.VisualStyleState%2A> 类的 <xref:System.Windows.Forms.Application> 属性，验证它是否具有 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> 或 <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>值。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭应用程序并立即启动一个新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用`Restart`的最常见原因是启动[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]使用`Update`或`UpdateAsync`方法下载的新版本的应用程序。  
  
 应用程序在其最初运行的上下文中重新启动。 如果你的应用程序是使用直接指向应用程序的主要可执行文件的 URL 启动的, 则将使用相同的 URL 重新启动该应用程序。 如果你的[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序是应用程序, 则将使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]重新启动该应用程序。  
  
 如果你的应用程序最初是在执行时提供的命令行选项<xref:System.Windows.Forms.Application.Restart%2A> , 将再次用相同的选项启动该应用程序。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">您的代码不是 Windows 窗体应用程序。 不能在此上下文中调用此方法。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">需要<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />权限。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在当前线程上开始运行标准应用程序消息循环。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在没有窗体的情况下，在当前线程上开始运行标准应用程序消息循环。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在基于 Win32 的应用程序或 Windows 窗体的应用程序中, 消息循环是处理用户事件 (例如鼠标单击和键盘笔划) 的代码例程。 每个正在运行的基于 Windows 的应用程序都需要一个活动消息循环 (称为主消息循环)。 关闭主消息循环后, 应用程序将退出。 在 Windows 窗体中, 当调用<xref:System.Windows.Forms.Application.Exit%2A>方法时或<xref:System.Windows.Forms.Application.ExitThread%2A>在运行主消息循环的线程上调用方法时, 将关闭此循环。  
  
 大多数 Windows 窗体开发人员都不需要使用此版本的方法。 应使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>重载来启动具有主窗体的应用程序, 以便应用程序在主窗体关闭时终止。 对于所有其他情况, 请使用<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>重载, 该重载支持<xref:System.Windows.Forms.ApplicationContext>提供对象以更好地控制应用程序的生存期。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在此线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">一个 <see cref="T:System.Windows.Forms.ApplicationContext" />，应用程序将在其中运行。</param>
        <summary>在特定的 <see cref="T:System.Windows.Forms.ApplicationContext" /> 中，在当前线程上开始运行标准应用程序消息循环。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 消息循环运行到或<xref:System.Windows.Forms.Application.Exit%2A> <xref:System.Windows.Forms.Application.ExitThread%2A>之前, 或者在上下文<xref:System.Windows.Forms.Application.ThreadExit>对象上引发了事件。  
  
   
  
## Examples  
 该示例显示两个窗体并在两个窗体关闭时退出应用程序。 当应用程序启动和退出时, 将记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.ApplicationContext> `Application.Run(context)`和方法在应用程序启动时显示多个窗体。  
  
 类`MyApplicationContext` 从<xref:System.Windows.Forms.ApplicationContext>继承, 并在每个窗体关闭时保持跟踪, 并在两个窗体关闭时保持跟踪, 并在两个窗体均 类存储用户的每个窗体的位置。 窗体位置数据存储在名`Appdata.txt`为的文件中, 该文件在<xref:System.Windows.Forms.Application.UserAppDataPath%2A>由确定的位置创建。 方法调用`Application.Run(context)`来启动给定的<xref:System.Windows.Forms.ApplicationContext>应用程序。 `Main`  
  
 出于简洁的目的`AppForm1` , `AppForm2`不显示和窗体的代码。 有关完整的代码清单, 请参阅类概述。<xref:System.Windows.Forms.ApplicationContext>  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在此线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">一个 <see cref="T:System.Windows.Forms.Form" />，它代表要使之可见的窗体。</param>
        <summary>在当前线程上开始运行标准应用程序消息循环，并使指定窗体可见。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常, 应用程序的主要功能调用此方法并向其传递应用程序的主窗口。  
  
 此方法将事件处理程序添加到`mainForm` <xref:System.Windows.Forms.Form.Closed>事件的参数。 事件处理程序调用<xref:System.Windows.Forms.Application.ExitThread%2A>来清理应用程序。  
  
> [!NOTE]
>  在返回此方法<xref:System.Windows.Forms.Form>之前, 将调用类的方法。<xref:System.Windows.Forms.Control.Dispose%2A>  
  
   
  
## Examples  
 下面的代码示例在窗体上的列表框中列出了数字。 每次单击`button1`时, 应用程序都会向列表中添加一个编号。  
  
 方法调用<xref:System.Windows.Forms.Application.Run%2A>以启动应用程序, 该应用程序将创建窗`listBox1`体、 `button1`和。 `Main` 用户单击`button1`时, 该`button1_Click`方法会向列表<xref:System.Windows.Forms.MessageBox>框中添加一个到三个数字, 并显示。 如果用户单击上的 "否<xref:System.Windows.Forms.MessageBox>", `button1_Click`则该方法将向列表中添加另一个数字。 如果用户单击 **"是"**, 应用程序<xref:System.Windows.Forms.Application.Exit%2A>将调用来处理队列中所有剩余的消息, 然后退出。  
  
 该示例要求`listBox1`和`button1`已创建并放置在窗体上。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">主消息循环已在当前线程上运行。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置当顶级窗口标题与版权警告标志一起显示时，要应用于顶级窗口标题的格式字符串。</summary>
        <value>要应用于顶级窗口标题的格式字符串。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">适用于所有 windows 设置此属性。 关联的枚举:<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">用于新控件的默认值。 如果为 <see langword="true" />，则支持 <c>UseCompatibleTextRendering</c> 的新控件使用基于 [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] 的 <see cref="T:System.Drawing.Graphics" /> 类进行文本呈现；如果为 <see langword="false" />，则新控件使用基于 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 的 <see cref="T:System.Windows.Forms.TextRenderer" /> 类。</param>
        <summary>将某些控件上定义的 <c>UseCompatibleTextRendering</c> 属性设置为应用程序范围内的默认值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 某些<xref:System.Windows.Forms.TextRenderer> Windows 窗体控件可以使用类 (基于[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] <xref:System.Drawing.Graphics>图形库) 或类 (基于[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]图形库) 来呈现文本。 [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]由于的性能和本地化[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]问题, 在中进行了此更改。 用于<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>为支持控件的控件设置`UseCompatibleTextRendering`属性的默认值。  
  
 属性旨在提供<xref:System.Windows.Forms.TextRenderer>使用[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)] 类[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]呈现文本的 Windows 窗体控件与使用执行自定义文本呈现的应用程序之间的视觉兼容性`UseCompatibleTextRendering` <xref:System.Drawing.Graphics>类。 在大多数情况下, 如果你的应用程序未从[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]或[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]升级, 则建议你`UseCompatibleTextRendering`将设置为的默认值`false`。  
  
 中引入<xref:System.Windows.Forms.TextRenderer>了[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]基于的类, 以便提高性能, 使文本更好地显示, 并改善对国际字体的支持。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 在的[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]早期版本中, 使用了<xref:System.Drawing.Graphics>基于的[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]类来执行所有文本呈现。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]以不同于的[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]方式计算字符间距和自动换行。 在使用<xref:System.Drawing.Graphics>类呈现文本的 Windows 窗体应用程序中, 这可能会导致使用<xref:System.Windows.Forms.TextRenderer>的控件的文本与应用程序中的其他文本显示不相同。 若要解决这种不兼容性问题`UseCompatibleTextRendering` , 可`true`将属性设置为。 若要`UseCompatibleTextRendering` `true`为应用程序中的所有受支持的控件设置<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A> , 请使用参数`true`调用方法。  
  
 如果 Windows 窗体代码承载于其他应用程序 (如 Internet Explorer) 中, 则永远不应调用此方法。 仅在独立 Windows 窗体应用程序中调用此方法。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  若要为或更高`UseCompatibleTextRendering`版本[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]中的默认值<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>设置, 请参阅。  
  
 在[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]或更高版本中, <xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>对的调用是在 Program.cs 文件中自动生成的。 若要更改文本呈现默认值, 请修改生成的代码。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">您只能在 Windows 窗体应用程序创建第一个窗口之前调用此方法。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetHighDpiMode">
      <MemberSignature Language="C#" Value="public static bool SetHighDpiMode (System.Windows.Forms.HighDpiMode highDpiMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetHighDpiMode(valuetype System.Windows.Forms.HighDpiMode highDpiMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetHighDpiMode(System.Windows.Forms.HighDpiMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetHighDpiMode(System::Windows::Forms::HighDpiMode highDpiMode);" />
      <MemberSignature Language="F#" Value="static member SetHighDpiMode : System.Windows.Forms.HighDpiMode -&gt; bool" Usage="System.Windows.Forms.Application.SetHighDpiMode highDpiMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="highDpiMode" Type="System.Windows.Forms.HighDpiMode" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="highDpiMode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">指示要转换到的目标电源活动模式的 <see cref="T:System.Windows.Forms.PowerState" />。</param>
        <param name="force">若要立即强制挂起模式，则为 <see langword="true" />；若要使 Windows 向每个应用程序发送挂起请求，则为 <see langword="false" />。</param>
        <param name="disableWakeEvent">值为 <see langword="true" /> 时可在发生唤醒事件时禁止将系统的电源状态恢复为活动状态；值为 <see langword="false" /> 时可在发生唤醒事件时允许将系统的电源状态恢复为活动状态。</param>
        <summary>挂起系统或使系统休眠，或者请求系统挂起或休眠。</summary>
        <returns>如果正在挂起该系统，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果应用程序在20秒内未响应挂起请求, 则 Windows 会确定它处于非响应状态, 并且可以将应用程序置于睡眠状态或终止状态。 但是, 应用程序响应挂起请求后, 它可能需要清理资源并关闭活动进程所需的任何时间。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示应用程序如何响应未经处理的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。 此设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>使所有异常都由应用程序处理, 而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常, <xref:System.AppDomain.UnhandledException>并使用事件来处理非 ui 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法阻止应用程序终止, 因此该示例只是在终止之前将错误记录在应用程序事件日志中。  
  
 此示例假设你<xref:System.Windows.Forms.Button>已在<xref:System.Windows.Forms.Form>类上定义了`button1`两`button2`个控件: 和。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</param>
        <summary>指示应用程序如何响应未经处理的异常。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 捕获 Windows 窗体引发的所有异常通常是不切实际的。 使用此方法, 你可以指示应用程序是应该捕获由 Windows 窗体组件引发的所有未处理异常并继续运行, 还是应将它们公开给用户并暂停执行。  
  
 使用方法实例化应用程序的主窗体之前, 请调用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>。 <xref:System.Windows.Forms.Application.Run%2A>  
  
 若要捕获不是由 Windows 窗体创建并拥有的线程中发生的异常<xref:System.AppDomain.UnhandledException> , 请使用事件处理程序。  
  
   
  
## Examples  
 下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。 此设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>使所有异常都由应用程序处理, 而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常, <xref:System.AppDomain.UnhandledException>并使用事件来处理非 ui 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法阻止应用程序终止, 因此该示例只是在终止之前将错误记录在应用程序事件日志中。  
  
 此示例假设你<xref:System.Windows.Forms.Button>已在<xref:System.Windows.Forms.Form>类上定义了`button1`两`button2`个控件: 和。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在应用程序创建其第一个窗口后，您将无法设置异常模式。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">一个 <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 值，描述在引发未捕获的异常时应用程序的行为方式。</param>
        <param name="threadScope">如果设置线程异常模式，为 <see langword="true" />；否则为 <see langword="false" />。</param>
        <summary>指示应用程序如何响应未经处理的异常，同时可选择应用特定于线程的行为。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 捕获 Windows 窗体引发的所有异常通常是不切实际的。 使用此方法, 你可以指示应用程序是应该捕获由 Windows 窗体组件引发的所有未处理异常并继续运行, 还是应将它们公开给用户并暂停执行。  
  
 使用方法实例化应用程序的主窗体之前, 请调用<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>。 <xref:System.Windows.Forms.Application.Run%2A>  
  
 当`threadScope` 为`true`时, 将设置线程异常模式。 如果`mode`未设置为<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>, 则线程异常模式将重写应用程序异常模式。  
  
 当`threadScope` 为`false`时, 将设置应用程序异常模式。 应用程序异常模式用于具有<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>模式的所有线程。 设置应用程序异常模式不会影响当前线程的设置。  
  
 若要捕获不是由 Windows 窗体创建并拥有的线程中发生的异常<xref:System.AppDomain.UnhandledException> , 请使用事件处理程序。  
  
   
  
## Examples  
 下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。 此设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>使所有异常都由应用程序处理, 而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常, <xref:System.AppDomain.UnhandledException>并使用事件来处理非 ui 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法阻止应用程序终止, 因此该示例只是在终止之前将错误记录在应用程序事件日志中。  
  
 此示例假设你<xref:System.Windows.Forms.Button>已在<xref:System.Windows.Forms.Form>类上定义了`button1`两`button2`个控件: 和。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在应用程序创建其第一个窗口后，您将无法设置异常模式。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取启动了应用程序的可执行文件的路径，不包括可执行文件的名称。</summary>
        <value>启动了应用程序的可执行文件的路径。  
  
取决于是否使用 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] 部署 Windows 窗体应用程序，此路径将会不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]应用程序存储在每个用户的应用程序缓存中的 c:\documents and 和\\设置*用户名*目录中。 有关详细信息, 请参阅[在 ClickOnce 应用程序中访问本地数据和远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的代码示例获取此属性, 并在文本框中显示其值。 该示例要求`textBox1`已置于窗体上。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">用于获取路径。 关联的枚举:<see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在发生未捕获线程异常时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此事件允许 Windows 窗体应用程序处理 Windows 窗体线程中发生的未经处理的异常。 将事件处理程序附加到<xref:System.Windows.Forms.Application.ThreadException>事件来处理这些异常, 这些异常会使应用程序处于未知状态。 如果可能, 应通过结构化异常处理块处理异常。  
  
 通过设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>, 可以更改此回调是否用于未处理的 Windows 窗体线程异常。 若要捕获不是由 Windows 窗体创建并拥有的线程中发生的异常<xref:System.AppDomain.UnhandledException> , 请使用事件处理程序。  
  
> [!NOTE]
>  若要确保不会错过此事件的激活, 则必须在调用<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>之前附加处理程序。  
  
> [!CAUTION]
>  因为这是一个静态事件, 所以必须在释放应用程序时分离事件处理程序, 否则会导致内存泄漏。  
  
   
  
## Examples  
 下面的代码示例为在 Windows 窗体线程上发生的异常和其他线程上发生的异常设置事件处理程序。 此设置<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>使所有异常都由应用程序处理, 而不考虑应用程序的用户配置文件中的设置。 它使用<xref:System.Windows.Forms.Application.ThreadException>事件来处理 UI 线程异常, <xref:System.AppDomain.UnhandledException>并使用事件来处理非 ui 线程异常。 由于<xref:System.AppDomain.UnhandledException>无法阻止应用程序终止, 因此该示例只是在终止之前将错误记录在应用程序事件日志中。  
  
 此示例假设你<xref:System.Windows.Forms.Button>已在<xref:System.Windows.Forms.Form>类上定义了`button1`两`button2`个控件: 和。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">当向此事件添加处理程序时, 直接调用方可以调用非托管代码。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>在某线程即将关闭时发生。 当应用程序的主线程即将关闭时，首先引发该事件，随后是 <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> 事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 您必须将事件处理程序附加到<xref:System.Windows.Forms.Application.ThreadExit>事件, 以在线程停止运行之前执行任何未处理的、必需的任务。 关闭此线程打开的文件, 或释放垃圾回收器未回收的对象。  
  
> [!CAUTION]
>  因为这是一个静态事件, 所以必须在释放应用程序时分离事件处理程序, 否则会导致内存泄漏。  
  
   
  
## Examples  
 下面的代码示例演示如何使用此成员。 在此示例中, 事件处理程序报告<xref:System.Windows.Forms.Application.ThreadExit>事件的发生。 此报表可帮助你了解何时发生事件, 并可帮助你进行调试。 若要报告多个事件或频繁发生的事件, 请考虑<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>将<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>消息替换为多行或将<xref:System.Windows.Forms.TextBox>其追加到多行。  
  
 若要运行示例代码, 请将其粘贴到 Windows 窗体中, 并确保事件处理程序与<xref:System.Windows.Forms.Application.ThreadExit>事件相关联。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>注销使用 <see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> 发出的消息循环回调。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户的应用程序数据的路径。</summary>
        <value>用户的应用程序数据的路径。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果路径不存在, 则将使用以下格式创建一个路径:  
  
 *基路径*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 存储在此路径中的数据是为漫游启用的用户配置文件的一部分。 漫游用户在网络中的多台计算机上工作。 漫游用户的用户配置文件保存在网络上的服务器上, 并在用户登录时加载到系统上。 对于要被视为漫游的用户配置文件, 操作系统必须支持漫游配置文件, 并且必须启用该配置文件。  
  
 典型的基路径为 "c:\documents and"\\和 "Settings*username*\Application Data"。 但是, 如果使用[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]部署 Windows 窗体应用程序, 则此路径将有所不同。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]创建独立于所有其他应用程序的应用程序数据目录。 有关详细信息, 请参阅[在 ClickOnce 应用程序中访问本地数据和远程数据](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)。  
  
   
  
## Examples  
 下面的代码示例显示两个窗体并在两个窗体关闭时退出应用程序。 当应用程序启动和退出时, 将记住每个窗体的位置。 此示例演示如何使用<xref:System.Windows.Forms.Application.UserAppDataPath%2A>属性存储用户的应用程序数据。  
  
 类`MyApplicationContext` 从<xref:System.Windows.Forms.ApplicationContext>继承, 并在每个窗体关闭时保持跟踪, 并在两个窗体关闭时保持跟踪, 并在两个窗体均 类存储用户的每个窗体的位置。 窗体位置数据存储在名`Appdata.txt`为的文件中, 该文件在<xref:System.Windows.Forms.Application.UserAppDataPath%2A>由确定的位置创建。 方法调用`Application.Run(context)`来启动给定的<xref:System.Windows.Forms.ApplicationContext>应用程序。 `Main`  
  
 此代码摘自<xref:System.Windows.Forms.ApplicationContext>类概述中所示的示例。 为了简洁起见, 不显示某些代码。 有关<xref:System.Windows.Forms.ApplicationContext>完整的代码清单, 请参阅。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用户的应用程序数据的注册表项。</summary>
        <value>一个 <see cref="T:Microsoft.Win32.RegistryKey" />，它表示特定于用户的应用程序数据的注册表项。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果该键不存在, 则将采用以下格式创建它:  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 此注册表项中存储的数据是为漫游启用的用户配置文件的一部分。 漫游用户在网络中的多台计算机上工作。 漫游用户的用户配置文件保存在网络上的服务器上, 并在用户登录时加载到系统上。 对于要被视为漫游的用户配置文件, 操作系统必须支持漫游配置文件, 并且必须启用该配置文件。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseVisualStyles">
      <MemberSignature Language="C#" Value="public static bool UseVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UseVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UseVisualStyles : bool" Usage="System.Windows.Forms.Application.UseVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置是否对应用程序的所有打开窗体使用等待光标。</summary>
        <value>如果等待光标用于所有打开的窗体，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果将此属性设置为`true`, 则<xref:System.Windows.Forms.Control.UseWaitCursor%2A>应用程序中所有打开的窗体的属性都将`true`设置为。 在对所有窗体设置此属性之前, 此调用将不会返回。 如果有长时间运行的操作, 并且希望在所有应用程序窗体中指示该操作仍在进行处理, 请使用此属性。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取指定可视样式如何应用于应用程序窗口的值。</summary>
        <value><see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 值的按位组合。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此<xref:System.Windows.Forms.Application.VisualStyleState%2A>属性确定在应用程序窗口的客户端区域或非工作区中是否启用视觉样式。 通常, 应在主窗体的构造函数或<xref:System.Windows.Forms.Form.Load>事件处理程序中设置此属性。  
  
   
  
## Examples  
 下面的代码<xref:System.Windows.Forms.Application.VisualStyleState%2A>示例将属性设置为<xref:System.Windows.Forms.Button>控件的<xref:System.Windows.Forms.Control.Click>事件<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>处理程序中的值之一。 此代码示例是为<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>枚举提供的更大示例的一部分。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>