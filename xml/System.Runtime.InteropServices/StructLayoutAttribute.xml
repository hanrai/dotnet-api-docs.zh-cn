<Type Name="StructLayoutAttribute" FullName="System.Runtime.InteropServices.StructLayoutAttribute">
  <Metadata><Meta Name="ms.openlocfilehash" Value="14b339054799ef8da8dd1958b61f195b93cfe9d3" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69269321" /></Metadata><TypeSignature Language="C#" Value="public sealed class StructLayoutAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit StructLayoutAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.StructLayoutAttribute" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class StructLayoutAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class StructLayoutAttribute sealed : Attribute" />
  <TypeSignature Language="F#" Value="type StructLayoutAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="0f9bc-101">允许你控制内存中类或结构的数据字段的物理布局。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-101">Lets you control the physical layout of the data fields of a class or structure in memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0f9bc-102">可以将此特性应用于类或结构。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-102">You can apply this attribute to classes or structures.</span></span>  
  
 <span data-ttu-id="0f9bc-103">公共语言运行时控制托管内存中类或结构的数据字段的物理布局。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-103">The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.</span></span> <span data-ttu-id="0f9bc-104">但是, 如果要将类型传递给非托管代码, 则可以使用<xref:System.Runtime.InteropServices.StructLayoutAttribute>特性来控制类型的非托管布局。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-104">However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type.</span></span> <span data-ttu-id="0f9bc-105">将属性与结合<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>使用, 可强制成员按其出现的顺序进行排列。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-105">Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> to force the members to be laid out sequentially in the order they appear.</span></span> <span data-ttu-id="0f9bc-106">对于直接类型的<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>类型, 会在托管内存和非托管内存中控制布局。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-106">For blittable types, <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> controls both the layout in managed memory and the layout in unmanaged memory.</span></span> <span data-ttu-id="0f9bc-107">对于不可直接复制的类型, 它会在将类或结构封送到非托管代码时控制布局, 但不会控制托管内存中的布局。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-107">For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.</span></span> <span data-ttu-id="0f9bc-108">使用特性<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>来控制每个数据成员的精确位置。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-108">Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> to control the precise position of each data member.</span></span> <span data-ttu-id="0f9bc-109">这会影响托管和非托管布局, 同时用于本机和非直接复制类型。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-109">This affects both managed and unmanaged layout, for both blittable and non-blittable types.</span></span> <span data-ttu-id="0f9bc-110">使用<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> 需要<xref:System.Runtime.InteropServices.FieldOffsetAttribute>使用属性来指示每个字段在类型中的位置。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-110">Using <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type.</span></span>  
  
 <span data-ttu-id="0f9bc-111">C#默认情况下, C++ Visual Basic 和编译器<xref:System.Runtime.InteropServices.LayoutKind.Sequential>将布局值应用到结构。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-111">C#, Visual Basic, and C++ compilers apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential> layout value to structures by default.</span></span> <span data-ttu-id="0f9bc-112">对于类, 必须显式应用<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>值。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-112">For classes, you must apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> value explicitly.</span></span> <span data-ttu-id="0f9bc-113">[Tlbimp.exe (类型库导入程序)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)也<xref:System.Runtime.InteropServices.StructLayoutAttribute> <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>会应用该属性; 在导入类型库时, 它始终应用值。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-113">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) also applies the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute; it always applies the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> value when it imports a type library.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0f9bc-114">下面的示例演示`GetSystemTime`函数的托管声明, 并定义`MySystemTime`带有<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>布局的类。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-114">The following example demonstrates a managed declaration of the `GetSystemTime` function and defines `MySystemTime` class with <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> layout.</span></span> <span data-ttu-id="0f9bc-115">`GetSystemTime`获取系统时间, 并将其打印到控制台。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-115">`GetSystemTime` gets the system time and prints to the console.</span></span>  
  
 [!code-cpp[StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/StructLayoutAttribute/CPP/structlayoutattribute.cpp#1)]
 [!code-csharp[StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/StructLayoutAttribute/CS/structlayoutattribute.cs#1)]
 [!code-vb[StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StructLayoutAttribute/VB/structlayoutattribute.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/framework/tools/tlbimp-exe-type-library-importer.md"><span data-ttu-id="0f9bc-116">Tlbimp.exe（类型库导入程序）</span><span class="sxs-lookup"><span data-stu-id="0f9bc-116">Tlbimp.exe (Type Library Importer)</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="0f9bc-117">初始化 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-117">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (short layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int16 layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (layoutKind As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(short layoutKind);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.StructLayoutAttribute : int16 -&gt; System.Runtime.InteropServices.StructLayoutAttribute" Usage="new System.Runtime.InteropServices.StructLayoutAttribute layoutKind" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Int16" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="layoutKind"><span data-ttu-id="0f9bc-118">表示一个 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 值的 16 位整数，指定应如何排列类或结构。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-118">A 16-bit integer that represents one of the <see cref="T:System.Runtime.InteropServices.LayoutKind" /> values that specifies how the class or structure should be arranged.</span></span></param>
        <summary><span data-ttu-id="0f9bc-119">使用指定的 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 枚举成员初始化 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-119">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class with the specified <see cref="T:System.Runtime.InteropServices.LayoutKind" /> enumeration member.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0f9bc-120">此构造函数采用表示每个<xref:System.Runtime.InteropServices.LayoutKind>枚举成员的基础16位整数。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-120">This constructor takes an underlying 16-bit integer that represents each <xref:System.Runtime.InteropServices.LayoutKind> enumeration member.</span></span> <span data-ttu-id="0f9bc-121">[Tlbimp.exe (类型库导入程序)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-121">The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) uses this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
        <related type="Article" href="~/docs/framework/tools/tlbimp-exe-type-library-importer.md"><span data-ttu-id="0f9bc-122">Tlbimp.exe（类型库导入程序）</span><span class="sxs-lookup"><span data-stu-id="0f9bc-122">Tlbimp.exe (Type Library Importer)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StructLayoutAttribute (System.Runtime.InteropServices.LayoutKind layoutKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Runtime.InteropServices.LayoutKind layoutKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StructLayoutAttribute(System::Runtime::InteropServices::LayoutKind layoutKind);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.StructLayoutAttribute : System.Runtime.InteropServices.LayoutKind -&gt; System.Runtime.InteropServices.StructLayoutAttribute" Usage="new System.Runtime.InteropServices.StructLayoutAttribute layoutKind" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="layoutKind" Type="System.Runtime.InteropServices.LayoutKind" />
      </Parameters>
      <Docs>
        <param name="layoutKind"><span data-ttu-id="0f9bc-123">一个枚举值，指定应如何排列类或结构。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-123">One of the enumeration values that specifies how the class or structure should be arranged.</span></span></param>
        <summary><span data-ttu-id="0f9bc-124">使用指定的 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 枚举成员初始化 <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-124">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> class with the specified <see cref="T:System.Runtime.InteropServices.LayoutKind" /> enumeration member.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0f9bc-125">对于不容易出错的可读代码, 请始终使用此构造函数。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-125">For readable code that is less prone to error, always use this constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.LayoutKind" />
      </Docs>
    </Member>
    <Member MemberName="CharSet">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.CharSet CharSet;" />
      <MemberSignature Language="ILAsm" Value=".field public valuetype System.Runtime.InteropServices.CharSet CharSet" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet" />
      <MemberSignature Language="VB.NET" Value="Public CharSet As CharSet " />
      <MemberSignature Language="C++ CLI" Value="public: System::Runtime::InteropServices::CharSet CharSet;" />
      <MemberSignature Language="F#" Value="val mutable CharSet : System.Runtime.InteropServices.CharSet" Usage="System.Runtime.InteropServices.StructLayoutAttribute.CharSet" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.CharSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0f9bc-126">指示在默认情况下是否应将类中的字符串数据字段作为 <see langword="LPWSTR" /> 或 <see langword="LPSTR" /> 进行封送处理。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-126">Indicates whether string data fields within the class should be marshaled as <see langword="LPWSTR" /> or <see langword="LPSTR" /> by default.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0f9bc-127">如果字段设置为<xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType>, 则在将所有字符串参数传递到非托管实现`LPWSTR`之前, 会将其转换为 Unicode 字符 ()。 `CharSet`</span><span class="sxs-lookup"><span data-stu-id="0f9bc-127">If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet.Unicode?displayProperty=nameWithType>, all string arguments are converted to Unicode characters (`LPWSTR`) before they are passed to the unmanaged implementation.</span></span> <span data-ttu-id="0f9bc-128">如果字段设置为<xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType>, 则会将字符串转换为 ANSI 字符串 (`LPSTR`)。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-128">If the field is set to <xref:System.Runtime.InteropServices.CharSet.Ansi?displayProperty=nameWithType>, the strings are converted to ANSI strings (`LPSTR`).</span></span> <span data-ttu-id="0f9bc-129">如果字段设置为<xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType>, 则转换与平台相关 (在 windows 98 和 windows Me 上为 ANSI, 在更高版本上为 Unicode)。 `CharSet`</span><span class="sxs-lookup"><span data-stu-id="0f9bc-129">If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet.Auto?displayProperty=nameWithType>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.CharSet" />
      </Docs>
    </Member>
    <Member MemberName="Pack">
      <MemberSignature Language="C#" Value="public int Pack;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Pack" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Pack" />
      <MemberSignature Language="VB.NET" Value="Public Pack As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Pack;" />
      <MemberSignature Language="F#" Value="val mutable Pack : int" Usage="System.Runtime.InteropServices.StructLayoutAttribute.Pack" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0f9bc-130">控制类或结构的数据字段在内存中的对齐方式。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-130">Controls the alignment of data fields of a class or structure in memory.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0f9bc-131"><xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>字段控制类型字段在内存中的对齐方式。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-131">The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory.</span></span>  <span data-ttu-id="0f9bc-132">它会影响<xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>和<xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-132">It affects both <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> and <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0f9bc-133">默认情况下, 此值为 0, 指示当前平台的默认封装大小。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-133">By default, the value is 0, indicating the default packing size for the current platform.</span></span> <span data-ttu-id="0f9bc-134">的<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>值必须为0、1、2、4、8、16、32、64或 128:</span><span class="sxs-lookup"><span data-stu-id="0f9bc-134">The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:</span></span>  
  
 <span data-ttu-id="0f9bc-135">使用以下规则对齐类型实例的字段:</span><span class="sxs-lookup"><span data-stu-id="0f9bc-135">The fields of a type instance are aligned by using the following rules:</span></span>  
  
-   <span data-ttu-id="0f9bc-136">该类型的对齐方式是其最大元素 (1、2、4、8等) 的大小或指定的封装大小 (以较小者为准)。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-136">The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.</span></span>  
  
-   <span data-ttu-id="0f9bc-137">每个字段都必须与其自身大小 (1、2、4、8等) 的字段或该类型的对齐方式 (以较小者为准) 一致。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-137">Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.</span></span>  <span data-ttu-id="0f9bc-138">因为该类型的默认对齐方式是其最大元素的大小, 该大小大于或等于所有其他字段长度, 这通常意味着字段按其大小对齐。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-138">Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.</span></span> <span data-ttu-id="0f9bc-139">例如, 即使类型中的最大字段为64位 (8 字节) 或 Pack 字段设置为 8, <xref:System.Byte>字段也会在1字节边界上对齐, <xref:System.Int16>字段在2字节边界<xref:System.Int32>对齐, 字段在4字节边界上对齐。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-139">For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries.</span></span>  
  
-   <span data-ttu-id="0f9bc-140">在字段之间添加填充以满足对齐要求。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-140">Padding is added between fields to satisfy the alignment requirements.</span></span>  
  
 <span data-ttu-id="0f9bc-141">例如, 当<xref:System.Byte> <xref:System.Int32>与字段的各种值一起使用时, 请考虑以下结构, 其中包含两个字段和一个字段。 <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack></span><span class="sxs-lookup"><span data-stu-id="0f9bc-141">For example, consider the following structure, which consists of two <xref:System.Byte> fields and one <xref:System.Int32> field, when it is used with various values for the <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="0f9bc-142">若要成功编译C#示例, 必须指定`/unsafe`编译器开关。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-142">To successfully compile the C# examples, you must specify the `/unsafe` compiler switch.</span></span>  
  
 <span data-ttu-id="0f9bc-143">如果指定默认的打包大小, 则结构的大小为8个字节。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-143">If you specify the default packing size, the size of the structure is 8 bytes.</span></span> <span data-ttu-id="0f9bc-144">这两个字节占用前两个字节的内存, 因为字节必须在一个字节边界上对齐。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-144">The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.</span></span> <span data-ttu-id="0f9bc-145">由于该类型的默认对齐方式为4字节 (这是其最大字段`i3`的大小), 因此有两个填充字节, 后跟整数字段。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-145">Because the default alignment of the type is 4 bytes, which is the size of its largest fields, `i3`, there are two bytes of padding followed by the integer field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)]  
  
 <span data-ttu-id="0f9bc-146">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>设置为 2, 则结构的大小为6个字节。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-146">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes.</span></span> <span data-ttu-id="0f9bc-147">与之前一样, 两个字节占用前两个字节的内存。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-147">As before, the two bytes occupy the first two bytes of memory.</span></span> <span data-ttu-id="0f9bc-148">由于字段现在按2字节边界对齐, 因此, 在第二个字节和整数之间没有任何空白。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-148">Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)]  
  
 <span data-ttu-id="0f9bc-149">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>设置为 4, 则结构的大小与默认大小写相同, 其中, 类型的对齐方式由其最大`i3`字段的大小定义, 即4。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-149">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, `i3`, which is 4.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)]  
  
 <span data-ttu-id="0f9bc-150">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>设置为 8, 则结构的大小与默认情况下的大小相同, `i3`因为字段在4字节边界上对齐, 这小于 Pack 字段指定的8字节边界。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-150">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the still same as in the default case, because the `i3` field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)]  
  
 <span data-ttu-id="0f9bc-151">若要获得另一个示例, 请考虑以下结构, 其中包含两个字节字段、1 32 位带符号整数字段、单元素字节数组和十进制值。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-151">To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.</span></span> <span data-ttu-id="0f9bc-152">对于默认的封装大小, 结构的大小为28个字节。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-152">With the default packing size, the size of the structure is 28 bytes.</span></span> <span data-ttu-id="0f9bc-153">这两个字节占用前两个字节的内存, 后跟两个填充字节, 后跟整数。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-153">The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.</span></span> <span data-ttu-id="0f9bc-154">接下来是单字节数组, 后跟三个填充字节。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-154">Next is the one-byte array, followed by three bytes of padding.</span></span> <span data-ttu-id="0f9bc-155">最后, 由于<xref:System.Decimal>一个十进制值由四个<xref:System.Int32>字段组成, 因此该字段 d5 在4字节边界上对齐, 因此, 其对齐方式基于其字段的最大大小, 而不是整个<xref:System.Decimal>结构的大小。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-155">Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)]  
  
 <span data-ttu-id="0f9bc-156">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>设置为 2, 则结构的大小为24个字节。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-156">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 24 bytes.</span></span> <span data-ttu-id="0f9bc-157">与默认对齐方式相比, 两个字节和整数之间的两个填充字节已被删除, 因为该类型的对齐方式现在为4而不是2。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-157">In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.</span></span> <span data-ttu-id="0f9bc-158">并将填充后`a4`的三个字节替换为一个填充字节, 因为`d5`现在在2字节边界上对齐, 而不是在4字节边界上对齐。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-158">And the three bytes of padding after `a4` have been replaced by one byte of padding, since `d5` now aligns on a 2-byte boundary rather than a 4-byte boundary.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)]  
  
 <span data-ttu-id="0f9bc-159">如果<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>设置为 8, 则结构的大小与默认情况相同, 因为此结构中的所有对齐要求都小于8。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-159">If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)]  
  
 <span data-ttu-id="0f9bc-160">在<xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack>磁盘和网络写入操作过程中导出结构时, 通常会使用该字段。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-160">The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations.</span></span> <span data-ttu-id="0f9bc-161">在平台调用和互操作操作期间, 也经常使用此字段。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-161">The field is also frequently used during platform invoke and interop operations.</span></span>  
  
 <span data-ttu-id="0f9bc-162">偶尔, 该字段用于通过生成更严格的封装大小来减少内存需求。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-162">Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.</span></span> <span data-ttu-id="0f9bc-163">但是, 这种用法需要仔细考虑实际的硬件限制, 并可能会降低性能。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-163">However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size;" />
      <MemberSignature Language="ILAsm" Value=".field public int32 Size" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.StructLayoutAttribute.Size" />
      <MemberSignature Language="VB.NET" Value="Public Size As Integer " />
      <MemberSignature Language="C++ CLI" Value="public: int Size;" />
      <MemberSignature Language="F#" Value="val mutable Size : int" Usage="System.Runtime.InteropServices.StructLayoutAttribute.Size" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0f9bc-164">指示类或结构的绝对大小。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-164">Indicates the absolute size of the class or structure.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0f9bc-165">此字段必须等于或大于类或结构的成员的总大小 (以字节为单位)。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-165">This field must be equal or greater than the total size, in bytes, of the members of the class or structure.</span></span> <span data-ttu-id="0f9bc-166">此字段主要适用于想要扩展结构占用的内存以实现直接的非托管访问的编译器编写器。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-166">This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.</span></span> <span data-ttu-id="0f9bc-167">例如, 在使用不直接在元数据中表示的联合时, 可以使用此字段。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-167">For example, you can use this field when working with unions that are not represented in metadata directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.LayoutKind Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.InteropServices.LayoutKind Value" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.StructLayoutAttribute.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As LayoutKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Runtime::InteropServices::LayoutKind Value { System::Runtime::InteropServices::LayoutKind get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : System.Runtime.InteropServices.LayoutKind" Usage="System.Runtime.InteropServices.StructLayoutAttribute.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.LayoutKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="0f9bc-168">获取 <see cref="T:System.Runtime.InteropServices.LayoutKind" /> 值，该值指定如何排列类或结构。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-168">Gets the <see cref="T:System.Runtime.InteropServices.LayoutKind" /> value that specifies how the class or structure is arranged.</span></span></summary>
        <value><span data-ttu-id="0f9bc-169">枚举值之一，指定如何排列类或结构。</span><span class="sxs-lookup"><span data-stu-id="0f9bc-169">One of the enumeration values that specifies how the class or structure is arranged.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
