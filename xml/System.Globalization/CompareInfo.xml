<Type Name="CompareInfo" FullName="System.Globalization.CompareInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7b25ec1a1a97770e2bab17db24264f5a82ce4661" /><Meta Name="ms.sourcegitcommit" Value="e7974886b08aa83a8fb461e8550f31a7d4331ee3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/23/2019" /><Meta Name="ms.locfileid" Value="68397288" /></Metadata><TypeSignature Language="C#" Value="public class CompareInfo : System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit CompareInfo extends System.Object implements class System.Runtime.Serialization.IDeserializationCallback" />
  <TypeSignature Language="DocId" Value="T:System.Globalization.CompareInfo" />
  <TypeSignature Language="VB.NET" Value="Public Class CompareInfo&#xA;Implements IDeserializationCallback" />
  <TypeSignature Language="C++ CLI" Value="public ref class CompareInfo : System::Runtime::Serialization::IDeserializationCallback" />
  <TypeSignature Language="F#" Value="type CompareInfo = class&#xA;    interface IDeserializationCallback" />
  <AssemblyInfo>
    <AssemblyName>System.Globalization</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>实现用于区分区域性的字符串的一组方法。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 用于比较和排序数据的约定因区域性而异。 例如，排序顺序可能基于拼音或基于字符的可视表示形式。 在东亚语言中，按文字的笔画和部首对字符进行排序。 排序也取决于字母表使用的排序语言和区域性。 例如, 丹麦语包含一个 "Æ" 字符, 该字符在字母表中的 "Z" 之后排序。 此外，比较可以区分大小写或不区分大小写，并且大小写规则也可能因区域性而异。 <xref:System.Globalization.CompareInfo> 类负责维护此区分区域性的字符串比较数据并执行区分区域性的字符串运算。

 通常，您不必直接实例化 <xref:System.Globalization.CompareInfo> 对象，因为所有非序号字符串比较运算会隐式使用一个此对象，包括对 <xref:System.String.Compare%2A?displayProperty=nameWithType> 方法的调用。 但是，若要检索 <xref:System.Globalization.CompareInfo> 对象，您可通过下列方法之一执行此操作：

-   通过检索特定区域性的 <xref:System.Globalization.CultureInfo.CompareInfo%2A?displayProperty=nameWithType> 属性的值。

-   通过使用区域性名称调用静态 <xref:System.Globalization.CompareInfo.GetCompareInfo%2A> 方法。 这允许对 <xref:System.Globalization.CompareInfo> 对象进行后期绑定访问。

## <a name="ignored-search-values"></a>已忽略的搜索值
 字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 当比较方法（如 <xref:System.Globalization.CompareInfo.IndexOf%2A> 和 <xref:System.Globalization.CompareInfo.LastIndexOf%2A>）执行区分区域性的比较时，它们不会考虑此类字符。 可忽略的字符包括：

-   <xref:System.String.Empty?displayProperty=nameWithType>。 区分区域性的比较方法将始终在要搜索的字符串的开头（索引为零）查找空字符串。

-   字符或由多个字符和运算中未考虑的码位（因为比较选项）构成的字符串，具体而言，<xref:System.Globalization.CompareOptions.IgnoreNonSpace?displayProperty=nameWithType> 和 <xref:System.Globalization.CompareOptions.IgnoreSymbols?displayProperty=nameWithType> 选项生成忽略符号和非间距组合字符的搜索。

-   带没有语义的码位的字符串。 例如，始终在区分区域性的字符串比较中忽略软连字符 (U+00AD)。

## <a name="security-considerations"></a>安全注意事项
 如果安全决策取决于字符串比较或大小写更改，则您应使用 <xref:System.Globalization.CultureInfo.InvariantCulture%2A> 属性来确保行为一致，无论操作系统的区域性设置如何。

> [!NOTE]
>  如果可能, 应使用具有类型<xref:System.Globalization.CompareOptions>参数的字符串比较方法来指定预期的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>指定或。



## Examples
 下面的示例演示<xref:System.Globalization.CompareInfo> <xref:System.Globalization.CultureInfo>与对象关联的对象如何影响字符串比较。

 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/download/details.aspx?id=10921">为 Windows 操作系统排序权重表</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">适用于 Linux 和 macOS 的默认 Unicode 排序规则元素表</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>比较两个字符串。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, string string2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, string string2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, string2 As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, System::String ^ string2);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * string -&gt; int&#xA;override this.Compare : string * string -&gt; int" Usage="compareInfo.Compare (string1, string2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="string2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <summary>比较两个字符串。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> 值

 </term><description> 条件

 </description></listheader><item><term> 零

 </term><description> 这两个字符串相等。

 </description></item><item><term> 小于零

 </term><description><paramref name="string1" /> 小于 <paramref name="string2" />。

 </description></item><item><term> 大于零

 </term><description><paramref name="string1" /> 大于 <paramref name="string2" />。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 默认情况下, 使用<xref:System.Globalization.CompareOptions.None?displayProperty=nameWithType>执行比较。 如果安全决策取决于字符串比较或大小写更改, 则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性来确保无论操作系统的区域性设置如何, 行为都保持一致。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>指定或。



## Examples
 下面的示例使用不同<xref:System.Globalization.CompareInfo>的对象比较两个字符串的各个部分:

-   <xref:System.Globalization.CompareInfo>与采用国际排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与采用传统排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与关联的对象。<xref:System.Globalization.CultureInfo.InvariantCulture%2A>

 [!code-cpp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CPP/comparestrstr.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CS/comparestrstr.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/VB/comparestrstr.vb#1)]

 下面的示例演示如何调用 <xref:System.Globalization.CompareInfo.Compare%2A> 方法。

 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 当<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.String)" />方法执行区分区域性的比较时, 它不会考虑此类字符。 例如, 使用 "ani" (使用软连字符或 U + 00AD) 的 "动物" 比较区分区域性的比较表明这两个字符串是等效的, 如下面的示例所示。

[!code-vb[System.Globalization.CompareInfo.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.compare/vb/compare1.vb#1)]

若要在字符串比较中识别可忽略字符, <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.String,System.Globalization.CompareOptions)" />请调用方法, 并为<paramref name="options" />参数<see cref="F:System.Globalization.CompareOptions.Ordinal" />提供<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />或的值。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, string string2, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, string string2, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, string2 As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, System::String ^ string2, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * string * System.Globalization.CompareOptions -&gt; int&#xA;override this.Compare : string * string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.Compare (string1, string2, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="string1" /> 和 <paramref name="string2" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、<see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" /> 和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值比较两个字符串。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> 值

 </term><description> 条件

 </description></listheader><item><term> 零

 </term><description> 这两个字符串相等。

 </description></item><item><term> 小于零

 </term><description><paramref name="string1" /> 小于 <paramref name="string2" />。

 </description></item><item><term> 大于零

 </term><description><paramref name="string1" /> 大于 <paramref name="string2" />。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果安全决策取决于字符串比较或大小写更改, 则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性来确保无论操作系统的区域性设置如何, 行为都保持一致。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>指定或。



## Examples
 下面的示例使用不同<xref:System.Globalization.CompareOptions>的设置来比较两个字符串。

 [!code-cpp[System.Globalization.CompareInfo.CompareStrStrOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStrOpt/CPP/comparestrstropt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStrOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStrOpt/CS/comparestrstropt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStrOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStrOpt/VB/comparestrstropt.vb#1)]

 下面的示例演示如何调用 <xref:System.Globalization.CompareInfo.Compare%2A> 方法。

 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 当<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.String,System.Globalization.CompareOptions)" />方法执行区分区域性的比较时, 它不会考虑此类字符。 若要在比较中识别可忽略字符, 请为<see cref="F:System.Globalization.CompareOptions.Ordinal" /> <paramref name="options" />参数<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />提供值或。</para></block>
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, string string2, int offset2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, string string2, int32 offset2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, string2 As String, offset2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, System::String ^ string2, int offset2);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * string * int -&gt; int&#xA;override this.Compare : string * int * string * int -&gt; int" Usage="compareInfo.Compare (string1, offset1, string2, offset2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1"><paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2"><paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <summary>将一个字符串的结尾部分与另一个字符串的结尾部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> 值

 </term><description> 条件

 </description></listheader><item><term> 零

 </term><description> 这两个字符串相等。

 </description></item><item><term> 小于零

 </term><description> <paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。

 </description></item><item><term> 大于零

 </term><description> <paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果安全决策取决于字符串比较或大小写更改, 则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性来确保无论操作系统的区域性设置如何, 行为都保持一致。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>指定或。



## Examples
 下面的示例使用不同<xref:System.Globalization.CompareInfo>的对象比较两个字符串的各个部分:

-   <xref:System.Globalization.CompareInfo>与采用国际排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与采用传统排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与关联的对象。<xref:System.Globalization.CultureInfo.InvariantCulture%2A>

 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntStrInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrInt/CPP/comparestrintstrint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntStrInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrInt/CS/comparestrintstrint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntStrInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrInt/VB/comparestrintstrint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset1" /> 或 <paramref name="offset2" /> 小于零。

- 或 -

 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。

或

 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 此<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32)" />方法在执行语言或区分区域性的比较时不考虑这些字符。 若要在比较中识别可忽略字符, <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions)" />请调用方法, 并为<see cref="F:System.Globalization.CompareOptions.Ordinal" /> <paramref name="options" />参数<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />提供值或。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, string string2, int offset2, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, string string2, int32 offset2, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, string2 As String, offset2 As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, System::String ^ string2, int offset2, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * string * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.Compare : string * int * string * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.Compare (string1, offset1, string2, offset2, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1"><paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2"><paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="string1" /> 和 <paramref name="string2" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、<see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" /> 和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值将一个字符串的结尾部分与另一个字符串的结尾部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> 值

 </term><description> 条件

 </description></listheader><item><term> 零

 </term><description> 这两个字符串相等。

 </description></item><item><term> 小于零

 </term><description> <paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。

 </description></item><item><term> 大于零

 </term><description> <paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果安全决策取决于字符串比较或大小写更改, 则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性来确保无论操作系统的区域性设置如何, 行为都保持一致。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>指定或。



## Examples
 下面的示例使用不同<xref:System.Globalization.CompareOptions>的设置来比较两个字符串的各个部分。

 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntStrIntOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrIntOpt/CPP/comparestrintstrintopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntStrIntOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrIntOpt/CS/comparestrintstrintopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntStrIntOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntStrIntOpt/VB/comparestrintstrintopt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset1" /> 或 <paramref name="offset2" /> 小于零。

或

 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。

或

 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符，在执行语言性的或区分区域性的比较时该字符不被考虑。 执行<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.String,System.Int32,System.Globalization.CompareOptions)" />区分区域性的比较时, 该方法不会考虑此类字符。 若要在比较中识别可忽略字符, 请为<see cref="F:System.Globalization.CompareOptions.Ordinal" /> <paramref name="options" />参数<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />提供值或。</para></block>
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, int length1, string string2, int offset2, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, int32 length1, string string2, int32 offset2, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, length1 As Integer, string2 As String, offset2 As Integer, length2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, int length1, System::String ^ string2, int offset2, int length2);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * int * string * int * int -&gt; int&#xA;override this.Compare : string * int * int * string * int * int -&gt; int" Usage="compareInfo.Compare (string1, offset1, length1, string2, offset2, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1"><paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length1"><paramref name="string1" /> 中要比较的连续字符数。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2"><paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length2"><paramref name="string2" /> 中要比较的连续字符数。</param>
        <summary>将一个字符串的一部分与另一个字符串的一部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> 值

 </term><description> 条件

 </description></listheader><item><term> 零

 </term><description> 这两个字符串相等。

 </description></item><item><term> 小于零

 </term><description> <paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。

 </description></item><item><term> 大于零

 </term><description> <paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果安全决策取决于字符串比较或大小写更改, 则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性来确保无论操作系统的区域性设置如何, 行为都保持一致。

> [!NOTE]
>  如果可能, 应使用具有类型<xref:System.Globalization.CompareOptions>参数的字符串比较方法来指定预期的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>指定或。



## Examples
 下面的示例使用不同<xref:System.Globalization.CompareInfo>的对象比较两个字符串的各个部分:

-   <xref:System.Globalization.CompareInfo>与采用国际排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与采用传统排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与关联的对象。<xref:System.Globalization.CultureInfo.InvariantCulture%2A>

 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntIntStrIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntInt/CPP/comparestrintintstrintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntIntStrIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntInt/CS/comparestrintintstrintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntIntStrIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntInt/VB/comparestrintintstrintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset1" />、<paramref name="length1" />、<paramref name="offset2" /> 或 <paramref name="length2" /> 小于零。

或

 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。

- 或 -

 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。

- 或 -

 <paramref name="length1" /> 大于从 <paramref name="offset1" /> 到 <paramref name="string1" /> 末尾的字符数。

- 或 -

 <paramref name="length2" /> 大于从 <paramref name="offset2" /> 到 <paramref name="string2" /> 末尾的字符数。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 此<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32)" />方法在执行语言或区分区域性的比较时不考虑这些字符。 若要在比较中识别可忽略字符, <see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />请调用方法, 并为<see cref="F:System.Globalization.CompareOptions.Ordinal" /> <paramref name="options" />参数<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />提供值或。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public virtual int Compare (string string1, int offset1, int length1, string string2, int offset2, int length2, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Compare(string string1, int32 offset1, int32 length1, string string2, int32 offset2, int32 length2, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Compare (string1 As String, offset1 As Integer, length1 As Integer, string2 As String, offset2 As Integer, length2 As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Compare(System::String ^ string1, int offset1, int length1, System::String ^ string2, int offset2, int length2, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member Compare : string * int * int * string * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.Compare : string * int * int * string * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.Compare (string1, offset1, length1, string2, offset2, length2, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="string1" Type="System.String" />
        <Parameter Name="offset1" Type="System.Int32" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="string2" Type="System.String" />
        <Parameter Name="offset2" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="string1">要比较的第一个字符串。</param>
        <param name="offset1"><paramref name="string1" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length1"><paramref name="string1" /> 中要比较的连续字符数。</param>
        <param name="string2">要比较的第二个字符串。</param>
        <param name="offset2"><paramref name="string2" /> 中的字符从零开始的索引，将从此位置开始比较。</param>
        <param name="length2"><paramref name="string2" /> 中要比较的连续字符数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="string1" /> 和 <paramref name="string2" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、<see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" /> 和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值将一个字符串的一部分与另一个字符串的一部分相比较。</summary>
        <returns>一个 32 位有符号整数，指示两个比较数之间的词法关系。

 <list type="table"><listheader><term> 值

 </term><description> 条件

 </description></listheader><item><term> 零

 </term><description> 这两个字符串相等。

 </description></item><item><term> 小于零

 </term><description> <paramref name="string1" /> 的指定部分小于 <paramref name="string2" /> 的指定部分。

 </description></item><item><term> 大于零

 </term><description> <paramref name="string1" /> 的指定部分大于 <paramref name="string2" /> 的指定部分。

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果安全决策取决于字符串比较或大小写更改, 则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性来确保无论操作系统的区域性设置如何, 行为都保持一致。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase>指定或。



## Examples
 下面的示例使用不同<xref:System.Globalization.CompareOptions>的设置来比较两个字符串的各个部分。

 [!code-cpp[System.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt/CPP/comparestrintintstrintintopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt/CS/comparestrintintstrintintopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrIntIntStrIntIntOpt/VB/comparestrintintstrintintopt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset1" />、<paramref name="length1" />、<paramref name="offset2" /> 或 <paramref name="length2" /> 小于零。

或

 <paramref name="offset1" /> 大于或等于 <paramref name="string1" /> 中的字符数。

或

 <paramref name="offset2" /> 大于或等于 <paramref name="string2" /> 中的字符数。

或

 <paramref name="length1" /> 大于从 <paramref name="offset1" /> 到 <paramref name="string1" /> 末尾的字符数。

- 或 -

 <paramref name="length2" /> 大于从 <paramref name="offset2" /> 到 <paramref name="string2" /> 末尾的字符数。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符。 当<see cref="M:System.Globalization.CompareInfo.Compare(System.String,System.Int32,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法执行区分区域性的比较时, 该方法不考虑这些字符。 若要在比较中识别可忽略字符, 请为<see cref="F:System.Globalization.CompareOptions.Ordinal" /> <paramref name="options" />参数<see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />提供值或。</para></block>
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="compareInfo.Equals value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">将与当前 <see cref="T:System.Globalization.CompareInfo" /> 进行比较的对象。</param>
        <summary>确定指定的对象是否等于当前 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
        <returns>如果指定的对象等于当前的 <see cref="T:System.Globalization.CompareInfo" />，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果两个对象的<xref:System.Globalization.CompareInfo> <xref:System.Globalization.CompareInfo.Name%2A> 和属性相等,则这两<xref:System.Globalization.CompareInfo.LCID%2A>个对象相等。

 此方法重写 <xref:System.Object.Equals%2A?displayProperty=nameWithType>。

 如果安全决策取决于字符串比较或大小写更改, 则应使用<xref:System.Globalization.CultureInfo.InvariantCulture%2A>属性来确保无论操作系统的区域性设置如何, 行为都保持一致。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCompareInfo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化新的 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (int culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(int32 culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompareInfo (culture As Integer) As CompareInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(int culture);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : int -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">表示区域性标识符的整数。</param>
        <summary>初始化与具有指定标识符的区域性关联的新 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例使用不同<xref:System.Globalization.CompareInfo>的对象比较两个字符串的各个部分:

-   <xref:System.Globalization.CompareInfo>与采用国际排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与采用传统排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与关联的对象。<xref:System.Globalization.CultureInfo.InvariantCulture%2A>

 [!code-cpp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CPP/comparestrstr.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CS/comparestrstr.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/VB/comparestrstr.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCompareInfo (name As String) As CompareInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : string -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">表示区域性名称的字符串。</param>
        <summary>初始化与具有指定名称的区域性关联的新 <see cref="T:System.Globalization.CompareInfo" /> 对象。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例使用不同<xref:System.Globalization.CompareInfo>的对象比较两个字符串的各个部分:

-   <xref:System.Globalization.CompareInfo>与采用国际排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与采用传统排序的西班牙语 (西班牙) 区域性关联的对象

-   <xref:System.Globalization.CompareInfo>与关联的对象。<xref:System.Globalization.CultureInfo.InvariantCulture%2A>

 [!code-cpp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CPP/comparestrstr.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/CS/comparestrstr.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.CompareStrStr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.CompareStrStr/VB/comparestrstr.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 是无效的区域性名称。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (int culture, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(int32 culture, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.Int32,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(int culture, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : int * System.Reflection.Assembly -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo (culture, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="culture">表示区域性标识符的整数。</param>
        <param name="assembly">一个 <see cref="T:System.Reflection.Assembly" />，它包含将使用的字符串比较方法。</param>
        <summary>初始化一个新的 <see cref="T:System.Globalization.CompareInfo" /> 对象，该对象与指定区域性关联，并使用指定 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  此方法的行为是不可预测的。 建议应用程序使用不接受程序集输入的此方法版本。

 参数的类型必须与<xref:System.Reflection.Module.Assembly%2A?displayProperty=nameWithType>相同。 `assembly`

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="assembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="assembly" /> 属于无效类型。</exception>
        <altmember cref="P:System.Reflection.Module.Assembly" />
      </Docs>
    </Member>
    <Member MemberName="GetCompareInfo">
      <MemberSignature Language="C#" Value="public static System.Globalization.CompareInfo GetCompareInfo (string name, System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Globalization.CompareInfo GetCompareInfo(string name, class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetCompareInfo(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Globalization::CompareInfo ^ GetCompareInfo(System::String ^ name, System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetCompareInfo : string * System.Reflection.Assembly -&gt; System.Globalization.CompareInfo" Usage="System.Globalization.CompareInfo.GetCompareInfo (name, assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CompareInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="assembly" Type="System.Reflection.Assembly" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">表示区域性名称的字符串。</param>
        <param name="assembly">一个 <see cref="T:System.Reflection.Assembly" />，它包含将使用的字符串比较方法。</param>
        <summary>初始化一个新的 <see cref="T:System.Globalization.CompareInfo" /> 对象，该对象与指定区域性关联，并使用指定 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</summary>
        <returns>一个新 <see cref="T:System.Globalization.CompareInfo" /> 对象，它与具有指定标识符的区域性关联，并使用当前 <see cref="T:System.Reflection.Assembly" /> 中的字符串比较方法。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!NOTE]
>  此方法的行为是不可预测的。 建议使用不带程序集输入的此方法的版本。

 参数的类型必须与<xref:System.Reflection.Module.Assembly%2A?displayProperty=nameWithType>相同。 `assembly`

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。

- 或 -

 <paramref name="assembly" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> 是无效的区域性名称。

- 或 -

 <paramref name="assembly" /> 属于无效类型。</exception>
        <altmember cref="P:System.Reflection.Module.Assembly" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetHashCode">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回此 <see cref="T:System.Globalization.CompareInfo" /> 实例或特定字符串的哈希代码。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="compareInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>用作当前 <see cref="T:System.Globalization.CompareInfo" /> 的哈希函数，适合在哈希算法和数据结构（如哈希表）中使用。</summary>
        <returns>当前 <see cref="T:System.Globalization.CompareInfo" /> 的哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法重写 <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>。

 此方法为根据 <xref:System.Globalization.CompareInfo.Equals%2A> 方法视为相等的两个对象生成相同的哈希代码。

 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Globalization.CompareInfo.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (ReadOnlySpan&lt;char&gt; source, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; source, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetHashCode(System.ReadOnlySpan{System.Char},System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (source As ReadOnlySpan(Of Char), options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(ReadOnlySpan&lt;char&gt; source, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : ReadOnlySpan&lt;char&gt; * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.GetHashCode (source, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="source">要返回其哈希代码的字符范围。</param>
        <param name="options">确定如何比较字符串的值。</param>
        <summary>根据指定的比较选项获取字符范围的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此重载的行为取决于其实现, 该实现可能会从一个版本的公共语言运行时更改为另一个版本, 或从一个 .NET 实现更改为另一个版本。

> [!IMPORTANT]
>  如果两个字符跨越相等, 则此重载返回相同的值。 但是, 每个唯一字符跨度值没有唯一的哈希代码值。 不同的字符跨度可以返回相同的哈希代码。
>
>  哈希代码本身不一定是稳定的。 对于单个版本的 .net, 相同字符跨度的哈希代码在不同版本的 .NET 实现和各种平台 (如32位和64位) 之间可能会有所不同。
>
>  因此, 哈希代码决不能在创建它们的应用程序域的外部使用, 它们永远不应用作集合中的键字段, 它们永远不会保留。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode (string source, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode(string source, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetHashCode(System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode (source As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode(System::String ^ source, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.GetHashCode (source, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="source">要返回其哈希代码的字符串。</param>
        <param name="options">确定如何比较字符串的值。</param>
        <summary>根据指定的比较选项获取字符串的哈希代码。</summary>
        <returns>32 位有符号整数哈希代码。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 的<xref:System.Globalization.CompareInfo.GetHashCode%2A>行为依赖于其实现, 该实现可能会从公共语言运行时的一个版本更改为另一个版本, 或从一个 .NET Framework 平台更改为另一个版本。

> [!IMPORTANT]
>  如果两个字符串对象相等, 则<xref:System.Globalization.CompareInfo.GetHashCode%2A>该方法将返回相同的值。 但是, 每个唯一字符串值没有唯一的哈希代码值。 不同的字符串可以返回相同的哈希代码。
>
>  哈希代码本身不一定是稳定的。 对于同一版本的 .NET Framework, 相同字符串的哈希代码可能不同于不同版本的 .NET Framework 和跨平台 (例如32位和64位)。 在某些情况下, 它们甚至不同于应用程序域。
>
>  因此, 哈希代码决不能在创建它们的应用程序域的外部使用, 它们永远不应用作集合中的键字段, 它们永远不会保留。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSortKey">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>获取字符串的 <see cref="T:System.Globalization.SortKey" /> 对象。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSortKey">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.SortKey GetSortKey (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Globalization.SortKey GetSortKey(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetSortKey(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSortKey (source As String) As SortKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Globalization::SortKey ^ GetSortKey(System::String ^ source);" />
      <MemberSignature Language="F#" Value="abstract member GetSortKey : string -&gt; System.Globalization.SortKey&#xA;override this.GetSortKey : string -&gt; System.Globalization.SortKey" Usage="compareInfo.GetSortKey source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.SortKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">获取其 <see cref="T:System.Globalization.SortKey" /> 对象的字符串。</param>
        <summary>获取指定字符串的排序关键字。</summary>
        <returns>包含指定字符串的排序关键字的 <see cref="T:System.Globalization.SortKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 字符串中的每个字符都被给定多个排序权重类别, 包括脚本、字母、大小写和音调符号权重。 排序关键字是特定字符串的这些权重的存储库。 例如, 排序关键字可能包含字母权重的字符串, 后跟大小写权重等字符串。 方法等效于带有 LCMAP_SORTKEY 标志的 Windows API `LCMapString`方法。 <xref:System.Globalization.CompareInfo.GetSortKey%2A>

 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.SortKey" />
      </Docs>
    </Member>
    <Member MemberName="GetSortKey">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.SortKey GetSortKey (string source, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Globalization.SortKey GetSortKey(string source, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.GetSortKey(System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSortKey (source As String, options As CompareOptions) As SortKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Globalization::SortKey ^ GetSortKey(System::String ^ source, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member GetSortKey : string * System.Globalization.CompareOptions -&gt; System.Globalization.SortKey&#xA;override this.GetSortKey : string * System.Globalization.CompareOptions -&gt; System.Globalization.SortKey" Usage="compareInfo.GetSortKey (source, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.SortKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">获取其 <see cref="T:System.Globalization.SortKey" /> 对象的字符串。</param>
        <param name="options">以下一个或多个定义该排序关键字如何计算的枚举值的按位组合: <see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreWidth" />、 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />和 <see cref="F:System.Globalization.CompareOptions.StringSort" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.SortKey" /> 值获取指定字符串的 <see cref="T:System.Globalization.CompareOptions" /> 对象。</summary>
        <returns>包含指定字符串的排序关键字的 <see cref="T:System.Globalization.SortKey" /> 对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 字符串中的每个字符都被给定多个排序权重类别, 包括脚本、字母、大小写和音调符号权重。 排序关键字是特定字符串的这些权重的存储库。 例如, 排序关键字可能包含字母权重的字符串, 后跟大小写权重等字符串。 方法等效于带有 LCMAP_SORTKEY 标志的 Windows API `LCMapString`方法。 <xref:System.Globalization.CompareInfo.GetSortKey%2A>

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <altmember cref="T:System.Globalization.SortKey" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回某个值在一个字符串内或该字符串的一部分中第一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char -&gt; int&#xA;override this.IndexOf : string * char -&gt; int" Usage="compareInfo.IndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <summary>搜索指定的字符并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的第一个匹配项从零开始的索引；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法搜索字符串开头到字符串末尾的源字符串。

 此重载执行区分区域性的搜索。 如果`value`表示预构成 Unicode 字符 (如连字 "Æ" (u + 00C6)), 则它可能被视为等效于其组件在正确序列中的任何匹配项, 如 "AE" (u + 0041、u + 0045), 具体取决于区域性。 若要执行序号 (不区分区域性的) 搜索, 其中仅当字符的 Unicode 码位相同时才将其视为等效于另一个字符的, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载, 并使用<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>负值. 与<xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>(执行区分区域性的比较) 不同的是, 用于<xref:System.String.IndexOf%2A?displayProperty=nameWithType>搜索字符的方法的重载执行序号比较, 而用于搜索字符串的重载执行区分区域性的比较。

> [!NOTE]
>  如果可能, 应使用具有类型<xref:System.Globalization.CompareOptions>参数的字符串比较方法来指定预期的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" /> , 此方法始终返回 0 (零), 指示在<paramref name="source" />开头找到匹配项。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />方法用于在两个字符串中查找软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符为可忽略字符, 该方法将返回 0 (零), 指示它已在字符串的开头找到匹配项。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable2.cs#3)] [!code-vb[System.Globalization.CompareInfo.IndexOf#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable2.vb#3)]</para></block>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string -&gt; int&#xA;override this.IndexOf : string * string -&gt; int" Usage="compareInfo.IndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <summary>搜索指定的子字符串并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的第一个匹配项从零开始的索引；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从字符串的开头开始向前搜索源字符串, 并在字符串末尾结束。

 此重载执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性) 搜索, 其中 Unicode 值比较, 应使用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并<xref:System.Globalization.CompareOptions.Ordinal>使用值。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String)" />则此方法始终返回 0 (零) 以指示在开头<paramref name="source" />找到匹配项。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String)" />方法用于在两个字符串中查找三个子字符串 (软连字符 (U + 00AD)、软连字符后跟 "n" 和软连字符后跟 "m")。 只有一个字符串包含软连字符。 在每种情况下, 因为软连字符是可忽略字符, 所以结果与中<paramref name="value" />未包含软连字符的结果相同。 仅搜索软连字符时, 该方法返回 0 (零), 指示它已在字符串的开头找到匹配项。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable1.cs#2)] [!code-vb[System.Globalization.CompareInfo.IndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable1.vb#2)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * char * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="options">一个值，用于定义应如何比较这些字符串。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中找到 <paramref name="source" /> 的第一个匹配项的从零开始的索引，使用指定的比较选项；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从字符串的开头开始向前搜索源字符串, 并在字符串末尾结束。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性的) 搜索。 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符。 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应使用具有类型<xref:System.Globalization.CompareOptions>参数的字符串比较方法来指定预期的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Globalization.CompareOptions)" /> , 此方法始终返回 0 (零), 指示在<paramref name="source" />开头找到匹配项。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />方法用于在两个字符串中搜索软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符为可忽略字符, 所以区分区域性的搜索将返回 0 (零), 指示它已在字符串的开头找到匹配项。 不过, 序号搜索成功地在一个字符串中查找软连字符, 并报告从第二个字符串中缺少它。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable3.cs#4)] [!code-vb[System.Globalization.CompareInfo.IndexOf#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable3.vb#4)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int -&gt; int&#xA;override this.IndexOf : string * char * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Char" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <summary>搜索指定的字符，并返回源字符串内从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 到 <paramref name="startIndex" /> 的结尾这一部分）中找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从字符串的末尾开始向前搜索开始`startIndex`处的源字符串。

 此重载执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性的) 搜索, 其中, 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并使用<xref:System.Globalization.CompareOptions.Ordinal>负值. <xref:System.String.IndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32)" /> , 方法总是<paramref name="startIndex" />返回, 这是搜索开始处的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32)" />方法用于查找两个字符串中 "n" 后的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符为可忽略字符, 所以该方法返回 1, 指示它在 "n" 的位置找到了匹配项。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable4.cs#5)] [!code-vb[System.Globalization.CompareInfo.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable4.vb#5)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回整个源字符串内第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 中找到 <paramref name="source" /> 的第一个匹配项的从零开始的索引，使用指定的比较选项；否则为 -1。 如果 <paramref name="value" /> 为可忽略字符，则将返回 0（零）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从字符串的开头开始向前搜索源字符串, 并在字符串末尾结束。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性) 搜索, 其中 Unicode 值将进行比较。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Globalization.CompareOptions)" />则此方法始终返回 0 (零) 以指示在开头<paramref name="source" />找到匹配项。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找三个子字符串 (软连字符 (U + 00AD)、软连字符后跟 "n" 和软连字符后跟 "m")。 只有一个字符串包含软连字符。 由于软连字符是可忽略字符, 因此, 区分区域性的搜索将返回在搜索字符串中未包含软连字符时返回的相同值。 不过, 序号搜索成功地在一个字符串中查找软连字符, 并报告从第二个字符串中缺少它。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable5.cs#6)] [!code-vb[System.Globalization.CompareInfo.IndexOf#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable5.vb#6)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int -&gt; int&#xA;override this.IndexOf : string * string * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <summary>搜索指定的子字符串，并返回源字符串内从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 到 <paramref name="startIndex" /> 的结尾这一部分）中找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从字符串的末尾开始向前搜索开始`startIndex`处的源字符串。

 此重载执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性) 搜索, 其中 Unicode 值比较, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并<xref:System.Globalization.CompareOptions.Ordinal>使用值。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

- 或 -

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。

在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32)" />方法用于查找软连字符的位置 (U + 00AD), 后跟两个字符串中的 "m"。 只有一个字符串包含必需的子字符串。 在这两种情况下, 因为软连字符为可忽略字符, 该方法将返回字符串中的 "m" 的索引。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable13.cs#14)] [!code-vb[System.Globalization.CompareInfo.IndexOf#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable13.vb#14)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串中从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="startIndex" /> 的结尾这部分找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从字符串的末尾开始向前搜索开始`startIndex`处的源字符串。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性的) 搜索。 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符。 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" /> , 该方法<paramref name="startIndex" />始终返回, 即搜索第一次开始的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />方法用于查找两个字符串中 "n" 后的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符为可忽略字符, 所以区分区域性的搜索将返回 1, 指示它在 "n" 的位置找到了匹配项。 不过, 序号搜索成功地在一个字符串中查找软连字符, 并报告从第二个字符串中缺少它。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable7.cs#8)] [!code-vb[System.Globalization.CompareInfo.IndexOf#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable7.vb#8)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int * int -&gt; int&#xA;override this.IndexOf : string * char * int * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的字符，并返回源字符串内从指定的索引位置开始、包含指定的元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 的从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 所指定的元素数的部分中，找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `startIndex`将从`startIndex`  +  -1 开始向前搜索源字符串。 `count`

 此重载执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性的) 搜索, 其中, 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并使用<xref:System.Globalization.CompareOptions.Ordinal>负值. <xref:System.String.IndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

或

 <paramref name="count" /> 小于零。

或

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32)" /> , 该方法<paramref name="startIndex" />总是返回, 这是搜索第一次开始的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32)" />方法用于查找两个字符串中 "n" 后的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符为可忽略字符, 所以该方法返回 1, 指示它在 "n" 的位置找到了匹配项。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable8.cs#9)] [!code-vb[System.Globalization.CompareInfo.IndexOf#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable8.vb#9)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内从指定的索引位置到字符串结尾这一部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="startIndex" /> 的结尾这部分找到 <paramref name="source" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从字符串的末尾开始向前搜索开始`startIndex`处的源字符串。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性) 搜索, 其中 Unicode 值将进行比较。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。

在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />方法用于从两个字符串中的第三个字符位置开始, 查找软连字符 (U + 00AD) 后跟 "m" 的位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable14.cs#15)] [!code-vb[System.Globalization.CompareInfo.IndexOf#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable14.vb#15)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int * int -&gt; int&#xA;override this.IndexOf : string * string * int * int -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的子字符串，并返回源字符串内从指定的索引位置开始、包含指定的元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>如果在 <paramref name="value" /> 的从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 所指定的元素数的部分中，找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `startIndex`将从`startIndex`  +  -1 开始向前搜索源字符串。 `count`

 此重载执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性) 搜索, 其中 Unicode 值比较, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并<xref:System.Globalization.CompareOptions.Ordinal>使用值。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

- 或 -

 <paramref name="count" /> 小于零。

或

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。

在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32)" />方法用于查找软连字符 (U + 00AD) 后跟 "m" 的位置, 该位置从两个字符串中的第三个到第六个字符位置开始。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable16.cs#17)] [!code-vb[System.Globalization.CompareInfo.IndexOf#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable16.vb#17)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, char value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As Char, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, char value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串内从指定的索引位置开始、包含所指定元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 指定的元素数的部分找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `startIndex`将从`startIndex`  +  -1 开始向前搜索源字符串。 `count`

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性的) 搜索。 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符。 <xref:System.String.IndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

或

 <paramref name="count" /> 小于零。

或

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" /> , 该方法<paramref name="startIndex" />总是返回, 这是搜索第一次开始的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于查找两个字符串中 "n" 后的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符为可忽略字符, 所以区分区域性的搜索将返回 1, 指示它在 "n" 的位置找到了匹配项。 不过, 序号搜索成功地在一个字符串中查找软连字符, 并报告从第二个字符串中缺少它。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable11.cs#12)] [!code-vb[System.Globalization.CompareInfo.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable11.vb#12)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(string source, string value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (source As String, value As String, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::String ^ source, System::String ^ value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.IndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.IndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">从零开始的搜索的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内从指定的索引位置开始、包含所指定元素数的部分中第一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 开始、包含 <paramref name="startIndex" /> 指定的元素数的部分找到 <paramref name="count" /> 的第一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `startIndex`将从`startIndex`  +  -1 开始向前搜索源字符串。 `count`

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性) 搜索, 其中 Unicode 值将进行比较。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

- 或 -

 <paramref name="count" /> 小于零。

或

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。

在下面的示例中, <see cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于查找软连字符 (U + 00AD) 后跟 "m" 的位置, 该位置从两个字符串中的第三个到第六个字符位置开始。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 但当它执行序号比较时, 它只查找第一个字符串中的子字符串。 请注意, 对于包含软连字符后跟 "m" 的软连字符的第一个字符串, 该方法将无法返回软连字符的索引, 而是在执行区分区域性的比较时返回 "m" 的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[!code-csharp[System.Globalization.CompareInfo.IndexOf#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/ignorable15.cs#16)] [!code-vb[System.Globalization.CompareInfo.IndexOf#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/ignorable15.vb#16)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsPrefix">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定字符串是否以指定的前缀开头。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsPrefix">
      <MemberSignature Language="C#" Value="public virtual bool IsPrefix (string source, string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsPrefix(string source, string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsPrefix (source As String, prefix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsPrefix(System::String ^ source, System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member IsPrefix : string * string -&gt; bool&#xA;override this.IsPrefix : string * string -&gt; bool" Usage="compareInfo.IsPrefix (source, prefix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="prefix">要与 <paramref name="source" /> 的开头进行比较的字符串。</param>
        <summary>确定指定的源字符串是否以指定的前缀开头。</summary>
        <returns>如果 <paramref name="prefix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="prefix" /> 开始，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 每个字符串的开头和结尾均为空子字符串 ("");因此, 如果`prefix`是空字符串, 则此方法返回`true`。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符串是另一个字符串的前缀还是后缀。

 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CPP/isprefixsuffix.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CS/isprefixsuffix.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/VB/isprefixsuffix.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

- 或 -

 <paramref name="prefix" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="IsPrefix">
      <MemberSignature Language="C#" Value="public virtual bool IsPrefix (string source, string prefix, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsPrefix(string source, string prefix, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsPrefix (source As String, prefix As String, options As CompareOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsPrefix(System::String ^ source, System::String ^ prefix, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IsPrefix : string * string * System.Globalization.CompareOptions -&gt; bool&#xA;override this.IsPrefix : string * string * System.Globalization.CompareOptions -&gt; bool" Usage="compareInfo.IsPrefix (source, prefix, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="prefix">要与 <paramref name="source" /> 的开头进行比较的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="prefix" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值确定指定的源字符串是否以指定的前缀开头。</summary>
        <returns>如果 <paramref name="prefix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="prefix" /> 开始，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 每个字符串的开头和结尾均为空子字符串 ("");因此, 如果`prefix`是空字符串, 则此方法返回`true`。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符串是使用<xref:System.Globalization.CompareOptions>的另一个字符串的前缀还是后缀。

 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CPP/isprefixsuffixopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CS/isprefixsuffixopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/VB/isprefixsuffixopt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="prefix" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSortable">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指示指定的 Unicode 字符或字符串是否可排序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSortable">
      <MemberSignature Language="C#" Value="public static bool IsSortable (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSortable(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSortable(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSortable (ch As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSortable(char ch);" />
      <MemberSignature Language="F#" Value="static member IsSortable : char -&gt; bool" Usage="System.Globalization.CompareInfo.IsSortable ch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="ch">一个 Unicode 字符。</param>
        <summary>指示指定的 Unicode 字符是否可排序。</summary>
        <returns>如果 <paramref name="ch" /> 参数可排序，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 如果`ch`参数是在内部<xref:System.Globalization.CompareInfo>类排序表中定义的 Unicode 字符, 并且不是 private use 或不成对的高或低代理项字符, 则该参数是可排序的。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSortable">
      <MemberSignature Language="C#" Value="public static bool IsSortable (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSortable(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSortable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSortable (text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSortable(System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsSortable : string -&gt; bool" Usage="System.Globalization.CompareInfo.IsSortable text" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="text">由 0 或更多 Unicode 字符组成的字符串。</param>
        <summary>指示指定的 Unicode 字符串是否可排序。</summary>
        <returns>如果 <paramref name="str" /> 参数不是空字符串 ("") 且 <paramref name="str" /> 中的所有 Unicode 字符都是可排序的，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 参数中的`str`每个 Unicode 字符都由一个或多个 utf-16 编码<xref:System.Char>对象表示。 如果`str`每个 Unicode 字符都是在内部<xref:System.Globalization.CompareInfo>类排序表中定义的, 并且不是 private use 或不成对的高或低代理项字符, 则可对参数进行排序。

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsSuffix">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定字符串是否以特定的后缀结尾。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsSuffix">
      <MemberSignature Language="C#" Value="public virtual bool IsSuffix (string source, string suffix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSuffix(string source, string suffix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSuffix (source As String, suffix As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSuffix(System::String ^ source, System::String ^ suffix);" />
      <MemberSignature Language="F#" Value="abstract member IsSuffix : string * string -&gt; bool&#xA;override this.IsSuffix : string * string -&gt; bool" Usage="compareInfo.IsSuffix (source, suffix)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="suffix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="suffix">要与 <paramref name="source" /> 的结尾进行比较的字符串。</param>
        <summary>确定指定的源字符串是否以指定的后缀结尾。</summary>
        <returns>如果 <paramref name="suffix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="suffix" /> 结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 每个字符串的开头和结尾均为空子字符串 ("");因此, 如果`suffix`是空字符串, 则此方法返回`true`。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符串是另一个字符串的前缀还是后缀。

 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CPP/isprefixsuffix.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/CS/isprefixsuffix.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffix/VB/isprefixsuffix.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

- 或 -

 <paramref name="suffix" /> 为 <see langword="null" />。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="IsSuffix">
      <MemberSignature Language="C#" Value="public virtual bool IsSuffix (string source, string suffix, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSuffix(string source, string suffix, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.IsSuffix(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSuffix (source As String, suffix As String, options As CompareOptions) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSuffix(System::String ^ source, System::String ^ suffix, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member IsSuffix : string * string * System.Globalization.CompareOptions -&gt; bool&#xA;override this.IsSuffix : string * string * System.Globalization.CompareOptions -&gt; bool" Usage="compareInfo.IsSuffix (source, suffix, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="suffix" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要在其中搜索的字符串。</param>
        <param name="suffix">要与 <paramref name="source" /> 的结尾进行比较的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="suffix" />。 <paramref name="options" /> 可以为其自身使用的枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值确定指定的源字符串是否以指定的后缀结尾。</summary>
        <returns>如果 <paramref name="suffix" /> 的长度小于或等于 <paramref name="source" /> 的长度，并且 <paramref name="source" /> 以 <paramref name="suffix" /> 结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 每个字符串的开头和结尾均为空子字符串 ("");因此, 如果`suffix`是空字符串, 则此方法返回`true`。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符串是使用<xref:System.Globalization.CompareOptions>的另一个字符串的前缀还是后缀。

 [!code-cpp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CPP/isprefixsuffixopt.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/CS/isprefixsuffixopt.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IsPrefixSuffixOpt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IsPrefixSuffixOpt/VB/isprefixsuffixopt.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

- 或 -

 <paramref name="suffix" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>返回某个值在一个字符串内或该字符串的一部分中最后一个匹配项的从零开始的索引。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char -&gt; int&#xA;override this.LastIndexOf : string * char -&gt; int" Usage="compareInfo.LastIndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <summary>搜索指定的字符，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的最后一个匹配项从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后搜索, 从字符串末尾开始, 到字符串的开头处结束。

 此重载执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性的) 搜索, 其中, 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并使用<xref:System.Globalization.CompareOptions.Ordinal>负值. <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" /> , 方法始终返回中<paramref name="source" />的最后一个索引位置, 以指示在结束时<paramref name="source" />找到匹配项。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char)" />方法用于在两个字符串中查找软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 由于软连字符为可忽略字符, 该方法将返回字符串中的最后一个索引位置, 以指示它已在字符串末尾找到匹配项。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable2.cs#3)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable2.vb#3)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string -&gt; int&#xA;override this.LastIndexOf : string * string -&gt; int" Usage="compareInfo.LastIndexOf (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <summary>搜索指定的子字符串，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>如果找到，则为 <paramref name="value" /> 在 <paramref name="source" /> 内的最后一个匹配项从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后搜索, 从字符串末尾开始, 到字符串的开头处结束。

 此重载执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性) 搜索, 其中 Unicode 值比较, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>使用值。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个忽略字符, 该<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String)" />方法将始终<paramref name="source" />返回。<see cref="P:System.String.Length" /> -1, 表示中<paramref name="source" />的最后一个索引位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String)" />方法用于在两个字符串中查找三个子字符串 (软连字符 (U + 00AD)、软连字符后跟 "n" 和软连字符后跟 "m")。 只有一个字符串包含软连字符。 在每种情况下, 因为软连字符是可忽略字符, 所以结果与中<paramref name="value" />未包含软连字符的结果相同。 仅搜索软连字符时, 该方法返回6和5。 这些值对应于两个字符串中最后一个字符的索引。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable1.cs#2)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable1.vb#2)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * char * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在<paramref name="value" /> 中找到 <paramref name="source" /> 的最后一个匹配项，则为从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后搜索, 从字符串末尾开始, 到字符串的开头处结束。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性的) 搜索。 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符。 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Globalization.CompareOptions)" /> , 方法始终返回中<paramref name="source" />的最后一个字符位置, 以指示在结束时<paramref name="source" />找到匹配项。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Globalization.CompareOptions)" />方法用于在两个字符串中搜索软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符是可忽略字符, 所以区分区域性的搜索将返回源字符串中的最后一个索引位置。 与此相反, 序号搜索成功地在一个字符串中查找软连字符, 并报告它在第二个字符串中不存在。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable3.cs#4)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable3.vb#4)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int -&gt; int&#xA;override this.LastIndexOf : string * char * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.Char" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的字符，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 的开头到 <paramref name="source" /> 这一部分）中找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将从字符串开头开始`startIndex`向后搜索源字符串。

 此重载执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性的) 搜索, 其中, 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并使用<xref:System.Globalization.CompareOptions.Ordinal>负值. <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32)" /> , 方法总是<paramref name="startIndex" />返回, 这是搜索开始处的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32)" />方法用于查找两个字符串中位于最后一个 "m" 之前的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符是可忽略字符, 所以该方法返回 "m" 的索引位置, 这是的<paramref name="startIndex" />值。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable4.cs#5)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable4.vb#5)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * string * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回整个源字符串内最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在<paramref name="value" /> 中找到 <paramref name="source" /> 的最后一个匹配项，则为从零开始的索引；否则为 -1。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后搜索, 从字符串末尾开始, 到字符串的开头处结束。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性) 搜索, 其中 Unicode 值将进行比较。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例将确定字符串中第一个字符或子字符串的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CPP/indexof.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/CS/indexof.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOf/VB/indexof.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个忽略字符, 该<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Globalization.CompareOptions)" />方法将始终<paramref name="source" />返回。<see cref="P:System.String.Length" /> -1, 表示中<paramref name="source" />的最后一个索引位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Globalization.CompareOptions)" />方法用于在两个字符串中查找三个子字符串 (软连字符 (U + 00AD)、软连字符后跟 "n" 和软连字符后跟 "m")。 只有一个字符串包含软连字符。 由于软连字符是可忽略字符, 因此, 区分区域性的搜索将返回在搜索字符串中未包含软连字符时返回的相同值。 不过, 序号搜索成功地在一个字符串中查找软连字符, 并报告从第二个字符串中缺少它。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable5.cs#6)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable5.vb#6)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int -&gt; int&#xA;override this.LastIndexOf : string * string * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="value" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <summary>搜索指定的子字符串，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>如果在部分 <paramref name="value" />（从 <paramref name="source" /> 的开头到 <paramref name="source" /> 这一部分）中找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将从字符串开头开始`startIndex`向后搜索源字符串。

 此重载执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性) 搜索, 其中 Unicode 值比较, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>使用值。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

- 或 -

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32)" />方法用于查找包含软连字符 (U + 00AD) 并且在字符串中之前或包含最终 "m" 的子字符串。 由于搜索字符串中的软连字符被忽略, 因此调用方法查找包含软连字符的子字符串, 并将 "m" 返回到字符串中的 "m" 的位置, 而调用它可查找包含软连字符的子字符串, "n" 将返回 "n" 的位置。 如果搜索字符串只包含软连字符, 则方法返回 "m" 的索引, 该索引表示的值<paramref name="startIndex" />。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable6.cs#7)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable6.vb#7)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * char * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="source" /> 的开始这部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将从字符串开头开始`startIndex`向后搜索源字符串。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性的) 搜索。 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符。 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" /> , 方法总是<paramref name="startIndex" />返回, 这是搜索开始处的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Globalization.CompareOptions)" />方法用于查找两个字符串中位于最后一个 "m" 之前的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符是可忽略字符, 所以区分区域性的搜索将返回 "m" 的索引位置。 不过, 序号搜索成功地在一个字符串中查找软连字符, 并报告从第二个字符串中缺少它。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable7.cs#8)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable7.vb#8)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int * int -&gt; int&#xA;override this.LastIndexOf : string * char * int * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的字符，并返回源字符串内包含指定的元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>在包含 <paramref name="value" /> 所指定的元素数并以 <paramref name="source" /> 结尾的这部分 <paramref name="count" /> 中，如果找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后`startIndex`搜索, `startIndex`  -  `count`从 + 1 开始向后搜索。

 此重载执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性的) 搜索, 其中, 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并使用<xref:System.Globalization.CompareOptions.Ordinal>负值. <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

或

 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32)" /> , 方法总是<paramref name="startIndex" />返回, 这是搜索开始处的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32)" />方法用于查找两个字符串中位于最后一个 "m" 之前的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符是可忽略字符, 所以该方法返回 "m" 的索引位置, 这是的<paramref name="startIndex" />值。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable8.cs#9)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable8.vb#9)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * string * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内从字符串开头到指定的索引位置这一部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中从 <paramref name="source" /> 一直到 <paramref name="source" /> 的开始这部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 将从字符串开头开始`startIndex`向后搜索源字符串。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性) 搜索, 其中 Unicode 值将进行比较。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。 请注意, <xref:System.Globalization.CompareInfo.LastIndexOf%2A> `startIndex`和将在字符串的不同部分中搜索, 即使具有相同的参数也是如此。 <xref:System.Globalization.CompareInfo.IndexOf%2A>

 [!code-cpp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CPP/indexofint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/CS/indexofint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfInt/VB/indexofint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

- 或 -

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。

在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Globalization.CompareOptions)" />方法用于查找软连字符 (U + 00AD) 后跟 "m" 的位置 (从两个字符串中的最后一个 "m" 开始)。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable14.cs#15)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable14.vb#15)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int * int -&gt; int&#xA;override this.LastIndexOf : string * string * int * int -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <summary>搜索指定的子字符串，并返回源字符串内包含指定的元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>在包含 <paramref name="value" /> 所指定的元素数并以 <paramref name="source" /> 结尾的这部分 <paramref name="count" /> 中，如果找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后`startIndex`搜索, `startIndex`  -  `count`从 + 1 开始向后搜索。

 此重载执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 若要执行序号 (不区分区域性) 搜索, 其中 Unicode 值比较, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的重载之一, 并<xref:System.Globalization.CompareOptions.Ordinal>使用值。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

- 或 -

 <paramref name="count" /> 小于零。

或

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。

在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32)" />方法用于查找软连字符的位置 (U + 00AD), 后跟两个字符串的最后 "m" 前面三个字符中的 "m"。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 注意对于第一个字符串，包含软连字符后跟“m”，该方法无法返回该软连字符的索引，而是返回“m”的索引。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable16.cs#17)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable16.vb#17)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, char value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As Char, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, char value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * char * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的字符，并返回源字符串内包含所指定元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中结束于 <paramref name="source" /> 、包含 <paramref name="count" /> 指定的元素数的部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后`startIndex`搜索, `startIndex`  -  `count`从 + 1 开始向后搜索。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 如果该字符是表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)), 则它可能被视为等效于正确序列中出现的任何组件 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性的) 搜索。 仅当 Unicode 值相同时, 才将字符视为等效于另一个字符。 <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType>搜索字符的重载执行序号搜索, 而搜索字符串的重载执行区分区域性的搜索。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

或

 <paramref name="count" /> 小于零。

或

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索中, 如果<paramref name="value" />是可忽略字符, 则结果等效于在删除该字符的情况下进行搜索。 在这种情况下<see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" /> , 方法总是<paramref name="startIndex" />返回, 这是搜索开始处的字符位置。 在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.Char,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于查找两个字符串中位于最后一个 "m" 之前的软连字符 (U + 00AD)。 只有一个字符串包含软连字符。 在这两种情况下, 因为软连字符为可忽略字符, 所以区分区域性的搜索将返回 "m" 的索引位置, 即的值<paramref name="startIndex" />。 不过, 序号搜索成功地在一个字符串中查找软连字符, 并报告从第二个字符串中缺少它。

[!code-csharp[System.Globalization.CompareInfo.LastIndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/cs/lastignorable11.cs#12)] [!code-vb[System.Globalization.CompareInfo.LastIndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable11.vb#12)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public virtual int LastIndexOf (string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 LastIndexOf(string source, string value, int32 startIndex, int32 count, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LastIndexOf (source As String, value As String, startIndex As Integer, count As Integer, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int LastIndexOf(System::String ^ source, System::String ^ value, int startIndex, int count, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="abstract member LastIndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int&#xA;override this.LastIndexOf : string * string * int * int * System.Globalization.CompareOptions -&gt; int" Usage="compareInfo.LastIndexOf (source, value, startIndex, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="source">要搜索的字符串。</param>
        <param name="value">要在 <paramref name="source" /> 中定位的字符串。</param>
        <param name="startIndex">向后搜索的从零开始的起始索引。</param>
        <param name="count">要搜索的部分中的元素数。</param>
        <param name="options">一个值，用于定义应如何比较 <paramref name="source" /> 和 <paramref name="value" />。 <paramref name="options" /> 可以为枚举值 <see cref="F:System.Globalization.CompareOptions.Ordinal" />，或为以下一个或多个值的按位组合：<see cref="F:System.Globalization.CompareOptions.IgnoreCase" />、<see cref="F:System.Globalization.CompareOptions.IgnoreSymbols" />、<see cref="F:System.Globalization.CompareOptions.IgnoreNonSpace" />、<see cref="F:System.Globalization.CompareOptions.IgnoreWidth" /> 和 <see cref="F:System.Globalization.CompareOptions.IgnoreKanaType" />。</param>
        <summary>使用指定的 <see cref="T:System.Globalization.CompareOptions" /> 值，搜索指定的子字符串，并返回源字符串内包含所指定元素数、以指定的索引位置结尾的部分中最后一个匹配项的从零开始的索引。</summary>
        <returns>使用指定的比较选项，如果在 <paramref name="value" /> 中结束于 <paramref name="source" /> 、包含 <paramref name="count" /> 指定的元素数的部分找到 <paramref name="startIndex" /> 的最后一个匹配项，则为该项的从零开始的索引；否则为 -1。 如果 <paramref name="startIndex" /> 为可忽略字符，则将返回 <paramref name="value" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 从源字符串向后`startIndex`搜索, `startIndex`  -  `count`从 + 1 开始向后搜索。

 此<xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>方法的值无效。

 如果`options` 不<xref:System.Globalization.CompareOptions.Ordinal>包含该值, 此重载将执行区分区域性的搜索。 表示预构成字符的 Unicode 值 (如连字 "Æ" (U + 00C6)) 可能被视为等效于正确序列中任何字符的组成部分 (例如, "AE" (U + 0041, U + 0045), 具体取决于区域性)。 `options` 如果<xref:System.Globalization.CompareOptions.Ordinal>包含值, 则此重载执行序号 (不区分区域性) 搜索, 其中 Unicode 值将进行比较。

> [!NOTE]
>  如果可能, 应调用具有类型<xref:System.Globalization.CompareOptions>的参数的字符串比较方法, 以指定所需的比较类型。 作为一般规则, 请使用语言选项 (使用当前区域性) 比较用户界面中显示的字符串, 并为安全<xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType>比较<xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType>指定或。



## Examples
 下面的示例确定字符或字符串的一部分中的第一个和最后一个匹配项的索引。

 [!code-cpp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CPP/indexofintint.cpp#1)]
 [!code-csharp[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/CS/indexofintint.cs#1)]
 [!code-vb[System.Globalization.CompareInfo.IndexOfIntInt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Globalization.CompareInfo.IndexOfIntInt/VB/indexofintint.vb#1)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="source" /> 为 <see langword="null" />。

或

 <paramref name="value" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> 超出了 <paramref name="source" /> 的有效索引范围。

- 或 -

 <paramref name="count" /> 小于零。

- 或 -

 <paramref name="startIndex" /> 和 <paramref name="count" /> 未在 <paramref name="source" /> 中指定有效部分。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> 包含无效的 <see cref="T:System.Globalization.CompareOptions" /> 值。</exception>
        <block subset="none" type="usage"><para>字符集包括可忽略字符, 这是在执行语言或区分区域性的排序时不考虑的字符。 在区分区域性的搜索 (即，如果 <paramref name="options" /> 不是 <see cref="F:System.Globalization.CompareOptions.Ordinal" /> 或 <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" />) 中，如果 <paramref name="value" /> 包含一个可忽略字符，则结果与移除了该字符的搜索等效。 如果<paramref name="value" />仅包含一个或多个可忽略字符, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />则该方法<paramref name="startIndex" />将始终返回, 这是搜索开始处的字符位置。

在下面的示例中, <see cref="M:System.Globalization.CompareInfo.LastIndexOf(System.String,System.String,System.Int32,System.Int32,System.Globalization.CompareOptions)" />方法用于查找软连字符 (U + 00AD) 后跟 "m" 的位置, 而不是在两个字符串中的最后一个字符位置之前的第一个字符位置。 只有一个字符串包含必需的子字符串。 在这两种情况下，因为软连字符是可忽略字符，因此，在执行区分区域性的比较时，该方法在字符串中返回索引“m”。 但当它执行序号比较时, 它只查找第一个字符串中的子字符串。 请注意, 对于包含软连字符后跟 "m" 的软连字符的第一个字符串, 该方法将无法返回软连字符的索引, 而是在执行区分区域性的比较时返回 "m" 的索引。 只有当此方法执行序号比较时，它才会在第一个字符串中返回软连字符的索引。

[!code-vb[System.Globalization.CompareInfo.LastIndexOf#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.globalization.compareinfo.lastindexof/vb/lastignorable15.vb#16)]</para></block>
        <altmember cref="M:System.Globalization.CompareInfo.IndexOf(System.String,System.Char)" />
        <altmember cref="T:System.Globalization.CompareOptions" />
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CompareInfo.LCID" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LCID As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LCID { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LCID : int" Usage="System.Globalization.CompareInfo.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前 <see cref="T:System.Globalization.CompareInfo" /> 的格式正确的区域性标识符。</summary>
        <value>当前 <see cref="T:System.Globalization.CompareInfo" /> 的格式正确的区域性标识符。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 下面的示例演示了<xref:System.Globalization.CompareInfo.LCID%2A>属性。

 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CompareInfo.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Globalization.CompareInfo.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于通过 <see cref="T:System.Globalization.CompareInfo" /> 对象执行排序操作的区域性的名称。</summary>
        <value>区域性的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <xref:System.Globalization.CompareInfo.Name%2A> 和<xref:System.Globalization.CultureInfo.Name?displayProperty=nameWithType>属性可以具有不同的值。 例如, <xref:System.Globalization.CompareInfo.LCID%2A>十六进制0x10407 的属性值标识一种替换排序区域性, 它对名称的排序方式在德语电话簿中出现。 属性的值为 "de_phoneb", <xref:System.Globalization.CultureInfo.Name?displayProperty=nameWithType>而关联德语 (德国) 区域性的属性的值为 "de"。 <xref:System.Globalization.CompareInfo.Name%2A>



## Examples
 下面的示例使用 fr-fr 和 ja-jp 区域性比较三个字符串。 <xref:System.Globalization.CultureInfo.Name%2A>属性用于显示每个区域性的名称。

 [!code-cpp[CompareInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/CompareInfo/cpp/CompareInfo.cpp#1)]
 [!code-csharp[CompareInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/CompareInfo/CS/CompareInfo.cs#1)]
 [!code-vb[CompareInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CompareInfo/VB/CompareInfo.vb#1)]

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.IDeserializationCallback.OnDeserialization">
      <MemberSignature Language="C#" Value="void IDeserializationCallback.OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.System#Runtime#Serialization#IDeserializationCallback#OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDeserialization (sender As Object) Implements IDeserializationCallback.OnDeserialization" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System::Object ^ sender) = System::Runtime::Serialization::IDeserializationCallback::OnDeserialization;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="sender">启动回调的对象。</param>
        <summary>在整个对象图形已经反序列化时运行。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此成员是显式接口成员实现, 只能在当前<xref:System.Globalization.CompareInfo>对象被强制转换<xref:System.Runtime.Serialization.IDeserializationCallback>为接口时使用。 有关更多信息，请参见 <xref:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization%2A> 方法。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Serialization.IDeserializationCallback" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Globalization.CompareInfo.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="compareInfo.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回表示当前 <see cref="T:System.Globalization.CompareInfo" /> 对象的字符串。</summary>
        <returns>表示当前 <see cref="T:System.Globalization.CompareInfo" /> 对象的字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 此方法将<xref:System.Object.ToString%2A?displayProperty=nameWithType>重写方法。 它将返回一个字符串, 其中包含类名和实例<xref:System.Globalization.CompareInfo.Name%2A>属性的值 (用连字符分隔)。

 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>从 .NET Framework 4 开始，<see cref="M:System.Globalization.CompareInfo.ToString" /> 方法返回类名，后跟空格、连字符、空格和 <see cref="P:System.Globalization.CompareInfo.Name" /> 属性的值。 例如，对于表示 en-US 区域性的 <see cref="T:System.Globalization.CompareInfo" /> 对象，<see cref="M:System.Globalization.CompareInfo.ToString" /> 方法返回“CompareInfo - en-US”。 在 .NET Framework 的早期版本中，它返回后跟空格、连字符、空格和 <see cref="P:System.Globalization.CompareInfo.LCID" /> 属性的值的类名。 例如，对于表示 en-US 区域性的 <see cref="T:System.Globalization.CompareInfo" /> 对象，<see cref="M:System.Globalization.CompareInfo.ToString" /> 方法返回“CompareInfo - 1033”。</para></block>
        <altmember cref="M:System.Object.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public System.Globalization.SortVersion Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.SortVersion Version" />
      <MemberSignature Language="DocId" Value="P:System.Globalization.CompareInfo.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As SortVersion" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::SortVersion ^ Version { System::Globalization::SortVersion ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : System.Globalization.SortVersion" Usage="System.Globalization.CompareInfo.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Globalization</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.SortVersion</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于比较和排序字符串的 Unicode 版本的相关信息。</summary>
        <value>包含用于比较和排序字符串的 Unicode 版本的相关信息的对象。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 各个字符的权重, 因此, 比较或排序特定字符串的方式取决于特定版本的 .NET Framework 所实现的 Unicode 规范的版本。 在 [!INCLUDE[net_v45](~/includes/net-v45-md.md)] 中，这也取决于主机操作系统，如下表所示。 请注意，受支持的 Unicode 版本的列表仅适用于字符比较和排序；不适用于 Unicode 字符串按类别分类。

|.NET Framework 版本|操作系统|Unicode 版本|
|----------------------------|----------------------|---------------------|
|[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]|所有操作系统|Unicode 5.0|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]及更高版本|[!INCLUDE[win7](~/includes/win7-md.md)]|Unicode 5.0|
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]及更高版本|[!INCLUDE[win8](~/includes/win8-md.md)]和更高版本的 Windows 操作系统版本|Unicode 6。3|

 由 <xref:System.Globalization.SortVersion> 属性返回的 <xref:System.Globalization.CompareInfo.Version%2A> 对象不标识用于比较字符串的准确 Unicode 版本。 仅在比较两个 <xref:System.Globalization.SortVersion> 对象来确定它们是否使用相同版本的 Unicode 版本和区域性来比较字符串时很有用。 有关详细信息和示例，请参见 <xref:System.Globalization.SortVersion> 引用页。

 ]]></format>
        </remarks>
        <altmember cref="T:System.Globalization.SortVersion" />
      </Docs>
    </Member>
  </Members>
</Type>