<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="2024705a6acfb8e61320450a981cd3af9607a8a8" /><Meta Name="ms.sourcegitcommit" Value="252460010cd20c7b0dab38785e7164d932fa2768" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/30/2019" /><Meta Name="ms.locfileid" Value="70170266" /></Metadata><TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XmlReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlReader abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type XmlReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>表示提供对 XML 数据进行快速、非缓存、只进访问的读取器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader>提供对文档或流中的 XML 数据的只进只读访问。 此类符合 W3C[可扩展标记语言 (xml) 1.0 (第四版)](https://www.w3.org/TR/2006/REC-xml-20060816/)和[XML 1.0 (第三版) 建议中的命名空间](https://www.w3.org/TR/REC-xml-names/)。  
  
 <xref:System.Xml.XmlReader>方法可让你移动 XML 数据并读取节点的内容。 类的属性反映当前节点 (即读取器的位置) 的值。<xref:System.Xml.XmlReader.ReadState%2A>属性值指示 XML 读取器的当前状态。 <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>例如, 属性由<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>方法和<xref:System.Xml.ReadState.Closed?displayProperty=nameWithType> <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>方法设置为。 <xref:System.Xml.XmlReader>还针对 DTD 或架构提供数据一致性检查和验证。  
  
 <xref:System.Xml.XmlReader>使用请求模型检索数据。 此模型:  
  
-   通过自然的自顶向下过程优化简化了状态管理。  
  
-   支持多个输入流和分层。  
  
-   使客户端能够为分析器提供直接写入字符串的缓冲区, 从而避免了额外的字符串复制。  
  
-   支持选择性处理。 客户端可以跳过项, 并处理应用程序感兴趣的项。 你还可以提前设置属性以管理 XML 流的处理方式 (例如, 规范化)。  
  
 本节内容：  
  
 [创建 XML 读取器](#xmlreader_create)   
 [验证 XML 数据](#xmlreader_validate)   
 [数据一致性](#xmlreader_data)   
 [在节点间导航](#xmlreader_nodes)   
 [读取 XML 元素](#xmlreader_elements)   
 [读取 XML 特性](#xmlreader_attributes)   
 [读取 XML 内容](#xmlreader_content)   
 [转换为 CLR 类型](#xmlreader_clr)   
 [异步编程](#xmlreader_async)   
 [安全注意事项](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>创建 XML 读取器  
 <xref:System.Xml.XmlReader.Create%2A>使用方法<xref:System.Xml.XmlReader>创建实例。  
  
 尽管 .NET Framework 提供<xref:System.Xml.XmlReader>类的具体实现, 例如<xref:System.Xml.XmlTextReader>、 <xref:System.Xml.XmlNodeReader>和<xref:System.Xml.XmlValidatingReader>类, 但建议仅在以下情况下使用专用类:  
  
-   如果要从<xref:System.Xml.XmlNode>对象中读取 XML DOM 子树, 请<xref:System.Xml.XmlNodeReader>使用类。 (但是, 此类不支持 DTD 或架构验证。)  
  
-   如果必须按请求展开实体, 则不希望文本内容已规范化, 或者不希望返回默认属性, 请使用<xref:System.Xml.XmlTextReader>类。  
  
 若要指定要在 XML 读取器上启用的功能集, 请将<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>对象传递<xref:System.Xml.XmlReader.Create%2A>给方法。 您可以使用单个<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>对象创建具有相同功能的多个读取器, 或<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>修改对象以创建具有不同功能集的新读取器。 你还可以轻松地将功能添加到现有读取器。  
  
 如果不使用<xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType>对象, 则使用默认设置。 有关详细信息, 请参阅参考页。<xref:System.Xml.XmlReader.Create%2A>  
  
 <xref:System.Xml.XmlReader><xref:System.Xml.XmlException>引发 on XML 分析错误。 引发异常后, 读取器的状态不可预知。 例如, 报告的节点类型可能不同于当前节点的实际节点类型。 <xref:System.Xml.XmlReader.ReadState%2A>使用属性检查读取器是否处于错误状态。  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>验证 XML 数据  
 若要定义 XML 文档及其元素关系、数据类型和内容约束的结构, 请使用文档类型定义 (DTD) 或 XML 架构定义语言 (XSD) 架构。 如果 XML 文档满足[W3C XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)定义的所有语法要求, 则将其视为格式正确。 如果其格式正确并且符合其 DTD 或架构定义的约束, 则将其视为有效。 (请参阅[W3C XML 架构第1部分:](https://www.w3.org/TR/xmlschema-1/) 结构[和 W3C XML 架构第2部分:数据](https://www.w3.org/TR/xmlschema-2/)类型建议。)因此，虽然所有有效的 XML 文档都是格式正确的，但并不是所有格式正确的 XML 文档都是有效的。  
  
 可以对照 DTD、内联 XSD 架构或存储在<xref:System.Xml.Schema.XmlSchemaSet>对象 (缓存) 中的 XSD 架构来验证数据; 这些方案在 " <xref:System.Xml.XmlReader.Create%2A>引用" 页上进行了介绍。 <xref:System.Xml.XmlReader>不支持 XML 数据缩减 (XDR) 架构验证。  
  
 对<xref:System.Xml.XmlReaderSettings>类使用以下设置, 以指定<xref:System.Xml.XmlReader>实例支持的验证类型 (如果有)。  
  
|使用此<xref:System.Xml.XmlReaderSettings>成员|若要指定|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 属性|是否允许 DTD 处理。 默认设置为不允许 DTD 处理。|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 属性|读取器是否应验证数据, 以及要执行的验证类型 (DTD 或架构)。 默认设置为无数据验证。|  
|<xref:System.Xml.XmlReaderSettings.ValidationEventHandler> 事件|用于接收有关验证事件的信息的事件处理程序。 如果未提供事件处理程序，在出现第一个验证错误时将引发 <xref:System.Xml.XmlException>。|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A> 属性|通过枚举成员的<xref:System.Xml.Schema.XmlSchemaValidationFlags>其他验证选项:<br /><br /> -   `AllowXmlAttributes`--允许实例文档中`xml:*`的 XML 特性 (), 即使未在架构中定义也是如此。 属性基于其数据类型进行验证。 请参阅<xref:System.Xml.Schema.XmlSchemaValidationFlags> "参考" 页, 了解要在特定方案中使用的设置。 (默认情况下禁用。)<br />-   `ProcessIdentityConstraints`--处理在验证过程`xs:ID`中`xs:IDREF`遇到`xs:key`的`xs:keyref`标识`xs:unique`约束 (、、、)。 (默认情况下启用。)<br />-   `ProcessSchemaLocation`--处理`xsi:schemaLocation`或`xsi:noNamespaceSchemaLocation`属性指定的架构。 (默认情况下启用。)<br />-   `ProcessInlineSchema`--在验证期间处理内联 XML 架构。 (默认情况下禁用。)<br />-   `ReportValidationWarnings`--如果出现验证警告, 则报告事件。 如果没有验证特定元素或属性时所依据的 DTD 或 XML 架构，通常会发出警告。 <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> 用于通知。 (默认情况下禁用。)|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|用于验证的 <xref:System.Xml.Schema.XmlSchemaSet>。|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 属性|用于<xref:System.Xml.XmlResolver>解析和访问外部资源的。 这可能包括外部实体 (例如 DTD 和架构) 以及 XML `xs:include`架构`xs:import`中包含的任何或元素。 如果未指定<xref:System.Xml.XmlResolver>, 将<xref:System.Xml.XmlReader>使用没有用户凭据的<xref:System.Xml.XmlUrlResolver>默认值。|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>数据一致性  
 默认情况下, 由<xref:System.Xml.XmlReader.Create%2A>方法创建的 XML 读取器满足以下符合性要求:  
  
-   新行和属性值根据 W3C [XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/)进行标准化。  
  
-   所有实体都将自动展开。  
  
-   即使读者不进行验证, 也会始终添加在文档类型定义中声明的默认属性。  
  
-   允许声明映射到正确的 XML 命名空间 URI 的 XML 前缀。  
  
-   单个`NotationType`属性声明和`NmTokens`单个`Enumeration`属性声明中的表示法名称是不同的。  
  
 使用这些<xref:System.Xml.XmlReaderSettings>属性来指定要启用的一致性检查类型:  
  
|使用此<xref:System.Xml.XmlReaderSettings>属性|功能|默认|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> 属性|为以下项启用或禁用检查:<br /><br /> -字符在合法 XML 字符范围内, 由 W3C XML 1.0 建议的[2.2 字符](https://www.w3.org/TR/2006/REC-xml-20060816/#charsets)部分定义。<br />-所有 XML 名称都有效, 如 W3C XML 1.0 建议的[2.3 通用语法构造](https://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name)部分所定义。<br /><br /> 当此属性设置为`true` (默认值) 时<xref:System.Xml.XmlException> , 如果 xml 文件包含非法字符或无效的 xml 名称 (例如, 元素名称以数字开头), 则会引发异常。|启用了字符和名称检查。<br /><br /> 将 <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> 设置为 `false` 会禁用对字符实体引用的字符检查。 如果读取器正在处理文本数据, 不管此设置如何, 它都始终检查 XML 名称是否有效。 **注意：** 如果存在 DTD，XML 1.0 建议要求文档级别的一致性。 因此, 如果读取器配置为支持<xref:System.Xml.ConformanceLevel.Fragment?displayProperty=nameWithType>, 但 XML 数据包含文档类型定义 (DTD) <xref:System.Xml.XmlException> , 则会引发。|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A> 属性|选择要强制执行的一致性级别:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. 符合[格式正确的 XML 1.0 文档](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed)的规则。<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. 符合可以作为[外部分析的实体](https://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities)使用的格式正确的文档片段的规则。<br />-   <xref:System.Xml.ConformanceLevel.Auto>. 符合读取器决定的级别。<br /><br /> 如果数据不符合, <xref:System.Xml.XmlException>则会引发异常。|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>在节点间导航  
 当前节点是 XML 读取器当前定位在其上的 XML 节点。 所有<xref:System.Xml.XmlReader>方法都执行与此节点相关的操作, 所有<xref:System.Xml.XmlReader>属性都反映当前节点的值。  
  
 使用以下方法可以轻松地在节点之间导航和分析数据。  
  
|使用此<xref:System.Xml.XmlReaderSettings>方法|功能|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|读取第一个节点, 一次一个节点前进一个节点。 此类调用通常在`while`循环内执行。<br /><br /> <xref:System.Xml.XmlReader.NodeType%2A>使用属性可获取当前节点的类型 (例如, 特性、注释、元素等)。|  
|<xref:System.Xml.XmlReader.Skip%2A>|跳过当前节点的子级并移至下一个节点。|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> 和 <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|跳过非内容节点, 并移至下一个内容节点或文件结尾。<br /><br /> 非内容<xref:System.Xml.XmlNodeType.ProcessingInstruction>节点包括<xref:System.Xml.XmlNodeType.DocumentType> <xref:System.Xml.XmlNodeType.Comment>、 <xref:System.Xml.XmlNodeType.SignificantWhitespace>、 、和。<xref:System.Xml.XmlNodeType.Whitespace><br /><br /> 内容节点包括非空白文本、 <xref:System.Xml.XmlNodeType.CDATA> <xref:System.Xml.XmlNodeType.EntityReference> 、和<xref:System.Xml.XmlNodeType.EndEntity>。|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|读取元素及其所有子级, 并将设置为<xref:System.Xml.XmlReader> <xref:System.Xml.ReadState.Initial?displayProperty=nameWithType>的新实例。<br /><br /> 此方法对于围绕 XML 元素创建边界很有用;例如, 如果要将数据传递给另一个组件进行处理, 并且希望限制该组件可以访问的数据量。|  
  
 有关在文本流中导航一个节点并显示每个节点的类型的示例, 请参阅引用页。<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>  
  
 以下各节介绍了如何读取特定类型的数据, 例如元素、属性和类型化数据。  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>读取 XML 元素  
 下表列出了<xref:System.Xml.XmlReader>类提供的用于处理元素的方法和属性。 在 <xref:System.Xml.XmlReader> 置于某个元素上之后，节点属性（例如 <xref:System.Xml.XmlReader.Name%2A>）将反映元素的值。 除了下面所述的成员之外，<xref:System.Xml.XmlReader> 类的任何常规方法和属性也可以用于处理元素。 例如，可以使用 <xref:System.Xml.XmlReader.ReadInnerXml%2A> 方法读取元素的内容。  
  
> [!NOTE]
>  有关开始标记、结束标记和空元素标记的定义, 请参阅[W3C XML 1.0 建议](https://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags)的3.1 节。  
  
|使用此<xref:System.Xml.XmlReader>成员|功能|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.IsStartElement%2A> 方法|检查当前节点是否是开始标记或空元素标记。|  
|<xref:System.Xml.XmlReader.ReadStartElement%2A> 方法|检查当前节点是否为元素并将读取器推进到下一个节点 (调用<xref:System.Xml.XmlReader.IsStartElement%2A> <xref:System.Xml.XmlReader.Read%2A>后跟)。|  
|<xref:System.Xml.XmlReader.ReadEndElement%2A> 方法|检查当前节点是否为结束标记并将读取器推进到下一个节点。|  
|<xref:System.Xml.XmlReader.ReadElementString%2A> 方法|读取纯文本元素。|  
|<xref:System.Xml.XmlReader.ReadToDescendant%2A> 方法|将 XML 读取器前进到具有指定名称的下一个子代 (子元素) 元素。|  
|<xref:System.Xml.XmlReader.ReadToNextSibling%2A> 方法|将 XML 读取器前进到具有指定名称的下一个同级元素。|  
|<xref:System.Xml.XmlReader.IsEmptyElement%2A> 属性|检查当前元素是否具有结束元素标记。 例如:<br /><br /> -   `<item num="123"/>`(<xref:System.Xml.XmlReader.IsEmptyElement%2A> 为`true`。)<br />-   `<item num="123"> </item>`(<xref:System.Xml.XmlReader.IsEmptyElement%2A> 为`false`, 但元素的内容为空。)|  
  
 有关读取元素的文本内容的示例, 请参见<xref:System.Xml.XmlReader.ReadString%2A>方法。 下面的示例使用`while`循环来处理元素。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>读取 XML 特性  
 XML 特性最常见于元素, 但也可用于 XML 声明和文档类型节点。  
  
 当定位在元素节点上时, <xref:System.Xml.XmlReader.MoveToAttribute%2A>方法允许您通过元素的属性列表。 请注意, <xref:System.Xml.XmlReader.MoveToAttribute%2A>在调用之后, 节点属性<xref:System.Xml.XmlReader.Name%2A>(例如、 <xref:System.Xml.XmlReader.NamespaceURI%2A>和<xref:System.Xml.XmlReader.Prefix%2A> ) 反映了该属性的属性, 而不是该属性所属的元素的属性。  
  
 <xref:System.Xml.XmlReader>类提供这些方法和属性来读取和处理元素上的属性。  
  
|使用此<xref:System.Xml.XmlReader>成员|功能|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.HasAttributes%2A> 属性|检查当前节点是否有任何属性。|  
|<xref:System.Xml.XmlReader.AttributeCount%2A> 属性|获取当前元素的属性数。|  
|<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A> 方法|移动到元素中的第一个属性。|  
|<xref:System.Xml.XmlReader.MoveToNextAttribute%2A> 方法|转到元素中的下一个属性。|  
|<xref:System.Xml.XmlReader.MoveToAttribute%2A> 方法|移动到指定的属性。|  
|<xref:System.Xml.XmlReader.GetAttribute%2A>方法或<xref:System.Xml.XmlReader.Item%2A>属性|获取指定特性的值。|  
|<xref:System.Xml.XmlReader.IsDefault%2A> 属性|检查当前节点是否是从 DTD 或架构中定义的默认值生成的属性。|  
|<xref:System.Xml.XmlReader.MoveToElement%2A> 方法|转到拥有当前特性的元素。 使用此方法可以在通过元素的属性导航后返回到元素。|  
|<xref:System.Xml.XmlReader.ReadAttributeValue%2A> 方法|将属性值分析为一个或多`Text`个`EntityReference`、或`EndEntity`节点。|  
  
 任何常规的 <xref:System.Xml.XmlReader> 方法和属性也可以用于处理属性。 例如，在 <xref:System.Xml.XmlReader> 位于某个属性上之后，<xref:System.Xml.XmlReader.Name%2A> 和 <xref:System.Xml.XmlReader.Value%2A> 属性将反映该属性的值。 也可以使用任何内容 `Read` 方法来获取属性的值。  
  
 此示例使用<xref:System.Xml.XmlReader.AttributeCount%2A>属性来浏览元素上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 此示例使用`while`循环<xref:System.Xml.XmlReader.MoveToNextAttribute%2A>中的方法在属性中导航。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **读取 XML 声明节点上的特性**  
  
 当 xml 读取器定位在 xml 声明节点上时, <xref:System.Xml.XmlReader.Value%2A>属性将以单个字符串的形式返回版本、独立和编码信息。 <xref:System.Xml.XmlReader>由<xref:System.Xml.XmlReader.Create%2A>方法<xref:System.Xml.XmlValidatingReader> 、类和类创建的对象将版本、独立和编码项公开为属性。 <xref:System.Xml.XmlTextReader>  
  
 **读取文档类型节点上的属性**  
  
 当 XML 读取器定位在文档类型节点上时, <xref:System.Xml.XmlReader.GetAttribute%2A>可以使用方法和<xref:System.Xml.XmlReader.Item%2A>属性来返回系统的值和公共文本。 例如，调用 `reader.GetAttribute("PUBLIC")` 将返回 PUBLIC 值。  
  
 **读取处理指令节点上的属性**  
  
 在 <xref:System.Xml.XmlReader> 位于某个处理指令节点上时，<xref:System.Xml.XmlReader.Value%2A> 属性将返回整个文本内容。 处理指令节点中的项不会被视为属性。 不能通过<xref:System.Xml.XmlReader.GetAttribute%2A>或<xref:System.Xml.XmlReader.MoveToAttribute%2A>方法读取它们。  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>读取 XML 内容  
 XMLReader 类包含以下成员, 这些成员从 XML 文件读取内容并将内容作为字符串值返回。 (若要返回 CLR 类型, 请参阅[下一节](#xmlreader_clr)。)  
  
|使用此<xref:System.Xml.XmlReader>成员|功能|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Value%2A> 属性|获取当前节点的文本内容。 返回的值取决于节点类型;有关详细信息, 请参阅参考页。<xref:System.Xml.XmlReader.Value%2A>|  
|<xref:System.Xml.XmlReader.ReadString%2A> 方法|以字符串的形式获取元素或文本节点的内容。 此方法在处理指令和注释处停止。<br /><br /> 有关此方法如何处理特定节点类型的详细信息, 请<xref:System.Xml.XmlReader.ReadString%2A>参阅引用页。|  
|<xref:System.Xml.XmlReader.ReadInnerXml%2A> 和 <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A> 方法|获取当前节点的所有内容, 包括标记, 但不包括开始标记和结束标记。 例如, 对于:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A>返回<br /><br /> `this<child id="123"/>`|  
|<xref:System.Xml.XmlReader.ReadOuterXml%2A> 和 <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A> 方法|获取当前节点及其子节点的所有内容, 包括标记和开始/结束标记。 例如, 对于:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A>返回<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>转换为 CLR 类型  
 您可以使用<xref:System.Xml.XmlReader>类的成员 (下表中列出) 来读取 XML 数据并返回值作为公共语言运行时 (CLR) 类型而不是字符串。 这些成员使你能够获取最适合你的编码任务的表示形式的值, 而无需手动分析或转换字符串值。  
  
-   只能在元素节点类型上调用**ReadElementContentAs**方法。 这些方法不能在包含子元素或混合内容的元素上使用。 在调用时，<xref:System.Xml.XmlReader> 对象读取开始标记，读取元素内容，然后移过结束元素标记。 将忽略处理指令和注释并展开实体。  
  
-   **ReadContentAs**方法读取当前读取器位置处的文本内容, 如果 XML 数据没有任何与之关联的架构或数据类型信息, 则将文本内容转换为请求的返回类型。 文本、空白、有效空白和 CDATA 节串联在一起。 将跳过注释和处理指令, 并自动解析实体引用。  
  
 类使用[W3C XML 架构第2部分定义的规则: <xref:System.Xml.XmlReader>数据](https://www.w3.org/TR/xmlschema-2/)类型建议。  
  
|使用此<xref:System.Xml.XmlReader>方法|返回此 CLR 类型|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|用`returnType`参数指定的类型|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> 和 <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|由<xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType>属性指定的最适合的类型。 有关映射信息, 请参阅 system.exception[类中的类型支持](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md)。|  
  
 如果某个元素的格式无法轻松转换为 CLR 类型, 则可以使用架构映射来确保成功转换。 下面的示例使用`hire-date` .xsd 文件将元素转换`xs:date`为类型<xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> , 然后使用方法将该元素作为<xref:System.DateTime>对象返回。  
  
 **输入 (雇用日期:):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **架构 (雇用日期):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **编写**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **输出：**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>异步编程  
 <xref:System.Xml.XmlReader>大多数方法都具有异步的对应项, 它们的方法名称末尾包含 "Async"。 例如, 的异步等效项<xref:System.Xml.XmlReader.ReadContentAsObject%2A>是。 <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>  
  
 以下方法可用于异步方法调用:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 以下各节描述了不具有异步对应的方法的异步用法。  
  
 **ReadStartElement 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **ReadEndElement 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **ReadToNextSibling 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **ReadToFollowing 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **ReadToDescendant 方法**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>安全注意事项  
 使用<xref:System.Xml.XmlReader>类时, 请注意以下事项:  
  
-   从引发的<xref:System.Xml.XmlReader>异常可能会泄露您可能不希望冒泡到您的应用程序的路径信息。 应用必须捕获异常并对其进行相应处理。  
  
-   如果你担心拒绝服务问题, 或者如果你正在处理不受信任的源, 则不要启用 DTD 处理。 默认情况下, 对<xref:System.Xml.XmlReader> <xref:System.Xml.XmlReader.Create%2A>通过方法创建的对象禁用 DTD 处理。  
  
     如果启用了 DTD 处理，可以使用 <xref:System.Xml.XmlSecureResolver> 限制 <xref:System.Xml.XmlReader> 可以访问的资源。 你还可以设计应用程序, 以便 XML 处理的内存和时间受到限制。 例如, 可以在 ASP.NET 应用程序中配置超时限制。  
  
-   XML 数据可以包含对外部资源（例如架构文件）的引用。 默认情况下, 使用<xref:System.Xml.XmlUrlResolver>没有用户凭据的对象解析外部资源。 通过执行下列操作之一，可以使此操作更加安全：  
  
    -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
  
    -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>，不允许 `null` 打开任何外部资源。  
  
-   默认<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>情况<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>下, 不设置<xref:System.Xml.XmlReaderSettings>对象的和验证标志。 这样，在处理来自不可信的源的 XML 数据时，可以帮助防止 <xref:System.Xml.XmlReader> 受到基于架构的攻击。 设置了这些标志后，<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象的 <xref:System.Xml.XmlReaderSettings> 用于在 <xref:System.Xml.XmlReader> 中解析实例文档中遇到的架构位置。 如果将`null` <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>属性设置为, 则即使设置了和<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation>验证标志, 也不会解析架构位置。 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>  
  
     在验证过程中添加的架构会添加新类型，并且可能更改被验证的文档的验证结果。 因此，只应从可信的源解析外部架构。  
  
     建议在高可用性<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>方案中针对对文档很大一部分具有标识约束的架构验证不受信任的大型 XML 文档时禁用标志。 默认情况下启用此标志。  
  
-   XML 数据可以包含大量属性、命名空间声明、嵌套元素等，需要大量的时间来处理。 若要限制发送到的<xref:System.Xml.XmlReader>输入的大小, 可以:  
  
    -   通过设置<xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A>属性来限制文档的大小。  
  
    -   通过设置<xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A>属性来限制扩展实体所产生的字符数。  
  
    -   为创建一个`IStream`自定义实现。 <xref:System.Xml.XmlReader>  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A>方法可用于处理大型数据流。 此方法一次读取少量的字符，而不是为整个值分配单个字符串。  
  
-   读取具有大量唯一本地名称、命名空间或前缀的 XML 文档时, 可能会出现问题。 如果使用派生自<xref:System.Xml.XmlReader>的类, 并<xref:System.Xml.XmlReader.LocalName%2A> <xref:System.Xml.XmlReader.Prefix%2A> <xref:System.Xml.XmlReader.NamespaceURI%2A>为每个项调用、或属性, 则返回的字符串将添加到。 <xref:System.Xml.NameTable> 所保留<xref:System.Xml.NameTable>的集合的大小永远不会减小, 这会造成字符串句柄的虚拟内存泄露。 对此的缓解措施是从<xref:System.Xml.NameTable>类派生, 并强制实施最大大小配额。 (无法阻止使用<xref:System.Xml.NameTable>, 或<xref:System.Xml.NameTable>在它已满时进行切换)。 另一种缓解措施是避免使用所述的属性, <xref:System.Xml.XmlReader.MoveToAttribute%2A>而是在<xref:System.Xml.XmlReader.IsStartElement%2A>可能的情况下将方法与方法一起使用; 这些方法不返回字符串, <xref:System.Xml.NameTable>因此避免了 overfilling 集合的问题。  
  
-   <xref:System.Xml.XmlReaderSettings> 对象可以包含敏感信息，例如用户凭据。 不可信的组件可能会使用 <xref:System.Xml.XmlReaderSettings> 对象及其用户凭据来创建 <xref:System.Xml.XmlReader> 对象，以读取数据。 在缓存<xref:System.Xml.XmlReaderSettings>对象时, 或将<xref:System.Xml.XmlReaderSettings>对象从一个组件传递到另一个组件时, 请小心。  
  
-   不接受来自不可信的源的支持组件，例如 <xref:System.Xml.NameTable>、<xref:System.Xml.XmlNamespaceManager> 和 <xref:System.Xml.XmlResolver> 对象。  
  
   
  
## Examples  
 下面的示例代码演示如何使用异步 API 来分析 XML。  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/data/xml/index.md">XML 文档和数据</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see langword="XmlReader" /> 类的新实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数由派生类构造函数调用以初始化此类型中的状态。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点上的属性数。</summary>
        <value>当前节点上的属性数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性仅与`Element` `DocumentType`和`XmlDeclaration`节点相关。 (其他节点类型不具有属性。)  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的基 URI。</summary>
        <value>当前节点的基 URI。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 联网的 XML 文档包含使用各种 W3C 标准包含机制聚合的数据块, 因此包含来自不同位置的节点。 DTD 实体就是这样一个例子, 但这并不局限于 Dtd。 基本 URI 告诉您这些节点的来源。 如果返回的节点没有基 URI (例如, 从内存中字符串中对其进行了分析), `String.Empty`则返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Xml.XmlReader" /> 是否实现二进制内容读取方法。</summary>
        <value>如果实现了二进制内容读取方法，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 二进制内容读取方法<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>包括、 <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>、 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>和<xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>方法。 如果此属性返回`false` <xref:System.NotSupportedException> , 则在任何二进制读取方法被调用时返回。  
  
 <xref:System.Xml.XmlReader>类为此属性返回`true`的所有 Microsoft .NET 框架实现。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示 <see cref="T:System.Xml.XmlReader" /> 是否实现 <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> 方法。</summary>
        <value>如果 <see cref="T:System.Xml.XmlReader" /> 实现 <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> 方法，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从静态<xref:System.Xml.XmlReader> <xref:System.Xml.XmlReader.Create%2A>方法创建的文本分析对象将始终返回`true`。 <xref:System.Xml.XmlReader>类的所有其他 Microsoft .NET 框架实现, <xref:System.Xml.XmlTextReader>包括类, 返回`false`。  
  
 如果此属性返回`false` <xref:System.NotSupportedException> , 则在调用<xref:System.Xml.XmlReader.ReadValueChunk%2A>方法时返回。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示此读取器是否可以分析和解析实体。</summary>
        <value>如果此读取器可以分析和解析实体，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对于不支持 DTD `false`信息的<xref:System.Xml.XmlReader>实现, 此属性始终返回。 在这种情况下<xref:System.Xml.XmlReader.ResolveEntity%2A> , 调用会引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Close();" />
      <MemberSignature Language="F#" Value="abstract member Close : unit -&gt; unit&#xA;override this.Close : unit -&gt; unit" Usage="xmlReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将 <see cref="P:System.Xml.XmlReader.ReadState" /> 更改为 <see cref="F:System.Xml.ReadState.Closed" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法还释放读取过程中保留的任何资源。 如果<xref:System.Xml.XmlReader.Close%2A>已调用, 则不执行任何操作。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大多数重载都包含一个`settings`接受<xref:System.Xml.XmlReaderSettings>对象的参数。 <xref:System.Xml.XmlReader.Create%2A> 您可以使用此对象执行以下操作:  
  
-   指定要在<xref:System.Xml.XmlReader>对象上支持的功能。  
  
-   重新使用<xref:System.Xml.XmlReaderSettings>对象以创建多个读取器。 可以使用相同的设置创建多个具有相同功能的读取器。 或者, 您可以修改<xref:System.Xml.XmlReaderSettings>实例上的设置, 并使用一组不同的功能创建新的读取器。  
  
-   向现有的 XML 读取器添加功能。 <xref:System.Xml.XmlReader.Create%2A> 方法可以接受其他 <xref:System.Xml.XmlReader> 对象。 基础<xref:System.Xml.XmlReader>对象可以是用户定义的读取器<xref:System.Xml.XmlTextReader> 、对象或要向其添加<xref:System.Xml.XmlReader>附加功能的另一个实例。  
  
-   充分利用功能, 如更好的一致性检查和符合[XML 1.0 (第四版)](https://www.w3.org/TR/2006/REC-xml-20060816/)建议, 这些建议仅在静态<xref:System.Xml.XmlReader> <xref:System.Xml.XmlReader.Create%2A>方法创建的对象上可用。  
  
> [!NOTE]
>  尽管 .NET Framework <xref:System.Xml.XmlReader>包括类的具体实现, 例如<xref:System.Xml.XmlTextReader>、 <xref:System.Xml.XmlNodeReader>和<xref:System.Xml.XmlValidatingReader> <xref:System.Xml.XmlReader.Create%2A>类, 但我们建议你<xref:System.Xml.XmlReader>使用付款方式.  
  
## <a name="default-settings"></a>默认设置  
 如果使用<xref:System.Xml.XmlReader.Create%2A>不<xref:System.Xml.XmlReaderSettings>接受对象的重载, 则使用以下默认读取器设置:  
  
|设置|默认|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel.Document?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|空的 <xref:System.Xml.Schema.XmlSchemaSet> 对象|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>能够|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|一个新 <xref:System.Xml.XmlUrlResolver> 对象。  从 .NET Framework 4.5.2 开始, 此设置的默认值为`null`。|  
  
## <a name="settings-for-common-scenarios"></a>常见方案的设置  
 下面是<xref:System.Xml.XmlReaderSettings>应该为一些典型的 XML 读取器方案设置的属性。  
  
|需求|Set|  
|-----------------|---------|  
|数据必须是格式正确的 XML 文档。|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>到<xref:System.Xml.ConformanceLevel.Document>。|  
|数据必须是格式正确的 XML 分析实体。|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>到<xref:System.Xml.ConformanceLevel.Fragment>。|  
|数据必须针对 DTD 进行验证。|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> 至 <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A>到<xref:System.Xml.ValidationType.DTD>。|  
|必须根据 XML 架构对数据进行验证。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 至 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A>要用于<xref:System.Xml.Schema.XmlSchemaSet>验证的。 请注意<xref:System.Xml.XmlReader> , 不支持 XML 数据缩减 (XDR) 架构验证。|  
|必须根据内联 XML 架构对数据进行验证。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 至 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>到<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>。|  
|类型支持。|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> 至 <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A>要使用<xref:System.Xml.Schema.XmlSchemaSet>的。|  
  
 <xref:System.Xml.XmlReader>不支持 XML 数据缩减 (XDR) 架构验证。  
  
## <a name="asynchronous-programming"></a>异步编程  
 在同步模式下, <xref:System.Xml.XmlReader.Create%2A>方法从文件、流或文本读取器的缓冲区中读取第一个数据块。 如果 i/o 操作失败, 这可能会引发异常。 在异步模式下, 第一次 i/o 操作的执行是读取操作, 因此, 发生读取操作时会引发发生的异常。  
  
## <a name="security-considerations"></a>安全注意事项  
 默认情况下, <xref:System.Xml.XmlReader> <xref:System.Xml.XmlUrlResolver>使用没有用户凭据的对象打开资源。 这意味着, 默认情况下, XML 读取器可以访问不需要凭据的任何位置。 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>使用属性来控制对资源的访问:  
  
-   设置<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>为一个<xref:System.Xml.XmlSecureResolver>对象以限制 XML 读取器可以访问的资源。  
  
 或  
  
-   设置<xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 为`null` , 以防止 XML 读取器打开任何外部资源。  
  
   
  
## Examples  
 此示例将创建一个 XML 读取器, 该读取器可去除无意义的空白、去除注释并执行片段级别的一致性检查。  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 下面的示例使用<xref:System.Xml.XmlUrlResolver>具有默认凭据的来访问文件。  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 下面的代码在其他读取器中包装一个读取器实例。  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 此示例将读取器链接到添加 DTD 和 XML 架构验证。  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <summary>使用带默认设置的指定流创建新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用具有默认设置的对象来创建读取器。<xref:System.Xml.XmlReaderSettings> 如果希望在创建的读取器上指定支持的功能, 请使用将<xref:System.Xml.XmlReaderSettings>对象作为其参数之一的重载, 并传入<xref:System.Xml.XmlReaderSettings>具有正确设置的对象。  
  
 不带<xref:System.Xml.XmlUrlResolver>凭据的默认值用于访问任何外部资源, 例如文档类型定义 (DTD)、实体和架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 则<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定具有所需凭据的。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
   
  
## Examples  
 下面的示例创建一个<xref:System.Xml.XmlReader> <xref:System.IO.FileStream>从中读取的对象。  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> 没有足够的权限访问 XML 数据的位置。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create input" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，XML 读取器未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <summary>使用指定的文本读取器创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用具有默认设置的对象来创建读取器。<xref:System.Xml.XmlReaderSettings> 如果希望在创建的读取器上指定支持的功能, 请使用将<xref:System.Xml.XmlReaderSettings>对象作为其参数之一的重载, 并传入<xref:System.Xml.XmlReaderSettings>具有正确设置的对象。  
  
 不带<xref:System.Xml.XmlUrlResolver>凭据的默认值用于访问任何外部资源, 例如文档类型定义 (DTD)、实体和架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 则<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定具有所需凭据的。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
   
  
## Examples  
 下面的示例使用<xref:System.IO.StringReader>类读取 XML 字符串。  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create inputUri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 数据的文件的 URI。 <see cref="T:System.Xml.XmlUrlResolver" /> 类用于将路径转换为规范化数据表示形式。</param>
        <summary>用指定的 URI 创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用具有默认设置的对象来创建读取器。<xref:System.Xml.XmlReaderSettings> 如果希望在创建的读取器上指定支持的功能, 请使用将<xref:System.Xml.XmlReaderSettings>对象作为其参数之一的重载, 并传入<xref:System.Xml.XmlReaderSettings>具有正确设置的对象。  
  
 不带<xref:System.Xml.XmlUrlResolver>凭据的默认值用于访问任何外部资源, 例如文档类型定义 (DTD)、实体和架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 则<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定具有所需凭据的。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
   
  
## Examples  
 下面的示例创建一个<xref:System.Xml.XmlReader>对象, 该对象读取 URI 指定的 XML 数据文件。  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputUri" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> 没有足够的权限访问 XML 数据的位置。</exception>
        <exception cref="T:System.IO.FileNotFoundException">由 URI 标识的文件不存在。</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。  
  
</para>
          </block>  
  
 URI 格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <summary>使用指定的流和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  你可以使用以下方法之一来控制<xref:System.Xml.XmlReader>可访问的资源:  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  - 或 -  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，XML 读取器未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 的设置。 此值可为 <see langword="null" />。</param>
        <summary>使用指定的文本读取器和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  你可以使用以下方法之一来控制<xref:System.Xml.XmlReader>可访问的资源:  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  - 或 -  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 数据的文件的 URI。 <see cref="T:System.Xml.XmlReaderSettings" /> 对象上的 <see cref="T:System.Xml.XmlResolver" /> 对象用于将路径转换为规范化数据表示形式。 如果 <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> 为 <see langword="null" />，则使用新的 <see cref="T:System.Xml.XmlUrlResolver" /> 对象。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <summary>使用指定的 URI 和设置创建新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 这意味着<xref:System.Xml.XmlReader>可以访问不需要身份验证的任何位置。 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  可以通过<xref:System.Xml.XmlReader> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>将属性设置为<xref:System.Xml.XmlSecureResolver>对象来限制可以访问的资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
   
  
## Examples  
 下面的示例创建一个<xref:System.Xml.XmlReader>支持文档类型定义 (DTD) 验证的对象。  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="inputUri" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 URI 指定的文件。</exception>
        <exception cref="T:System.UriFormatException"><block subset="none" type="note">
            <para>  
 在<see href="https://go.microsoft.com/fwlink/?LinkID=247912">适用于 Windows 应用商店应用的 .NET</see> 或<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">可移植类库</see>中，改为捕获基类异常 <see cref="T:System.FormatException" />。  
  
</para>
          </block>  
  
 URI 格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (reader As XmlReader, settings As XmlReaderSettings) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::Xml::XmlReader ^ reader, System::Xml::XmlReaderSettings ^ settings);" />
      <MemberSignature Language="F#" Value="static member Create : System.Xml.XmlReader * System.Xml.XmlReaderSettings -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (reader, settings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reader">要用作基础 XML 读取器的对象。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。  
  
<see cref="T:System.Xml.XmlReaderSettings" /> 对象的一致性级别要么必须与基础读取器的一致性级别匹配，要么必须设置为 <see cref="F:System.Xml.ConformanceLevel.Auto" />。</param>
        <summary>使用指定的 XML 读取器和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>在指定的 <see cref="T:System.Xml.XmlReader" /> 对象周围包装的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法允许您将其他功能添加到基础<xref:System.Xml.XmlReader>对象。 基础<xref:System.Xml.XmlReader>对象可以是由<xref:System.Xml.XmlReader.Create%2A>方法<xref:System.Xml.XmlReader>创建的另一个对象, 也<xref:System.Xml.XmlReader>可以是使用一个具体<xref:System.Xml.XmlReader>实现创建的对象。  
  
 不带<xref:System.Xml.XmlUrlResolver>凭据的默认值用于访问任何外部资源 (如架构)。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 则<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定具有所需凭据的。  
  
> [!IMPORTANT]
>  你可以使用以下方法之一来控制<xref:System.Xml.XmlReader>可访问的资源:  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  - 或 -  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
   
  
## Examples  
 下面的示例创建一个在<xref:System.Xml.XmlReader> <xref:System.Xml.XmlNodeReader>对象周围环绕的验证对象。  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReaderSettings" /> 对象指定的一致性级别与基础读取器的一致性级别不一致。  
  
或 
基础 <see cref="T:System.Xml.XmlReader" /> 处于 <see cref="F:System.Xml.ReadState.Error" /> 或 <see cref="F:System.Xml.ReadState.Closed" /> 状态。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="baseUri">正在读取的实体或文档的基 URI。 此值可为 <see langword="null" />。  
  
 **安全说明** 基 URI 用于解析 XML 文档的相对 URI。 不要使用来自非信任源的基 URI。</param>
        <summary>使用指定的流、基 URI 和设置创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  你可以使用以下方法之一来控制<xref:System.Xml.XmlReader>可访问的资源:  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As Stream, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::Stream ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.Stream * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">包含 XML 数据的流。  
  
<see cref="T:System.Xml.XmlReader" /> 对流的前几个字节进行扫描，查找字节顺序标记或其他编码标志。 在确定编码方式后，使用该编码方式继续读取流，而处理过程继续将输入内容分析为 (Unicode) 字符流。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="inputContext">分析 XML 片段所需的上下文信息. 上下文信息可以包括要使用的 <see cref="T:System.Xml.XmlNameTable" />、编码、命名空间范围、当前的 <c>xml:lang</c> 和 <c>xml:space</c> 范围、基 URI 和文档类型定义。  
  
此值可为 <see langword="null" />。</param>
        <summary>使用指定的流、设置和用于分析的上下文信息创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  你可以使用以下方法之一来控制<xref:System.Xml.XmlReader>可访问的资源:  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, baseUri As String) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::String ^ baseUri);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * string -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, baseUri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="baseUri" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，<see cref="T:System.Xml.XmlReader" /> 未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="baseUri">正在读取的实体或文档的基 URI。 此值可为 <see langword="null" />。  
  
 **安全说明** 基 URI 用于解析 XML 文档的相对 URI。 不要使用来自非信任源的基 URI。</param>
        <summary>使用指定的文本读取器、设置和基 URI 创建一个新的 <see cref="T:System.Xml.XmlReader" />。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  你可以使用以下方法之一来控制<xref:System.Xml.XmlReader>可访问的资源:  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (input As TextReader, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::IO::TextReader ^ input, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : System.IO.TextReader * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (input, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="input">从其中读取 XML 数据的文本读取器。 由于文本读取器返回的是 Unicode 字符流，因此，XML 读取器未使用 XML 声明中指定的编码对数据流进行解码。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="inputContext">分析 XML 片段所需的上下文信息. 上下文信息可以包括要使用的 <see cref="T:System.Xml.XmlNameTable" />、编码、命名空间范围、当前的 <c>xml:lang</c> 和 <c>xml:space</c> 范围、基 URI 和文档类型定义。  
  
此值可为 <see langword="null" />。</param>
        <summary>使用指定的文本读取器、设置和要用于分析的上下文信息创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  你可以使用以下方法之一来控制<xref:System.Xml.XmlReader>可访问的资源:  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> 对象限制 <xref:System.Xml.XmlSecureResolver> 可访问的资源。  
>   
>  或  
>   
>  -   通过将 <xref:System.Xml.XmlReader> 属性设置为 <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>，不允许 `null` 打开任何外部资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
   
  
## Examples  
 下面的示例创建一个<xref:System.Xml.XmlReader>读取 XML 片段的对象。  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="input" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 和 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 属性都包含值。 （只能设置并使用这些 <see langword="NameTable" /> 属性之中的一个）。</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (inputUri As String, settings As XmlReaderSettings, inputContext As XmlParserContext) As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Xml::XmlReader ^ Create(System::String ^ inputUri, System::Xml::XmlReaderSettings ^ settings, System::Xml::XmlParserContext ^ inputContext);" />
      <MemberSignature Language="F#" Value="static member Create : string * System.Xml.XmlReaderSettings * System.Xml.XmlParserContext -&gt; System.Xml.XmlReader" Usage="System.Xml.XmlReader.Create (inputUri, settings, inputContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="inputUri">包含 XML 数据的文件的 URI。 <see cref="T:System.Xml.XmlReaderSettings" /> 对象上的 <see cref="T:System.Xml.XmlResolver" /> 对象用于将路径转换为规范化数据表示形式。 如果 <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> 为 <see langword="null" />，则使用新的 <see cref="T:System.Xml.XmlUrlResolver" /> 对象。</param>
        <param name="settings">新 <see cref="T:System.Xml.XmlReader" /> 实例的设置。 此值可为 <see langword="null" />。</param>
        <param name="inputContext">分析 XML 片段所需的上下文信息. 上下文信息可以包括要使用的 <see cref="T:System.Xml.XmlNameTable" />、编码、命名空间范围、当前的 <c>xml:lang</c> 和 <c>xml:space</c> 范围、基 URI 和文档类型定义。  
  
此值可为 <see langword="null" />。</param>
        <summary>使用指定的 URI、设置和进行分析的上下文信息创建一个新的 <see cref="T:System.Xml.XmlReader" /> 实例。</summary>
        <returns>一个用于读取数据流中所含数据的对象。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下<xref:System.Xml.XmlUrlResolver> , 不带凭据的将用于访问任何外部资源, 例如文档类型定义 (DTD)、实体、架构等。  
  
> [!IMPORTANT]
>  从 .NET Framework 4.5.2 开始, 不提供默认<xref:System.Xml.XmlUrlResolver>值。 如果你的解决方案面向 .NET Framework 4.5.2 或更高版本, 请<xref:System.Xml.XmlResolver> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>使用属性指定。  
  
 这意味着<xref:System.Xml.XmlReader>可以访问不需要身份验证的任何位置。 如果外部资源位于要求身份验证的网络资源上, 请使用<xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType>属性<xref:System.Xml.XmlResolver>指定具有必要凭据的。  
  
> [!IMPORTANT]
>  可以通过<xref:System.Xml.XmlReader> <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>将属性设置为<xref:System.Xml.XmlSecureResolver>对象来限制可以访问的资源。  
  
 创建<xref:System.Xml.XmlReader>的对象扩展实体引用并执行新行字符的 XML 规范化。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see langword="inputUri" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.Security.SecurityException"><see cref="T:System.Xml.XmlReader" /> 没有足够的权限访问 XML 数据的位置。</exception>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Xml.XmlReaderSettings.NameTable" /> 和 <see cref="P:System.Xml.XmlParserContext.NameTable" /> 属性都包含值。 （只能设置并使用这些 <see langword="NameTable" /> 属性之中的一个）。</exception>
        <exception cref="T:System.IO.FileNotFoundException">找不到 URI 指定的文件。</exception>
        <exception cref="T:System.UriFormatException">URI 格式不正确。</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取 XML 文档中当前节点的深度。</summary>
        <value>XML 文档中当前节点的深度。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 有关<xref:System.Xml.XmlTextReader.Depth%2A>使用此属性`XmlTextReader`的示例, 请参阅 (在类中)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>释放 <see cref="T:System.Xml.XmlReader" /> 类使用的资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="xmlReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>释放 <see cref="T:System.Xml.XmlReader" /> 类的当前实例所使用的所有资源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="xmlReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示释放托管资源和非托管资源；<see langword="false" /> 表示仅释放非托管资源。</param>
        <summary>释放由 <see cref="T:System.Xml.XmlReader" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示此读取器是否定位在流的结尾。</summary>
        <value>如果此读取器定位在流的结尾，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，获取属性的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : int -&gt; string" Usage="xmlReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">属性的索引。 索引是从零开始的。 （第一个属性的索引为 0。）</param>
        <summary>当在派生类中被重写时，获取具有指定索引的属性的值。</summary>
        <returns>指定的属性的值。 此方法不移动读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例获取第三个属性的值。  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="i" /> 超出范围。 它必须是非负数且小于特性集合的大小。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string -&gt; string" Usage="xmlReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的属性的值。</summary>
        <returns>指定的属性的值。 如果找不到该属性，或者值为 <see langword="String.Empty" />，则返回 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法不移动读取器。  
  
 如果读取器定位在`DocumentType`节点上, 则此方法可用于获取公共和系统文本, 例如`reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 下面的示例获取 ISBN 特性的值。  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAttribute (name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ GetAttribute(System::String ^ name, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member GetAttribute : string * string -&gt; string" Usage="xmlReader.GetAttribute (name, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="namespaceURI">属性的命名空间 URI。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的属性的值。</summary>
        <returns>指定的属性的值。 如果找不到该属性，或者值为 <see langword="String.Empty" />，则返回 <see langword="null" />。 此方法不移动读取器。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 以下 XML 包含特定命名空间中的属性:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 可以使用一个参数`dt:type` (前缀和本地名称) 或两个参数 (本地名称和命名空间 URI) 来查找属性:  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 若要查找`xmlns:dt`属性, 请使用以下参数之一:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 你还可以使用<xref:System.Xml.XmlReader.Prefix%2A>属性获取此信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValueAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ GetValueAsync();" />
      <MemberSignature Language="F#" Value="abstract member GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.GetValueAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.GetValueAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步获取当前节点的值。</summary>
        <returns>当前节点的值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在这种情况下，将通过消息“异步操作已在进行中”引发 <see cref="T:System.InvalidOperationException" />。

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasAttributes As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasAttributes { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAttributes : bool" Usage="System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取一个值，该值指示当前节点是否有任何属性。</summary>
        <value>如果当前节点具有属性，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示当前节点是否可以具有 <see cref="P:System.Xml.XmlReader.Value" />。</summary>
        <value>如果读取器当前定位在的节点可以具有 <see langword="Value" />，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则节点值为 <see langword="String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 下表列出具有要返回的值的节点类型。  
  
|节点类型|值|  
|---------------|-----------|  
|`Attribute`|属性的值。|  
|`CDATA`|CDATA 节的内容。|  
|`Comment`|注释的内容。|  
|`DocumentType`|内部子集。|  
|`ProcessingInstruction`|全部内容（不包括指令目标）。|  
|`SignificantWhitespace`|混合内容模型中标记之间的空白。|  
|`Text`|文本节点的内容。|  
|`Whitespace`|标记之间的空白。|  
|`XmlDeclaration`|声明的内容。|  
  
   
  
## Examples  
 有关<xref:System.Xml.XmlTextReader.HasValue%2A>使用此方法`XmlTextReader`的示例, 请参阅 (在类中)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示当前节点是否是从 DTD 或架构中定义的默认值生成的特性。</summary>
        <value>如果当前节点是其值从 DTD 或架构中定义的默认值生成的属性，则为 <see langword="true" />；如果属性值为显式设置的，则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault`对于不`false`支持架构或`XmlReader` DTD 信息的实现, 始终返回。 此属性仅适用于属性节点。  
  
   
  
## Examples  
 下面的示例显示根元素上的所有属性。  
  
```csharp  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 该示例使用以下文件作为输入。  
  
 `book4.xml`  
  
```xml  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取一个值，该值指示当前节点是否为空元素（例如 <c>&lt;MyElement/&gt;</c>）。</summary>
        <value><see langword="true" />如果当前节点<see cref="P:System.Xml.XmlReader.NodeType" />是一个以结尾<see langword="XmlNodeType.Element" /> <c>/ &gt;</c>的元素 (等于), <see langword="false" />则为; 否则为。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性使您能够确定下面各项之间的差异：  
  
 `<item num="123"/>`(`IsEmptyElement` 为`true`)。  
  
 `<item num="123"></item>`(`IsEmptyElement` 为`false`, 但元素内容为空)。  
  
 不会`EndElement`为空元素生成相应的节点。  
  
 如果由于架构验证而将默认内容添加到元素, `IsEmptyElement`则仍返回。 `true` 它与元素是否具有默认值无关。 换言之, `IsEmptyElement`只会报告源文档中的元素是否具有结束元素标记。  
  
   
  
## Examples  
 下面的示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 该示例使用文件`elems.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsName (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsName(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsName : string -&gt; bool" Usage="System.Xml.XmlReader.IsName str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要验证的名称。</param>
        <summary>返回一个值，该值指示字符串参数是否是有效的 XML 名称。</summary>
        <returns>如果该名称有效，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[W3C XML 1.0 建议](https://go.microsoft.com/fwlink/?LinkId=49863)来确定名称是否有效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNameToken (str As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNameToken(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsNameToken : string -&gt; bool" Usage="System.Xml.XmlReader.IsNameToken str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">要验证的名称标记。</param>
        <summary>返回一个值，该值指示该字符串参数是否是有效的 XML 名称标记。</summary>
        <returns>如果它是有效的名称标记，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法使用[W3C XML 1.0 建议](https://go.microsoft.com/fwlink/?LinkId=49863)来确定名称令牌是否有效。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> 值为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="IsStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>测试当前内容节点是否是开始标记。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement();" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : unit -&gt; bool&#xA;override this.IsStartElement : unit -&gt; bool" Usage="xmlReader.IsStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>调用 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 并测试当前内容节点是否是开始标记或空元素标记。</summary>
        <returns>如果 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 找到开始标记或空元素标记，则为 <see langword="true" />；如果找到不同于 <see langword="false" /> 的节点类型，则为 <see langword="XmlNodeType.Element" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法跳过空白、注释和处理指令, 直到将读取器定位在内容节点上。 然后, 方法测试当前节点是否为元素。  
  
   
  
## Examples  
 下面的示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 该示例使用文件`elems.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string -&gt; bool&#xA;override this.IsStartElement : string -&gt; bool" Usage="xmlReader.IsStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">与找到的元素的 <see langword="Name" /> 属性匹配的字符串。</param>
        <summary>调用 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 并测试当前内容节点是否是开始标记或空元素标记，以及所找到元素的 <see cref="P:System.Xml.XmlReader.Name" /> 属性是否与给定的参数匹配。</summary>
        <returns>如果生成的节点是一个元素，且 <see langword="true" /> 属性与指定的字符串匹配，则为 <see langword="Name" />。 如果找到 <see langword="false" /> 之外的节点类型，或者元素的 <see langword="XmlNodeType.Element" /> 属性与指定的字符串不匹配，则为 <see langword="Name" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法跳过空白、注释和处理指令, 直到将读取器定位在内容节点上。 然后, 方法测试当前节点是否为元素。  
  
   
  
## Examples  
 下面的示例显示每个价格元素。  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsStartElement (localname As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member IsStartElement : string * string -&gt; bool&#xA;override this.IsStartElement : string * string -&gt; bool" Usage="xmlReader.IsStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">与找到的元素的 <see langword="LocalName" /> 属性匹配的字符串。</param>
        <param name="ns">与找到的元素的 <see langword="NamespaceURI" /> 属性匹配的字符串。</param>
        <summary>调用 <see cref="M:System.Xml.XmlReader.MoveToContent" /> 并测试当前内容节点是否是开始标记或空元素标记，以及所找到元素的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 属性是否与给定的字符串匹配。</summary>
        <returns>如果生成的节点是一个元素，则为 <see langword="true" />。 如果找到 <see langword="false" /> 之外的节点类型，或者元素的 <see langword="XmlNodeType.Element" /> 和 <see langword="LocalName" /> 属性与指定的字符串不匹配，则为 <see langword="NamespaceURI" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法跳过空白、注释和处理指令, 直到将读取器定位在内容节点上。 然后, 方法测试当前节点是否为元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.MoveToContent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Item">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，获取此属性的值。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[int] { System::String ^ get(int i); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">属性的索引。</param>
        <summary>当在派生类中被重写时，获取具有指定索引的属性的值。</summary>
        <value>指定的属性的值。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性不移动读取器。  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^] { System::String ^ get(System::String ^ name); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的属性的值。</summary>
        <value>指定的属性的值。 如果未找到该属性，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性不移动读取器。  
  
 如果读取器定位在`DocumentType`节点上, 则此方法可用于获取公共和系统文本, 例如`reader["PUBLIC"]`  
  
   
  
## Examples  
 下面的示例获取 ISBN 特性的值。  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overridable ReadOnly Property Item(name As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ default[System::String ^, System::String ^] { System::String ^ get(System::String ^ name, System::String ^ namespaceURI); };" />
      <MemberSignature Language="F#" Value="member this.Item(string * string) : string" Usage="System.Xml.XmlReader.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="namespaceURI">属性的命名空间 URI。</param>
        <summary>当在派生类中被重写时，获取具有指定 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的属性的值。</summary>
        <value>指定的属性的值。 如果未找到该属性，则返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性不移动读取器。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的本地名称。</summary>
        <value>移除了前缀的当前节点的名称。 例如, <see langword="LocalName" /> <see langword="book" />对于元素<c>&gt;bk: book。 &lt;</c>  
  
对于没有名称的节点类型（如 <see langword="Text" />、<see langword="Comment" /> 等），该属性返回 <see langword="String.Empty" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示每个节点的本地名称, 并显示前缀和命名空间 URI (如果存在)。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 该示例使用文件 book2 作为输入。  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.Name" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="abstract member LookupNamespace : string -&gt; string" Usage="xmlReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">要解析其命名空间 URI 的前缀。 若要匹配默认命名空间，请传递一个空字符串。</param>
        <summary>当在派生类中被重写时，在当前元素的范围内解析命名空间前缀。</summary>
        <returns>前缀映射到的命名空间 URI；如果未找到任何匹配的前缀，则为 <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在下面的 XML 字符串中, 如果读取器定位在`href`属性上, 则通过调用`reader.LookupNamespace("a")`来解析前缀`a` 。 返回的字符串为`urn:456`。  
  
```xml  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>当在派生类中被重写时，移动到指定的属性。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : int -&gt; unit&#xA;override this.MoveToAttribute : int -&gt; unit" Usage="xmlReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">属性的索引。</param>
        <summary>当在派生类中被重写时，移动到具有指定索引的属性。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">参数为负值。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string -&gt; bool" Usage="xmlReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的限定名称。</param>
        <summary>当在派生类中被重写时，移动到具有指定 <see cref="P:System.Xml.XmlReader.Name" /> 的属性。</summary>
        <returns>如果找到了属性，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则读取器的位置未改变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用`MoveToAttribute`后,<xref:System.Xml.XmlReader.NamespaceURI%2A>、和属性<xref:System.Xml.XmlReader.Prefix%2A>将反映该特性的属性。 <xref:System.Xml.XmlReader.Name%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToAttribute (name As String, ns As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToAttribute(System::String ^ name, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member MoveToAttribute : string * string -&gt; bool" Usage="xmlReader.MoveToAttribute (name, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">属性的本地名称。</param>
        <param name="ns">属性的命名空间 URI。</param>
        <summary>当在派生类中被重写时，移动到具有指定的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的属性。</summary>
        <returns>如果找到了属性，则为 <see langword="true" />；否则为 <see langword="false" />。 如果为 <see langword="false" />，则读取器的位置未改变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 调用`MoveToAttribute`后,<xref:System.Xml.XmlReader.NamespaceURI%2A>、和属性<xref:System.Xml.XmlReader.Prefix%2A>将反映该特性的属性。 <xref:System.Xml.XmlReader.Name%2A>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContent () As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlNodeType MoveToContent();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContent : unit -&gt; System.Xml.XmlNodeType&#xA;override this.MoveToContent : unit -&gt; System.Xml.XmlNodeType" Usage="xmlReader.MoveToContent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查当前节点是否是内容（非空白文本、<see langword="CDATA" />、<see langword="Element" />、<see langword="EndElement" />、<see langword="EntityReference" /> 或 <see langword="EndEntity" />）节点。 如果此节点不是内容节点，则读取器向前跳至下一个内容节点或文件结尾。 它跳过以下类型的节点：<see langword="ProcessingInstruction" />、<see langword="DocumentType" />、<see langword="Comment" />、<see langword="Whitespace" /> 或 <see langword="SignificantWhitespace" />。</summary>
        <returns>此方法找到的当前节点的 <see cref="P:System.Xml.XmlReader.NodeType" />；如果读取器已到达输入流的末尾，则为 <see langword="XmlNodeType.None" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前节点是属性节点, 则此方法会将读取器移回拥有该属性的元素。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.MoveToContentAsync%2A>。  
  
   
  
## Examples  
 如果希望编写可在不中断的情况下跳过随机 XML 标记的代码, 则此方法非常有用。 例如, 假设你有以下代码:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 此代码可以在不中断的情况下处理以下输入:  
  
```xml  
<price>123.4</price>  
```  
  
 和  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 和  
  
```xml  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTITY p  
  "123.4">]><price>&p;</price>  
```  
  
 和  
  
```xml  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveToContentAsync () As Task(Of XmlNodeType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Xml::XmlNodeType&gt; ^ MoveToContentAsync();" />
      <MemberSignature Language="F#" Value="abstract member MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;&#xA;override this.MoveToContentAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;" Usage="xmlReader.MoveToContentAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步检查当前节点是否为内容节点。 如果此节点不是内容节点，则读取器向前跳至下一个内容节点或文件结尾。</summary>
        <returns>此方法找到的当前节点的 <see cref="P:System.Xml.XmlReader.NodeType" />；如果读取器已到达输入流的末尾，则为 <see langword="XmlNodeType.None" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.MoveToContent%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToElement();" />
      <MemberSignature Language="F#" Value="abstract member MoveToElement : unit -&gt; bool" Usage="xmlReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，移动到包含当前属性节点的元素。</summary>
        <returns>如果读取器定位在属性上（读取器移动到拥有该属性的元素），则为 <see langword="true" />；如果读取器未定位在属性上（读取器的位置不更改），则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以在通过元素的属性导航后返回到元素。 此方法将读取器移动到以下节点类型之一: `Element`、 `DocumentType`或`XmlDeclaration`。  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToFirstAttribute : unit -&gt; bool" Usage="xmlReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，移动到第一个属性。</summary>
        <returns>如果属性存在（读取器移动到第一个属性），则为 <see langword="true" />；否则为 <see langword="false" />（读取器的位置不更改）。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例获取第一个属性的值。  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="abstract member MoveToNextAttribute : unit -&gt; bool" Usage="xmlReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，移动到下一个属性。</summary>
        <returns>如果存在下一个属性，则为 <see langword="true" />；如果没有其他属性，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果当前节点是元素节点, 则此方法等效于<xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>。 如果`MoveToNextAttribute` 返回`true`, 则读取器移动到下一个特性; 否则, 读取器的位置不会更改。  
  
   
  
## Examples  
 下面的示例显示当前节点上的所有属性。  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的限定名。</summary>
        <value>当前节点的限定名称。 例如, <see langword="Name" /> <see langword="bk:book" />对于元素<c>&gt;bk: book。 &lt;</c>  
  
返回的名称取决于节点的 <see cref="P:System.Xml.XmlReader.NodeType" />。 下列节点类型返回所列的值。 所有其他节点类型返回空字符串。  
  
 <list type="table"><listheader><term> 节点类型 
 </term><description> name 
 </description></listheader><item><term><see langword="Attribute" /></term><description> 属性名。  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> 文档类型名称。  
  
 </description></item><item><term><see langword="Element" /></term><description> 标记名称。  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> 引用的实体的名称。  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> 处理指令的目标。  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> 字符串 <see langword="xml" />。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例读取 XML 文件并显示每个节点。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 该示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.LocalName" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取读取器定位在其上的节点的命名空间 URI（采用 W3C 命名空间规范中定义的形式）。</summary>
        <value>当前节点的命名空间 URI；否则为空字符串。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性仅与`Element`和`Attribute`节点相关。  
  
   
  
## Examples  
 下面的示例显示每个节点的本地名称, 并显示前缀和命名空间 URI (如果存在)。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 该示例使用文件 book2 作为输入。  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取与该实现关联的 <see cref="T:System.Xml.XmlNameTable" />。</summary>
        <value><see langword="XmlNameTable" />，它使你能够获取该节点内字符串的原子化版本。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从<xref:System.Xml.XmlReader>返回的所有节点和属性名称都`NameTable`使用进行原子化。 如果多次返回相同的名称 (例如`Customer`), 则将为该名称返回相同`String`的对象。 这样一来, 就可以编写有效的代码, 对这些字符串进行对象比较, 而不是对开销较高的字符串进行比较。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="T:System.Xml.XmlNameTable" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的类型。</summary>
        <value>指定当前节点的类型的枚举值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例读取 XML 文件并显示每个节点。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 该示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取与当前节点关联的命名空间前缀。</summary>
        <value>与当前节点关联的命名空间前缀。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示每个节点的本地名称, 并显示前缀和命名空间 URI (如果存在)。  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 该示例使用文件 book2 作为输入。  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取用于括住特性节点值的引号字符。</summary>
        <value>用于括起属性节点的值的引号字符（" 或 '）。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性仅适用于属性节点。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool Read();" />
      <MemberSignature Language="F#" Value="abstract member Read : unit -&gt; bool" Usage="xmlReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，从流中读取下一个节点。</summary>
        <returns>如果已成功读取下一节点，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader>首次创建和初始化时, 没有可用的信息。 您必须调用<xref:System.Xml.XmlReader.Read%2A>以读取第一个节点。 方法将 xml 读取器的状态设置为 "启动<xref:System.Xml.ReadState.Initial?displayProperty=nameWithType> ", 并按顺序在 xml 文件中移动, 直到它到达文件末尾, 此时`false`方法返回值。 <xref:System.Xml.XmlReader.Read%2A>  
  
 此方法至少需要数据流中的四个字节, 才能开始分析。 如果返回的字节数少于四个, 并且流中没有更多的数据, 则该`false`方法将返回。 如果流中有更多数据, 该方法将会阻止分析, 直到收到第四个字节。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadAsync%2A>。  
  
   
  
## Examples  
 下面的示例读取 XML 文件并显示每个节点:
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 该示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **输出：**  

 [!INCLUDE [xmlreader-read-sample-output](~/includes/xmlreader-read-sample-output.md)] 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadAsync () As Task(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;bool&gt; ^ ReadAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;&#xA;override this.ReadAsync : unit -&gt; System.Threading.Tasks.Task&lt;bool&gt;" Usage="xmlReader.ReadAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取该流的下一个节点。</summary>
        <returns>如果成功读取了下一个节点，则为 <see langword="true" />；如果没有其他节点可读取，则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.Read%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="abstract member ReadAttributeValue : unit -&gt; bool" Usage="xmlReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将属性值解析为一个或多个 <see langword="Text" />、<see langword="EntityReference" /> 或 <see langword="EndEntity" /> 节点。</summary>
        <returns>如果有可返回的节点，则为 <see langword="true" />。  
  
 如果进行初始调用时读取器不是定位在属性节点上，或者如果已读取了所有属性值，则为 <see langword="false" />。  
  
如果是空属性（如 <c>misc=""</c>），则返回 <see langword="true" />，同时返回值为 <see langword="String.Empty" /> 的单个节点。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用<xref:System.Xml.XmlReader.MoveToAttribute%2A>以读取组成特性值的文本或实体引用节点之前, 请使用此方法。 <xref:System.Xml.XmlReader.Depth%2A>属性值节点的是一个加号节点的深度, 在单步执行和跳出常规实体引用时, 它会递增和递减一个。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。  
  
 **注意**：随着 .NET Framework 3.5 的发布，<paramref name="returnType" /> 参数的值现在可以为 <see cref="T:System.DateTimeOffset" /> 类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。 例如，将 <see cref="T:System.Xml.XmlQualifiedName" /> 对象转换为 <c>xs:string</c> 时可以使用此对象。  
  
此值可为 <see langword="null" />。</param>
        <summary>将内容作为指定类型的对象读取。</summary>
        <returns>已转换为请求类型的串联文本内容或属性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取当前读取器位置处的文本内容, 并将其转换为请求的返回类型。 文本、空白、有效空白和 CDATA 节串联在一起。 跳过注释和处理指令，并自动解析实体引用。  
  
 此方法用于读取、转换 (如有必要), 并从当前节点内容返回原子值项。 如果输入类型是当前节点的类型的有效映射, 则返回包含当前节点的值的目标类型的实例。 有关默认映射的列表, <xref:System.Xml.XmlReader>请参阅 "参考" 页中的 "备注" 部分。  
  
 例如, 如果有以下 XML 文本:  
  
```xml  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 如果数据已类型化并向<xref:System.Xml.XmlReader.ReadContentAs%2A>方法调用提供字符串数组, 则根据有效 CLR 类型映射的列表, 将整数值转换为字符串。  
  
 如果数据是非类型化的, 并且为<xref:System.Xml.XmlReader.ReadContentAs%2A>方法调用提供了字符串数组, 则会将内容解析为单独的字符串。 返回一个包含两个字符串的数组, 其值为 "123" 和 "456"。 不会保留内容中的空格。  
  
 通常, 在读取非类型化数据时, 将根据提供的类型分析内容。 例如, 如果向<xref:System.Xml.XmlReader.ReadContentAs%2A>方法调用提供一个整数数组, 则该字符串将被解析为一个整数{123,456}数组。  
  
 在下面的示例中, XML 文本不由空格分隔  
  
```xml  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 如果内容是非类型化的, 并且为<xref:System.Xml.XmlReader.ReadContentAs%2A>方法调用提供了字符串数组, 则返回一个包含一个串联字符串的数组, 其值为 "123456789"。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadContentAsAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadContentAs%2A>方法将 colors 元素的内容返回到字符串对象数组中。  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 示例使用 `dataFile_2.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">内容格式不是目标类型的正确格式。</exception>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="returnType" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不是所支持的节点类型。 有关详细信息，请参见下表。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.OverflowException">读取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <summary>将内容作为指定类型的对象异步读取。</summary>
        <returns>已转换为请求类型的串联文本内容或属性值。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadContentAs%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取内容并返回 Base64 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对内容进行流式处理、 `Base64`对内容进行解码, 并将解码后的二进制字节 (如`Base64`内联编码的 GIF 图像) 返回到缓冲区中。 可以连续调用此方法以读取大量嵌入文本。 有关详细信息, 请参阅 RFC 1521 "MIME (多用途 Internet 邮件扩展) 第一部分:指定和描述 Internet 邮件正文格式的机制 "。 你可以从[征求意见](https://go.microsoft.com/fwlink/?LinkId=37119)网站获取 rfc。  
  
> [!NOTE]
>  在方法返回值<xref:System.Xml.XmlReader.ReadContentAsBase64%2A> `0`之前, 不应访问方法之间的任何读取器属性。  
  
 此方法具有以下行为:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>当达到其`0`所操作的字节流的末尾时, 返回该值。 读取器定位在第一个非内容节点上。  
  
-   如果要求的数量少于或等于的字节数, 则读取器将保留在其当前位置。  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>以下`Element`XML 节点类型不支持: `Document` `None`、 `XmlDeclaration`、、 `DocumentType` `Notation`、 `Entity` 、`DocumentFragment`、和。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不支持 <see cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取内容并返回 Base64 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取内容并返回 <see langword="BinHex" /> 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法对内容进行流式处理、 `BinHex`对内容进行解码, 并将解码后的二进制字节 (如`BinHex`内联编码的 GIF 图像) 返回到缓冲区中。 可以连续调用此方法以读取大量嵌入文本。  
  
> [!NOTE]
>  在方法返回值<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> `0`之前, 不应访问方法之间的任何读取器属性。  
  
 此方法具有以下行为:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>当达到其`0`所操作的字节流的末尾时, 返回该值。 读取器定位在第一个非内容节点上。  
  
-   如果请求的字节数少于或小于的字节数, 则读取器将保留在其当前位置。  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>以下 XML 节点`Element`类型不支持: `None`、 `XmlDeclaration`、、 `Document`、 `DocumentType` `Notation, Entity`、、 `DocumentFragment`。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不支持 <see cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取内容并返回 <see langword="BinHex" /> 解码的二进制字节。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

- 或 -

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsBoolean : unit -&gt; bool&#xA;override this.ReadContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see langword="Boolean" /> 读取。</summary>
        <returns>作为 <see cref="T:System.Boolean" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化`xsd:boolean`的, 则读取器将<xref:System.Boolean>返回取消装箱的对象。 如果未键入`xsd:boolean`内容, 读取器将尝试根据[W3C XML 架构第 2 <xref:System.Boolean>部分定义的规则将其转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>参考页[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A>方法将属性`Boolean`作为值读取。  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 示例使用 `dataFile_2.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.DateTime" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.DateTime" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化`xsd:dateTime`的, 则读取器将<xref:System.DateTime>返回取消装箱的对象。 如果未键入`xsd:dateTime`内容, 读取器将尝试根据[W3C XML 架构第 2 <xref:System.DateTime>部分定义的规则将其转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
> [!NOTE]
>  如果内容类型化为 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>，则不能使用 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader>在这种<xref:System.DateTime.Year%2A?displayProperty=nameWithType>情况下, 始终将值设置为1904。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>参考页[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDateTimeOffset () As DateTimeOffset" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTimeOffset ReadContentAsDateTimeOffset();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset&#xA;override this.ReadContentAsDateTimeOffset : unit -&gt; DateTimeOffset" Usage="xmlReader.ReadContentAsDateTimeOffset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.DateTimeOffset" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.DateTimeOffset" /> 对象的文本内容。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.Decimal" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.Decimal" /> 对象的当前位置的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化`xsd:decimal`的, 则读取器将<xref:System.Decimal>返回取消装箱的对象。 如果未键入`xsd:decimal`内容, 读取器将尝试根据[W3C XML 架构第 2 <xref:System.Decimal>部分定义的规则将其转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>参考页[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsDouble : unit -&gt; double&#xA;override this.ReadContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为双精度浮点数读取。</summary>
        <returns>作为双精度浮点数的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化`xsd:double`的, 则读取器将返回一个双精度浮点数。 如果未键入`xsd:double`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为双精度浮点数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>参考页[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsFloat : unit -&gt; single&#xA;override this.ReadContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为单精度浮点数读取。</summary>
        <returns>作为单精度浮点数的当前位置的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化`xsd:float`的, 则读取器将返回取消装箱的单精度浮点数。 如果未键入`xsd:float`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为单精度浮点数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsInt : unit -&gt; int&#xA;override this.ReadContentAsInt : unit -&gt; int" Usage="xmlReader.ReadContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 32 位有符号整数读取。</summary>
        <returns>作为 32 位有符号整数的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化`xsd:integer`的, 则读取器将返回取消装箱的32位有符号整数。 如果未键入`xsd:integer`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为32位有符号整数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsLong : unit -&gt; int64&#xA;override this.ReadContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 64 位有符号整数读取。</summary>
        <returns>作为 64 位有符号整数的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化`xsd:long`的, 则读取器将返回取消装箱的64位有符号整数。 如果未键入`xsd:long`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为64位有符号整数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|`XmlConvert.ToXxx`与属性值相同。|读取器保持在当前位置|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObject : unit -&gt; obj&#xA;override this.ReadContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.Object" /> 读取。</summary>
        <returns>作为最适当的公共语言运行时 (CLR) 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 如果内容是类型化的, 则读取器将返回由<xref:System.Xml.XmlReader.ValueType%2A>属性指定的最适合类型的已装箱 CLR。 如果内容是列表类型, 则读取器将返回适当类型的装箱对象的数组。  
  
> [!NOTE]
>  如果在分析内容时出现验证错误, 并且读取器是<xref:System.Xml.XmlReader> <xref:System.Xml.XmlReader.Create%2A>由方法创建的对象, 则读取器将内容作为字符串返回。 换句话说, 当发生验证错误或警告时, 内容将被视为非类型化的。  
  
 如果内容未类型化，读取器将以字符串的形式返回内容。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器保持在当前位置|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|如果读取器是架构验证读取器 (<xref:System.Xml.XmlReaderSettings.ValidationType%2A>设置为<xref:System.Xml.ValidationType.Schema>), 则为元素的值; 否则为空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.Object" /> 对象异步读取。</summary>
        <returns>作为最适当的公共语言运行时 (CLR) 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadContentAsObject%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsString : unit -&gt; string&#xA;override this.ReadContentAsString : unit -&gt; string" Usage="xmlReader.ReadContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.String" /> 对象读取。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法连接文本、空格、有效空白和 CDATA 部分, 并跳过任何注释或处理指令。 实体引用会自动得到解决。  
  
 此方法可用于将类型化值转换为字符串, 或在跳过注释和处理指令时读取文本内容。  
  
 下表描述了此方法如何处理每个节点类型。  
  
|XmlNodeType|返回值|读取器行为|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|将文本、CDATA、空白和有效空白节点的串联内容转换为所请求的类型。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`Attribute`|与对属性`XmlConvert.ToXxx`值调用相同。|读取器仍保留在当前位置。|  
|`Comment`<br /><br /> `ProcessingInstruction`|忽略处理指令 (PI) 或注释，读取 PI 或注释后面的串联文本内容。|移至下一个开始元素或结束元素标记。 实体引用自动展开。|  
|`EndElement`|空字符串。|读取器仍保留在当前位置。|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|引发 <xref:System.InvalidOperationException>。|未定义，尽管通常读取器将保留在当前位置。|  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">试图进行的强制转换无效。</exception>
        <exception cref="T:System.FormatException">该字符串格式无效。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>将当前位置的文本内容作为 <see cref="T:System.String" /> 对象异步读取。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的文本内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadContentAsString%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAs">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取当前元素，并将内容作为指定类型的对象返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。  
  
 **注意**：随着 .NET Framework 3.5 的发布，<paramref name="returnType" /> 参数的值现在可以为 <see cref="T:System.DateTimeOffset" /> 类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <summary>将元素内容作为请求类型读取。</summary>
        <returns>转换为请求类型的对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadElementContentAs%2A>方法读取`date`节点的内容。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.OverflowException">读取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAs (returnType As Type, namespaceResolver As IXmlNamespaceResolver, localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAs(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver, System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj&#xA;override this.ReadElementContentAs : Type * System.Xml.IXmlNamespaceResolver * string * string -&gt; obj" Usage="xmlReader.ReadElementContentAs (returnType, namespaceResolver, localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="localName" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。  
  
 **注意**：随着 .NET Framework 3.5 的发布，<paramref name="returnType" /> 参数的值现在可以为 <see cref="T:System.DateTimeOffset" /> 类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后将元素内容作为请求类型读取。</summary>
        <returns>转换为请求类型的对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
        <exception cref="T:System.OverflowException">读取 <see langword="Decimal.MaxValue" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsAsync (returnType As Type, namespaceResolver As IXmlNamespaceResolver) As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsAsync(Type ^ returnType, System::Xml::IXmlNamespaceResolver ^ namespaceResolver);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsAsync : Type * System.Xml.IXmlNamespaceResolver -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsAsync (returnType, namespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="returnType">要返回的值的类型。</param>
        <param name="namespaceResolver">一个 <see cref="T:System.Xml.IXmlNamespaceResolver" /> 对象，用于解析与类型转换有关的任何命名空间前缀。</param>
        <summary>将元素内容作为请求类型异步读取。</summary>
        <returns>转换为请求类型的对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadElementContentAs%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”
- 或 -

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64 : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取元素并对 <see langword="Base64" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取元素内容, 使用`Base64`编码对其进行解码, 并将解码后的二进制字节 (例如, 内联`Base64`编码的 GIF 图像) 返回到缓冲区中。 有关详细信息, 请参阅 RFC 1521 "MIME (多用途 Internet 邮件扩展) 第一部分:指定和描述 Internet 邮件正文格式的机制 "。 你可以从[征求意见](https://go.microsoft.com/fwlink/?LinkId=37119)网站获取 rfc。  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>只能读取简单内容元素。 元素可以包含文本、空格、有效空白、CDATA 部分、注释和处理指令。 它还可以包含自动扩展的实体引用。 元素不能有子元素。  
  
 此方法与<xref:System.Xml.XmlReader.ReadContentAsBase64%2A>方法非常类似, 只是它只能在元素节点类型上调用。  
  
 如果值大于文档中的字节数, 或者它等于文档中的字节数, 则<xref:System.Xml.XmlReader>读取文档中的所有剩余字节并返回读取的字节数。 `count` 下一个<xref:System.Xml.XmlReader>方法调用返回零, 并将读取器移动到`EndElement`后面的节点。  
  
 如果在所有<xref:System.Xml.XmlReader.Read%2A>元素内容被使用之前调用, 则读取器的行为可能与先使用第一个内容, <xref:System.Xml.XmlReader.Read%2A>然后调用方法相同。 这意味着读取器将读取所有文本, 直到遇到结束元素。 然后, 它将读取结束标记节点, 读取下一个节点, 然后在下一个后续节点上定位自身。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>。  
  
   
  
## Examples  
 下面的示例读取内联`Base64`编码的图像。 数据嵌入到`<image>`元素中。 `Base64` <xref:System.IO.BinaryWriter>用于创建新的二进制数据文件。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不是元素节点。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <exception cref="T:System.Xml.XmlException">该元素包含混合内容。</exception>
        <exception cref="T:System.FormatException">无法将内容转换成请求的类型。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBase64Async (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBase64Async(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBase64Async : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBase64Async (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取元素并对 <see langword="Base64" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHex : byte[] * int * int -&gt; int&#xA;override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>读取元素并对 <see langword="BinHex" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取元素内容, 使用`BinHex`编码对其进行解码, 并将解码后的二进制字节 (例如, 内联`BinHex`编码的 GIF 图像) 返回到缓冲区中。  
  
 此方法只能读取简单内容元素。 元素可以包含文本、空格、有效空白、CDATA 部分、注释和处理指令。 它还可以包含自动扩展的实体引用。 元素不能有子元素。  
  
 此方法与<xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>方法非常类似, 只是它只能在元素节点类型上调用。  
  
 如果值大于文档中的字节数, 或者它等于文档中的字节数, 则<xref:System.Xml.XmlReader>读取文档中的所有剩余字节并返回读取的字节数。 `count` 下一个<xref:System.Xml.XmlReader>方法调用返回零, 并将读取器移动到`EndElement`后面的节点。  
  
 如果在所有<xref:System.Xml.XmlReader.Read%2A>元素内容被使用之前调用, 则读取器的行为可能与先使用第一个内容, <xref:System.Xml.XmlReader.Read%2A>然后调用方法相同。 这意味着读取器将读取所有文本, 直到遇到结束元素。 然后, 它将读取结束标记节点, 读取下一个节点, 然后在下一个后续节点上定位自身。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>。  
  
   
  
## Examples  
 下面的示例读取内联`BinHex`编码的图像。 数据嵌入到`<image>`元素中。 `BinHex` <xref:System.IO.BinaryWriter>用于创建新的二进制数据文件。  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">当前节点不是元素节点。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <exception cref="T:System.Xml.XmlException">该元素包含混合内容。</exception>
        <exception cref="T:System.FormatException">无法将内容转换成请求的类型。</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBinHexAsync (buffer As Byte(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadElementContentAsBinHexAsync(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadElementContentAsBinHexAsync : byte[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadElementContentAsBinHexAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">结果文本复制到的缓冲区。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移，从这个位置开始将结果复制到缓冲区中。</param>
        <param name="count">要复制到缓冲区的最大字节数。 此方法返回复制的实际字节数。</param>
        <summary>异步读取元素并对 <see langword="BinHex" /> 内容进行解码。</summary>
        <returns>写入缓冲区的字节数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

- 或 -

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsBoolean">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>将当前元素值作为 <see cref="T:System.Boolean" /> 对象读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : unit -&gt; bool&#xA;override this.ReadElementContentAsBoolean : unit -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Boolean" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Boolean" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果键入`xsd:boolean`了元素内容, 则读取器将返回取消<xref:System.Boolean>装箱的对象。 如果未键入`xsd:boolean`内容, 读取器将尝试根据[W3C XML 架构第 2 <xref:System.Boolean>部分定义的规则将其转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.Boolean" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsBoolean (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadElementContentAsBoolean(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsBoolean : string * string -&gt; bool&#xA;override this.ReadElementContentAsBoolean : string * string -&gt; bool" Usage="xmlReader.ReadElementContentAsBoolean (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.Boolean" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Boolean" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:boolean`的, 则读取器将<xref:System.Boolean>返回取消装箱的对象。 如果未键入`xsd:boolean`内容, 读取器将尝试根据[W3C XML 架构第 2 <xref:System.Boolean>部分定义的规则将其转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDateTime">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取当前元素并将内容作为 <see cref="T:System.DateTime" /> 对象返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime () As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : unit -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : unit -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.DateTime" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.DateTime" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:dateTime`的, 则读取器将<xref:System.DateTime>返回取消装箱的对象。 如果未键入`xsd:dateTime`内容, 读取器将尝试根据[W3C XML 架构第 2 <xref:System.DateTime>部分定义的规则将其转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
> [!NOTE]
>  如果内容类型化为 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>，则不能使用 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader>在这种<xref:System.DateTime.Year%2A?displayProperty=nameWithType>情况下, 始终将值设置为1904。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>方法读取`date`元素的内容。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.DateTime" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDateTime (localName As String, namespaceURI As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual DateTime ReadElementContentAsDateTime(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDateTime : string * string -&gt; DateTime&#xA;override this.ReadElementContentAsDateTime : string * string -&gt; DateTime" Usage="xmlReader.ReadElementContentAsDateTime (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.DateTime" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.DateTime" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:dateTime`的, 则读取器将<xref:System.DateTime>返回取消装箱的对象。 如果未键入`xsd:dateTime`内容, 读取器将尝试根据[W3C XML 架构第 2 <xref:System.DateTime>部分定义的规则将其转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
> [!NOTE]
>  如果内容类型化为 <xref:System.DateTime.Year%2A?displayProperty=nameWithType>，则不能使用 `xsd:gMonthDay` 值。 <xref:System.Xml.XmlReader>在这种<xref:System.DateTime.Year%2A?displayProperty=nameWithType>情况下, 始终将值设置为1904。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDecimal">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>将当前元素值作为 <see cref="T:System.Decimal" /> 对象读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal () As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : unit -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : unit -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Decimal" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Decimal" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 读取器根据[W3C XML 架构第2部分定义<xref:System.Decimal>的规则尝试将元素内容转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.Decimal" />。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDecimal (localName As String, namespaceURI As String) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Decimal ReadElementContentAsDecimal(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDecimal : string * string -&gt; decimal&#xA;override this.ReadElementContentAsDecimal : string * string -&gt; decimal" Usage="xmlReader.ReadElementContentAsDecimal (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.Decimal" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.Decimal" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 读取器根据[W3C XML 架构第2部分定义<xref:System.Decimal>的规则尝试将元素内容转换为对象:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.Decimal" />。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsDouble">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取当前元素并将内容作为双精度浮点数返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : unit -&gt; double&#xA;override this.ReadElementContentAsDouble : unit -&gt; double" Usage="xmlReader.ReadElementContentAsDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为双精度浮点数返回。</summary>
        <returns>作为双精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:double`的, 则读取器将返回一个双精度浮点数。 如果未键入`xsd:double`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为双精度浮点数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
   
  
## Examples  
 下面的示例使用方法将元素内容作为双精度浮点数返回。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换为双精度浮点数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsDouble (localName As String, namespaceURI As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double ReadElementContentAsDouble(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsDouble : string * string -&gt; double&#xA;override this.ReadElementContentAsDouble : string * string -&gt; double" Usage="xmlReader.ReadElementContentAsDouble (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为双精度浮点数返回。</summary>
        <returns>作为双精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:double`的, 则读取器将返回一个双精度浮点数。 如果未键入`xsd:double`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为双精度浮点数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsFloat">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>将当前元素值作为单精度浮点数读取。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat () As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : unit -&gt; single&#xA;override this.ReadElementContentAsFloat : unit -&gt; single" Usage="xmlReader.ReadElementContentAsFloat " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为单精度浮点数返回。</summary>
        <returns>作为单精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 读取器根据[W3C XML 架构第2部分定义的规则尝试将元素内容转换为单精度浮点数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 元素内容不能转换为单精度浮点数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsFloat (localName As String, namespaceURI As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual float ReadElementContentAsFloat(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsFloat : string * string -&gt; single&#xA;override this.ReadElementContentAsFloat : string * string -&gt; single" Usage="xmlReader.ReadElementContentAsFloat (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为单精度浮点数返回。</summary>
        <returns>作为单精度浮点数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 读取器根据[W3C XML 架构第2部分定义的规则尝试将元素内容转换为单精度浮点数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 - 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 - 或 -  
  
 元素内容不能转换为单精度浮点数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsInt">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取当前元素并将内容作为 32 位有符号整数返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : unit -&gt; int&#xA;override this.ReadElementContentAsInt : unit -&gt; int" Usage="xmlReader.ReadElementContentAsInt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 32 位有符号整数返回。</summary>
        <returns>作为 32 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:integer`的, 则读取器将返回取消装箱的32位有符号整数。 如果未键入`xsd:integer`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为32位有符号整数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 - 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换为 32 位有符号整数。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsInt (localName As String, namespaceURI As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadElementContentAsInt(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsInt : string * string -&gt; int&#xA;override this.ReadElementContentAsInt : string * string -&gt; int" Usage="xmlReader.ReadElementContentAsInt (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 32 位有符号整数返回。</summary>
        <returns>作为 32 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:integer`的, 则读取器将返回取消装箱的32位有符号整数。 如果未键入`xsd:integer`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为32位有符号整数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换为 32 位有符号整数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsLong">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取当前元素并将内容作为 64 位有符号整数返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : unit -&gt; int64&#xA;override this.ReadElementContentAsLong : unit -&gt; int64" Usage="xmlReader.ReadElementContentAsLong " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 64 位有符号整数返回。</summary>
        <returns>作为 64 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:long`的, 则读取器将返回取消装箱的64位有符号整数。 如果未键入`xsd:long`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为64位有符号整数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>方法读取`longValue`元素的内容。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 - 或 -  
  
 无法将元素内容转换为 64 位有符号整数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsLong (localName As String, namespaceURI As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual long ReadElementContentAsLong(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsLong : string * string -&gt; int64&#xA;override this.ReadElementContentAsLong : string * string -&gt; int64" Usage="xmlReader.ReadElementContentAsLong (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 64 位有符号整数返回。</summary>
        <returns>作为 64 位有符号整数的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 如果内容是类型化`xsd:long`的, 则读取器将返回取消装箱的64位有符号整数。 如果未键入`xsd:long`内容, 读取器将尝试根据[W3C XML 架构第2部分定义的规则将其转换为64位有符号整数:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关详细信息，请参阅 <xref:System.Xml.XmlReader> 引用页的“备注”部分。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 - 或 -  
  
 无法将元素内容转换为 64 位有符号整数。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsObject">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : unit -&gt; obj&#xA;override this.ReadElementContentAsObject : unit -&gt; obj" Usage="xmlReader.ReadElementContentAsObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
        <returns>一个最适当类型的装箱的公共语言运行时 (CLR) 对象。 <see cref="P:System.Xml.XmlReader.ValueType" /> 属性确定了适当的 CLR 类型。 如果将内容类型化为列表类型，则此方法返回一个适当类型的装箱对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>。  
  
   
  
## Examples  
 下面的示例使用方法读取`price`节点的内容。 读取器使用架构中的信息将内容映射到正确的数据类型。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 该示例使用以下两个文件作为输入。  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换成请求的类型</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObject (localName As String, namespaceURI As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ReadElementContentAsObject(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObject : string * string -&gt; obj&#xA;override this.ReadElementContentAsObject : string * string -&gt; obj" Usage="xmlReader.ReadElementContentAsObject (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
        <returns>一个最适当类型的装箱的公共语言运行时 (CLR) 对象。 <see cref="P:System.Xml.XmlReader.ValueType" /> 属性确定了适当的 CLR 类型。 如果将内容类型化为列表类型，则此方法返回一个适当类型的装箱对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
 或  
  
 无法将元素内容转换成请求的类型。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsObjectAsync () As Task(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::Object ^&gt; ^ ReadElementContentAsObjectAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;&#xA;override this.ReadElementContentAsObjectAsync : unit -&gt; System.Threading.Tasks.Task&lt;obj&gt;" Usage="xmlReader.ReadElementContentAsObjectAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取当前元素并将内容作为 <see cref="T:System.Object" /> 返回。</summary>
        <returns>一个最适当类型的装箱的公共语言运行时 (CLR) 对象。 <see cref="P:System.Xml.XmlReader.ValueType" /> 属性确定了适当的 CLR 类型。 如果将内容类型化为列表类型，则此方法返回一个适当类型的装箱对象的数组。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementContentAsString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取当前元素并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : unit -&gt; string&#xA;override this.ReadElementContentAsString : unit -&gt; string" Usage="xmlReader.ReadElementContentAsString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取当前元素并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>。  
  
   
  
## Examples  
 下面的示例读取`stringValue`元素并返回文本内容 (忽略注释和处理指令)。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.String" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsString (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementContentAsString(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsString : string * string -&gt; string&#xA;override this.ReadElementContentAsString : string * string -&gt; string" Usage="xmlReader.ReadElementContentAsString (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>检查指定的本地名称和命名空间 URI 与当前元素的本地名称和命名空间 URI 是否匹配，然后读取当前元素，并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法读取开始标记和元素的内容, 并将读取器移动到结束元素标记之后。 它扩展实体并忽略处理指令和注释。 元素只能包含简单内容。 也就是说, 它不能有子元素。  
  
 有关详细信息, 请参阅<xref:System.Xml.XmlReader>引用页的 "备注" 部分[和 W3C XML 架构第2部分:数据](https://go.microsoft.com/fwlink/?LinkId=4871)类型建议。  
  
   
  
## Examples  
 下面的示例读取`stringValue`元素并返回文本内容 (忽略注释和处理指令)。  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 示例使用 `dataFile.xml` 文件作为输入。  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Xml.XmlReader" /> 未定位在元素上。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.Xml.XmlException">当前元素包含子元素。  
  
或 
无法将元素内容转换为 <see cref="T:System.String" /> 对象。</exception>
        <exception cref="T:System.ArgumentNullException">使用 <see langword="null" /> 参数调用此方法。</exception>
        <exception cref="T:System.ArgumentException">指定的本地名称和命名空间 URI 与所读取的当前元素的本地名称和命名空间 URI 不匹配。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementContentAsStringAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadElementContentAsStringAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadElementContentAsStringAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadElementContentAsStringAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取当前元素并将内容作为 <see cref="T:System.String" /> 对象返回。</summary>
        <returns>作为 <see cref="T:System.String" /> 对象的元素内容。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>读取只有简单文本的元素。 但是，建议改用 <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议使用<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>方法读取文本元素。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString();" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : unit -&gt; string&#xA;override this.ReadElementString : unit -&gt; string" Usage="xmlReader.ReadElementString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>读取纯文本元素。 但是，建议改用 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>所读取的元素中包含的文本。 如果元素为空，则返回一个空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议使用<xref:System.Xml.XmlReader.ReadElementContentAsString>方法读取文本元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">下一个内容节点不是开始标记；或者找到的元素不包含简单文本值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string -&gt; string&#xA;override this.ReadElementString : string -&gt; string" Usage="xmlReader.ReadElementString name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="name">要检查的名称。</param>
        <summary>在读取纯文本元素之前，检查所找到元素的 <see cref="P:System.Xml.XmlReader.Name" /> 属性是否与给定的字符串匹配。 但是，建议改用 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>所读取的元素中包含的文本。 如果元素为空，则返回一个空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议使用<xref:System.Xml.XmlReader.ReadElementContentAsString>方法读取文本元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">如果下一个内容节点不是一个开始标记；如果元素 <see langword="Name" /> 与给定的参数不匹配；或者如果找到的元素不包含简单的文本值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadElementString (localname As String, ns As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadElementString(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadElementString : string * string -&gt; string&#xA;override this.ReadElementString : string * string -&gt; string" Usage="xmlReader.ReadElementString (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="ns" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="localname">要检查的本地名称。</param>
        <param name="ns">要检查的命名空间 URI。</param>
        <summary>在读取纯文本元素之前，检查所找到元素的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 属性是否与给定的字符串匹配。 但是，建议改用 <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>所读取的元素中包含的文本。 如果元素为空，则返回一个空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议使用<xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29>方法读取文本元素。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">如果下一个内容节点不是一个开始标记；如果元素 <see langword="LocalName" /> 或 <see langword="NamespaceURI" /> 与给定的参数不匹配；或者如果找到的元素不包含简单的文本值。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadEndElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadEndElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadEndElement : unit -&gt; unit&#xA;override this.ReadEndElement : unit -&gt; unit" Usage="xmlReader.ReadEndElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查当前内容节点是否为结束标记并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 该示例使用`book3.xml`文件。  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">当前节点不是一个结束标记，或者如果在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadStartElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadInnerXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXml : unit -&gt; string&#xA;override this.ReadInnerXml : unit -&gt; string" Usage="xmlReader.ReadInnerXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将所有内容（包括标记）当做字符串读取。</summary>
        <returns>当前节点中的所有 XML 内容（包括标记）。 如果当前节点没有任何子级，则返回空字符串。  
  
 如果当前节点既非元素，也非属性，则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法返回当前节点的所有内容, 包括标记。 不返回当前节点（开始标记）和对应的结束节点（结束标记）。 例如, 如果你具有以下内容:  
  
```xml  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` 返回 `this <child id="123"/>`  
  
 此方法按以下方式处理元素节点和属性节点:  
  
|节点类型|调用之前的位置|XML 片断|返回值|调用后的位置|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|在 `item1` 开始标记上。|\<item1>text1\</item1>\<item2>text2\</item2>|text1|在 `item2` 开始标记上。|  
|`Attribute`|在 `attr1` 属性节点上。|\<item attr1="val1" attr2="val2">text\</item>|val1|保留在 `attr1` 属性节点上。|  
  
 如果读取器定位在叶节点上，则调用 `ReadInnerXml` 等效于调用 <xref:System.Xml.XmlReader.Read%2A>。 方法返回`String.Empty` (属性节点除外, 在这种情况下, 返回属性的值)。  
  
 此方法检查格式正确的 XML。 `ReadInnerXml` 如果<xref:System.Xml.XmlValidatingReader>从调用, 则此方法还会验证返回的内容。  
  
 在<xref:System.Xml.XmlNodeReader>、和`ReadOuterXml` <xref:System.Xml.XmlTextReader> 类中实现时,方法是识别`XmlValidatingReader`命名空间的。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>。  
  
   
  
## Examples  
 下面的示例对`ReadInnerXml`和<xref:System.Xml.XmlReader.ReadOuterXml%2A>方法进行比较。  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 该示例使用`2books.xml`文件作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML 的格式不良，或分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadInnerXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadInnerXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadInnerXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadInnerXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取所有内容，包括作为字符串的标记。</summary>
        <returns>当前节点中的所有 XML 内容（包括标记）。 如果当前节点没有任何子级，则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadInnerXml%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXml () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadOuterXml();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXml : unit -&gt; string&#xA;override this.ReadOuterXml : unit -&gt; string" Usage="xmlReader.ReadOuterXml " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，读取表示该节点和所有它的子级的内容（包括标记）。</summary>
        <returns>如果读取器定位在元素或属性节点上，此方法将返回当前节点及其所有子级的所有 XML 内容（包括标记）；否则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法类似于, <xref:System.Xml.XmlReader.ReadInnerXml%2A>只不过它还返回开始标记和结束标记。  
  
 此方法按以下方式处理元素节点和属性节点:  
  
|节点类型|调用之前的位置|XML 片断|返回值|调用后的位置|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|在 `item1` 开始标记上。|\<item1>text1\</item1>\<item2>text2\</item2>|\<item1>text1\</item1>|在 `item2` 开始标记上。|  
|`Attribute`|在 `attr1` 属性节点上。|\<item attr1="val1" attr2="val2">text\</item>|attr1="val1"|保留在 `attr1` 属性节点上。|  
  
 如果读取器定位在叶节点上，则调用 `ReadOuterXml` 等效于调用 <xref:System.Xml.XmlReader.Read%2A>。 方法返回`String.Empty` (属性节点除外, 在这种情况下, 将返回特性标记)。  
  
 此方法检查格式正确的 XML。 `ReadOuterXml` 如果<xref:System.Xml.XmlValidatingReader>从调用, 则此方法还会验证返回的内容  
  
 在<xref:System.Xml.XmlNodeReader>、和`ReadOuterXml` <xref:System.Xml.XmlTextReader> 类中实现时,方法是识别`XmlValidatingReader`命名空间的。 给定`<A xmlns:S="urn:1"><S:B>hello</S:B></A>`以下 XML 文本, 如果读取器定位`S:B`在开始标记上, `ReadOuterXml`则返回`<S:B xmlns:S="urn:1">hello<S:B/>`。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>。  
  
   
  
## Examples  
 下面的示例对`ReadInnerXml`和`ReadOuterXml`方法进行比较。  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 该示例使用`2books.xml`文件作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML 的格式不良，或分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadOuterXmlAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadOuterXmlAsync();" />
      <MemberSignature Language="F#" Value="abstract member ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;&#xA;override this.ReadOuterXmlAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="xmlReader.ReadOuterXmlAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-2.2;netcore-3.0">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步读取包含该节点和所有它的子级的内容（包括标记）。</summary>
        <returns>如果读取器定位在元素或属性节点上，此方法将返回当前节点及其所有子级的所有 XML 内容（包括标记）；否则返回空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadOuterXml%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadStartElement">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>检查当前节点是否为元素并将读取器推进到下一个节点。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement();" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : unit -&gt; unit&#xA;override this.ReadStartElement : unit -&gt; unit" Usage="xmlReader.ReadStartElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>检查当前节点是否为元素并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法调用<xref:System.Xml.XmlReader.IsStartElement%2A> <xref:System.Xml.XmlReader.Read%2A>后跟, 以将你置于输入流中找到的元素的内容上。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string -&gt; unit&#xA;override this.ReadStartElement : string -&gt; unit" Usage="xmlReader.ReadStartElement name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">元素的限定名。</param>
        <summary>检查当前内容节点是否为具有给定 <see cref="P:System.Xml.XmlReader.Name" /> 的元素并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对此方法的调用对应于对的调用<xref:System.Xml.XmlReader.IsStartElement%2A> , 然后<xref:System.Xml.XmlReader.Read%2A>调用。  
  
   
  
## Examples  
 下面的示例显示每个元素的文本内容。  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 该示例使用`book3.xml`文件。  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。  
  
或 
元素的 <see cref="P:System.Xml.XmlReader.Name" /> 不匹配给定的 <paramref name="name" />。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ReadStartElement (localname As String, ns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReadStartElement(System::String ^ localname, System::String ^ ns);" />
      <MemberSignature Language="F#" Value="abstract member ReadStartElement : string * string -&gt; unit&#xA;override this.ReadStartElement : string * string -&gt; unit" Usage="xmlReader.ReadStartElement (localname, ns)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">元素的本地名称。</param>
        <param name="ns">元素的命名空间 URI。</param>
        <summary>检查当前内容节点是否为具有给定 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 的元素并将读取器推进到下一个节点。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 对此方法的调用对应于对的调用<xref:System.Xml.XmlReader.IsStartElement%2A> , 然后<xref:System.Xml.XmlReader.Read%2A>调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">在输入流中遇到不正确的 XML。  
  
或 
所找到元素的 <see cref="P:System.Xml.XmlReader.LocalName" /> 和 <see cref="P:System.Xml.XmlReader.NamespaceURI" /> 属性与给定的参数不匹配。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="M:System.Xml.XmlReader.ReadEndElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取读取器的状态。</summary>
        <value>指定读取器的状态的枚举值之一。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 该<xref:System.Xml.XmlReader.ReadState%2A>属性具有以下值之一:  
  
-   <xref:System.Xml.ReadState.Initial>如果<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>调用方法, 则为。  
  
-   <xref:System.Xml.ReadState.Interactive>如果调用了<xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType>方法, 则可以在读取器上调用其他方法。  
  
-   <xref:System.Xml.ReadState.EndOfFile>如果已成功到达 XML 文档的末尾, 则为。  
  
-   <xref:System.Xml.ReadState.Closed>如果<xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType>调用方法, 则为。  
  
-   <xref:System.Xml.ReadState.Error>如果错误导致读取操作无法继续, 则为。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="abstract member ReadString : unit -&gt; string&#xA;override this.ReadString : unit -&gt; string" Usage="xmlReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;netcore-2.2;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，将元素或文本节点的内容当做字符串读取。 但是，建议改用 <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> 方法，因为该方法可以更直接地处理此操作。</summary>
        <returns>元素的内容或空字符串。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 建议使用<xref:System.Xml.XmlReader.ReadElementContentAsString%2A>方法, 将元素或文本节点的内容读取为一个字符串。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">分析 XML 时出错。</exception>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadSubtree () As XmlReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Xml::XmlReader ^ ReadSubtree();" />
      <MemberSignature Language="F#" Value="abstract member ReadSubtree : unit -&gt; System.Xml.XmlReader&#xA;override this.ReadSubtree : unit -&gt; System.Xml.XmlReader" Usage="xmlReader.ReadSubtree " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>返回新的 <see langword="XmlReader" /> 实例，此实例可用于读取当前节点及其所有子节点。</summary>
        <returns>设置为 <see cref="F:System.Xml.ReadState.Initial" /> 的新 XML 实例。 调用 <see cref="M:System.Xml.XmlReader.Read" /> 方法时，会将新的读取器定位在调用 <see cref="M:System.Xml.XmlReader.ReadSubtree" /> 方法之前的当前节点上。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A>只能在元素节点上调用。 读取整个子树时, 对方法的<xref:System.Xml.XmlReader.Read%2A>调用将返回。 `false` 关闭新的 XML 读取器后, 原始读取器将定位到子树`EndElement`的节点上。 因此, 如果在 book 元素<xref:System.Xml.XmlReader.ReadSubtree%2A>的开始标记上调用方法, 则在读取子树并关闭新的 xml 读取器后, 原始的 xml 读取器将定位到 book 元素的结束标记上。  
  
 在关闭新的读取器之前，不应对原始读取器执行任何操作。 不支持此操作，因为这样可能会导致意想不到的行为。  
  
> [!NOTE]
>  此<xref:System.Xml.XmlReader.ReadSubtree%2A>方法不用于创建可单独使用的 XML 数据的副本。 它旨在围绕 XML 元素创建边界。 如果要将数据传递给另一个组件进行处理, 并且希望限制组件可以访问的数据量, 则这非常有用。 将该<xref:System.Xml.XmlReader.ReadSubtree%2A>方法返回的 xml 读取器传递到另一个应用程序时, 该应用程序只能访问该 xml 元素, 而不是整个 xml 文档。  
  
   
  
## Examples  
 下面的示例显示如何使用 <xref:System.Xml.XmlReader.ReadSubtree%2A> 方法。  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 使用以下 XML 数据运行本主题中的示例:  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">调用此方法时 XML 读取器没有定位在某个元素上。

或

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToDescendant">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>让 <see cref="T:System.Xml.XmlReader" /> 前进到下一个匹配的子代元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string -&gt; bool&#xA;override this.ReadToDescendant : string -&gt; bool" Usage="xmlReader.ReadToDescendant name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">要移动到的元素的限定名。</param>
        <summary>让 <see cref="T:System.Xml.XmlReader" /> 前进到下一个具有指定限定名的子代元素。</summary>
        <returns>如果找到匹配的子代元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果未找到匹配的子元素，<see cref="T:System.Xml.XmlReader" /> 将定位在元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。  
  
如果调用 <see cref="T:System.Xml.XmlReader" /> 时没有将 <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> 定位在某个元素上，则此方法返回 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 的位置保持不变。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 下面的示例分析第二个 book 节点。  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 该示例使用文件`2books.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToDescendant (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToDescendant(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToDescendant : string * string -&gt; bool&#xA;override this.ReadToDescendant : string * string -&gt; bool" Usage="xmlReader.ReadToDescendant (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">要移动到的元素的本地名称。</param>
        <param name="namespaceURI">要移动到的元素的命名空间 URI。</param>
        <summary>让 <see cref="T:System.Xml.XmlReader" /> 前进到下一个具有指定的本地名称和命名空间 URI 的子代元素。</summary>
        <returns>如果找到匹配的子代元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果未找到匹配的子元素，<see cref="T:System.Xml.XmlReader" /> 将定位在元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。  
  
如果调用 <see cref="T:System.Xml.XmlReader" /> 时没有将 <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> 定位在某个元素上，则此方法返回 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 的位置保持不变。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToFollowing">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>一直读取，直到找到命名元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string -&gt; bool&#xA;override this.ReadToFollowing : string -&gt; bool" Usage="xmlReader.ReadToFollowing name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">元素的限定名。</param>
        <summary>一直读取，直到找到具有指定限定名的元素。</summary>
        <returns>如果找到匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 位于文件的末尾。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在功能上等效于`following::name`从当前节点执行 XPath 表达式。 它提供了一种在 XML 文档中查找命名元素的快捷方法。 它将读取器前进到与指定名称匹配的下一个元素, 如果`true`找到匹配的元素, 则返回。 使用下面的示例, 读取器将读取到指定元素的第一个实例, 同时读取。  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 可以在所有节点类型上调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToFollowing (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToFollowing(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToFollowing : string * string -&gt; bool&#xA;override this.ReadToFollowing : string * string -&gt; bool" Usage="xmlReader.ReadToFollowing (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">元素的本地名称。</param>
        <param name="namespaceURI">元素的命名空间 URI。</param>
        <summary>一直读取，直到找到具有指定的本地名称和命名空间 URI 的元素。</summary>
        <returns>如果找到匹配的元素，则为 <see langword="true" />；否则为 <see langword="false" /> 且 <see cref="T:System.Xml.XmlReader" /> 位于文件的末尾。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法在功能上等效于`following::name`从当前节点执行 XPath 表达式。 它提供了一种在 XML 文档中查找命名元素的快捷方法。 它将读取器前进到与指定名称匹配的下一个元素, 如果`true`找到匹配的元素, 则返回。  
  
```xml  
<!--"sample.xml"-->  
<?xml version="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 可以在所有节点类型上调用此方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadToNextSibling">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <summary>让 <see langword="XmlReader" /> 前进到下一个匹配的同级元素。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string -&gt; bool&#xA;override this.ReadToNextSibling : string -&gt; bool" Usage="xmlReader.ReadToNextSibling name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="name">要移动到的同级元素的限定名。</param>
        <summary>让 <see langword="XmlReader" /> 前进到下一个具有指定限定名的同级元素。</summary>
        <returns>如果找到匹配的同级元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果没有找到匹配的同级元素，<see langword="XmlReader" /> 会定位在父元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  当是初始<xref:System.Xml.XmlReader.ReadToNextSibling%2A>状态<xref:System.Xml.XmlReader.ReadState%2A> (为<xref:System.Xml.ReadState.Initial>) 时不调用。 `XmlReader` 您可以调用<xref:System.Xml.XmlReader.Read%2A>来`XmlReader`前进, 然后调用<xref:System.Xml.XmlReader.ReadToNextSibling%2A>方法。  
  
   
  
## Examples  
 下面的示例读取每个 book 节点上的 ISBN 特性。  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentException">参数是空字符串。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadToNextSibling (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool ReadToNextSibling(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="abstract member ReadToNextSibling : string * string -&gt; bool&#xA;override this.ReadToNextSibling : string * string -&gt; bool" Usage="xmlReader.ReadToNextSibling (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="namespaceURI" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="localName">要移动到的同级元素的本地名称。</param>
        <param name="namespaceURI">你希望移动到的同级元素的命名空间 URI。</param>
        <summary>将 <see langword="XmlReader" /> 推进到具有指定的本地名称和命名空间 URI 的下一个同级元素。</summary>
        <returns>如果找到匹配的同级元素，则为 <see langword="true" />；否则为 <see langword="false" />。 如果没有找到匹配的同级元素，<see langword="XmlReader" /> 会定位在父元素的结束标记（<see cref="P:System.Xml.XmlReader.NodeType" /> 为 <see langword="XmlNodeType.EndElement" />）上。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  当是初始<xref:System.Xml.XmlReader.ReadToNextSibling%2A>状态<xref:System.Xml.XmlReader.ReadState%2A> (为<xref:System.Xml.ReadState.Initial>) 时不调用。 `XmlReader` 您可以调用<xref:System.Xml.XmlReader.Read%2A>来`XmlReader`前进, 然后调用<xref:System.Xml.XmlReader.ReadToNextSibling%2A>方法。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException">两个参数值均为 <see langword="null" />。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunk (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ReadValueChunk(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunk : char[] * int * int -&gt; int&#xA;override this.ReadValueChunk : char[] * int * int -&gt; int" Usage="xmlReader.ReadValueChunk (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">作为文本内容写入到的缓冲区的字符数组。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移量，<see cref="T:System.Xml.XmlReader" /> 可以从这个位置开始复制结果。</param>
        <param name="count">要复制到缓冲区中的最大字符数。 此方法返回复制的实际字符数。</param>
        <summary>读取嵌入在 XML 文档中的大量文本流。</summary>
        <returns>读取到缓冲区中的字符数。 如果不再有文本内容，则返回值零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法允许以流式处理的方式读取嵌入 XML 文档中的大量文本 (即一次只需少量字符), 而不是为整个值分配一个字符串。 此方法可在任何具有值 (<xref:System.Xml.XmlReader.HasValue%2A> is `true`) 的节点上调用, 但是, 仅当在文本、空白和有效空白节点上调用时, 才会发生节点值的实际流式处理。 其他节点类型值缓存, 包括属性和 CDATA 节点。  
  
 此方法只返回<xref:System.Xml.XmlReader.Value%2A>属性的内容, 而不<xref:System.Xml.XmlReader>移动。  
  
 此方法将节点值的指定数目的`count`字符 () 读入到字符缓冲区 (`buffer`) 中的指定偏移 (`index`), 并返回写入缓冲区的字符数。 它在到达`0`值的末尾时返回。 它无法重新启动以再次读取该值。  
  
 在对<xref:System.Xml.XmlReader>属性的<xref:System.Xml.XmlReader.ReadValueChunk%2A>调用之间, <xref:System.Xml.XmlReader.Value%2A>属性除外。 访问属性时, 它可能会返回一个部分值 (其中包含不返回的<xref:System.Xml.XmlReader.ReadValueChunk%2A>字符) 或完整值 (具体取决于实现)。 <xref:System.Xml.XmlReader.Value%2A> 命名空间<xref:System.Xml.XmlReader>中的所有实现均为<xref:System.Xml.XmlReader.Value%2A>属性实现返回一个部分值。 <xref:System.Xml>  
  
 可以在对的调用<xref:System.Xml.XmlReader.ReadValueChunk%2A>之间调用任何读取方法。 如果出现这种情况<xref:System.Xml.XmlReader> , 则会跳<xref:System.Xml.XmlNodeType>过流中的下一个和所有尚未返回的字符。  
  
 可能会出现<xref:System.Xml.XmlReader.ReadValueChunk%2A>返回小于所请求的字符数的情况。 例如, 如果你的长度为200个字符的长度为个字符的值, 并且在位置127和<xref:System.Xml.XmlReader.ReadValueChunk%2A> 128 处调用了, 而你使用了128字符的缓冲区调用, 则该方法调用将返回127字符, 而不是所请求的128。 然后, 将在下一次<xref:System.Xml.XmlReader.ReadValueChunk%2A>调用时返回代理项对。 在这种情况<xref:System.Xml.XmlReader.ReadValueChunk%2A>下, 未返回请求的128字符, 这是因为这样做可能会导致缓冲区末尾的代理项对不完整。  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">当前节点没有值（<see cref="P:System.Xml.XmlReader.HasValue" /> 为 <see langword="false" />）。

或 
在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> 值为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">缓冲区中的索引或者索引与计数之和大于分配的缓冲区大小。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Xml.XmlReader" /> 实现不支持此方法。</exception>
        <exception cref="T:System.Xml.XmlException">XML 数据不是格式良好的。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReadValueChunkAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task&lt;int&gt; ^ ReadValueChunkAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="abstract member ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;&#xA;override this.ReadValueChunkAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="xmlReader.ReadValueChunkAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">作为文本内容写入到的缓冲区的字符数组。 此值不能为 <see langword="null" />。</param>
        <param name="index">缓冲区中的偏移量，<see cref="T:System.Xml.XmlReader" /> 可以从这个位置开始复制结果。</param>
        <param name="count">要复制到缓冲区中的最大字符数。 此方法返回复制的实际字符数。</param>
        <summary>异步读取嵌入在 XML 文档中的大量文本流。</summary>
        <returns>读取到缓冲区中的字符数。 如果不再有文本内容，则返回值零。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.ReadValueChunk%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”
或

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ResolveEntity();" />
      <MemberSignature Language="F#" Value="abstract member ResolveEntity : unit -&gt; unit" Usage="xmlReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>当在派生类中被重写时，解析 <see langword="EntityReference" /> 节点的实体引用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果读取器定位在`EntityReference`节点上 (`XmlNodeType.EntityReference`), <xref:System.Xml.XmlReader.Read%2A>则在调用此方法后调用, 将分析实体替换文本。 实体替换文本完成后, 将返回一个`EndEntity`节点以关闭实体引用作用域。  
  
> [!NOTE]
>  调用此方法后, 如果实体是属性值的一部分, 则必须调用<xref:System.Xml.XmlReader.ReadAttributeValue%2A>以单步执行此实体。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">读取器未定位在 <see langword="EntityReference" /> 节点上；该读取器的实现不能解析实体（<see cref="P:System.Xml.XmlReader.CanResolveEntity" /> 返回 <see langword="false" />）。

- 或 -

在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="P:System.Xml.XmlReader.CanResolveEntity" />
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SchemaInfo As IXmlSchemaInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::Schema::IXmlSchemaInfo ^ SchemaInfo { System::Xml::Schema::IXmlSchemaInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SchemaInfo : System.Xml.Schema.IXmlSchemaInfo" Usage="System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取作为架构验证结果分配给当前节点的架构信息。</summary>
        <value>一个包含当前节点的架构信息的 <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> 对象。 架构信息可以在元素、特性或具有非空 <see cref="P:System.Xml.XmlReader.ValueType" />（类型化值）的文本节点上设置。  
  
如果当前节点不属于上述节点类型，或者如果 <see langword="XmlReader" /> 实例未报告架构信息，则此属性返回 <see langword="null" />。  
  
如果从 <see cref="T:System.Xml.XmlTextReader" /> 或 <see cref="T:System.Xml.XmlValidatingReader" /> 对象调用此属性，则此属性总是返回 <see langword="null" />。 这些 <see langword="XmlReader" /> 实现不会通过 <see langword="SchemaInfo" /> 属性公开架构信息。  
  
 <block subset="none" type="note"><para>  
 如果必须为某个元素获取架构验证后信息集 (PSVI)，请在此元素的结束标记处（而不是在开始标记处）放置读取器。 您可以通过读取器的 <see langword="SchemaInfo" /> 属性获取 PSVI。 通过 <see cref="Overload:System.Xml.XmlReader.Create" /> 并使用设置为 <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> 的 <see cref="F:System.Xml.ValidationType.Schema" /> 属性创建的验证读取器具有完整的 PSVI，仅在将读取器放置在元素的结束标记处时，此 PSVI 才对元素可用。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.Schema.IXmlSchemaInfo>接口公开与 XML 节点关联的后架构验证信息集 (PSVI) 的子集。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Settings As XmlReaderSettings" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlReaderSettings ^ Settings { System::Xml::XmlReaderSettings ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Settings : System.Xml.XmlReaderSettings" Usage="System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取用于创建此 <see cref="T:System.Xml.XmlReader" /> 实例的 <see cref="T:System.Xml.XmlReaderSettings" /> 对象。</summary>
        <value>用于创建此读取器实例的 <see cref="T:System.Xml.XmlReaderSettings" /> 对象。 如果此读取器不是使用 <see cref="Overload:System.Xml.XmlReader.Create" /> 方法创建的，则此属性返回 <see langword="null" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Xml.XmlReaderSettings>对象可以包含敏感信息, 例如用户凭据。 在缓存此对象或将其传递给其他组件时, 应用程序一定要小心。  
  
 <xref:System.Xml.XmlReaderSettings>类用于指定要在创建的读取器实例上支持的功能集。 不<xref:System.Xml.XmlReaderSettings>能修改此属性返回的对象。 尝试更改各个设置会导致引发异常。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Skip();" />
      <MemberSignature Language="F#" Value="abstract member Skip : unit -&gt; unit&#xA;override this.Skip : unit -&gt; unit" Usage="xmlReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>跳过当前节点的子级。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在以下 XML 输入中, 如果读取器定位在`<a>`节点或它的任何属性上, 则调用`Skip`会将读取器`<b>`定位到节点。  
  
 如果读取器已定位在叶节点上 ( `<x>`例如节点或文本节点`abc`), 则调用`Skip`与调用<xref:System.Xml.XmlReader.Read%2A>相同。  
  
```xml  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 此方法检查格式正确的 XML。  
  
 如果读取器是<xref:System.Xml.XmlValidatingReader>, 则此方法还会验证已跳过的内容。  
  
 实现确定`Skip`方法是否将展开外部实体。 `XmlReader` 下表描述了是否对各种类型的`XmlReader`对象展开外部实体。  
  
|XmlReader 的类型|展开外部实体|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|不是。|  
|<xref:System.Xml.XmlReader>由读取文本数据<xref:System.Xml.XmlReader.Create%2A>的方法创建的实例。|不是。|  
|<xref:System.Xml.XmlReader>由读取二进制数据<xref:System.Xml.XmlReader.Create%2A>的方法创建的实例。|不适用。|  
|通过方法创建<xref:System.Xml.XmlReader>的架构验证实例。 <xref:System.Xml.XmlReader.Create%2A>|可以。|  
|<xref:System.Xml.XmlValidatingReader>|可以。|  
|<xref:System.Xml.XmlReader><xref:System.Xml.XPath.XPathNavigator>对象返回的实例。|不适用。|  
|<xref:System.Xml.XmlNodeReader>|不是。|  
|<xref:System.Xml.XmlReader>在另一个<xref:System.Xml.XmlReader>实例中换行的实例。|依赖于基础<xref:System.Xml.XmlReader>的实现。 (调用`Skip`基础<xref:System.Xml.XmlReader>上的方法)。|  
  
 有关此方法的异步版本, 请参阅<xref:System.Xml.XmlReader.SkipAsync%2A>。  
  
   
  
## Examples  
 下面的示例分析从第二个 book 节点开始的 XML 文件。  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 该示例使用文件`2books.xml`作为输入。  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SkipAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Threading::Tasks::Task ^ SkipAsync();" />
      <MemberSignature Language="F#" Value="abstract member SkipAsync : unit -&gt; System.Threading.Tasks.Task&#xA;override this.SkipAsync : unit -&gt; System.Threading.Tasks.Task" Usage="xmlReader.SkipAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>异步跳过当前节点的子级。</summary>
        <returns>当前节点。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 这是的异步版本<xref:System.Xml.XmlReader.Skip%2A>, 具有相同的功能。 若要使用此方法, 必须将<xref:System.Xml.XmlReaderSettings.Async%2A>标志设置为。 `true`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”

- 或 -

调用了 <see cref="T:System.Xml.XmlReader" /> 异步方法，但未将 <see cref="P:System.Xml.XmlReaderSettings.Async" /> 标志设置为 <see langword="true" />。 在此情况下，将引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“若要使用 Async 方法，请将 XmlReaderSettings.Async 设置为 True。”</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/db854f91-ccef-4035-ae4d-0911fde808c7">使用 Async 和 Await 的异步编程（C# 和 Visual Basic）</related>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>有关此成员的说明，请参见 <see cref="M:System.IDisposable.Dispose" />。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

此成员是显式接口成员的实现。 它只能在 <xref:System.Xml.XmlReader> 实例被强制转换为 <xref:System.IDisposable> 接口时使用。

此成员在[可移植类库](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)项目中使用时的行为可能不同。 有关详细信息, 请参阅[可移植类库中的 API 差异](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/gg597392(v=vs.100))。

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前节点的文本值。</summary>
        <value>返回的值取决于节点的 <see cref="P:System.Xml.XmlReader.NodeType" />。 下表列出具有要返回的值的节点类型。 所有其他节点类型返回 <see langword="String.Empty" />。  
  
 <list type="table"><listheader><term> 节点类型 
 </term><description> 值 
 </description></listheader><item><term><see langword="Attribute" /></term><description> 属性的值。  
  
 </description></item><item><term><see langword="CDATA" /></term><description> CDATA 节的内容。  
  
 </description></item><item><term><see langword="Comment" /></term><description> 注释的内容。  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> 内部子集。  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> 全部内容（不包括指令目标）。  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> 混合内容模型中标记之间的空白。  
  
 </description></item><item><term><see langword="Text" /></term><description> 文本节点的内容。  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> 标记之间的空白。  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> 声明的内容。  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关此属性的异步版本, 请参见<xref:System.Xml.XmlReader.GetValueAsync%2A>方法。  
  
   
  
## Examples  
 下面的示例读取 XML 文件并显示每个节点。  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 该示例使用`items.xml`文件。  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ValueType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ValueType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValueType : Type" Usage="System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前节点的公共语言运行时 (CLR) 类型。</summary>
        <value>与节点的类型化值对应的 CLR 类型。 默认值为 <see langword="System.String" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关默认映射的列表, 请参阅[System.web 类中的类型支持](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md)。  
  
 默认情况下, `xs:int`类型的`ValueType`元素`System.Int32`具有的。 但是, `ValueType`可以是可以映射到`xs:int`的有效类型之一, 例如`System.Int16`或`System.Double`。  
  
 如果节点是未类型化的, 或者如果该节点是包含混合内容的元素, 则将节点值映射到该`System.String`类型。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <block subset="none" type="overrides"><para>实现<see langword="ValueType" />程序必须为每个节点提供, 即使它<see langword="System.String" />只是类型。</para></block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前的 <see langword="xml:lang" /> 范围。</summary>
        <value>当前 <see langword="xml:lang" /> 范围。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此属性表示`xml:lang`当前节点所在的作用域。 例如, 以下是根元素中`xml:lang`设置为 US 英语的 XML 片段:  
  
```xml  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 当读取器定位在`name`元素上时, 可以使用此属性来查找它是否在美国英语`xml:lang`特性的作用域中。  
  
   
  
## Examples  
 有关<xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType>使用此属性的示例, 请参阅。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlSpace" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>当在派生类中被重写时，获取当前的 <see langword="xml:space" /> 范围。</summary>
        <value><see cref="T:System.Xml.XmlSpace" /> 值之一。 如果不存在任何 <see langword="xml:space" /> 范围，则该属性默认值为 <see langword="XmlSpace.None" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 有关<xref:System.Xml.XmlTextReader.XmlSpace%2A>使用此属性`XmlTextReader`的示例, 请参阅 (在类中)。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">在上一次异步操作完成之前调用了 <see cref="T:System.Xml.XmlReader" /> 方法。 在此情况下，会引发 <see cref="T:System.InvalidOperationException" /> 并显示消息“异步操作已在进行中。”</exception>
        <altmember cref="P:System.Xml.XmlReader.XmlLang" />
      </Docs>
    </Member>
  </Members>
</Type>
