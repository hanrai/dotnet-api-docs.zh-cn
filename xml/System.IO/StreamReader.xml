<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="55c5793c8442e2c63b2aa7f0ce83d3fa8a62954d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69242930" /></Metadata><TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <TypeSignature Language="VB.NET" Value="Public Class StreamReader&#xA;Inherits TextReader" />
  <TypeSignature Language="C++ CLI" Value="public ref class StreamReader : System::IO::TextReader" />
  <TypeSignature Language="F#" Value="type StreamReader = class&#xA;    inherit TextReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="6002c-101">实现一个 <see cref="T:System.IO.TextReader" />，使其以一种特定的编码从字节流中读取字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-101">Implements a <see cref="T:System.IO.TextReader" /> that reads characters from a byte stream in a particular encoding.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-102"><xref:System.IO.StreamReader>设计用于特定编码的字符输入, 而<xref:System.IO.Stream>类用于字节输入和输出。</span><span class="sxs-lookup"><span data-stu-id="6002c-102"><xref:System.IO.StreamReader> is designed for character input in a particular encoding, whereas the <xref:System.IO.Stream> class is designed for byte input and output.</span></span> <span data-ttu-id="6002c-103"><xref:System.IO.StreamReader>用于读取标准文本文件中的行信息。</span><span class="sxs-lookup"><span data-stu-id="6002c-103">Use <xref:System.IO.StreamReader> for reading lines of information from a standard text file.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="6002c-104">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="6002c-104">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="6002c-105">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="6002c-105">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="6002c-106">若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-106">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="6002c-107">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="6002c-107">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="6002c-108">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="6002c-108">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="6002c-109"><xref:System.IO.StreamReader>除非另外指定, 否则默认为 UTF-8 编码, 而不是默认为当前系统的 ANSI 代码页。</span><span class="sxs-lookup"><span data-stu-id="6002c-109"><xref:System.IO.StreamReader> defaults to UTF-8 encoding unless specified otherwise, instead of defaulting to the ANSI code page for the current system.</span></span> <span data-ttu-id="6002c-110">UTF-8 正确地处理 Unicode 字符, 并为操作系统的本地化版本提供一致的结果。</span><span class="sxs-lookup"><span data-stu-id="6002c-110">UTF-8 handles Unicode characters correctly and provides consistent results on localized versions of the operating system.</span></span> <span data-ttu-id="6002c-111">如果使用<xref:System.IO.StreamReader.CurrentEncoding%2A>属性获取当前字符编码, 则该值在第一<xref:System.IO.StreamReader.Read%2A>种方法之后才是可靠的, 因为在首次调用<xref:System.IO.StreamReader.Read%2A>方法之前不会进行编码自动检测。</span><span class="sxs-lookup"><span data-stu-id="6002c-111">If you get the current character encoding using the <xref:System.IO.StreamReader.CurrentEncoding%2A> property, the value is not reliable until after the first <xref:System.IO.StreamReader.Read%2A> method, since encoding auto detection is not done until the first call to a <xref:System.IO.StreamReader.Read%2A> method.</span></span>  
  
 <span data-ttu-id="6002c-112">默认情况下, <xref:System.IO.StreamReader>不是线程安全的。</span><span class="sxs-lookup"><span data-stu-id="6002c-112">By default, a <xref:System.IO.StreamReader> is not thread safe.</span></span> <span data-ttu-id="6002c-113">有关<xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType>线程安全包装, 请参阅。</span><span class="sxs-lookup"><span data-stu-id="6002c-113">See <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> for a thread-safe wrapper.</span></span>  
  
 <span data-ttu-id="6002c-114">和方法重载读取并写入`count`参数所指定的字符数。 <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="6002c-114">The <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method overloads read and write the number of characters specified by the `count` parameter.</span></span> <span data-ttu-id="6002c-115">这些将从<xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType>和<xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>中区分, 它们可读取和写入`count`参数指定的字节数。</span><span class="sxs-lookup"><span data-stu-id="6002c-115">These are to be distinguished from <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> and <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, which read and write the number of bytes specified by the `count` parameter.</span></span> <span data-ttu-id="6002c-116"><xref:System.IO.BufferedStream>使用方法仅用于读取和写入整数个字节数组元素。</span><span class="sxs-lookup"><span data-stu-id="6002c-116">Use the <xref:System.IO.BufferedStream> methods only for reading and writing an integral number of byte array elements.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6002c-117">从读取时<xref:System.IO.Stream>, 使用与流的内部缓冲区大小相同的缓冲区会更有效。</span><span class="sxs-lookup"><span data-stu-id="6002c-117">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
 <span data-ttu-id="6002c-118">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-118">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-119">下面的示例使用的<xref:System.IO.StreamReader>实例读取文件中的文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-119">The following example uses an instance of <xref:System.IO.StreamReader> to read text from a file.</span></span> <span data-ttu-id="6002c-120">在此示例中使用的构造函数不支持在应用[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]程序中使用。</span><span class="sxs-lookup"><span data-stu-id="6002c-120">The constructor used in this example is not supported for use in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] Apps.</span></span>  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 <span data-ttu-id="6002c-121">下面的示例实例化<xref:System.IO.StreamReader>一个对象并调用<xref:System.IO.StreamReader.ReadAsync%2A>其方法以异步读取文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-121">The following example instantiates a <xref:System.IO.StreamReader> object and calls its <xref:System.IO.StreamReader.ReadAsync%2A> method to read a file asynchronously.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Text.Encoding" />
    <altmember cref="T:System.IO.Stream" />
    <altmember cref="T:System.IO.StreamWriter" />
    <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-122">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-122">File and Stream I/O</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-123">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-123">How to: Read Text from a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-124">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-124">How to: Write Text to a File</span></span></related>
    <related type="Article" href="~/docs/standard/io/how-to-read-and-write-to-a-newly-created-data-file.md"><span data-ttu-id="6002c-125">如何：对新建的数据文件进行读取和写入</span><span class="sxs-lookup"><span data-stu-id="6002c-125">How to: Read and Write to a Newly Created Data File</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6002c-126">为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="6002c-126">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader stream" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="6002c-127">要读取的流。</span><span class="sxs-lookup"><span data-stu-id="6002c-127">The stream to be read.</span></span></param>
        <summary><span data-ttu-id="6002c-128">为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="6002c-128">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-129">此构造函数将编码初始化<xref:System.Text.UTF8Encoding>为, <xref:System.IO.StreamReader.BaseStream%2A>使用`stream`参数的属性, 并将内部缓冲区大小为1024字节。</span><span class="sxs-lookup"><span data-stu-id="6002c-129">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="6002c-130">调用<xref:System.IO.StreamReader> <xref:System.IO.Stream.Dispose> <xref:System.IO.Stream>时,对象对提供的对象调用<xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6002c-130">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-131">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-131">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-132">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-132">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-133">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-133">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-134"><paramref name="stream" /> 不支持读取。</span><span class="sxs-lookup"><span data-stu-id="6002c-134"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-135"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-135"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-136">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-136">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-137">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-137">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-138">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-138">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6002c-139">要读取的完整文件路径。</span><span class="sxs-lookup"><span data-stu-id="6002c-139">The complete file path to be read.</span></span></param>
        <summary><span data-ttu-id="6002c-140">为指定的文件名初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例。</span><span class="sxs-lookup"><span data-stu-id="6002c-140">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-141">完整的文件路径是由`path`参数指定的。</span><span class="sxs-lookup"><span data-stu-id="6002c-141">The complete file path is specified by the `path` parameter.</span></span> <span data-ttu-id="6002c-142">此构造函数将编码初始化<xref:System.Text.UTF8Encoding>为, 缓冲区大小为1024个字节。</span><span class="sxs-lookup"><span data-stu-id="6002c-142">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding> and the buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="6002c-143">`path`参数可以是文件名, 包括通用命名约定 (UNC) 共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-143">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="6002c-144">`path`参数不需要是存储在磁盘上的文件; 它可以是系统的任何支持使用流进行访问的部分。</span><span class="sxs-lookup"><span data-stu-id="6002c-144">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-145">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-145">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-146">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-146">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-147">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-147">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-148"><paramref name="path" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6002c-148"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-149"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-149"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6002c-150">无法找到该文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-150">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="6002c-151">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="6002c-151">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-152"><paramref name="path" /> 包括不正确或无效的文件名、目录名或卷标的语法。</span><span class="sxs-lookup"><span data-stu-id="6002c-152"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-153">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-153">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-154">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-154">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-155">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-155">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="6002c-156">要读取的流。</span><span class="sxs-lookup"><span data-stu-id="6002c-156">The stream to be read.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="6002c-157">指示是否在文件头查找字节顺序标记。</span><span class="sxs-lookup"><span data-stu-id="6002c-157">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="6002c-158">用指定的字节顺序标记检测选项，为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="6002c-158">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-159">此构造函数将编码初始化<xref:System.Text.UTF8Encoding>为, <xref:System.IO.StreamReader.BaseStream%2A>使用`stream`参数的属性, 并将内部缓冲区大小为1024字节。</span><span class="sxs-lookup"><span data-stu-id="6002c-159">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="6002c-160">`detectEncodingFromByteOrderMarks`参数通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-160">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-161">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-161">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-162">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-162">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-163">调用<xref:System.IO.StreamReader> <xref:System.IO.Stream.Dispose> <xref:System.IO.Stream>时,对象对提供的对象调用<xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6002c-163">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
 <span data-ttu-id="6002c-164">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-164">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-165">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-165">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-166"><paramref name="stream" /> 不支持读取。</span><span class="sxs-lookup"><span data-stu-id="6002c-166"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-167"><paramref name="stream" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-167"><paramref name="stream" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-168">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-168">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-169">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-169">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-170">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-170">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="6002c-171">要读取的流。</span><span class="sxs-lookup"><span data-stu-id="6002c-171">The stream to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="6002c-172">要使用的字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-172">The character encoding to use.</span></span></param>
        <summary><span data-ttu-id="6002c-173">用指定的字符编码为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="6002c-173">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-174">字符编码由`encoding`参数设置, 缓冲区大小设置为1024字节。</span><span class="sxs-lookup"><span data-stu-id="6002c-174">The character encoding is set by the `encoding` parameter, and the buffer size is set to 1024 bytes.</span></span> <span data-ttu-id="6002c-175"><xref:System.IO.StreamReader>对象尝试通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-175">The <xref:System.IO.StreamReader> object attempts to  detect the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-176">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-176">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-177">否则, 将使用用户提供的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-177">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="6002c-178">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-178">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-179">调用<xref:System.IO.StreamReader> <xref:System.IO.Stream.Dispose> <xref:System.IO.Stream>时,对象对提供的对象调用<xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6002c-179">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-180">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-180">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-181">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-181">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-182">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-182">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-183"><paramref name="stream" /> 不支持读取。</span><span class="sxs-lookup"><span data-stu-id="6002c-183"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-184"><paramref name="stream" /> 或 <paramref name="encoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-184"><paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-185">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-185">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-186">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-186">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-187">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-187">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String, detectEncodingFromByteOrderMarks As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6002c-188">要读取的完整文件路径。</span><span class="sxs-lookup"><span data-stu-id="6002c-188">The complete file path to be read.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="6002c-189">指示是否在文件头查找字节顺序标记。</span><span class="sxs-lookup"><span data-stu-id="6002c-189">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="6002c-190">为指定的文件名初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例，带有指定的字节顺序标记检测选项。</span><span class="sxs-lookup"><span data-stu-id="6002c-190">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-191">此构造函数将编码初始化<xref:System.Text.UTF8Encoding>为, <xref:System.IO.StreamReader.BaseStream%2A>使用`stream`参数的属性, 并将内部缓冲区大小为1024字节。</span><span class="sxs-lookup"><span data-stu-id="6002c-191">This constructor initializes the encoding to <xref:System.Text.UTF8Encoding>, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="6002c-192">`path`参数可以是文件名, 包括通用命名约定 (UNC) 共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-192">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="6002c-193">`path`参数不需要是存储在磁盘上的文件; 它可以是系统的任何支持使用流进行访问的部分。</span><span class="sxs-lookup"><span data-stu-id="6002c-193">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
 <span data-ttu-id="6002c-194">`detectEncodingFromByteOrderMarks`参数通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-194">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-195">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-195">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-196">否则, <xref:System.Text.UTF8Encoding>使用。</span><span class="sxs-lookup"><span data-stu-id="6002c-196">Otherwise, the <xref:System.Text.UTF8Encoding> is used.</span></span> <span data-ttu-id="6002c-197">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-197">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-198">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-198">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-199">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-199">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-200"><paramref name="path" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6002c-200"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-201"><paramref name="path" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-201"><paramref name="path" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6002c-202">无法找到该文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-202">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="6002c-203">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="6002c-203">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-204"><paramref name="path" /> 包括不正确或无效的文件名、目录名或卷标的语法。</span><span class="sxs-lookup"><span data-stu-id="6002c-204"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-205">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-205">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-206">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-206">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-207">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-207">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6002c-208">要读取的完整文件路径。</span><span class="sxs-lookup"><span data-stu-id="6002c-208">The complete file path to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="6002c-209">要使用的字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-209">The character encoding to use.</span></span></param>
        <summary><span data-ttu-id="6002c-210">用指定的字符编码，为指定的文件名初始化 <see cref="T:System.IO.StreamReader" /> 类的一个新实例。</span><span class="sxs-lookup"><span data-stu-id="6002c-210">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-211">此构造函数按照`encoding`参数指定的方式初始化编码, 内部缓冲区大小为1024个字节。</span><span class="sxs-lookup"><span data-stu-id="6002c-211">This constructor initializes the encoding as specified by the `encoding` parameter, and the internal buffer size to 1024 bytes.</span></span> <span data-ttu-id="6002c-212"><xref:System.IO.StreamReader>对象尝试通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-212">The <xref:System.IO.StreamReader> object attempts to  detect the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-213">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-213">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-214">否则, 将使用用户提供的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-214">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="6002c-215">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-215">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-216">`path`参数可以是文件名, 包括通用命名约定 (UNC) 共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-216">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="6002c-217">`path`参数不需要是存储在磁盘上的文件; 它可以是系统的任何支持使用流进行访问的部分。</span><span class="sxs-lookup"><span data-stu-id="6002c-217">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-218">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-218">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-219">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-219">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-220">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-220">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-221"><paramref name="path" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6002c-221"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-222"><paramref name="path" /> 或 <paramref name="encoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-222"><paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6002c-223">无法找到该文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-223">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="6002c-224">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="6002c-224">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6002c-225"><paramref name="path" /> 包括不正确或无效的文件名、目录名或卷标的语法。</span><span class="sxs-lookup"><span data-stu-id="6002c-225"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-226">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-226">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-227">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-227">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-228">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-228">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="6002c-229">要读取的流。</span><span class="sxs-lookup"><span data-stu-id="6002c-229">The stream to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="6002c-230">要使用的字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-230">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="6002c-231">指示是否在文件头查找字节顺序标记。</span><span class="sxs-lookup"><span data-stu-id="6002c-231">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="6002c-232">为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例，带有指定的字符编码和字节顺序标记检测选项。</span><span class="sxs-lookup"><span data-stu-id="6002c-232">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding and byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-233">此构造函数按`encoding`参数指定的、使用`stream`参数的<xref:System.IO.StreamReader.BaseStream%2A>属性和内部缓冲区大小到1024字节初始化编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-233">This constructor initializes the encoding as specified by the `encoding` parameter, the <xref:System.IO.StreamReader.BaseStream%2A> property using the `stream` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="6002c-234">`detectEncodingFromByteOrderMarks`参数通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-234">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-235">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-235">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-236">否则, 将使用用户提供的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-236">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="6002c-237">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-237">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-238">调用<xref:System.IO.StreamReader> <xref:System.IO.Stream.Dispose> <xref:System.IO.Stream>时,对象对提供的对象调用<xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6002c-238">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-239">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-239">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-240">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-240">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-241">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-241">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-242"><paramref name="stream" /> 不支持读取。</span><span class="sxs-lookup"><span data-stu-id="6002c-242"><paramref name="stream" /> does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-243"><paramref name="stream" /> 或 <paramref name="encoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-243"><paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-244">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-244">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-245">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-245">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-246">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-246">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6002c-247">要读取的完整文件路径。</span><span class="sxs-lookup"><span data-stu-id="6002c-247">The complete file path to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="6002c-248">要使用的字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-248">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="6002c-249">指示是否在文件头查找字节顺序标记。</span><span class="sxs-lookup"><span data-stu-id="6002c-249">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <summary><span data-ttu-id="6002c-250">为指定的文件名初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例，带有指定的字符编码和字节顺序标记检测选项。</span><span class="sxs-lookup"><span data-stu-id="6002c-250">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding and byte order mark detection option.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-251">此构造函数按照`encoding`参数指定的方式初始化编码, 内部缓冲区大小为1024个字节。</span><span class="sxs-lookup"><span data-stu-id="6002c-251">This constructor initializes the encoding as specified by the `encoding` parameter, and the internal buffer size to 1024 bytes.</span></span>  
  
 <span data-ttu-id="6002c-252">`detectEncodingFromByteOrderMarks`参数通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-252">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-253">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-253">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-254">否则, 将使用用户提供的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-254">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="6002c-255">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-255">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-256">`path`参数可以是文件名, 包括通用命名约定 (UNC) 共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-256">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="6002c-257">`path`参数不需要是存储在磁盘上的文件; 它可以是系统的任何支持使用流进行访问的部分。</span><span class="sxs-lookup"><span data-stu-id="6002c-257">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-258">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-258">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-259">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-259">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-260">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-260">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-261"><paramref name="path" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6002c-261"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-262"><paramref name="path" /> 或 <paramref name="encoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-262"><paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6002c-263">无法找到该文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-263">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="6002c-264">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="6002c-264">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6002c-265"><paramref name="path" /> 包括不正确或无效的文件名、目录名或卷标的语法。</span><span class="sxs-lookup"><span data-stu-id="6002c-265"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-266">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-266">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-267">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-267">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-268">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-268">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="6002c-269">要读取的流。</span><span class="sxs-lookup"><span data-stu-id="6002c-269">The stream to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="6002c-270">要使用的字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-270">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="6002c-271">指示是否在文件头查找字节顺序标记。</span><span class="sxs-lookup"><span data-stu-id="6002c-271">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="6002c-272">最小缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="6002c-272">The minimum buffer size.</span></span></param>
        <summary><span data-ttu-id="6002c-273">为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例，带有指定的字符编码、字节顺序标记检测选项和缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="6002c-273">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream, with the specified character encoding, byte order mark detection option, and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-274">缓冲区大小 (以16位字符的数目) 由`bufferSize`参数设置。</span><span class="sxs-lookup"><span data-stu-id="6002c-274">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="6002c-275">如果`bufferSize`小于允许的最小大小 (128 个字符), 则使用允许的最小大小。</span><span class="sxs-lookup"><span data-stu-id="6002c-275">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="6002c-276">此构造函数允许您在第一次从<xref:System.IO.StreamReader>对象读取时更改编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-276">This constructor allows you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="6002c-277">`detectEncodingFromByteOrderMarks`参数通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-277">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-278">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-278">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-279">否则, 将使用用户提供的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-279">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="6002c-280">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-280">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-281">调用<xref:System.IO.StreamReader> <xref:System.IO.Stream.Dispose> <xref:System.IO.Stream>时,对象对提供的对象调用<xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="6002c-281">The <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6002c-282">从读取时<xref:System.IO.Stream>, 使用与流的内部缓冲区大小相同的缓冲区会更有效。</span><span class="sxs-lookup"><span data-stu-id="6002c-282">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-283">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-283">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-284">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-284">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-285">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-285">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-286">流不支持读取。</span><span class="sxs-lookup"><span data-stu-id="6002c-286">The stream does not support reading.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-287"><paramref name="stream" /> 或 <paramref name="encoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-287"><paramref name="stream" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-288"><paramref name="bufferSize" /> 小于或等于零。</span><span class="sxs-lookup"><span data-stu-id="6002c-288"><paramref name="bufferSize" /> is less than or equal to zero.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-289">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-289">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-290">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-290">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-291">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-291">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::String ^ path, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : string * System.Text.Encoding * bool * int -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (path, encoding, detectEncodingFromByteOrderMarks, bufferSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="6002c-292">要读取的完整文件路径。</span><span class="sxs-lookup"><span data-stu-id="6002c-292">The complete file path to be read.</span></span></param>
        <param name="encoding"><span data-ttu-id="6002c-293">要使用的字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-293">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="6002c-294">指示是否在文件头查找字节顺序标记。</span><span class="sxs-lookup"><span data-stu-id="6002c-294">Indicates whether to look for byte order marks at the beginning of the file.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="6002c-295">最小缓冲区大小（以 16 位字符的数目为单位）。</span><span class="sxs-lookup"><span data-stu-id="6002c-295">The minimum buffer size, in number of 16-bit characters.</span></span></param>
        <summary><span data-ttu-id="6002c-296">为指定的文件名初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例，带有指定字符编码、字节顺序标记检测选项和缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="6002c-296">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified file name, with the specified character encoding, byte order mark detection option, and buffer size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-297">此构造函数按照`encoding`参数指定的方式初始化编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-297">This constructor initializes the encoding as specified by the `encoding` parameter.</span></span>  
  
 <span data-ttu-id="6002c-298">此构造函数允许您在第一次从<xref:System.IO.StreamReader>对象读取时更改编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-298">This constructor allows you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="6002c-299">`detectEncodingFromByteOrderMarks`参数通过查看流的前四个字节来检测编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-299">The `detectEncodingFromByteOrderMarks` parameter detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-300">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-300">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-301">否则, 将使用用户提供的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-301">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="6002c-302">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-302">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
 <span data-ttu-id="6002c-303">缓冲区大小 (以16位字符的数目) 由`bufferSize`参数设置。</span><span class="sxs-lookup"><span data-stu-id="6002c-303">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="6002c-304">如果`bufferSize`小于允许的最小大小 (128 个字符), 则使用允许的最小大小。</span><span class="sxs-lookup"><span data-stu-id="6002c-304">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="6002c-305">`path`参数可以是文件名, 包括通用命名约定 (UNC) 共享上的文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-305">The `path` parameter can be a file name, including a file on a Universal Naming Convention (UNC) share.</span></span>  
  
 <span data-ttu-id="6002c-306">`path`参数不需要是存储在磁盘上的文件; 它可以是系统的任何支持使用流进行访问的部分。</span><span class="sxs-lookup"><span data-stu-id="6002c-306">The `path` parameter is not required to be a file stored on disk; it can be any part of a system that supports access using streams.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-307">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能不是可解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-307">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpretable, and could cause an exception to be thrown.</span></span>  
  
 <span data-ttu-id="6002c-308">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-308">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-309">下面的代码示例演示了<xref:System.IO.StreamReader>此构造函数。</span><span class="sxs-lookup"><span data-stu-id="6002c-309">The following code example demonstrates this <xref:System.IO.StreamReader> constructor.</span></span>  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-310"><paramref name="path" /> 为空字符串 ("")。</span><span class="sxs-lookup"><span data-stu-id="6002c-310"><paramref name="path" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-311"><paramref name="path" /> 或 <paramref name="encoding" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-311"><paramref name="path" /> or <paramref name="encoding" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="6002c-312">无法找到该文件。</span><span class="sxs-lookup"><span data-stu-id="6002c-312">The file cannot be found.</span></span></exception>
        <exception cref="T:System.IO.DirectoryNotFoundException"><span data-ttu-id="6002c-313">指定的路径无效，例如位于未映射的驱动器上。</span><span class="sxs-lookup"><span data-stu-id="6002c-313">The specified path is invalid, such as being on an unmapped drive.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="6002c-314"><paramref name="path" /> 包括不正确或无效的文件名、目录名或卷标的语法。</span><span class="sxs-lookup"><span data-stu-id="6002c-314"><paramref name="path" /> includes an incorrect or invalid syntax for file name, directory name, or volume label.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-315"><paramref name="buffersize" /> 小于或等于零。</span><span class="sxs-lookup"><span data-stu-id="6002c-315"><paramref name="buffersize" /> is less than or equal to zero.</span></span></exception>
        <altmember cref="T:System.Text.Encoding" />
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-316">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-316">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-317">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-317">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-318">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-318">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StreamReader(System::IO::Stream ^ stream, System::Text::Encoding ^ encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="F#" Value="new System.IO.StreamReader : System.IO.Stream * System.Text.Encoding * bool * int * bool -&gt; System.IO.StreamReader" Usage="new System.IO.StreamReader (stream, encoding, detectEncodingFromByteOrderMarks, bufferSize, leaveOpen)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="encoding" Type="System.Text.Encoding" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bufferSize" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="leaveOpen" Type="System.Boolean" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="6002c-319">要读取的流。</span><span class="sxs-lookup"><span data-stu-id="6002c-319">The stream to read.</span></span></param>
        <param name="encoding"><span data-ttu-id="6002c-320">要使用的字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-320">The character encoding to use.</span></span></param>
        <param name="detectEncodingFromByteOrderMarks"><span data-ttu-id="6002c-321">如果要在文件开头查找字节顺序标记，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-321"><see langword="true" /> to look for byte order marks at the beginning of the file; otherwise, <see langword="false" />.</span></span></param>
        <param name="bufferSize"><span data-ttu-id="6002c-322">最小缓冲区大小。</span><span class="sxs-lookup"><span data-stu-id="6002c-322">The minimum buffer size.</span></span></param>
        <param name="leaveOpen"><span data-ttu-id="6002c-323">如果在释放 <see cref="T:System.IO.StreamReader" /> 对象后保持流处于打开状态，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-323"><see langword="true" /> to leave the stream open after the <see cref="T:System.IO.StreamReader" /> object is disposed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="6002c-324">为指定的流初始化 <see cref="T:System.IO.StreamReader" /> 类的新实例，带有指定的字符编码、字节顺序标记检测选项和缓冲区大小，有选择性的打开流。</span><span class="sxs-lookup"><span data-stu-id="6002c-324">Initializes a new instance of the <see cref="T:System.IO.StreamReader" /> class for the specified stream based on the specified character encoding, byte order mark detection option, and buffer size, and optionally leaves the stream open.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-325">除非您设置`leaveOpen`参数`true`，则<xref:System.IO.StreamReader>对象调用<xref:System.IO.Stream.Dispose>上提供<xref:System.IO.Stream>对象时<xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType>调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-325">Unless you set the `leaveOpen` parameter to `true`, the <xref:System.IO.StreamReader> object calls <xref:System.IO.Stream.Dispose> on the provided <xref:System.IO.Stream> object when <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> is called.</span></span>  
  
 <span data-ttu-id="6002c-326">缓冲区大小 (以16位字符的数目) 由`bufferSize`参数设置。</span><span class="sxs-lookup"><span data-stu-id="6002c-326">The buffer size, in number of 16-bit characters, is set by the `bufferSize` parameter.</span></span> <span data-ttu-id="6002c-327">如果`bufferSize`小于允许的最小大小 (128 个字符), 则使用允许的最小大小。</span><span class="sxs-lookup"><span data-stu-id="6002c-327">If `bufferSize` is less than the minimum allowable size (128 characters), the minimum allowable size is used.</span></span>  
  
 <span data-ttu-id="6002c-328">此构造函数使你能够在第一次从<xref:System.IO.StreamReader>对象读取时更改编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-328">This constructor enables you to change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="6002c-329">如果参数为`true`, 则构造函数通过查看流的前四个字节来检测编码。 `detectEncodingFromByteOrderMarks`</span><span class="sxs-lookup"><span data-stu-id="6002c-329">If the `detectEncodingFromByteOrderMarks` parameter is `true`, the constructor detects the encoding by looking at the first four bytes of the stream.</span></span> <span data-ttu-id="6002c-330">如果文件以适当的字节顺序标记开头, 则它会自动识别 UTF-8、小字节序 Unicode、大字节序 Unicode、小字节序 UTF-32 和大序位 UTF-32 文本。</span><span class="sxs-lookup"><span data-stu-id="6002c-330">It automatically recognizes UTF-8, little-endian Unicode, big-endian Unicode, little-endian UTF-32, and big-endian UTF-32 text if the file starts with the appropriate byte order marks.</span></span> <span data-ttu-id="6002c-331">否则, 将使用用户提供的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-331">Otherwise, the user-provided encoding is used.</span></span> <span data-ttu-id="6002c-332">有关更多信息，请参阅 <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-332">See the <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> method for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6002c-333">从读取时<xref:System.IO.Stream>, 使用与流的内部缓冲区大小相同的缓冲区会更有效。</span><span class="sxs-lookup"><span data-stu-id="6002c-333">When reading from a <xref:System.IO.Stream>, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="6002c-334">使用特定的区域性设置编译一组字符并使用不同的区域性设置检索这些相同的字符时, 这些字符可能无法正确解释, 并且可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-334">When you compile a set of characters with a particular cultural setting and retrieve those same characters with a different cultural setting, the characters might not be interpreted correctly, and could cause an exception to be thrown.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property BaseStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::IO::Stream ^ BaseStream { System::IO::Stream ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseStream : System.IO.Stream" Usage="System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6002c-335">返回基础流。</span><span class="sxs-lookup"><span data-stu-id="6002c-335">Returns the underlying stream.</span></span></summary>
        <value><span data-ttu-id="6002c-336">基础流。</span><span class="sxs-lookup"><span data-stu-id="6002c-336">The underlying stream.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-337">使用此属性可以访问基础流。</span><span class="sxs-lookup"><span data-stu-id="6002c-337">You use this property to access the underlying stream.</span></span> <span data-ttu-id="6002c-338">调用<xref:System.IO.StreamReader> <xref:System.IO.StreamReader.Read%2A>方法之一时, 类会缓冲基础流中的输入。</span><span class="sxs-lookup"><span data-stu-id="6002c-338">The <xref:System.IO.StreamReader> class buffers input from the underlying stream when you call one of the <xref:System.IO.StreamReader.Read%2A> methods.</span></span> <span data-ttu-id="6002c-339">如果在将数据读入缓冲区后操作基础流的位置, 则基础流的位置可能与内部缓冲区的位置不匹配。</span><span class="sxs-lookup"><span data-stu-id="6002c-339">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="6002c-340">若要重置内部缓冲区, 请<xref:System.IO.StreamReader.DiscardBufferedData%2A>调用方法; 但是, 此方法会降低性能, 只应在绝对必要的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-340">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span> <span data-ttu-id="6002c-341">在第一`detectEncodingFromByteOrderMarks` <xref:System.IO.StreamReader> 次从对象中读取时,具有参数的构造函数<xref:System.IO.StreamReader>可以更改编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-341">The <xref:System.IO.StreamReader> constructors that have the `detectEncodingFromByteOrderMarks` parameter can change the encoding the first time you read from the <xref:System.IO.StreamReader> object.</span></span>  
  
 <span data-ttu-id="6002c-342">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-342">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-343">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-343">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-344">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-344">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-345">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-345">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="streamReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-346">关闭 <see cref="T:System.IO.StreamReader" /> 对象和基础流，并释放与读取器关联的所有系统资源。</span><span class="sxs-lookup"><span data-stu-id="6002c-346">Closes the <see cref="T:System.IO.StreamReader" /> object and the underlying stream, and releases any system resources associated with the reader.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="6002c-347">此方法将<xref:System.IO.TextReader.Close%2A?displayProperty=nameWithType>重写方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-347">This method overrides the <xref:System.IO.TextReader.Close%2A?displayProperty=nameWithType> method.</span></span>  
  
<span data-ttu-id="6002c-348">的这一<xref:System.IO.StreamReader.Close%2A>实现<xref:System.IO.StreamReader.Dispose%2A>调用方法, 传递一个`true`值。</span><span class="sxs-lookup"><span data-stu-id="6002c-348">This implementation of <xref:System.IO.StreamReader.Close%2A> calls the <xref:System.IO.StreamReader.Dispose%2A> method, passing a `true` value.</span></span>  
  
<span data-ttu-id="6002c-349">调用<xref:System.IO.StreamReader.Close%2A>后, 读取器上的任何操作都可能引发异常。</span><span class="sxs-lookup"><span data-stu-id="6002c-349">Following a call to <xref:System.IO.StreamReader.Close%2A>, any operations on the reader might raise exceptions.</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-350">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-350">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-351">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-351">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-352">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-352">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Text::Encoding ^ CurrentEncoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentEncoding : System.Text.Encoding" Usage="System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6002c-353">获取当前 <see cref="T:System.IO.StreamReader" /> 对象正在使用的当前字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-353">Gets the current character encoding that the current <see cref="T:System.IO.StreamReader" /> object is using.</span></span></summary>
        <value><span data-ttu-id="6002c-354">当前读取器所使用的当前字符编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-354">The current character encoding used by the current reader.</span></span> <span data-ttu-id="6002c-355">第一次调用 <see cref="T:System.IO.StreamReader" /> 的任何 <see cref="Overload:System.IO.StreamReader.Read" /> 方法后，该值可能会不同，因为直到第一次调用 <see cref="Overload:System.IO.StreamReader.Read" /> 方法时，才会进行编码的自动检测。</span><span class="sxs-lookup"><span data-stu-id="6002c-355">The value can be different after the first call to any <see cref="Overload:System.IO.StreamReader.Read" /> method of <see cref="T:System.IO.StreamReader" />, since encoding autodetection is not done until the first call to a <see cref="Overload:System.IO.StreamReader.Read" /> method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-356">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-356">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-357">下面的代码示例获取指定<xref:System.IO.StreamReader>对象的编码。</span><span class="sxs-lookup"><span data-stu-id="6002c-357">The following code example gets the encoding of the specified <xref:System.IO.StreamReader> object.</span></span>  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-358">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-358">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-359">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-359">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-360">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-360">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberSignature Language="VB.NET" Value="Public Sub DiscardBufferedData ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DiscardBufferedData();" />
      <MemberSignature Language="F#" Value="member this.DiscardBufferedData : unit -&gt; unit" Usage="streamReader.DiscardBufferedData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-361">清除内部缓冲区。</span><span class="sxs-lookup"><span data-stu-id="6002c-361">Clears the internal buffer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-362">使用方法可重置<xref:System.IO.StreamReader>对象的内部缓冲区。 <xref:System.IO.StreamReader.DiscardBufferedData%2A></span><span class="sxs-lookup"><span data-stu-id="6002c-362">Use the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method to reset the internal buffer for the <xref:System.IO.StreamReader> object.</span></span> <span data-ttu-id="6002c-363">仅当内部缓冲区和的<xref:System.IO.StreamReader.BaseStream%2A>位置不匹配时, 才需要调用此方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-363">You need to call this method only when the position of the internal buffer and the <xref:System.IO.StreamReader.BaseStream%2A> do not match.</span></span> <span data-ttu-id="6002c-364">在将数据读入缓冲区并在基础流中查找新位置时, 这些位置可能会变得不匹配。</span><span class="sxs-lookup"><span data-stu-id="6002c-364">These positions can become mismatched when you read data into the buffer and then seek a new position in the underlying stream.</span></span> <span data-ttu-id="6002c-365">此方法会降低性能, 只应在绝对必要的情况下使用, 例如, 当你想要多次读取<xref:System.IO.StreamReader>对象的部分内容时。</span><span class="sxs-lookup"><span data-stu-id="6002c-365">This method slows performance and should be used only when absolutely necessary, such as when you want to read a portion of the contents of a <xref:System.IO.StreamReader> object more than once.</span></span>  
  
 <span data-ttu-id="6002c-366">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-366">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-367">下面的示例演示了一个方案, <xref:System.IO.StreamReader.DiscardBufferedData%2A>在此方案中, 必须调用方法以同步内部缓冲区和基础流。</span><span class="sxs-lookup"><span data-stu-id="6002c-367">The following example shows a scenario where the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method must be called to synchronize the internal buffer and the underlying stream.</span></span> <span data-ttu-id="6002c-368">示例中的文件用于说明位置并包含文本`abcdefghijklmnopqrstuvwxyz`。</span><span class="sxs-lookup"><span data-stu-id="6002c-368">The file in the example is used to illustrate position and consists of the text `abcdefghijklmnopqrstuvwxyz`.</span></span> <span data-ttu-id="6002c-369">通过在<xref:System.IO.StreamReader.DiscardBufferedData%2A>读取数据后调用, 此示例将按预期方式工作。</span><span class="sxs-lookup"><span data-stu-id="6002c-369">By calling <xref:System.IO.StreamReader.DiscardBufferedData%2A> after the data is read, the example works as expected.</span></span> <span data-ttu-id="6002c-370">读取前15个字符后, 将重置为偏移量值 2, 并读取所有剩余字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-370">After the first 15 characters are read, the position is reset to the offset value of 2 and all the remaining characters are read.</span></span> <span data-ttu-id="6002c-371">如果删除对<xref:System.IO.StreamReader.DiscardBufferedData%2A>的调用, 则该示例不会按预期方式工作。</span><span class="sxs-lookup"><span data-stu-id="6002c-371">If you remove the call to <xref:System.IO.StreamReader.DiscardBufferedData%2A>, the example does not work as expected.</span></span> <span data-ttu-id="6002c-372">读取前15个字符, 但仅重置基础流的位置。</span><span class="sxs-lookup"><span data-stu-id="6002c-372">The first 15 characters are read, but only the position of the underlying stream is reset.</span></span> <span data-ttu-id="6002c-373"><xref:System.IO.StreamReader>对象的内部缓冲区仍在第16个字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-373">The internal buffer of the <xref:System.IO.StreamReader> object is still on the 16th character.</span></span> <span data-ttu-id="6002c-374">因此, <xref:System.IO.StreamReader.ReadToEnd%2A>将返回缓冲区中的所有字符以及从重置位置开始的底层流中的字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-374">Therefore, <xref:System.IO.StreamReader.ReadToEnd%2A> returns all the characters in the buffer plus the characters in the underlying stream starting from the reset position.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-375">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-375">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-376">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-376">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-377">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-377">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="streamReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="6002c-378"><see langword="true" /> 表示释放托管资源和非托管资源；<see langword="false" /> 表示仅释放非托管资源。</span><span class="sxs-lookup"><span data-stu-id="6002c-378"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="6002c-379">关闭基础流，释放 <see cref="T:System.IO.StreamReader" /> 使用的未托管资源，同时还可以根据需要释放托管资源。</span><span class="sxs-lookup"><span data-stu-id="6002c-379">Closes the underlying stream, releases the unmanaged resources used by the <see cref="T:System.IO.StreamReader" />, and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-380">此方法由公共<xref:System.IDisposable.Dispose%2A>方法<xref:System.Object.Finalize%2A>和方法调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-380">This method is called by the public <xref:System.IDisposable.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="6002c-381"><xref:System.IDisposable.Dispose%2A>调用受保护<xref:System.IO.StreamReader.Dispose%2A>的方法, `disposing`并将参数设置为 true。</span><span class="sxs-lookup"><span data-stu-id="6002c-381"><xref:System.IDisposable.Dispose%2A> invokes the protected <xref:System.IO.StreamReader.Dispose%2A> method with the `disposing` parameter set to true.</span></span> <span data-ttu-id="6002c-382"><xref:System.Object.Finalize%2A>如果<xref:System.IO.StreamReader.Dispose%2A>调用`disposing` , 则设置为 false。</span><span class="sxs-lookup"><span data-stu-id="6002c-382"><xref:System.Object.Finalize%2A> invokes <xref:System.IO.StreamReader.Dispose%2A> with `disposing` set to false.</span></span>  
  
 <span data-ttu-id="6002c-383">当参数为`true`时, 此方法将释放由<xref:System.IO.StreamReader>对象引用的任何托管对象所持有的所有资源。 `disposing`</span><span class="sxs-lookup"><span data-stu-id="6002c-383">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that the <xref:System.IO.StreamReader> object references.</span></span> <span data-ttu-id="6002c-384">此方法调用每个引用对象的 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-384">This method invokes the <xref:System.IDisposable.Dispose%2A> method of each referenced object.</span></span>  
  
 <span data-ttu-id="6002c-385">。</span><span class="sxs-lookup"><span data-stu-id="6002c-385">.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="6002c-386">Dispose 可以由其他对象多次调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-386">Dispose can be called multiple times by other objects.</span></span> <span data-ttu-id="6002c-387">重写<see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />时, 请注意不要引用先前在 Dispose [cref,...] 调用中释放的对象。有关如何实现<see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />的详细信息, 请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-387">When overriding <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to Dispose[cref,...]. For more information about how to implement <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="6002c-388">有关<see cref="M:System.IDisposable.Dispose" /> 和<see cref="M:System.Object.Finalize" />的详细信息, 请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-388">For more information about <see cref="M:System.IDisposable.Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span></para></block>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-389">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-389">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-390">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-390">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-391">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-391">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfStream As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfStream { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfStream : bool" Usage="System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6002c-392">获取一个值，该值表示当前的流位置是否在流的末尾。</span><span class="sxs-lookup"><span data-stu-id="6002c-392">Gets a value that indicates whether the current stream position is at the end of the stream.</span></span></summary>
        <value><span data-ttu-id="6002c-393">如果当前流位置位于流的末尾，则为<see langword="true" /> ；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-393"><see langword="true" /> if the current stream position is at the end of the stream; otherwise <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="6002c-394">基础流已释放。</span><span class="sxs-lookup"><span data-stu-id="6002c-394">The underlying stream has been disposed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Null As StreamReader " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::IO::StreamReader ^ Null;" />
      <MemberSignature Language="F#" Value=" staticval mutable Null : System.IO.StreamReader" Usage="System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="6002c-395">空流周围的 <see cref="T:System.IO.StreamReader" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-395">A <see cref="T:System.IO.StreamReader" /> object around an empty stream.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-396">当在上<xref:System.IO.StreamReader.Null>调用读取方法时, 将始终返回零。</span><span class="sxs-lookup"><span data-stu-id="6002c-396">When read methods are invoked on <xref:System.IO.StreamReader.Null>, zero is always returned.</span></span> <span data-ttu-id="6002c-397">当<xref:System.IO.StreamReader.ReadLine%2A>在上<xref:System.IO.StreamReader.Null>调用时`null` , 将返回。</span><span class="sxs-lookup"><span data-stu-id="6002c-397">When <xref:System.IO.StreamReader.ReadLine%2A> is invoked on <xref:System.IO.StreamReader.Null>, `null` is returned.</span></span>  
  
 <span data-ttu-id="6002c-398">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-398">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-399">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-399">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-400">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-400">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-401">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-401">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Peek () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Peek();" />
      <MemberSignature Language="F#" Value="override this.Peek : unit -&gt; int" Usage="streamReader.Peek " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-402">返回下一个可用的字符，但不使用它。</span><span class="sxs-lookup"><span data-stu-id="6002c-402">Returns the next available character but does not consume it.</span></span></summary>
        <returns><span data-ttu-id="6002c-403">表示下一个要读取的字符的整数，或者，如果没有要读取的字符或该流不支持查找，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="6002c-403">An integer representing the next character to be read, or -1 if there are no characters to be read or if the stream does not support seeking.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-404"><xref:System.IO.StreamReader.Peek%2A>方法返回一个整数值, 以确定文件的末尾或发生了其他错误。</span><span class="sxs-lookup"><span data-stu-id="6002c-404">The <xref:System.IO.StreamReader.Peek%2A> method returns an integer value in order to determine whether the end of the file, or another error has occurred.</span></span> <span data-ttu-id="6002c-405">这允许用户首先检查返回值是否为-1, 然后再将其强制转换为<xref:System.Char>类型。</span><span class="sxs-lookup"><span data-stu-id="6002c-405">This allows a user to first check if the returned value is -1 before casting it to a <xref:System.Char> type.</span></span>  
  
 <span data-ttu-id="6002c-406">此方法重写 <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6002c-406">This method overrides <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6002c-407">不会<xref:System.IO.StreamReader> <xref:System.IO.StreamReader.Peek%2A>更改对象的当前位置。</span><span class="sxs-lookup"><span data-stu-id="6002c-407">The current position of the <xref:System.IO.StreamReader> object is not changed by <xref:System.IO.StreamReader.Peek%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-408">下面的代码示例读取文件中的行, 直到到达文件末尾。</span><span class="sxs-lookup"><span data-stu-id="6002c-408">The following code example reads lines from a file until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-409">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="6002c-409">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-410">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-410">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-411">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-411">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-412">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-412">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Read">
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="6002c-413">读取输入流中的下一个字符或下一组字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-413">Reads the next character or next set of characters from the input stream.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; int" Usage="streamReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-414">读取输入流中的下一个字符并使该字符的位置提升一个字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-414">Reads the next character from the input stream and advances the character position by one character.</span></span></summary>
        <returns><span data-ttu-id="6002c-415">输入流中表示为 <see cref="T:System.Int32" /> 对象的下一个字符。如果不再有可用的字符，则为 -1。</span><span class="sxs-lookup"><span data-stu-id="6002c-415">The next character from the input stream represented as an <see cref="T:System.Int32" /> object, or -1 if no more characters are available.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-416">此方法重写 <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6002c-416">This method overrides <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6002c-417">如果已到达流的末尾, 则此方法返回一个整数, 以便它可以返回-1。</span><span class="sxs-lookup"><span data-stu-id="6002c-417">This method returns an integer so that it can return -1 if the end of the stream has been reached.</span></span> <span data-ttu-id="6002c-418">如果在将数据读入缓冲区后操作基础流的位置, 则基础流的位置可能与内部缓冲区的位置不匹配。</span><span class="sxs-lookup"><span data-stu-id="6002c-418">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="6002c-419">若要重置内部缓冲区, 请<xref:System.IO.StreamReader.DiscardBufferedData%2A>调用方法; 但是, 此方法会降低性能, 只应在绝对必要的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-419">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="6002c-420">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-420">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-421">下面的代码示例演示<xref:System.IO.StreamReader.Read%2A>方法的简单用法。</span><span class="sxs-lookup"><span data-stu-id="6002c-421">The following code example demonstrates a simple use of the <xref:System.IO.StreamReader.Read%2A> method.</span></span>  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 <span data-ttu-id="6002c-422">下面的代码示例演示如何使用<xref:System.IO.StreamReader.Read>方法重载读取单个字符, 并将 ASCII 整数输出的格式设置为 decimal 和十六进制。</span><span class="sxs-lookup"><span data-stu-id="6002c-422">The following code example demonstrates reading a single character using the <xref:System.IO.StreamReader.Read> method overload, formatting the ASCII integer output as decimal and hexadecimal.</span></span>  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-423">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="6002c-423">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-424">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-424">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-425">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-425">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-426">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-426">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.Read : Span&lt;char&gt; -&gt; int" Usage="streamReader.Read buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int Read(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.Read : char[] * int * int -&gt; int" Usage="streamReader.Read (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="6002c-427">当此方法返回时，包含指定字符数组，此数组中 <paramref name="index" /> 和 (<c>index + count - 1</c>) 之间的值被从当前源中读取的字符所替换。</span><span class="sxs-lookup"><span data-stu-id="6002c-427">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<c>index + count - 1</c>) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="6002c-428">开始写入的 <paramref name="buffer" /> 的索引。</span><span class="sxs-lookup"><span data-stu-id="6002c-428">The index of <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="6002c-429">最多读取的字符数。</span><span class="sxs-lookup"><span data-stu-id="6002c-429">The maximum number of characters to read.</span></span></param>
        <summary><span data-ttu-id="6002c-430">从当前流中将指定的最多个字符读到指定索引位置开始的缓冲区。</span><span class="sxs-lookup"><span data-stu-id="6002c-430">Reads a specified maximum of characters from the current stream into a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="6002c-431">已读取的字符数，或者如果已到达流的末尾并且未读取任何数据，则为 0。</span><span class="sxs-lookup"><span data-stu-id="6002c-431">The number of characters that have been read, or 0 if at the end of the stream and no data was read.</span></span> <span data-ttu-id="6002c-432">该数小于或等于 <paramref name="count" /> 参数，具体取决于流中是否有可用的数据。</span><span class="sxs-lookup"><span data-stu-id="6002c-432">The number will be less than or equal to the <paramref name="count" /> parameter, depending on whether the data is available within the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-433">此方法重写 <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6002c-433">This method overrides <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6002c-434">如果已到达流的末尾, 则此方法返回一个整数, 以便它可以返回0。</span><span class="sxs-lookup"><span data-stu-id="6002c-434">This method returns an integer so that it can return 0 if the end of the stream has been reached.</span></span>  
  
 <span data-ttu-id="6002c-435">使用<xref:System.IO.StreamReader.Read%2A>方法时, 使用与流的内部缓冲区大小相同的缓冲区比将内部缓冲区设置为所需的块大小并始终读取小于块大小效率更高。</span><span class="sxs-lookup"><span data-stu-id="6002c-435">When using the <xref:System.IO.StreamReader.Read%2A> method, it is more efficient to use a buffer that is the same size as the internal buffer of the stream, where the internal buffer is set to your desired block size, and to always read less than the block size.</span></span> <span data-ttu-id="6002c-436">如果在构造流时未指定内部缓冲区的大小, 则其默认大小为 4 kb (4096 字节)。</span><span class="sxs-lookup"><span data-stu-id="6002c-436">If the size of the internal buffer was unspecified when the stream was constructed, its default size is 4 kilobytes (4096 bytes).</span></span> <span data-ttu-id="6002c-437">如果在将数据读入缓冲区后操作基础流的位置, 则基础流的位置可能与内部缓冲区的位置不匹配。</span><span class="sxs-lookup"><span data-stu-id="6002c-437">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="6002c-438">若要重置内部缓冲区, 请<xref:System.IO.StreamReader.DiscardBufferedData%2A>调用方法; 但是, 此方法会降低性能, 只应在绝对必要的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-438">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="6002c-439">此方法在读取`count`参数指定的字符数后返回, 或到达文件的结尾。</span><span class="sxs-lookup"><span data-stu-id="6002c-439">This method returns after either the number of characters specified by the `count` parameter are read, or the end of the file is reached.</span></span> <span data-ttu-id="6002c-440"><xref:System.IO.TextReader.ReadBlock%2A>是的<xref:System.IO.StreamReader.Read%2A>阻止版本。</span><span class="sxs-lookup"><span data-stu-id="6002c-440"><xref:System.IO.TextReader.ReadBlock%2A> is a blocking version of <xref:System.IO.StreamReader.Read%2A>.</span></span>  
  
 <span data-ttu-id="6002c-441">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-441">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-442">下面的代码示例一次读取五个字符, 直到到达文件末尾。</span><span class="sxs-lookup"><span data-stu-id="6002c-442">The following code example reads five characters at a time until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-443">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-443">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-444"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-444"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-445"><paramref name="index" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="6002c-445"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-446">出现 I/O 错误，如流被关闭。</span><span class="sxs-lookup"><span data-stu-id="6002c-446">An I/O error occurs, such as the stream is closed.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-447">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-447">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-448">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-448">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-449">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-449">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="6002c-450">当此方法返回时，包含指定的字符数组，此数组中 <paramref name="index" /> 和 (<paramref name="index" /> + <paramref name="count" /> - 1) 之间的值被从当前源中读取的字符所替换。</span><span class="sxs-lookup"><span data-stu-id="6002c-450">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<paramref name="index" /> + <paramref name="count" /> - 1) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="6002c-451">在 <paramref name="buffer" /> 中开始写入的位置。</span><span class="sxs-lookup"><span data-stu-id="6002c-451">The position in <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="6002c-452">要读取的最大字符数。</span><span class="sxs-lookup"><span data-stu-id="6002c-452">The maximum number of characters to read.</span></span> <span data-ttu-id="6002c-453">如果在将指定的字符数写入缓冲区之前已到达流结尾，则将返回当前方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-453">If the end of the stream is reached before the specified number of characters is written into the buffer, the current method returns.</span></span></param>
        <summary><span data-ttu-id="6002c-454">从当前流中异步读取指定的最大字符，并且从指定的索引位置开始将该数据写入缓冲区。</span><span class="sxs-lookup"><span data-stu-id="6002c-454">Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="6002c-455">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="6002c-455">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="6002c-456"><paramref name="TResult" /> 参数的值包含读入缓冲区的总字符数。</span><span class="sxs-lookup"><span data-stu-id="6002c-456">The value of the <paramref name="TResult" /> parameter contains the total number of characters read into the buffer.</span></span> <span data-ttu-id="6002c-457">如果当前可用字符数少于所请求的字符数，则该结果值可小于所请求的字符数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="6002c-457">The result value can be less than the number of characters requested if the number of characters currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-458">在读取`count`参数指定的字符数或到达流的末尾后, 任务完成。</span><span class="sxs-lookup"><span data-stu-id="6002c-458">The task completes after either the number of characters specified by the `count` parameter are read or the end of the stream is reached.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-459">下面的示例演示如何使用<xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法读取文件中的所有字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-459">The following example shows how to read all the characters in a file by using the <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="6002c-460">它在将字符添加到<xref:System.Text.StringBuilder>类的实例之前, 检查每个字符是否为字母、数字或空格。</span><span class="sxs-lookup"><span data-stu-id="6002c-460">It checks whether each character is a letter, digit, or white space before adding the character to an instance of the <xref:System.Text.StringBuilder> class.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-461"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-461"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-462"><paramref name="index" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="6002c-462"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-463"><paramref name="index" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="6002c-463">The sum of <paramref name="index" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="6002c-464">已释放流。</span><span class="sxs-lookup"><span data-stu-id="6002c-464">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6002c-465">以前的读取操作当前正在使用读取器。</span><span class="sxs-lookup"><span data-stu-id="6002c-465">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (Span&lt;char&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock(valuetype System.Span`1&lt;char&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Span{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Span(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(Span&lt;char&gt; buffer);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : Span&lt;char&gt; -&gt; int" Usage="streamReader.ReadBlock buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlock (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadBlock(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlock : char[] * int * int -&gt; int" Usage="streamReader.ReadBlock (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="6002c-466">当此方法返回时，包含指定字符数组，此数组中 <paramref name="index" /> 和 (<c>index + count - 1</c>) 之间的值被从当前源中读取的字符所替换。</span><span class="sxs-lookup"><span data-stu-id="6002c-466">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<c>index + count - 1</c>) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="6002c-467">在 <paramref name="buffer" /> 中开始写入的位置。</span><span class="sxs-lookup"><span data-stu-id="6002c-467">The position in <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="6002c-468">最多读取的字符数。</span><span class="sxs-lookup"><span data-stu-id="6002c-468">The maximum number of characters to read.</span></span></param>
        <summary><span data-ttu-id="6002c-469">从当前流中读取指定数目的字符并从指定索引开始将该数据写入缓冲区。</span><span class="sxs-lookup"><span data-stu-id="6002c-469">Reads a specified maximum number of characters from the current stream and writes the data to a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="6002c-470">已读取的字符数。</span><span class="sxs-lookup"><span data-stu-id="6002c-470">The number of characters that have been read.</span></span> <span data-ttu-id="6002c-471">该数字将小于或等于 <paramref name="count" />，具体取决于是否所有的输入字符都已读取。</span><span class="sxs-lookup"><span data-stu-id="6002c-471">The number will be less than or equal to <paramref name="count" />, depending on whether all input characters have been read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-472">基础流的位置由读入`buffer`的字符数来提前。</span><span class="sxs-lookup"><span data-stu-id="6002c-472">The position of the underlying stream is advanced by the number of characters that were read into `buffer`.</span></span>  
  
 <span data-ttu-id="6002c-473">方法会一直阻止, `count`直到读取或到达流的末尾。</span><span class="sxs-lookup"><span data-stu-id="6002c-473">The method blocks until either `count` characters are read, or the end of the stream has been reached.</span></span> <span data-ttu-id="6002c-474">这是的<xref:System.IO.StreamReader.Read%2A>一个阻止版。</span><span class="sxs-lookup"><span data-stu-id="6002c-474">This is a blocking version of <xref:System.IO.StreamReader.Read%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-475"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-475"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-476">缓冲区长度减去 <paramref name="index" /> 小于 <paramref name="count" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-476">The buffer length minus <paramref name="index" /> is less than <paramref name="count" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-477"><paramref name="index" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="6002c-477"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="6002c-478"><see cref="T:System.IO.StreamReader" /> 是关闭的。</span><span class="sxs-lookup"><span data-stu-id="6002c-478">The <see cref="T:System.IO.StreamReader" /> is closed.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-479">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="6002c-479">An I/O error occurred.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.ValueTask&lt;int&gt; ReadBlockAsync (Memory&lt;char&gt; buffer, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadBlockAsync(valuetype System.Memory`1&lt;char&gt; buffer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Memory{System.Char},System.Threading.CancellationToken)" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : Memory&lt;char&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadBlockAsync (buffer As Char(), index As Integer, count As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;int&gt; ^ ReadBlockAsync(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadBlockAsync : char[] * int * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="streamReader.ReadBlockAsync (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="index" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="6002c-480">当此方法返回时，包含指定的字符数组，此数组中 <paramref name="index" /> 和 (<paramref name="index" /> + <paramref name="count" /> - 1) 之间的值被从当前源中读取的字符所替换。</span><span class="sxs-lookup"><span data-stu-id="6002c-480">When this method returns, contains the specified character array with the values between <paramref name="index" /> and (<paramref name="index" /> + <paramref name="count" /> - 1) replaced by the characters read from the current source.</span></span></param>
        <param name="index"><span data-ttu-id="6002c-481">在 <paramref name="buffer" /> 中开始写入的位置。</span><span class="sxs-lookup"><span data-stu-id="6002c-481">The position in <paramref name="buffer" /> at which to begin writing.</span></span></param>
        <param name="count"><span data-ttu-id="6002c-482">最多读取的字符数。</span><span class="sxs-lookup"><span data-stu-id="6002c-482">The maximum number of characters to read.</span></span> <span data-ttu-id="6002c-483">如果在将指定的字符数写入到缓冲区之前就已经达到流结尾，则将返回此方法。</span><span class="sxs-lookup"><span data-stu-id="6002c-483">If the end of the stream is reached before the specified number of characters is written into the buffer, the method returns.</span></span></param>
        <summary><span data-ttu-id="6002c-484">从当前流中异步读取指定的最大字符，并且从指定的索引位置开始将该数据写入缓冲区。</span><span class="sxs-lookup"><span data-stu-id="6002c-484">Reads a specified maximum number of characters from the current stream asynchronously and writes the data to a buffer, beginning at the specified index.</span></span></summary>
        <returns><span data-ttu-id="6002c-485">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="6002c-485">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="6002c-486"><paramref name="TResult" /> 参数的值包含读入缓冲区的总字符数。</span><span class="sxs-lookup"><span data-stu-id="6002c-486">The value of the <paramref name="TResult" /> parameter contains the total number of characters read into the buffer.</span></span> <span data-ttu-id="6002c-487">如果当前可用字符数少于所请求的字符数，则该结果值可小于所请求的字符数；如果已到达流结尾时，则为 0（零）。</span><span class="sxs-lookup"><span data-stu-id="6002c-487">The result value can be less than the number of characters requested if the number of characters currently available is less than the requested number, or it can be 0 (zero) if the end of the stream has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-488">在读取`count`参数指定的字符数或已到达流的末尾之前, 任务不会完成。</span><span class="sxs-lookup"><span data-stu-id="6002c-488">The task does not complete until either the number of characters specified by the `count` parameter are read, or the end of the stream has been reached.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="6002c-489"><paramref name="buffer" /> 为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-489"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-490"><paramref name="index" /> 或 <paramref name="count" /> 为负数。</span><span class="sxs-lookup"><span data-stu-id="6002c-490"><paramref name="index" /> or <paramref name="count" /> is negative.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="6002c-491"><paramref name="index" /> 和 <paramref name="count" /> 的总和大于缓冲区长度。</span><span class="sxs-lookup"><span data-stu-id="6002c-491">The sum of <paramref name="index" /> and <paramref name="count" /> is larger than the buffer length.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="6002c-492">已释放流。</span><span class="sxs-lookup"><span data-stu-id="6002c-492">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6002c-493">以前的读取操作当前正在使用读取器。</span><span class="sxs-lookup"><span data-stu-id="6002c-493">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadLine();" />
      <MemberSignature Language="F#" Value="override this.ReadLine : unit -&gt; string" Usage="streamReader.ReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-494">从当前流中读取一行字符并将数据作为字符串返回。</span><span class="sxs-lookup"><span data-stu-id="6002c-494">Reads a line of characters from the current stream and returns the data as a string.</span></span></summary>
        <returns><span data-ttu-id="6002c-495">输入流中的下一行；如果到达了输入流的末尾，则为 <see langword="null" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-495">The next line from the input stream, or <see langword="null" /> if the end of the input stream is reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-496">行定义为字符序列, 后跟换行符 ("\n")、回车符 ("\r") 或后跟换行符 ("\r\n") 的回车符。</span><span class="sxs-lookup"><span data-stu-id="6002c-496">A line is defined as a sequence of characters followed by a line feed ("\n"), a carriage return ("\r"), or a carriage return immediately followed by a line feed ("\r\n").</span></span> <span data-ttu-id="6002c-497">返回的字符串不包含终止回车符或换行符。</span><span class="sxs-lookup"><span data-stu-id="6002c-497">The string that is returned does not contain the terminating carriage return or line feed.</span></span> <span data-ttu-id="6002c-498">如果到达了输入`null`流的末尾, 则返回值为。</span><span class="sxs-lookup"><span data-stu-id="6002c-498">The returned value is `null` if the end of the input stream is reached.</span></span>  
  
 <span data-ttu-id="6002c-499">此方法重写 <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6002c-499">This method overrides <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6002c-500">如果当前方法引发<xref:System.OutOfMemoryException>, 则读取器在基础<xref:System.IO.Stream>对象中的位置将由该方法可以读取的字符数提前, 但已读入内部<xref:System.IO.StreamReader.ReadLine%2A>缓冲区的字符将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="6002c-500">If the current method throws an <xref:System.OutOfMemoryException>, the reader's position in the underlying <xref:System.IO.Stream> object is advanced by the number of characters the method was able to read, but the characters already read into the internal <xref:System.IO.StreamReader.ReadLine%2A> buffer are discarded.</span></span> <span data-ttu-id="6002c-501">如果在将数据读入缓冲区后操作基础流的位置, 则基础流的位置可能与内部缓冲区的位置不匹配。</span><span class="sxs-lookup"><span data-stu-id="6002c-501">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="6002c-502">若要重置内部缓冲区, 请<xref:System.IO.StreamReader.DiscardBufferedData%2A>调用方法; 但是, 此方法会降低性能, 只应在绝对必要的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-502">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="6002c-503">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-503">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-504">下面的代码示例读取文件中的行, 直到到达文件末尾。</span><span class="sxs-lookup"><span data-stu-id="6002c-504">The following code example reads lines from a file until the end of the file is reached.</span></span>  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="6002c-505">没有足够的内存来为返回的字符串分配缓冲区。</span><span class="sxs-lookup"><span data-stu-id="6002c-505">There is insufficient memory to allocate a buffer for the returned string.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-506">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="6002c-506">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-507">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-507">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-508">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-508">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-509">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-509">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadLineAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadLineAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadLineAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadLineAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-510">从当前流中异步读取一行字符并将数据作为字符串返回。</span><span class="sxs-lookup"><span data-stu-id="6002c-510">Reads a line of characters asynchronously from the current stream and returns the data as a string.</span></span></summary>
        <returns><span data-ttu-id="6002c-511">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="6002c-511">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="6002c-512"><paramref name="TResult" /> 参数的值包含来自流的下一行或为 <see langword="null" /> 如果读取所有字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-512">The value of the <paramref name="TResult" /> parameter contains the next line from the stream, or is <see langword="null" /> if all the characters have been read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6002c-513">下面的示例演示如何使用<xref:System.IO.StreamReader.ReadLineAsync>方法读取文件的第一行。</span><span class="sxs-lookup"><span data-stu-id="6002c-513">The following example shows how to read the first line of a file by using the <xref:System.IO.StreamReader.ReadLineAsync> method.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-514">下一行中的字符数大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-514">The number of characters in the next line is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="6002c-515">已释放流。</span><span class="sxs-lookup"><span data-stu-id="6002c-515">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6002c-516">以前的读取操作当前正在使用读取器。</span><span class="sxs-lookup"><span data-stu-id="6002c-516">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadToEnd();" />
      <MemberSignature Language="F#" Value="override this.ReadToEnd : unit -&gt; string" Usage="streamReader.ReadToEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-517">从流的当前位置到末尾读取所有字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-517">Reads all characters from the current position to the end of the stream.</span></span></summary>
        <returns><span data-ttu-id="6002c-518">字符串形式的流的其余部分（从当前位置到末尾）。</span><span class="sxs-lookup"><span data-stu-id="6002c-518">The rest of the stream as a string, from the current position to the end.</span></span> <span data-ttu-id="6002c-519">如果当前位置位于流的末尾，则返回空字符串 (“”)。</span><span class="sxs-lookup"><span data-stu-id="6002c-519">If the current position is at the end of the stream, returns an empty string ("").</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="6002c-520">此方法重写 <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6002c-520">This method overrides <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6002c-521"><xref:System.IO.StreamReader.ReadToEnd%2A>当你需要从流的当前位置到末尾读取所有输入时, 效果最佳。</span><span class="sxs-lookup"><span data-stu-id="6002c-521"><xref:System.IO.StreamReader.ReadToEnd%2A> works best when you need to read all the input from the current position to the end of the stream.</span></span> <span data-ttu-id="6002c-522">如果需要对从流中读取的字符进行更多的控制, 请使用<xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>方法重载, 这通常会提高性能。</span><span class="sxs-lookup"><span data-stu-id="6002c-522">If more control is needed over how many characters are read from the stream, use the <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method overload, which generally results in better performance.</span></span>  
  
 <span data-ttu-id="6002c-523"><xref:System.IO.StreamReader.ReadToEnd%2A>假定流知道何时到达结束。</span><span class="sxs-lookup"><span data-stu-id="6002c-523"><xref:System.IO.StreamReader.ReadToEnd%2A> assumes that the stream knows when it has reached an end.</span></span> <span data-ttu-id="6002c-524">对于交互式协议, 服务器仅在请求时发送数据, 并且不会关闭连接, <xref:System.IO.StreamReader.ReadToEnd%2A>因此可能会无限期阻止, 因为它没有到达末尾, 应避免这样做。</span><span class="sxs-lookup"><span data-stu-id="6002c-524">For interactive protocols in which the server sends data only when you ask for it and does not close the connection, <xref:System.IO.StreamReader.ReadToEnd%2A> might block indefinitely because it does not reach an end, and should be avoided.</span></span>  
  
 <span data-ttu-id="6002c-525">请注意, 使用<xref:System.IO.StreamReader.Read%2A>方法时, 使用与流的内部缓冲区大小相同的缓冲区会更有效。</span><span class="sxs-lookup"><span data-stu-id="6002c-525">Note that when using the <xref:System.IO.StreamReader.Read%2A> method, it is more efficient to use a buffer that is the same size as the internal buffer of the stream.</span></span> <span data-ttu-id="6002c-526">如果在构造流时未指定缓冲区的大小, 则其默认大小为 4 kb (4096 字节)。</span><span class="sxs-lookup"><span data-stu-id="6002c-526">If the size of the buffer was unspecified when the stream was constructed, its default size is 4 kilobytes (4096 bytes).</span></span>  
  
 <span data-ttu-id="6002c-527">如果当前方法引发<xref:System.OutOfMemoryException>, 则读取器在基础<xref:System.IO.Stream>对象中的位置将由该方法可以读取的字符数提前, 但已读入内部<xref:System.IO.StreamReader.ReadLine%2A>缓冲区的字符将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="6002c-527">If the current method throws an <xref:System.OutOfMemoryException>, the reader's position in the underlying <xref:System.IO.Stream> object is advanced by the number of characters the method was able to read, but the characters already read into the internal <xref:System.IO.StreamReader.ReadLine%2A> buffer are discarded.</span></span> <span data-ttu-id="6002c-528">如果在将数据读入缓冲区后操作基础流的位置, 则基础流的位置可能与内部缓冲区的位置不匹配。</span><span class="sxs-lookup"><span data-stu-id="6002c-528">If you manipulate the position of the underlying stream after reading data into the buffer, the position of the underlying stream might not match the position of the internal buffer.</span></span> <span data-ttu-id="6002c-529">若要重置内部缓冲区, 请<xref:System.IO.StreamReader.DiscardBufferedData%2A>调用方法; 但是, 此方法会降低性能, 只应在绝对必要的情况下调用。</span><span class="sxs-lookup"><span data-stu-id="6002c-529">To reset the internal buffer, call the <xref:System.IO.StreamReader.DiscardBufferedData%2A> method; however, this method slows performance and should be called only when absolutely necessary.</span></span>  
  
 <span data-ttu-id="6002c-530">有关常见 i/o 任务的列表, 请参阅[常见 I/o 任务](~/docs/standard/io/common-i-o-tasks.md)。</span><span class="sxs-lookup"><span data-stu-id="6002c-530">For a list of common I/O tasks, see [Common I/O Tasks](~/docs/standard/io/common-i-o-tasks.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="6002c-531">下面的代码示例在一次操作中全部读取到文件末尾。</span><span class="sxs-lookup"><span data-stu-id="6002c-531">The following code example reads all the way to the end of a file in one operation.</span></span>  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="6002c-532">没有足够的内存来为返回的字符串分配缓冲区。</span><span class="sxs-lookup"><span data-stu-id="6002c-532">There is insufficient memory to allocate a buffer for the returned string.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="6002c-533">出现 I/O 错误。</span><span class="sxs-lookup"><span data-stu-id="6002c-533">An I/O error occurs.</span></span></exception>
        <related type="Article" href="~/docs/standard/io/index.md"><span data-ttu-id="6002c-534">文件和流 I/O</span><span class="sxs-lookup"><span data-stu-id="6002c-534">File and Stream I/O</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-read-text-from-a-file.md"><span data-ttu-id="6002c-535">如何：从文件读取文本</span><span class="sxs-lookup"><span data-stu-id="6002c-535">How to: Read Text from a File</span></span></related>
        <related type="Article" href="~/docs/standard/io/how-to-write-text-to-a-file.md"><span data-ttu-id="6002c-536">如何：向文件写入文本</span><span class="sxs-lookup"><span data-stu-id="6002c-536">How to: Write Text to a File</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadToEndAsync () As Task(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task&lt;System::String ^&gt; ^ ReadToEndAsync();" />
      <MemberSignature Language="F#" Value="override this.ReadToEndAsync : unit -&gt; System.Threading.Tasks.Task&lt;string&gt;" Usage="streamReader.ReadToEndAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="6002c-537">异步读取从当前位置到流的结尾的所有字符并将它们作为一个字符串返回。</span><span class="sxs-lookup"><span data-stu-id="6002c-537">Reads all characters from the current position to the end of the stream asynchronously and returns them as one string.</span></span></summary>
        <returns><span data-ttu-id="6002c-538">表示异步读取操作的任务。</span><span class="sxs-lookup"><span data-stu-id="6002c-538">A task that represents the asynchronous read operation.</span></span> <span data-ttu-id="6002c-539"><paramref name="TResult" /> 参数值包括字符串来自当前位置到结束流字符。</span><span class="sxs-lookup"><span data-stu-id="6002c-539">The value of the <paramref name="TResult" /> parameter contains a string with the characters from the current position to the end of the stream.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="6002c-540">下面的示例演示如何使用<xref:System.IO.StreamReader.ReadToEndAsync>方法读取文件的内容。</span><span class="sxs-lookup"><span data-stu-id="6002c-540">The following example shows how to read the contents of a file by using the <xref:System.IO.StreamReader.ReadToEndAsync> method.</span></span>  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="6002c-541">字符数大于 <see cref="F:System.Int32.MaxValue" />。</span><span class="sxs-lookup"><span data-stu-id="6002c-541">The number of characters is larger than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="6002c-542">已释放流。</span><span class="sxs-lookup"><span data-stu-id="6002c-542">The stream has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="6002c-543">以前的读取操作当前正在使用读取器。</span><span class="sxs-lookup"><span data-stu-id="6002c-543">The reader is currently in use by a previous read operation.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
