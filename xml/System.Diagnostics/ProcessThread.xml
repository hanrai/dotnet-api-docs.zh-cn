<Type Name="ProcessThread" FullName="System.Diagnostics.ProcessThread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e69454ab18ebc0dc9ebf1ec2ed5e4e0e47ca59ae" /><Meta Name="ms.sourcegitcommit" Value="a81314feefaa9d10797d6bfe39dab52ca7fd1709" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/22/2019" /><Meta Name="ms.locfileid" Value="69973097" /></Metadata><TypeSignature Language="C#" Value="public class ProcessThread : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ProcessThread extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.ProcessThread" />
  <TypeSignature Language="VB.NET" Value="Public Class ProcessThread&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ProcessThread : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ProcessThread = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessThreadDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="41614-101">表示操作系统进程线程。</span><span class="sxs-lookup"><span data-stu-id="41614-101">Represents an operating system process thread.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-102">使用<xref:System.Diagnostics.ProcessThread>获取有关系统上当前正在运行的线程的信息。</span><span class="sxs-lookup"><span data-stu-id="41614-102">Use <xref:System.Diagnostics.ProcessThread> to obtain information about a thread that is currently running on the system.</span></span> <span data-ttu-id="41614-103">例如, 这样做可以监视线程的性能特征。</span><span class="sxs-lookup"><span data-stu-id="41614-103">Doing so allows you, for example, to monitor the thread's performance characteristics.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="41614-104">此类型实现 <xref:System.IDisposable> 接口。</span><span class="sxs-lookup"><span data-stu-id="41614-104">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="41614-105">在使用完类型后，您应直接或间接释放类型。</span><span class="sxs-lookup"><span data-stu-id="41614-105">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="41614-106">若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="41614-106">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="41614-107">若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。</span><span class="sxs-lookup"><span data-stu-id="41614-107">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="41614-108">有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。</span><span class="sxs-lookup"><span data-stu-id="41614-108">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="41614-109">线程是通过程序执行的路径。</span><span class="sxs-lookup"><span data-stu-id="41614-109">A thread is a path of execution through a program.</span></span> <span data-ttu-id="41614-110">它是 Win32 计划的最小执行单位。</span><span class="sxs-lookup"><span data-stu-id="41614-110">It is the smallest unit of execution that Win32 schedules.</span></span> <span data-ttu-id="41614-111">它包含堆栈、CPU 寄存器状态以及系统计划程序执行列表中的条目。</span><span class="sxs-lookup"><span data-stu-id="41614-111">It consists of a stack, the state of the CPU registers, and an entry in the execution list of the system scheduler.</span></span>  
  
 <span data-ttu-id="41614-112">进程包含一个或多个线程, 以及内存中程序的代码、数据和其他资源。</span><span class="sxs-lookup"><span data-stu-id="41614-112">A process consists of one or more threads and the code, data, and other resources of a program in memory.</span></span> <span data-ttu-id="41614-113">典型的程序资源包括打开的文件、信号量和动态分配的内存。</span><span class="sxs-lookup"><span data-stu-id="41614-113">Typical program resources are open files, semaphores, and dynamically allocated memory.</span></span> <span data-ttu-id="41614-114">进程的每个资源都由进程的所有线程共享。</span><span class="sxs-lookup"><span data-stu-id="41614-114">Each resource of a process is shared by all that process's threads.</span></span>  
  
 <span data-ttu-id="41614-115">当系统计划程序向程序的一个线程提供执行控制时, 将执行一个程序。</span><span class="sxs-lookup"><span data-stu-id="41614-115">A program executes when the system scheduler gives execution control to one of the program's threads.</span></span> <span data-ttu-id="41614-116">计划程序确定哪些线程应运行以及何时运行。</span><span class="sxs-lookup"><span data-stu-id="41614-116">The scheduler determines which threads should run and when.</span></span> <span data-ttu-id="41614-117">较低优先级的线程可能会被强制等待, 而较高优先级的线程将完成其任务。</span><span class="sxs-lookup"><span data-stu-id="41614-117">A lower-priority thread might be forced to wait while higher-priority threads complete their tasks.</span></span> <span data-ttu-id="41614-118">在多处理器计算机上, 计划程序可将单个线程移动到不同的处理器, 从而平衡 CPU 负载。</span><span class="sxs-lookup"><span data-stu-id="41614-118">On multiprocessor computers, the scheduler can move individual threads to different processors, thus balancing the CPU load.</span></span>  
  
 <span data-ttu-id="41614-119">每个进程都以单个线程 (称为主线程) 开头。</span><span class="sxs-lookup"><span data-stu-id="41614-119">Each process starts with a single thread, which is known as the primary thread.</span></span> <span data-ttu-id="41614-120">任何线程都可以创建其他线程。</span><span class="sxs-lookup"><span data-stu-id="41614-120">Any thread can create additional threads.</span></span> <span data-ttu-id="41614-121">进程中的所有线程都共享该进程的地址空间。</span><span class="sxs-lookup"><span data-stu-id="41614-121">All the threads within a process share the address space of that process.</span></span>  
  
 <span data-ttu-id="41614-122">主线程不一定位于集合中的第一个索引处。</span><span class="sxs-lookup"><span data-stu-id="41614-122">The primary thread is not necessarily located at the first index in the collection.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41614-123">从 .NET Framework 版本2.0 开始, 许多 .NET Framework 方法和属性已消除了引用其他计算机上的性能计数器数据的功能。</span><span class="sxs-lookup"><span data-stu-id="41614-123">Starting with the .NET Framework version 2.0, the ability to reference performance counter data on other computers has been eliminated for many of the .NET Framework methods and properties.</span></span> <span data-ttu-id="41614-124">这项更改是为了提高性能并使非管理员能够使用<xref:System.Diagnostics.ProcessThread>该类。</span><span class="sxs-lookup"><span data-stu-id="41614-124">This change was made to improve performance and to enable non-administrators to use the <xref:System.Diagnostics.ProcessThread> class.</span></span> <span data-ttu-id="41614-125">因此, 在早期版本的 .NET Framework 中没有获得异常的某些应用程序现在可能会获取<xref:System.NotSupportedException>。</span><span class="sxs-lookup"><span data-stu-id="41614-125">As a result, some applications that did not get exceptions in earlier versions of the .NET Framework may now get a <xref:System.NotSupportedException>.</span></span> <span data-ttu-id="41614-126">受影响的方法和属性在此处列出太多, 但已将异常信息添加到受影响的成员主题中。</span><span class="sxs-lookup"><span data-stu-id="41614-126">The methods and properties affected are too numerous to list here, but the exception information has been added to the affected member topics.</span></span>  
  
 <span data-ttu-id="41614-127">进程的线程单独执行并且彼此不知道, 除非您使它们彼此可见。</span><span class="sxs-lookup"><span data-stu-id="41614-127">The threads of a process execute individually and are unaware of each other unless you make them visible to each other.</span></span> <span data-ttu-id="41614-128">但是, 共享公共资源的线程必须使用信号量或其他进程间通信方法来协调其工作。</span><span class="sxs-lookup"><span data-stu-id="41614-128">Threads that share common resources, however, must coordinate their work by using semaphores or another method of interprocess communication.</span></span>  
  
 <span data-ttu-id="41614-129">若要获取与当前进程关联<xref:System.Diagnostics.ProcessThread>的所有对象的集合, 请<xref:System.Diagnostics.Process.Threads%2A>获取该<xref:System.Diagnostics.Process>实例的属性。</span><span class="sxs-lookup"><span data-stu-id="41614-129">To get a collection of all the <xref:System.Diagnostics.ProcessThread> objects associated with the current process, get the <xref:System.Diagnostics.Process.Threads%2A> property of the <xref:System.Diagnostics.Process> instance.</span></span>  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.Process" />
    <altmember cref="P:System.Diagnostics.Process.Threads" />
  </Docs>
  <Members>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.ProcessThread.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The base priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-130">获取线程的基本优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-130">Gets the base priority of the thread.</span></span></summary>
        <value><span data-ttu-id="41614-131">线程的基本优先级，它由操作系统通过将进程优先级类与关联线程的优先级别相结合进行计算。</span><span class="sxs-lookup"><span data-stu-id="41614-131">The base priority of the thread, which the operating system computes by combining the process priority class with the priority level of the associated thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-132"><xref:System.Diagnostics.ProcessThread.BasePriority%2A>是进程线程的启动优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-132">The <xref:System.Diagnostics.ProcessThread.BasePriority%2A> is the starting priority for the process thread.</span></span> <span data-ttu-id="41614-133">你可以通过系统监视器的优先级基准计数器查看有关基本优先级的信息。</span><span class="sxs-lookup"><span data-stu-id="41614-133">You can view information about the base priority through the System Monitor's Priority Base counter.</span></span>  
  
 <span data-ttu-id="41614-134">操作系统通过将线程的优先级范围与进程的优先级类结合起来来计算线程的基本优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-134">The operating system computes a thread's base priority by combining the thread's priority level range with the process's priority class.</span></span> <span data-ttu-id="41614-135">可以将进程的<xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType>属性设置为<xref:System.Diagnostics.ProcessPriorityClass> <xref:System.Diagnostics.ProcessPriorityClass.Normal>枚举中的值之一, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>即<xref:System.Diagnostics.ProcessPriorityClass.BelowNormal> <xref:System.Diagnostics.ProcessPriorityClass.Idle> <xref:System.Diagnostics.ProcessPriorityClass.High>、、、、或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>。</span><span class="sxs-lookup"><span data-stu-id="41614-135">You can set the process's <xref:System.Diagnostics.Process.PriorityClass%2A?displayProperty=nameWithType> property to one of the values in the <xref:System.Diagnostics.ProcessPriorityClass> enumeration, which are <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>.</span></span> <span data-ttu-id="41614-136">可将线程的<xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>属性设置为限定线程基本优先级的值范围。</span><span class="sxs-lookup"><span data-stu-id="41614-136">You can set the thread's <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> property to a range of values that bounds the thread's base priority.</span></span> <span data-ttu-id="41614-137">Win32 使用四个优先级类, 每个类具有7个基本优先级别。</span><span class="sxs-lookup"><span data-stu-id="41614-137">Win32 uses four priority classes with seven base priority levels per class.</span></span>  
  
 <span data-ttu-id="41614-138">线程的当前优先级可能偏离基本优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-138">The thread's current priority might deviate from the base priority.</span></span> <span data-ttu-id="41614-139">例如, 当某个进程必须提前到其他<xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>进程以访问处理器时, 操作系统可以根据所用时间或其他提升来更改属性。</span><span class="sxs-lookup"><span data-stu-id="41614-139">For example, the operating system can change the <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> property based on the time elapsed or other boosts when a process must be put ahead of others for access to the processor.</span></span> <span data-ttu-id="41614-140">此外, 您还可以设置<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>属性, 使系统在进程退出等待状态时暂时提高线程的优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-140">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to cause the system to temporarily boost the priority of a thread whenever the process is taken out of the wait state.</span></span> <span data-ttu-id="41614-141">当进程返回到等待状态时, 将重置此优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-141">The priority is reset when the process returns to the wait state.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="CurrentPriority">
      <MemberSignature Language="C#" Value="public int CurrentPriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CurrentPriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int CurrentPriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPriority : int" Usage="System.Diagnostics.ProcessThread.CurrentPriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current priority of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadCurrentPriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-142">获取线程的当前优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-142">Gets the current priority of the thread.</span></span></summary>
        <value><span data-ttu-id="41614-143">线程的当前优先级，可根据操作系统如何安排该线程而偏离基本优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-143">The current priority of the thread, which may deviate from the base priority based on how the operating system is scheduling the thread.</span></span> <span data-ttu-id="41614-144">可为活动线程暂时提升优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-144">The priority may be temporarily boosted for an active thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-145">线程的当前优先级可能偏离基本优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-145">The thread's current priority might deviate from the base priority.</span></span> <span data-ttu-id="41614-146">例如, 当某个进程必须提前在其他<xref:System.Diagnostics.ProcessThread.CurrentPriority%2A>进程中以访问处理器时, 操作系统可以根据已用时间或其他提升来更改属性。</span><span class="sxs-lookup"><span data-stu-id="41614-146">For example, the operating system can change the <xref:System.Diagnostics.ProcessThread.CurrentPriority%2A> property based on the time elapsed, or other boosts, when a process must be put ahead of others for access to the processor.</span></span> <span data-ttu-id="41614-147">此外, 您还可以设置<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>属性, 使系统在进程退出等待状态时暂时提高线程的优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-147">In addition, you can set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to cause the system to temporarily boost the priority of a thread whenever the process is taken out of the wait state.</span></span> <span data-ttu-id="41614-148">当进程返回到等待状态时, 将重置此优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-148">The priority is reset when the process returns to the wait state.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.ProcessThread.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The ID of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-149">获取线程的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="41614-149">Gets the unique identifier of the thread.</span></span></summary>
        <value><span data-ttu-id="41614-150">与指定线程关联的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="41614-150">The unique identifier associated with a specific thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-151">操作系统重新运行线程标识号, 该标识号仅在线程的生存期内标识线程。</span><span class="sxs-lookup"><span data-stu-id="41614-151">The operating system reuses thread identification numbers, which identify threads only during their lifetimes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdealProcessor">
      <MemberSignature Language="C#" Value="public int IdealProcessor { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IdealProcessor" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Property IdealProcessor As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int IdealProcessor {  void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.IdealProcessor : int" Usage="System.Diagnostics.ProcessThread.IdealProcessor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-152">设置让此线程在其上运行的首选处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-152">Sets the preferred processor for this thread to run on.</span></span></summary>
        <value><span data-ttu-id="41614-153">线程的首选处理器，用来在系统安排线程时确定在哪个处理器上运行线程。</span><span class="sxs-lookup"><span data-stu-id="41614-153">The preferred processor for the thread, used when the system schedules threads, to determine which processor to run the thread on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-154"><xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>该值从零开始。</span><span class="sxs-lookup"><span data-stu-id="41614-154">The <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> value is zero-based.</span></span>  <span data-ttu-id="41614-155">换句话说, 若要为第一个处理器设置线程关联, 请将属性设置为零。</span><span class="sxs-lookup"><span data-stu-id="41614-155">In other words, to set the thread affinity for the first processor, set the property to zero.</span></span>  
  
 <span data-ttu-id="41614-156">系统会尽可能地在其首选处理器上安排线程。</span><span class="sxs-lookup"><span data-stu-id="41614-156">The system schedules threads on their preferred processors whenever possible.</span></span>  
  
 <span data-ttu-id="41614-157">进程线程可以从处理器迁移到处理器, 每次迁移都重新加载处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="41614-157">A process thread can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="41614-158">为线程指定处理器可以减少重新加载处理器缓存的次数, 从而提高系统负载下的性能。</span><span class="sxs-lookup"><span data-stu-id="41614-158">Specifying a processor for a thread can improve performance under heavy system loads by reducing the number of times the processor cache is reloaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41614-159">下面的示例演示如何将 Notepad 实例<xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>的属性设置为第一个处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-159">The following example demonstrates how to set the <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> property for an instance of Notepad to the first processor.</span></span>  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-160">系统未能设置线程在指定的处理器上启动。</span><span class="sxs-lookup"><span data-stu-id="41614-160">The system could not set the thread to start on the specified processor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-161">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-161">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.ProcessThread.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Thread gets a priority boot when interactively used by a user.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-162">获取或设置一个值，该值指示每当关联线程的进程主窗口接收焦点时，操作系统是否暂时提升该线程的优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-162">Gets or sets a value indicating whether the operating system should temporarily boost the priority of the associated thread whenever the main window of the thread's process receives the focus.</span></span></summary>
        <value><span data-ttu-id="41614-163">若要在用户与进程的界面交互时提升线程的优先级，则为 <see langword="true" />；否则为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="41614-163"><see langword="true" /> to boost the thread's priority when the user interacts with the process's interface; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="41614-164">默认值为 <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="41614-164">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-165">当<xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> 为`true`时, 只要其关联进程从等待状态中消失, 系统就会暂时提高线程的优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-165">When <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> is `true`, the system temporarily boosts the thread's priority whenever its associated process is taken out of the wait state.</span></span> <span data-ttu-id="41614-166">此操作可防止其他进程中断当前线程的处理。</span><span class="sxs-lookup"><span data-stu-id="41614-166">This action prevents other processes from interrupting the processing of the current thread.</span></span> <span data-ttu-id="41614-167">此<xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A>设置会影响所有现有线程以及此进程随后创建的任何线程。</span><span class="sxs-lookup"><span data-stu-id="41614-167">The <xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> setting affects all existing threads as well as any threads subsequently created by the process.</span></span> <span data-ttu-id="41614-168">若要还原正常行为, 请<xref:System.Diagnostics.Process.PriorityBoostEnabled%2A>将属性`false`设置为。</span><span class="sxs-lookup"><span data-stu-id="41614-168">To restore normal behavior, set the <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> property to `false`.</span></span>  
  
 <span data-ttu-id="41614-169"><xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A>仅<xref:System.Diagnostics.Process.PriorityClass%2A>当线程在设置为动态优先级枚举值之一 (<xref:System.Diagnostics.ProcessPriorityClass.Normal>、 <xref:System.Diagnostics.ProcessPriorityClass.High>或<xref:System.Diagnostics.ProcessPriorityClass.RealTime>) 的进程中运行时才起作用。</span><span class="sxs-lookup"><span data-stu-id="41614-169"><xref:System.Diagnostics.ProcessThread.PriorityBoostEnabled%2A> has an effect only when the thread is running in a process that has a <xref:System.Diagnostics.Process.PriorityClass%2A> set to one of the dynamic priority enumeration values (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, or <xref:System.Diagnostics.ProcessPriorityClass.RealTime>).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="41614-170">提升优先级过高可能会耗尽基本操作系统和网络功能的资源。</span><span class="sxs-lookup"><span data-stu-id="41614-170">Boosting the priority too high can drain resources from essential operating system and network functions.</span></span> <span data-ttu-id="41614-171">这可能会导致其他操作系统任务出现问题。</span><span class="sxs-lookup"><span data-stu-id="41614-171">This could cause problems with other operating system tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-172">未能检索到优先级提升信息。</span><span class="sxs-lookup"><span data-stu-id="41614-172">The priority boost information could not be retrieved.</span></span>  
  
 <span data-ttu-id="41614-173">或</span><span class="sxs-lookup"><span data-stu-id="41614-173">-or-</span></span>  
  
 <span data-ttu-id="41614-174">未能设置优先级提升信息。</span><span class="sxs-lookup"><span data-stu-id="41614-174">The priority boost information could not be set.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-175">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-175">The process is on a remote computer.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
      </Docs>
    </Member>
    <Member MemberName="PriorityLevel">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadPriorityLevel PriorityLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadPriorityLevel PriorityLevel" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityLevel As ThreadPriorityLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadPriorityLevel PriorityLevel { System::Diagnostics::ThreadPriorityLevel get(); void set(System::Diagnostics::ThreadPriorityLevel value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityLevel : System.Diagnostics.ThreadPriorityLevel with get, set" Usage="System.Diagnostics.ProcessThread.PriorityLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority level of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPriorityLevel")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadPriorityLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-176">获取或设置线程的优先级别。</span><span class="sxs-lookup"><span data-stu-id="41614-176">Gets or sets the priority level of the thread.</span></span></summary>
        <value><span data-ttu-id="41614-177"><see cref="T:System.Diagnostics.ThreadPriorityLevel" /> 值之一，它指定限制线程优先级的范围。</span><span class="sxs-lookup"><span data-stu-id="41614-177">One of the <see cref="T:System.Diagnostics.ThreadPriorityLevel" /> values, specifying a range that bounds the thread's priority.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-178">优先级别不是单个值, 而是值的范围。</span><span class="sxs-lookup"><span data-stu-id="41614-178">The priority level is not a single value, but rather a range of values.</span></span> <span data-ttu-id="41614-179">操作系统使用进程的<xref:System.Diagnostics.Process.PriorityClass%2A>从<xref:System.Diagnostics.ProcessThread.PriorityLevel%2A>属性中指定的范围内选择一个值来计算该线程的基本优先级。</span><span class="sxs-lookup"><span data-stu-id="41614-179">The operating system computes the thread's base priority by using the process's <xref:System.Diagnostics.Process.PriorityClass%2A> to choose a value from the range specified in the <xref:System.Diagnostics.ProcessThread.PriorityLevel%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-180">未能检索到线程优先级别信息。</span><span class="sxs-lookup"><span data-stu-id="41614-180">The thread priority level information could not be retrieved.</span></span>  
  
 <span data-ttu-id="41614-181">或</span><span class="sxs-lookup"><span data-stu-id="41614-181">-or-</span></span>  
  
 <span data-ttu-id="41614-182">未能设置线程优先级别。</span><span class="sxs-lookup"><span data-stu-id="41614-182">The thread priority level could not be set.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-183">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-183">The process is on a remote computer.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.ProcessThread.BasePriority" />
        <altmember cref="P:System.Diagnostics.ProcessThread.CurrentPriority" />
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in privileged mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-184">获取线程在操作系统内核中运行代码所用的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-184">Gets the amount of time that the thread has spent running code inside the operating system core.</span></span></summary>
        <value><span data-ttu-id="41614-185"><see cref="T:System.TimeSpan" />，它指示线程在操作系统内核中运行代码所用的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-185">A <see cref="T:System.TimeSpan" /> indicating the amount of time that the thread has spent running code inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-186">Windows 使用几种不同的保护机制, 它们的根本都是用户模式与特权模式之间的区别。</span><span class="sxs-lookup"><span data-stu-id="41614-186">Windows uses several different protection mechanisms, and at the root of them all is the distinction between user mode and privileged mode.</span></span> <span data-ttu-id="41614-187"><xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>对应于应用程序在特权模式下运行时在操作系统内核中所用的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-187"><xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> corresponds to the amount of time that the application has spent running in privileged mode, inside the operating system core.</span></span> <span data-ttu-id="41614-188"><xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>属性表示应用程序在系统内核之外的用户模式下运行代码所用的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-188">The <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> property indicates the amount of time that the application has spent running code in user mode, outside the system core.</span></span>  
  
 <span data-ttu-id="41614-189">用户模式通过两个重要方式限制了应用程序。</span><span class="sxs-lookup"><span data-stu-id="41614-189">User mode restricts the application in two important ways.</span></span> <span data-ttu-id="41614-190">首先, 应用程序不能直接访问外围设备, 而是必须调用操作系统内核才能获取或设置外围数据。</span><span class="sxs-lookup"><span data-stu-id="41614-190">First, the application cannot directly access the peripherals, but instead must call the operating system core to get or set peripheral data.</span></span> <span data-ttu-id="41614-191">因此, 操作系统可以确保一个应用程序不会销毁另一个应用程序所需的外部数据。</span><span class="sxs-lookup"><span data-stu-id="41614-191">The operating system can thus ensure that one application does not destroy peripheral data that is needed by another.</span></span> <span data-ttu-id="41614-192">其次, 应用程序无法读取或更改操作系统本身维护的数据。</span><span class="sxs-lookup"><span data-stu-id="41614-192">Second, the application cannot read or change data that the operating system itself maintains.</span></span> <span data-ttu-id="41614-193">此限制可防止无意或有意损坏内核的应用程序。</span><span class="sxs-lookup"><span data-stu-id="41614-193">This restriction prevents applications from either inadvertently or intentionally corrupting the core.</span></span> <span data-ttu-id="41614-194">如果应用程序需要操作系统执行操作, 它将调用系统的一个例程。</span><span class="sxs-lookup"><span data-stu-id="41614-194">If the application needs the operating system to perform an operation, it calls one of the system's routines.</span></span> <span data-ttu-id="41614-195">其中许多转换为特权模式, 执行操作, 并平稳地返回到用户模式。</span><span class="sxs-lookup"><span data-stu-id="41614-195">Many of these transition into privileged mode, perform the operation, and smoothly return to user mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-196">未能检索到线程时间。</span><span class="sxs-lookup"><span data-stu-id="41614-196">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-197">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-197">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity {  void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint" Usage="System.Diagnostics.ProcessThread.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-2.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-198">设置关联线程可以在其上运行的处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-198">Sets the processors on which the associated thread can run.</span></span></summary>
        <value><span data-ttu-id="41614-199">指向一组位的 <see cref="T:System.IntPtr" />，每个位表示该线程可在其上运行的一个处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-199">An <see cref="T:System.IntPtr" /> that points to a set of bits, each of which represents a processor that the thread can run on.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-200">线程的处理器关联是它与之有关系的一组处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-200">The processor affinity of a thread is the set of processors it has a relationship to.</span></span> <span data-ttu-id="41614-201">换句话说, 它可以计划在其上运行。</span><span class="sxs-lookup"><span data-stu-id="41614-201">In other words, those it can be scheduled to run on.</span></span>  
  
 <span data-ttu-id="41614-202"><xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>将每个处理器表示为一个位。</span><span class="sxs-lookup"><span data-stu-id="41614-202"><xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> represents each processor as a bit.</span></span> <span data-ttu-id="41614-203">位0表示处理器 1, 第1位表示处理器 2, 依此类推。</span><span class="sxs-lookup"><span data-stu-id="41614-203">Bit 0 represents processor one, bit 1 represents processor two, and so on.</span></span> <span data-ttu-id="41614-204">下表显示了四处理器系统的一部分<xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>可能。</span><span class="sxs-lookup"><span data-stu-id="41614-204">The following table shows a subset of the possible <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> for a four-processor system.</span></span>  
  
|<span data-ttu-id="41614-205">属性值 (十六进制)</span><span class="sxs-lookup"><span data-stu-id="41614-205">Property value (in hexadecimal)</span></span>|<span data-ttu-id="41614-206">有效处理器</span><span class="sxs-lookup"><span data-stu-id="41614-206">Valid processors</span></span>|  
|---------------------------------------|----------------------|  
|<span data-ttu-id="41614-207">0x0001</span><span class="sxs-lookup"><span data-stu-id="41614-207">0x0001</span></span>|<span data-ttu-id="41614-208">1</span><span class="sxs-lookup"><span data-stu-id="41614-208">1</span></span>|  
|<span data-ttu-id="41614-209">0x0002</span><span class="sxs-lookup"><span data-stu-id="41614-209">0x0002</span></span>|<span data-ttu-id="41614-210">2</span><span class="sxs-lookup"><span data-stu-id="41614-210">2</span></span>|  
|<span data-ttu-id="41614-211">0x0003</span><span class="sxs-lookup"><span data-stu-id="41614-211">0x0003</span></span>|<span data-ttu-id="41614-212">1或2</span><span class="sxs-lookup"><span data-stu-id="41614-212">1 or 2</span></span>|  
|<span data-ttu-id="41614-213">0x0004</span><span class="sxs-lookup"><span data-stu-id="41614-213">0x0004</span></span>|<span data-ttu-id="41614-214">3</span><span class="sxs-lookup"><span data-stu-id="41614-214">3</span></span>|  
|<span data-ttu-id="41614-215">0x0005</span><span class="sxs-lookup"><span data-stu-id="41614-215">0x0005</span></span>|<span data-ttu-id="41614-216">1或3</span><span class="sxs-lookup"><span data-stu-id="41614-216">1 or 3</span></span>|  
|<span data-ttu-id="41614-217">0x0007</span><span class="sxs-lookup"><span data-stu-id="41614-217">0x0007</span></span>|<span data-ttu-id="41614-218">1、2或3</span><span class="sxs-lookup"><span data-stu-id="41614-218">1, 2, or 3</span></span>|  
|<span data-ttu-id="41614-219">0x000F</span><span class="sxs-lookup"><span data-stu-id="41614-219">0x000F</span></span>|<span data-ttu-id="41614-220">1、2、3或4</span><span class="sxs-lookup"><span data-stu-id="41614-220">1, 2, 3, or 4</span></span>|  
  
 <span data-ttu-id="41614-221">还可以通过设置<xref:System.Diagnostics.ProcessThread.IdealProcessor%2A>属性来指定线程的单个首选处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-221">You can also specify the single, preferred processor for a thread by setting the <xref:System.Diagnostics.ProcessThread.IdealProcessor%2A> property.</span></span> <span data-ttu-id="41614-222">进程线程可以从处理器迁移到处理器, 每次迁移都重新加载处理器缓存。</span><span class="sxs-lookup"><span data-stu-id="41614-222">A process thread can migrate from processor to processor, with each migration reloading the processor cache.</span></span> <span data-ttu-id="41614-223">为线程指定处理器可以减少重新加载处理器缓存的次数, 从而提高系统负载下的性能。</span><span class="sxs-lookup"><span data-stu-id="41614-223">Specifying a processor for a thread can improve performance under heavy system loads by reducing the number of times the processor cache is reloaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="41614-224">下面的示例演示如何将 Notepad 实例<xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A>的属性设置为第一个处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-224">The following example shows how to set the <xref:System.Diagnostics.ProcessThread.ProcessorAffinity%2A> property for an instance of Notepad to the first processor.</span></span>  
  
 [!code-csharp[ProcessThreadIdealProcessor#1](~/samples/snippets/csharp/VS_Snippets_CLR/ProcessThreadIdealProcessor/CS/program.cs#1)]
 [!code-vb[ProcessThreadIdealProcessor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ProcessThreadIdealProcessor/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-225">未能设置处理器关联。</span><span class="sxs-lookup"><span data-stu-id="41614-225">The processor affinity could not be set.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-226">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-226">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="ResetIdealProcessor">
      <MemberSignature Language="C#" Value="public void ResetIdealProcessor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetIdealProcessor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.ProcessThread.ResetIdealProcessor" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetIdealProcessor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetIdealProcessor();" />
      <MemberSignature Language="F#" Value="member this.ResetIdealProcessor : unit -&gt; unit" Usage="processThread.ResetIdealProcessor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="41614-227">重置此线程的理想处理器，以指示没有单个的理想处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-227">Resets the ideal processor for this thread to indicate that there is no single ideal processor.</span></span> <span data-ttu-id="41614-228">换言之，任何处理器都是理想处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-228">In other words, so that any processor is ideal.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-229">未能重置理想处理器。</span><span class="sxs-lookup"><span data-stu-id="41614-229">The ideal processor could not be reset.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-230">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-230">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.IdealProcessor" />
      </Docs>
    </Member>
    <Member MemberName="StartAddress">
      <MemberSignature Language="C#" Value="public IntPtr StartAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int StartAddress" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartAddress As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr StartAddress { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.StartAddress : nativeint" Usage="System.Diagnostics.ProcessThread.StartAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The start address in memory of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-231">获取操作系统调用的、启动此线程的函数的内存地址。</span><span class="sxs-lookup"><span data-stu-id="41614-231">Gets the memory address of the function that the operating system called that started this thread.</span></span></summary>
        <value><span data-ttu-id="41614-232">线程的起始地址，它指向线程执行的应用程序定义的函数。</span><span class="sxs-lookup"><span data-stu-id="41614-232">The thread's starting address, which points to the application-defined function that the thread executes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-233">每个进程都以单个线程 (称为主线程) 开头。</span><span class="sxs-lookup"><span data-stu-id="41614-233">Each process starts with a single thread, which is known as the primary thread.</span></span> <span data-ttu-id="41614-234">任何线程都可以创建其他线程。</span><span class="sxs-lookup"><span data-stu-id="41614-234">Any thread can create additional threads.</span></span>  
  
 <span data-ttu-id="41614-235">进程具有虚拟地址空间、可执行代码、数据、对象句柄、环境变量、基本优先级和最小和最大工作集大小。</span><span class="sxs-lookup"><span data-stu-id="41614-235">A process has a virtual address space, executable code, data, object handles, environment variables, a base priority, and minimum and maximum working set sizes.</span></span> <span data-ttu-id="41614-236">进程的所有线程共享其虚拟地址空间和系统资源。</span><span class="sxs-lookup"><span data-stu-id="41614-236">All the threads of a process share its virtual address space and system resources.</span></span> <span data-ttu-id="41614-237">此外, 每个线程维护异常处理程序、计划优先级和一组结构, 其中系统在线程等待计划时保存线程上下文。</span><span class="sxs-lookup"><span data-stu-id="41614-237">In addition, each thread maintains exception handlers, a scheduling priority, and a set of structures in which the system saves the thread context while the thread is waiting to be scheduled.</span></span> <span data-ttu-id="41614-238">线程上下文包括线程的计算机寄存器集、内核堆栈、线程环境块和线程进程的地址空间中的用户堆栈。</span><span class="sxs-lookup"><span data-stu-id="41614-238">The thread context includes the thread's set of machine registers, the kernel stack, a thread environment block, and a user stack in the address space of the thread's process.</span></span>  
  
 <span data-ttu-id="41614-239">每个 Windows 线程实际上在系统提供的函数中开始执行, 而不是由应用程序提供的函数。</span><span class="sxs-lookup"><span data-stu-id="41614-239">Every Windows thread actually begins execution in a system-supplied function, not the application-supplied function.</span></span> <span data-ttu-id="41614-240">因此, 主线程的起始地址是, 对于系统中的每个 Windows 进程, 它都是相同的 (它表示系统提供的函数的地址)。</span><span class="sxs-lookup"><span data-stu-id="41614-240">The starting address for the primary thread is, therefore, the same (as it represents the address of the system-supplied function) for every Windows process in the system.</span></span> <span data-ttu-id="41614-241">但是, <xref:System.Diagnostics.ProcessThread.StartAddress%2A>属性允许您获取特定于您的应用程序的起始函数地址。</span><span class="sxs-lookup"><span data-stu-id="41614-241">However, the <xref:System.Diagnostics.ProcessThread.StartAddress%2A> property allows you to get the starting function address that is specific to your application.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-242">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-242">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.ProcessThread.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time this thread was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-243">获取操作系统启动该线程的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-243">Gets the time that the operating system started the thread.</span></span></summary>
        <value><span data-ttu-id="41614-244"><see cref="T:System.DateTime" />，它表示操作系统启动该线程时系统上的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-244">A <see cref="T:System.DateTime" /> representing the time that was on the system when the operating system started the thread.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-245">未能检索到线程时间。</span><span class="sxs-lookup"><span data-stu-id="41614-245">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-246">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-246">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadState ThreadState { System::Diagnostics::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Diagnostics.ThreadState" Usage="System.Diagnostics.ProcessThread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The current state of this thread.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadThreadState")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-247">获取此线程的当前状态。</span><span class="sxs-lookup"><span data-stu-id="41614-247">Gets the current state of this thread.</span></span></summary>
        <value><span data-ttu-id="41614-248">指示线程执行情况的 <see cref="T:System.Diagnostics.ThreadState" />（例如运行、等待或终止）。</span><span class="sxs-lookup"><span data-stu-id="41614-248">A <see cref="T:System.Diagnostics.ThreadState" /> that indicates the thread's execution, for example, running, waiting, or terminated.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-249">仅<xref:System.Diagnostics.ProcessThread.WaitReason%2A> 当<xref:System.Diagnostics.ProcessThread.ThreadState%2A>值为<xref:System.Diagnostics.ThreadState.Wait>时, 属性值才有效。</span><span class="sxs-lookup"><span data-stu-id="41614-249">The <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property value is valid only when the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> value is <xref:System.Diagnostics.ThreadState.Wait>.</span></span> <span data-ttu-id="41614-250">因此, 请在<xref:System.Diagnostics.ProcessThread.ThreadState%2A> <xref:System.Diagnostics.ProcessThread.WaitReason%2A>获取属性之前检查值。</span><span class="sxs-lookup"><span data-stu-id="41614-250">Therefore, check the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> value before you get the <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-251">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-251">The process is on a remote computer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The total amount of CPU time used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-252">获取此线程使用处理器的时间总量。</span><span class="sxs-lookup"><span data-stu-id="41614-252">Gets the total amount of time that this thread has spent using the processor.</span></span></summary>
        <value><span data-ttu-id="41614-253"><see cref="T:System.TimeSpan" />，它指示线程控制处理器的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-253">A <see cref="T:System.TimeSpan" /> that indicates the amount of time that the thread has had control of the processor.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-254"><xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A>属性指示系统已将线程从等待状态中取出并在任何处理器上给予其优先级的总时间。</span><span class="sxs-lookup"><span data-stu-id="41614-254">The <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> property indicates the total amount of time that the system has taken the thread out of the wait state and given it priority on any processor.</span></span> <span data-ttu-id="41614-255">在多处理器系统上, 如果线程使用多个处理器, 则此值将包含在每个处理器上所花费的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-255">On a multiple processor system, this value would include time spent on each processor, if the thread used more than one processor.</span></span>  
  
 <span data-ttu-id="41614-256">属性是<xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> 和<xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>属性的和。 <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A></span><span class="sxs-lookup"><span data-stu-id="41614-256">The <xref:System.Diagnostics.ProcessThread.TotalProcessorTime%2A> property is the sum of the <xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> and <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> properties.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-257">未能检索到线程时间。</span><span class="sxs-lookup"><span data-stu-id="41614-257">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-258">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-258">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.ProcessThread.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time used in user mode.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-259">获取关联的线程在应用程序内运行代码所用的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-259">Gets the amount of time that the associated thread has spent running code inside the application.</span></span></summary>
        <value><span data-ttu-id="41614-260"><see cref="T:System.TimeSpan" />，它指示线程在应用程序内（相对于在操作系统内核中）运行代码所用的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-260">A <see cref="T:System.TimeSpan" /> indicating the amount of time that the thread has spent running code inside the application, as opposed to inside the operating system core.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-261">Windows NT 使用几种不同的保护机制, 其根本都是用户模式与特权模式之间的区别。</span><span class="sxs-lookup"><span data-stu-id="41614-261">Windows NT uses several different protection mechanisms, and at the root of them all is the distinction between user mode and privileged mode.</span></span> <span data-ttu-id="41614-262"><xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A>对应于应用程序在操作系统内核之外的用户模式下运行的时间。</span><span class="sxs-lookup"><span data-stu-id="41614-262"><xref:System.Diagnostics.ProcessThread.UserProcessorTime%2A> corresponds to the amount of time that the application has spent running in user mode, outside the operating system core.</span></span> <span data-ttu-id="41614-263"><xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A>对应于应用程序在特权模式下运行代码所用的时间, 以系统核心为限。</span><span class="sxs-lookup"><span data-stu-id="41614-263">The <xref:System.Diagnostics.ProcessThread.PrivilegedProcessorTime%2A> corresponds to the amount of time that the application has spent running code in privileged mode, inside the system core.</span></span>  
  
 <span data-ttu-id="41614-264">用户模式通过两个重要方式限制了应用程序。</span><span class="sxs-lookup"><span data-stu-id="41614-264">User mode restricts the application in two important ways.</span></span> <span data-ttu-id="41614-265">首先, 应用程序不能直接访问外围设备, 而是必须调用操作系统内核才能获取或设置外围数据。</span><span class="sxs-lookup"><span data-stu-id="41614-265">First, the application cannot directly access the peripherals, but instead must call the operating system core to get or set peripheral data.</span></span> <span data-ttu-id="41614-266">因此, 操作系统可以确保一个应用程序不会销毁另一个应用程序所需的外部数据。</span><span class="sxs-lookup"><span data-stu-id="41614-266">The operating system can thus ensure that one application does not destroy peripheral data that is needed by another.</span></span> <span data-ttu-id="41614-267">其次, 应用程序无法读取或更改操作系统本身维护的数据。</span><span class="sxs-lookup"><span data-stu-id="41614-267">Second, the application cannot read or change data that the operating system itself maintains.</span></span> <span data-ttu-id="41614-268">此限制可防止无意或有意损坏内核的应用程序。</span><span class="sxs-lookup"><span data-stu-id="41614-268">This restriction prevents applications from either inadvertently or intentionally corrupting the core.</span></span> <span data-ttu-id="41614-269">如果应用程序需要操作系统执行操作, 它将调用系统的一个例程。</span><span class="sxs-lookup"><span data-stu-id="41614-269">If the application needs the operating system to perform an operation, it calls one of the system's routines.</span></span> <span data-ttu-id="41614-270">其中许多转换为特权模式, 执行操作, 并平稳地返回到用户模式。</span><span class="sxs-lookup"><span data-stu-id="41614-270">Many of these transition into privileged mode, perform the operation, and smoothly return to user mode.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception"><span data-ttu-id="41614-271">未能检索到线程时间。</span><span class="sxs-lookup"><span data-stu-id="41614-271">The thread time could not be retrieved.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-272">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-272">The process is on a remote computer.</span></span></exception>
        <altmember cref="P:System.Diagnostics.ProcessThread.PrivilegedProcessorTime" />
        <altmember cref="P:System.Diagnostics.ProcessThread.TotalProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="WaitReason">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ThreadWaitReason WaitReason { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ThreadWaitReason WaitReason" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.ProcessThread.WaitReason" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WaitReason As ThreadWaitReason" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ThreadWaitReason WaitReason { System::Diagnostics::ThreadWaitReason get(); };" />
      <MemberSignature Language="F#" Value="member this.WaitReason : System.Diagnostics.ThreadWaitReason" Usage="System.Diagnostics.ProcessThread.WaitReason" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The reason why this thread is waiting.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ThreadWaitReason")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ThreadWaitReason</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="41614-273">获取线程等待的原因。</span><span class="sxs-lookup"><span data-stu-id="41614-273">Gets the reason that the thread is waiting.</span></span></summary>
        <value><span data-ttu-id="41614-274">一个 <see cref="T:System.Diagnostics.ThreadWaitReason" />，表示线程处于等待状态的原因。</span><span class="sxs-lookup"><span data-stu-id="41614-274">A <see cref="T:System.Diagnostics.ThreadWaitReason" /> representing the reason that the thread is in the wait state.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="41614-275">仅<xref:System.Diagnostics.ProcessThread.WaitReason%2A> 当为<xref:System.Diagnostics.ThreadState.Wait>时, 属性才有效。 <xref:System.Diagnostics.ProcessThread.ThreadState%2A></span><span class="sxs-lookup"><span data-stu-id="41614-275">The <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property is valid only when the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> is <xref:System.Diagnostics.ThreadState.Wait>.</span></span> <span data-ttu-id="41614-276">因此, 请在<xref:System.Diagnostics.ProcessThread.ThreadState%2A> <xref:System.Diagnostics.ProcessThread.WaitReason%2A>获取属性之前检查值。</span><span class="sxs-lookup"><span data-stu-id="41614-276">Therefore, check the <xref:System.Diagnostics.ProcessThread.ThreadState%2A> value before you get the <xref:System.Diagnostics.ProcessThread.WaitReason%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="41614-277">线程不在等待状态。</span><span class="sxs-lookup"><span data-stu-id="41614-277">The thread is not in the wait state.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="41614-278">进程在远程计算机上。</span><span class="sxs-lookup"><span data-stu-id="41614-278">The process is on a remote computer.</span></span></exception>
        <altmember cref="T:System.Diagnostics.ThreadWaitReason" />
        <altmember cref="P:System.Diagnostics.ProcessThread.ThreadState" />
      </Docs>
    </Member>
  </Members>
</Type>
