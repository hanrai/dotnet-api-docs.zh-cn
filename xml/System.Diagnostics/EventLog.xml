<Type Name="EventLog" FullName="System.Diagnostics.EventLog">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0ff824b2a8e88519f623df8888db8a53b11a77e2" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69076435" /></Metadata><TypeSignature Language="C#" Value="public class EventLog : System.ComponentModel.Component, System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLog extends System.ComponentModel.Component implements class System.ComponentModel.ISupportInitialize" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.EventLog" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLog&#xA;Inherits Component&#xA;Implements ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLog : System::ComponentModel::Component, System::ComponentModel::ISupportInitialize" />
  <TypeSignature Language="F#" Value="type EventLog = class&#xA;    inherit Component&#xA;    interface ISupportInitialize" />
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
      <AttributeName>System.ComponentModel.DefaultEvent("EntryWritten")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Diagnostics.EventLogInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Represents an event log")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.EventLogInstallableComponentDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("EventLogDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType("System.Diagnostics.EventLogInstaller, System.Configuration.Install, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>提供与 Windows 事件日志的交互。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog>允许你访问或自定义 Windows 事件日志, 这些日志记录有关重要软件或硬件事件的信息。 使用<xref:System.Diagnostics.EventLog>, 你可以从现有日志读取、将条目写入日志、创建或删除事件源、删除日志以及响应日志条目。 你还可以在创建事件源时创建新日志。  
  
> [!IMPORTANT]
>  此类型实现 <xref:System.IDisposable> 接口。 在使用完类型后，您应直接或间接释放类型。 若要直接释放类型，请在 `try`/`catch` 块中调用其 <xref:System.IDisposable.Dispose%2A> 方法。 若要间接释放类型，请使用 `using`（在 C# 中）或 `Using`（在 Visual Basic 中）等语言构造。 有关详细信息，请参阅 <xref:System.IDisposable> 接口主题中的“使用实现 IDisposable 的对象”一节。  
  
 除了提供对单个事件日志及其项的访问权限外, <xref:System.Diagnostics.EventLog>类还允许您访问所有事件日志的集合。 您可以使用`static`的<xref:System.Diagnostics.EventLog>成员删除日志、获取日志列表、创建或删除源, 或确定计算机是否已包含特定的源。  
  
 有三个默认的事件日志:应用程序、系统和安全性。 安全日志为只读。 安装的其他应用程序和服务 (如 Active Directory) 可能具有其他事件日志。  
  
 使用<xref:System.Diagnostics.EventLog>类时, 有一些安全注意事项。 <xref:System.Diagnostics.EventLog>需要<xref:System.Diagnostics.EventLogPermission> .NET Framework 2.0 及更高版本中特定操作的权限, 或者 .NET Framework 1.0 和1.1 中的完全信任。 建议不要将<xref:System.Diagnostics.EventLogPermission>部分受信任的代码授予。  永远不要将任何事件日志对象 (包括<xref:System.Diagnostics.EventLogEntryCollection>和<xref:System.Diagnostics.EventLogEntry>对象) 传递给不太受信任的代码。 例如, 创建一个<xref:System.Diagnostics.EventLog>对象, 编写一个项, 然后将该<xref:System.Diagnostics.EventLog>对象传递给部分受信任的代码可能会导致安全问题, 因为读取和写入事件日志的功能允许代码执行发出操作, 例如发出事件日志消息。  
  
 从 Windows Vista 开始, 用户帐户控制 (UAC) 决定用户的凭据。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要运行访问安全日志的代码, 必须首先将你的凭据从标准用户提升为管理员。 你可以在启动应用程序时执行此操作 (如果你使用的是鼠标, 右键单击应用程序图标), 并指示你希望以管理员身份运行。  
  
 您可以使用<xref:System.Diagnostics.EventLog>创建可通过服务器的事件查看器查看的自定义事件日志。 <xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>使用方法在事件查看器中显示事件日志的本地化名称。 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>使用方法可在事件日志达到其最大日志大小时配置其行为。  
  
 若要从事件日志中读取, 请指定日志名称<xref:System.Diagnostics.EventLog.Log%2A> (属性) 和服务器计算机名称<xref:System.Diagnostics.EventLog.MachineName%2A> (事件日志的属性)。 如果未指定服务器计算机名称, 则假定为本地计算机 "."。 不需要指定事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性), 因为只需要将源写入日志。 将自动用事件日志的条目列表填充属性。<xref:System.Diagnostics.EventLog.Entries%2A>  
  
 若要写入事件日志, 请指定或创建事件源 (<xref:System.Diagnostics.EventLog.Source%2A>属性)。 您必须具有计算机上的管理凭据才能创建新的事件源。 事件源会将事件日志中的应用程序注册为条目的有效源。 您可以使用事件源一次只写入一个日志。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任何随机字符串, 但该名称必须与计算机上的其他源不同。 事件源通常是应用程序的名称或其他标识字符串。 尝试创建重复<xref:System.Diagnostics.EventLog.Source%2A>值会引发异常。 不过, 单个事件日志可以与多个源关联。  
  
 如果与<xref:System.Diagnostics.EventLog>实例关联的事件日志的事件源不存在, 则创建一个新的事件源。 若要在 Windows Vista 和更高版本或 Windows Server 2003 中创建事件源, 您必须具有管理凭据。  
  
 此要求是因为必须搜索所有事件日志 (包括安全日志), 才能确定事件源是否唯一。 从 Windows Vista 开始, 用户没有访问安全日志的权限;因此, <xref:System.Security.SecurityException>将引发。  
  
> [!IMPORTANT]
>  创建或删除事件源需要使用已命名的 mutex 同步基础代码。 如果高度特权的应用程序锁定了已命名的互斥体, 则尝试创建或删除事件源会导致应用程序停止响应, 直到锁被释放。 若要帮助避免此问题, 请<xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>不要向不受信任的代码授予权限。 此外, <xref:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode>权限可能会允许绕过其他权限, 只应授予高度受信任的代码。  
  
 应用程序和服务应写入到应用程序日志或自定义日志。 设备驱动程序应该写入系统日志。 如果未显式设置<xref:System.Diagnostics.EventLog.Log%2A>属性, 则事件日志会默认为应用程序日志。  
  
> [!NOTE]
>  没有任何内容可以保护应用程序不会写入任何已注册的源。  如果向应用程序授予<xref:System.Diagnostics.EventLogPermissionAccess.Write>了权限, 则它可以为在计算机上注册的任何有效源写入事件。  
  
 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用和<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法可将事件写入事件日志。 您必须指定事件源以写入事件;在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以通过使用<xref:System.Diagnostics.EventLogInstaller>对象<xref:System.Diagnostics.EventLog.CreateEventSource%2A>或方法来配置新源。 您必须具有计算机上的管理凭据才能创建新的事件源。  
  
 每个源一次只能写入一个事件日志;但是, 应用程序可以使用多个源来写入多个事件日志。 例如, 你的应用程序可能需要为不同的事件日志或不同的资源文件配置多个源。 若要更改现有源的配置详细信息, 必须删除该源, 并使用新配置创建它。 如果其他应用程序或组件使用现有源, 请使用更新的配置创建新的源, 而不是删除现有源。  
  
 可以向事件类别和消息字符串的本地化资源注册事件源。 应用程序可以通过使用资源标识符而不是指定实际的字符串值来编写事件日志项。 有关配置<xref:System.Diagnostics.EventSourceCreationData>源和资源文件的详细信息,请<xref:System.Diagnostics.EventLogInstaller>参阅和类。  
  
 如果你的应用程序将字符串值直接写入事件日志, 则无需设置源的资源文件属性。 源必须配置为写入本地化项或写入直接字符串。 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
 写入事件时, 必须至少为消息字符串指定消息字符串或资源标识符。 其他事件属性是可选的。 可选事件设置的示例包括以下各项:  
  
-   您可以设置<xref:System.Diagnostics.EventLogEntryType>以指定事件查看器为该项显示的图标。  
  
-   如果你的应用程序使用类别来筛选事件, 则可以为事件指定类别标识符。  
  
-   如果要将其他信息与给定事件关联, 可以将二进制数据附加到事件条目。  
  
> [!IMPORTANT]
>  事件日志记录会消耗磁盘空间、处理器时间和其他系统资源。 只记录重要信息非常重要。 建议你将事件日志调用放置在错误路径中, 而不是放在主代码路径中, 因此它们不会对性能产生负面影响。  
  
 有关实例<xref:System.Diagnostics.EventLog>的初始属性值的列表, <xref:System.Diagnostics.EventLog.%23ctor%2A>请参见构造函数。  
  
   
  
## Examples  
 下面的示例创建事件源`MySource` (如果它尚不存在), 并将项写入事件日志。 `MyNewLog`  
  
> [!NOTE]
>  从 Windows Vista 开始, 你必须以管理员身份运行此应用程序。  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Diagnostics.EventLogInstaller" />
    <altmember cref="T:System.Diagnostics.EventLogEntry" />
    <altmember cref="T:System.Diagnostics.EntryWrittenEventArgs" />
    <altmember cref="T:System.ServiceProcess.ServiceBase" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 不将该实例与任何日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 在调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>之前, <xref:System.Diagnostics.EventLog.Source%2A>指定<xref:System.Diagnostics.EventLog>实例的属性。 如果只是从日志<xref:System.Diagnostics.EventLog.Entries%2A>中读取, 则可以另外指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>, 则假定使用本地计算机 (".")。  
  
 下表显示了实例的<xref:System.Diagnostics.EventLog>初始属性值。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|本地计算机 (".")。|  
  
   
  
## Examples  
 如果源尚不存在, `MySource`则下面的示例将创建源, 并将项写入事件日志。 `MyNewLog`  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog logName" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">本地计算机上日志的名称。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将该实例与本地计算机上的日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将<xref:System.Diagnostics.EventLog.Log%2A>属性设置`logName`为参数。 在调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>之前, <xref:System.Diagnostics.EventLog.Source%2A>指定<xref:System.Diagnostics.EventLog>实例的属性。 如果只是从日志<xref:System.Diagnostics.EventLog.Entries%2A>中读取, 则可以另外指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>, 则假定使用本地计算机 (".")。 构造函数的此重载指定<xref:System.Diagnostics.EventLog.Log%2A>属性, 但你可以在<xref:System.Diagnostics.EventLog.Entries%2A>读取属性之前更改此重载。  
  
 如果您在<xref:System.Diagnostics.EventLog.Source%2A>属性中指定的源与计算机上的其他源是唯一的, 则随后<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用会创建具有指定名称的日志 (如果它尚不存在)。  
  
 下表显示了实例的<xref:System.Diagnostics.EventLog>初始属性值。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|本地计算机 (".")。|  
  
   
  
## Examples  
 下面的示例读取本地计算机上的事件日志 "myNewLog" 中的条目。  
  
 [!code-cpp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定算机上日志的名称。</param>
        <param name="machineName">日志所在的计算机。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将该实例与指定计算机上的日志关联。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载将<xref:System.Diagnostics.EventLog.Log%2A>属性设置`logName`为参数`machineName` , <xref:System.Diagnostics.EventLog.MachineName%2A>将属性设置为参数。 在调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>之前, 请<xref:System.Diagnostics.EventLog.Source%2A>指定的<xref:System.Diagnostics.EventLog>属性。 如果只是从日志<xref:System.Diagnostics.EventLog.Entries%2A>中读取, 则可以另外指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性。  
  
> [!NOTE]
>  构造函数的此重载指定<xref:System.Diagnostics.EventLog.Log%2A>和<xref:System.Diagnostics.EventLog.MachineName%2A>属性, 但你可以在读取<xref:System.Diagnostics.EventLog.Entries%2A>属性之前更改。  
  
 下表显示了实例的<xref:System.Diagnostics.EventLog>初始属性值。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|空字符串 ("")。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 参数。|  
  
   
  
## Examples  
 下面的示例读取计算机 "myServer" 上的事件日志 "myNewLog" 中的条目。  
  
 [!code-cpp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。  
  
 或  
  
 计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLog (string logName, string machineName, string source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string logName, string machineName, string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.#ctor(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (logName As String, machineName As String, source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLog(System::String ^ logName, System::String ^ machineName, System::String ^ source);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.EventLog : string * string * string -&gt; System.Diagnostics.EventLog" Usage="new System.Diagnostics.EventLog (logName, machineName, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">指定的计算机上日志的名称</param>
        <param name="machineName">日志所在的计算机。</param>
        <param name="source">事件日志项的源。</param>
        <summary>初始化 <see cref="T:System.Diagnostics.EventLog" /> 类的新实例。 将实例与指定的计算机上的日志关联，并为 <see cref="T:System.Diagnostics.EventLog" /> 实例创建或分配指定的源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此构造函数将<xref:System.Diagnostics.EventLog.Log%2A>属性设置`logName`为参数`machineName` , <xref:System.Diagnostics.EventLog.MachineName%2A>将属性设置为参数, 并<xref:System.Diagnostics.EventLog.Source%2A>将属性`source`设置为参数。 写入<xref:System.Diagnostics.EventLog.Source%2A>事件日志时, 属性是必需的。 但是, 如果只是从事件日志中读取, 则只<xref:System.Diagnostics.EventLog.Log%2A>需要和<xref:System.Diagnostics.EventLog.MachineName%2A>属性 (只要服务器上的事件日志已经有一个与其关联的源)。 如果仅从事件日志中读取, 则构造函数的另一个重载可能满足要求。  
  
 下表显示了实例的<xref:System.Diagnostics.EventLog>初始属性值。  
  
|Property|初始值|  
|--------------|-------------------|  
|<xref:System.Diagnostics.EventLog.Source%2A>|`source` 参数。|  
|<xref:System.Diagnostics.EventLog.Log%2A>|`logName` 参数。|  
|<xref:System.Diagnostics.EventLog.MachineName%2A>|`machineName` 参数。|  
  
   
  
## Examples  
 下面的示例使用源 "MySource" 将条目写入到本地计算机上的事件日志 "MyNewLog"。  
  
 [!code-cpp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EventLog3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EventLog3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EventLog3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">日志名称为 <see langword="null" />。</exception>
        <exception cref="T:System.ArgumentException">日志名称无效。  
  
 或  
  
 计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEvent" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberSignature Language="F#" Value="abstract member BeginInit : unit -&gt; unit&#xA;override this.BeginInit : unit -&gt; unit" Usage="eventLog.BeginInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.BeginInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>开始初始化用于窗体或由其他组件使用的 <see cref="T:System.Diagnostics.EventLog" />。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来启动窗体上使用的组件或其他组件的初始化。 <xref:System.Diagnostics.EventLog.EndInit%2A>方法结束初始化。 <xref:System.Diagnostics.EventLog.BeginInit%2A>使用和<xref:System.Diagnostics.EventLog.EndInit%2A>方法可防止控件在完全初始化之前被使用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Diagnostics.EventLog" /> 已初始化完毕。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.EndInit" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="eventLog.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>从事件日志中移除所有项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用最大大小设置事件日志, 以确定可以包含的条目数。 当事件日志已满时, 它会停止记录新的事件信息或开始覆盖以前的条目。 如果事件记录停止, 则可以使用此方法清除现有条目的日志, 并使其重新开始记录事件。 您必须对日志所在的计算机具有管理员权限, 才能清除事件日志条目。  
  
 <xref:System.Diagnostics.EventLog.Clear%2A>关闭事件日志, 释放事件句柄, 检索新的读取和写入句柄, 并重新打开事件日志。 对方法的调用后收到的事件与现有事件不会被清除。  
  
   
  
## Examples  
 下面的示例将清除事件日志。  
  
> [!CAUTION]
>  由于应用程序、系统、安全和其他非自定义日志可能包含重要信息,请确保在执行此示例代码之前指定自定义日志。 此示例将删除自定义`myNewLog`日志。  
  
 [!code-cpp[Classic EventLog.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 - 或 -  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <exception cref="T:System.ArgumentException">没有为 <see cref="P:System.Diagnostics.EventLog.Log" /> 属性指定值。 确保日志名称不是一个空字符串。</exception>
        <exception cref="T:System.InvalidOperationException">该日志不存在。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="eventLog.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>关闭事件日志并释放读写句柄。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 方法由受保护<xref:System.ComponentModel.Component.Dispose%2A>的方法调用。 <xref:System.Diagnostics.EventLog.Close%2A> 不需要在调用<xref:System.Diagnostics.EventLog.Close%2A> <xref:System.ComponentModel.Component.Dispose%2A>前调用。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">事件日志的读句柄或写句柄未成功释放。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>建立一个能够将事件信息写入到系统的特定日志中的应用程序。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (System.Diagnostics.EventSourceCreationData sourceData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(class System.Diagnostics.EventSourceCreationData sourceData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.Diagnostics.EventSourceCreationData)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (sourceData As EventSourceCreationData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::Diagnostics::EventSourceCreationData ^ sourceData);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : System.Diagnostics.EventSourceCreationData -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource sourceData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceData" Type="System.Diagnostics.EventSourceCreationData" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="sourceData">事件源及其目标事件日志的配置属性。</param>
        <summary>通过使用为该事件源和对应的事件日志指定的配置属性，建立一个写入本地化事件消息的有效事件源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此重载用于配置将条目写入到本地计算机或远程计算机上的事件日志的新源。 不需要使用此方法从事件日志中读取。  
  
 方法使用`sourceData`输入<xref:System.Diagnostics.EventSourceCreationData.Source%2A>和属性<xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>为新源及其关联事件日志在目标计算机上创建注册表值。 <xref:System.Diagnostics.EventSourceCreationData.LogName%2A> <xref:System.Diagnostics.EventLog.CreateEventSource%2A> 新的源名称不能与目标计算机上的现有源名称或现有事件日志名称相匹配。 如果未<xref:System.Diagnostics.EventSourceCreationData.LogName%2A>设置该属性, 则会为应用程序事件日志注册源。 <xref:System.Diagnostics.EventSourceCreationData.MachineName%2A>如果未设置, 则在本地计算机上注册源。  
  
> [!NOTE]
>  若要在 Windows Vista 和更高版本或 Windows Server 2003 中创建事件源, 您必须具有管理权限。  
>   
>  此要求的原因是必须搜索所有事件日志 (包括安全性), 以确定事件源是否唯一。 从 Windows Vista 开始, 用户没有访问安全日志的权限;因此, <xref:System.Security.SecurityException>将引发。  
>   
>  从 Windows Vista 开始, 用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问安全日志的代码, 必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A> 和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入事件日志。 您必须指定事件源以写入事件;在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 可以为现有事件日志或新的事件日志创建事件源。 为新的事件日志创建新源时, 系统将为该日志注册源, 但在向其中写入第一个条目之前, 不会创建日志。  
  
 操作系统将事件日志存储为文件。 使用<xref:System.Diagnostics.EventLogInstaller> 或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>创建新的事件日志时, 关联的文件将存储在指定计算机上的%SystemRoot%\System32\Config 目录中。 文件名的设置方法是将<xref:System.Diagnostics.EventLog.Log%2A>属性的前8个字符追加到文件扩展名 ".evt"。  
  
 每个源一次只能写入一个事件日志;但是, 应用程序可以使用多个源来写入多个事件日志。 例如, 你的应用程序可能需要为不同的事件日志或不同的资源文件配置多个源。  
  
 可以向事件类别和消息字符串的本地化资源文件注册事件源。 应用程序可以使用资源标识符而不是指定实际字符串来编写事件日志项。 事件查看器使用资源标识符从本地化的资源文件中查找并显示相应的字符串。 可以为事件类别、消息和参数插入字符串注册单独的文件, 也可以为所有这三种类型的字符串注册同一资源文件。 <xref:System.Diagnostics.EventSourceCreationData.CategoryCount%2A>使用、 <xref:System.Diagnostics.EventSourceCreationData.CategoryResourceFile%2A>、 <xref:System.Diagnostics.EventSourceCreationData.MessageResourceFile%2A>和属性将源配置为将本地化项写入事件日志。<xref:System.Diagnostics.EventSourceCreationData.ParameterResourceFile%2A> 如果你的应用程序将字符串值直接写入事件日志, 则无需设置这些属性。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
 若要更改现有源的配置详细信息, 必须删除该源, 并使用新配置创建它。 如果其他应用程序或组件使用现有源, 请使用更新的配置创建新的源, 而不是删除现有源。  
  
> [!NOTE]
>  如果为事件日志配置了源, 并为其他事件日志重新配置了源, 则必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例确定是否在本地计算机上`SampleApplicationSource`注册了名为的事件源。 如果事件源不存在, 则此示例将为源设置消息资源文件并创建新的事件源。 最后, 该示例使用中`DisplayNameMsgId`的资源标识符值和中`messageFile`的资源文件路径, 为事件日志设置本地化的显示名称。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 该示例使用资源库 EventLogMsgs 中内置的以下消息文本文件。 消息文本文件是从中创建消息资源文件的源。 消息文本文件定义类别、事件消息和参数插入字符串的资源标识符和文本。 具体而言, 为事件日志的本地化名称定义了资源标识符5001。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">在 <paramref name="sourceData" /> 中指定的计算机名称无效。  
  
或 
在 <paramref name="sourceData" /> 中指定的源名称为 <see langword="null" />。  
  
或 
在 <paramref name="sourceData" /> 中指定的日志名称无效。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
或 
在 <paramref name="sourceData" /> 中指定的日志名称对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
- 或 - 
该日志名称与一个现有事件源名称相匹配。  
  
或 
在 <paramref name="sourceData" /> 中指定的源名称导致注册表项路径的长度超过 254 个字符。  
  
或 
在 <paramref name="sourceData" /> 中指定的日志名称的前 8 个字符不唯一。  
  
或 
在 <paramref name="sourceData" /> 中指定的源名称已经注册过。  
  
- 或 - 
在 <paramref name="sourceData" /> 中指定的源名称与一个现有事件日志名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceData" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventSourceCreationData" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLogInstaller" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在本地计算机上注册时所采用的源名称。</param>
        <param name="logName">源的项写入的日志名。 可能的值包括“应用程序”、“系统”或自定义事件日志。</param>
        <summary>建立指定的源名称作为向本地计算机上的日志中写入日志项的有效事件源。 此方法还可在本地计算机上创建一个新的自定义日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建自定义日志, 或创建并注册<xref:System.Diagnostics.EventLog.Source%2A>到本地计算机上的现有日志。  
  
 如果`logName`在`null` 调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>时为或空字符串 (""), 则日志默认为应用程序日志。 如果本地计算机上不存在该日志, 系统将创建一个自定义日志, 并将应用程序<xref:System.Diagnostics.EventLog.Source%2A>注册为该日志的。  
  
> [!NOTE]
>  若要在 Windows Vista 和更高版本或 Windows Server 2003 中创建事件源, 您必须具有管理权限。  
>   
>  此要求的原因是必须搜索所有事件日志 (包括安全性), 以确定事件源是否唯一。 从 Windows Vista 开始, 用户没有访问安全日志的权限;因此, <xref:System.Security.SecurityException>将引发。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问安全日志的代码, 必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 只需在写入事件日志时创建事件源。 向事件日志写入条目之前, 必须将事件源作为事件的有效源注册到事件日志。 当你编写日志项时, 系统将使用<xref:System.Diagnostics.EventLog.Source%2A>来查找适当的日志, 以便在其中放置你的条目。 如果要读取事件日志, 可以指定<xref:System.Diagnostics.EventLog.Source%2A>、 <xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到本地计算机上的日志, 则不需要指定。 如果不指定<xref:System.Diagnostics.EventLog.MachineName%2A>从日志中读取时, 则假定为本地计算机 (".")。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A> 和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入事件日志。 您必须指定事件源以写入事件;在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 可以为现有事件日志或新的事件日志创建事件源。 为新的事件日志创建新源时, 系统将为该日志注册源, 但在向其中写入第一个条目之前, 不会创建日志。  
  
 操作系统将事件日志存储为文件。 使用<xref:System.Diagnostics.EventLogInstaller> 或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>创建新的事件日志时, 关联的文件将存储在指定计算机上的%SystemRoot%\System32\Config 目录中。 文件名的设置方法是将<xref:System.Diagnostics.EventLog.Log%2A>属性的前8个字符追加到文件扩展名 ".evt"。  
  
 源在本地计算机上必须唯一;新的源名称不能与现有的源名称或现有的事件日志名称相匹配。 每个源一次只能写入一个事件日志;但是, 应用程序可以使用多个源来写入多个事件日志。 例如, 你的应用程序可能需要为不同的事件日志或不同的资源文件配置多个源。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
 若要更改现有源的配置详细信息, 必须删除该源, 并使用新配置创建它。 如果其他应用程序或组件使用现有源, 请使用更新的配置创建新的源, 而不是删除现有源。  
  
> [!NOTE]
>  如果源已映射到日志, 并将其重新映射到新日志, 则必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 如果源尚不存在, `MySource`则下面的示例将创建源, 并将项写入事件日志。 `MyNewLog`  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 为空字符串 ("") 或 <see langword="null" />。  
  
或 
 <paramref name="logName" /> 不是有效的事件日志名称。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
或 
 <paramref name="logName" />对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
- 或 - 
该日志名称与一个现有事件源名称相匹配。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。  
  
- 或 - 
<paramref name="logName" /> 的前 8 个字符与现有事件日志名称的前 8 个字符相匹配。  
  
- 或 - 
无法注册该源，因为它已存在于本地计算机上。  
  
或 
该源名称与一个现有事件日志名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在本地计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateEventSource">
      <MemberSignature Language="C#" Value="public static void CreateEventSource (string source, string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateEventSource(string source, string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.CreateEventSource(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CreateEventSource (source As String, logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CreateEventSource(System::String ^ source, System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member CreateEventSource : string * string * string -&gt; unit" Usage="System.Diagnostics.EventLog.CreateEventSource (source, logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Obsolete("use CreateEventSource(EventSourceCreationData) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated.  Please use System.Diagnostics.EventLog.CreateEventSource(EventSourceCreationData sourceData) instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="logName">源的项写入的日志名。 可能的值包括“应用程序”、“系统”或自定义事件日志。 如果不指定值，则 <paramref name="logName" /> 默认为应用程序。</param>
        <param name="machineName">用来注册此事件源的计算机名称，对于本地计算机则为“.”。</param>
        <summary>建立指定的源名称作为向指定计算机上的日志中写入项的有效事件源。 此方法还可用于在指定计算机上创建一个新的自定义日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载创建自定义日志, 或创建并注册<xref:System.Diagnostics.EventLog.Source%2A>到指定计算机上的现有日志。  
  
 如果`logName`在`null` 调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>时为或空字符串 (""), 则日志默认为应用程序日志。 如果指定的计算机上不存在该日志, 系统将创建一个自定义日志, 并将应用程序<xref:System.Diagnostics.EventLog.Source%2A>注册为该日志的。  
  
 只需在写入事件日志时创建事件源。 向事件日志写入条目之前, 必须将事件源作为事件的有效源注册到事件日志。 当你编写日志项时, 系统将使用<xref:System.Diagnostics.EventLog.Source%2A>来查找适当的日志, 以便在其中放置你的条目。 如果要读取事件日志, 可以指定<xref:System.Diagnostics.EventLog.Source%2A>、 <xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  若要在 Windows Vista 和更高版本或 Windows Server 2003 中创建事件源, 您必须具有管理权限。  
>   
>  此要求的原因是必须搜索所有事件日志 (包括安全性), 以确定事件源是否唯一。 在 Windows Vista 和更高版本中, 用户没有访问安全日志的权限;因此, <xref:System.Security.SecurityException>将引发。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问安全日志的代码, 必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A> 和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入事件日志。 您必须指定事件源以写入事件;在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 可以为现有事件日志或新的事件日志创建事件源。 为新的事件日志创建新源时, 系统将为该日志注册源, 但在向其中写入第一个条目之前, 不会创建日志。  
  
 操作系统将事件日志存储为文件。 使用<xref:System.Diagnostics.EventLogInstaller> 或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>创建新的事件日志时, 关联的文件将存储在指定计算机上的%SystemRoot%\System32\Config 目录中。 文件名的设置方法是将<xref:System.Diagnostics.EventLog.Log%2A>属性的前8个字符追加到文件扩展名 ".evt"。  
  
 源在本地计算机上必须唯一;新的源名称不能与现有的源名称或现有的事件日志名称相匹配。 每个源一次只能写入一个事件日志;但是, 应用程序可以使用多个源来写入多个事件日志。 例如, 你的应用程序可能需要为不同的事件日志或不同的资源文件配置多个源。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
 若要更改现有源的配置详细信息, 必须删除该源, 并使用新配置创建它。 如果其他应用程序或组件使用现有源, 请使用更新的配置创建新的源, 而不是删除现有源。  
  
> [!NOTE]
>  如果源已映射到日志, 并将其重新映射到新日志, 则必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 下面的示例在计算机`MySource` `MyServer`上创建源, 并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 不是有效的计算机名称。  
  
- 或 - 
 <paramref name="source" /> 为空字符串 ("") 或 <see langword="null" />。  
  
- 或 - 
 <paramref name="logName" /> 不是有效的事件日志名称。 事件日志名称必须由可打印字符组成，且不得包含字符“*”、“?”或“\\”。  
  
或 
 <paramref name="logName" />对用户日志创建无效。 事件日志名称 AppEvent、SysEvent 和 SecEvent 是保留为系统使用的。  
  
或 
该日志名称与一个现有事件源名称相匹配。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。  
  
或 
<paramref name="logName" /> 的前 8 个字符与指定计算机上现有事件日志名称的前 8 个字符相匹配。  
  
或 
源无法注册，因为它已存在于指定的计算机上。  
  
或 
该源名称与一个现有事件源名称相匹配。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在指定的计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Delete">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>移除日志资源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Delete : string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要删除的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”和计算机上的任何自定义事件日志。</param>
        <summary>从本地计算机上移除事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要删除的日志在本地计算机上, 请使用此方法。 您可以删除计算机上的任何日志, 前提是您具有适当的注册表权限。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>`logName`从本地计算机中删除指定的日志。 如果只想删除注册到日志的源, 请调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果只想删除日志条目, 请调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 是`static`方法, 因此它们可以在类本身上调用。 不需要创建的新实例<xref:System.Diagnostics.EventLog>来调用这两种方法。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>方法首先删除保存日志内容的文件。 然后, 它将访问注册表, 并删除为该日志注册的所有事件源。 如果稍后再创建日志, 则应再次注册事件源 (如果要重复使用)。 如果未在指定日志名称的情况下将事件源和其他用户写入事件源, 则将在应用程序事件日志中创建事件源。 因此, 以前能够向已删除并重新创建的日志写入条目的应用程序将改为写入应用程序日志, 因为它现在包含事件源。  
  
> [!NOTE]
>  重新创建事件日志可能会很困难。 避免删除任何系统创建的事件日志, 例如应用程序日志。  
  
 通过对的调用<xref:System.Diagnostics.EventLog.Delete%2A>删除日志会自动删除注册到该日志的源。 这会使其他使用该日志的应用程序不起作用。  
  
   
  
## Examples  
 以下示例从本地计算机中删除日志。 该示例从其源确定日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 删除自定义日志之前, 请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> 为空字符串 ("") 或 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在本地计算机上打开。  
  
- 或 -
  
 本地计算机上不存在该日志。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 或  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Delete(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Delete (logName As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Delete(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Delete : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.Delete (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要删除的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”和指定计算机上的任何自定义事件日志。</param>
        <param name="machineName">要从中删除日志的计算机名称，对于本地计算机则为“.”。</param>
        <summary>从指定计算机上移除事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果要删除的日志位于远程计算机上, 请使用此方法。 您可以删除计算机上的任何日志, 前提是您具有适当的注册表权限。  
  
 <xref:System.Diagnostics.EventLog.Delete%2A>`logName` 从`machineName`指定的计算机中删除由指定的日志。 如果只想删除注册到日志的源, 请调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 如果只想删除日志条目, 请调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 是`static`方法, 因此它们可以在类本身上调用。 不需要创建的<xref:System.Diagnostics.EventLog>实例来调用这两种方法。  
  
 此方法首先删除保存日志内容的文件。 然后, 它将访问注册表, 并删除为该日志注册的所有事件源。 如果稍后再创建日志, 则应再次注册事件源 (如果要重复使用)。 如果未在指定日志名称的情况下将事件源和其他用户写入事件源, 则将在应用程序事件日志中创建事件源。 因此, 以前能够向已删除并重新创建的日志写入条目的应用程序将改为写入应用程序日志, 因为它现在包含事件源。  
  
> [!NOTE]
>  重新创建事件日志可能会很困难。 避免删除任何系统创建的事件日志, 例如应用程序日志。  
  
 通过对的调用<xref:System.Diagnostics.EventLog.Delete%2A>删除日志会自动删除注册到该日志的源。 这会使其他使用该日志的应用程序不起作用。  
  
   
  
## Examples  
 以下示例从指定的计算机中删除日志。 该示例从其源确定日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 删除自定义日志之前, 请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="logName" /> 为空字符串 ("") 或 <see langword="null" />。  
  
- 或 - 
 <paramref name="machineName" /> 不是有效的计算机名称。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能在指定的计算机上打开。  
  
或
  
 指定的计算机上不存在该日志。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">未成功清除事件日志。  
  
 - 或 -  
  
 无法打开日志。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
        <altmember cref="M:System.Diagnostics.EventLog.Close" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="DeleteEventSource">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>从事件日志中移除应用程序的事件源注册。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在事件日志系统中用来注册的名称。</param>
        <summary>从本地计算机的事件日志中移除事件源注册。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可<xref:System.Diagnostics.EventLog.Source%2A>从本地计算机删除注册。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>访问本地计算机上的注册表, 并将应用程序注册为事件的有效源。  
  
 如果你不再需要将组件写入到该日志中, 则可以将其作为事件的有效源删除。 例如, 如果需要将组件从一个日志更改为另一日志, 则可以执行此操作。 由于一次只能将一个源注册到一个日志, 因此更改日志时需要删除当前注册。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>仅删除注册到日志的源。 如果要删除日志本身, 请调用<xref:System.Diagnostics.EventLog.Delete%2A>。 如果只想删除日志条目, 请调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 是`static`方法, 因此它们可以在类本身上调用。 不需要创建的<xref:System.Diagnostics.EventLog>实例来调用这两种方法。  
  
 通过对的调用<xref:System.Diagnostics.EventLog.Delete%2A>删除日志会自动删除注册到该日志的源。 这会使其他使用该日志的应用程序不起作用。  
  
> [!NOTE]
>  如果源已映射到日志, 并将其重新映射到新日志, 则必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 以下示例从本地计算机中删除源。 该示例从其源确定日志, 然后删除日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 删除自定义日志之前, 请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">本地计算机的注册表中不存在 <paramref name="source" /> 参数。  
  
或 
您对事件日志的注册表项没有写访问权。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="DeleteEventSource">
      <MemberSignature Language="C#" Value="public static void DeleteEventSource (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteEventSource(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.DeleteEventSource(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DeleteEventSource (source As String, machineName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DeleteEventSource(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member DeleteEventSource : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.DeleteEventSource (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在事件日志系统中用来注册的名称。</param>
        <param name="machineName">要从中移除注册的计算机名，对于本地计算机则为“.”。</param>
        <summary>从指定的计算机上移除应用程序的事件源注册。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载<xref:System.Diagnostics.EventLog.Source%2A>从远程计算机中删除的注册。 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>访问由`machineName`指定的计算机上的注册表, 并将应用程序注册为事件的有效源。  
  
 如果你不再需要将组件写入到该日志中, 则可以将其作为事件的有效源删除。 例如, 如果需要将组件从一个日志更改为另一日志, 则可以执行此操作。 由于一次只能将一个源注册到一个日志, 因此更改日志时需要删除当前注册。  
  
 <xref:System.Diagnostics.EventLog.DeleteEventSource%2A>仅删除注册到日志的源。 如果要删除日志本身, 请调用<xref:System.Diagnostics.EventLog.Delete%2A>。 如果只想删除日志条目, 请调用<xref:System.Diagnostics.EventLog.Clear%2A>。 <xref:System.Diagnostics.EventLog.Delete%2A>和<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> 是`static`方法, 因此它们可以在类本身上调用。 不需要创建的<xref:System.Diagnostics.EventLog>实例来调用这两种方法。  
  
 通过对的调用<xref:System.Diagnostics.EventLog.Delete%2A>删除日志会自动删除注册到该日志的源。 这会使其他使用该日志的应用程序不起作用。  
  
> [!NOTE]
>  如果源已映射到日志, 并将其重新映射到新日志, 则必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 以下示例从指定的计算机中删除源。 该示例从其源确定日志, 然后删除日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 删除自定义日志之前, 请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.Delete1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Delete1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Delete1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Delete1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数无效。  
  
或 
指定计算机的注册表中不存在 <paramref name="source" /> 参数。  
  
- 或 - 
您对事件日志的注册表项没有写访问权。</exception>
        <exception cref="T:System.InvalidOperationException">无法删除 <paramref name="source" />，原因是在注册表中，<paramref name="source" /> 的父注册表项不包含与其同名的子项。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Clear" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="eventLog.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> 表示释放托管资源和非托管资源；<see langword="false" /> 表示仅释放非托管资源。</param>
        <summary>释放由 <see cref="T:System.Diagnostics.EventLog" /> 占用的非托管资源，还可以另外再释放托管资源。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 此方法由公共`Dispose()`方法<xref:System.Object.Finalize%2A>和方法调用。 `Dispose()`调用受保护`Dispose(Boolean)`的方法, `disposing`并将参数`true`设置为。 <xref:System.Object.Finalize%2A>在`Dispose` 设置`disposing` 为`false`的情况调用。  
  
 当参数为 true 时, 此方法释放该<xref:System.Diagnostics.EventLog>引用的任何托管对象所持有的所有资源。 `disposing` 此方法调用每个引用对象的 `Dispose()` 方法。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> 可以由其他对象多次调用。 当重<see langword="Dispose(Boolean)" />写时, 请注意不要引用先前在<see langword="Dispose" />调用时已释放的对象。 有关如何实现<see langword="Dispose(Boolean)" />的详细信息, 请参阅[实现 Dispose 方法](~/docs/standard/garbage-collection/implementing-dispose.md)。  
  
有关<see langword="Dispose" /> 和<see cref="M:System.Object.Finalize" />的详细信息, 请参阅[清理非托管资源](~/docs/standard/garbage-collection/unmanaged.md)。</para></block>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.EventLog.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If enabled raises event when a log is written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMonitoring")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置一个值，用以指示 <see cref="T:System.Diagnostics.EventLog" /> 是否接收 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件通知。</summary>
        <value>如果 <see cref="T:System.Diagnostics.EventLog" /> 在有项写入日志时接收通知，则为 <see langword="true" />；否则为 <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 属性确定在<xref:System.Diagnostics.EventLog>将项写入日志时是否引发事件。 <xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 当属性为`true`时, <xref:System.Diagnostics.EventLog.EntryWritten>接收事件的组件会在向<xref:System.Diagnostics.EventLog.Log%2A>属性中指定的日志中写入日志时接收通知。 如果<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A> 为`false`, 则不引发任何事件。  
  
> [!NOTE]
>  仅当在本地计算机上写入条目时, 才能接收事件通知。 您无法接收到在远程计算机上写入的条目的通知。  
  
   
  
## Examples  
 下面的示例处理一个<xref:System.Diagnostics.EventLog.EntryWritten>事件。  
  
 [!code-cpp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EnableRaisingEvents Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EnableRaisingEvents Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">事件日志位于远程计算机上。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberSignature Language="F#" Value="abstract member EndInit : unit -&gt; unit&#xA;override this.EndInit : unit -&gt; unit" Usage="eventLog.EndInit " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISupportInitialize.EndInit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>结束用于窗体或由其他组件使用的 <see cref="T:System.Diagnostics.EventLog" /> 的初始化。 此初始化在运行时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]设计环境使用此方法来结束对窗体或由其他组件使用的组件的初始化。 <xref:System.Diagnostics.EventLog.BeginInit%2A>方法启动初始化。 <xref:System.Diagnostics.EventLog.BeginInit%2A>使用和<xref:System.Diagnostics.EventLog.EndInit%2A>方法可防止控件在完全初始化之前被使用。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.BeginInit" />
      </Docs>
    </Member>
    <Member MemberName="Entries">
      <MemberSignature Language="C#" Value="public System.Diagnostics.EventLogEntryCollection Entries { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLogEntryCollection Entries" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Entries" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Entries As EventLogEntryCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::EventLogEntryCollection ^ Entries { System::Diagnostics::EventLogEntryCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Entries : System.Diagnostics.EventLogEntryCollection" Usage="System.Diagnostics.EventLog.Entries" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The entries in the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLogEntryCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取事件日志的内容。</summary>
        <value><see cref="T:System.Diagnostics.EventLogEntryCollection" />，保留事件日志中的项。 每个项均与 <see cref="T:System.Diagnostics.EventLogEntry" /> 类的一个实例关联。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 从事件日志中读取时使用成员。<xref:System.Diagnostics.EventLog.Entries%2A>  
  
 由于属性是只读的, 因此不能使用<xref:System.Diagnostics.EventLog.Entries%2A>修改项或写入日志。 改为指定<xref:System.Diagnostics.EventLog.Source%2A>并调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>以写入新的日志条目。 您可以使用<xref:System.Diagnostics.EventLog.Entries%2A>来计算事件日志中的条目数, 并查看集合中的<xref:System.Diagnostics.EventLogEntry>每个条目。 使用<xref:System.Diagnostics.EventLogEntryCollection.Item%2A>索引成员检索有关特定条目的信息, <xref:System.Diagnostics.EventLogEntry.Message%2A>例如、 <xref:System.Diagnostics.EventLogEntry.Category%2A> <xref:System.Diagnostics.EventLogEntry.TimeWritten%2A>、或<xref:System.Diagnostics.EventLogEntry.EntryType%2A>。  
  
 仅从日志中读取<xref:System.Diagnostics.EventLog.Source%2A>时, 无需指定。 只能为<xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog>实例指定名称和<xref:System.Diagnostics.EventLog.MachineName%2A> (服务器计算机名称) 属性。 在任一情况下, <xref:System.Diagnostics.EventLog.Entries%2A>都将自动填充该成员, 其中包含事件日志的条目列表。 您可以为此列表中的项选择适当的索引以读取各个项。  
  
 读取和写入日志项之间的重要区别在于, 无需显式调用读取方法。 <xref:System.Diagnostics.EventLog.Log%2A>指定和<xref:System.Diagnostics.EventLog.MachineName%2A>后, 将<xref:System.Diagnostics.EventLog.Entries%2A>自动填充属性。 如果更改<xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>属性的值, 则下次读取该<xref:System.Diagnostics.EventLog.Entries%2A>属性时, 将重新填充该属性。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志, 则不需要指定。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>, 则假定为本地计算机 "."。  
  
   
  
## Examples  
 下面的示例读取本地计算机上的事件日志 "MyNewLog" 中的条目。  
  
 [!code-cpp[Classic EventLog.Entries Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Entries Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Entries Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Entries Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
        <altmember cref="T:System.Diagnostics.EventLogEntry" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.WriteEntry" />
      </Docs>
    </Member>
    <Member MemberName="EntryWritten">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.EntryWrittenEventHandler EntryWritten;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.EntryWrittenEventHandler EntryWritten" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.EventLog.EntryWritten" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EntryWritten As EntryWrittenEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::EntryWrittenEventHandler ^ EntryWritten;" />
      <MemberSignature Language="F#" Value="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " Usage="member this.EntryWritten : System.Diagnostics.EntryWrittenEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Raised for each EventLog entry written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogEntryWritten")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EntryWrittenEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>向本地计算机上的事件日志写入项时发生。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 若要获取事件通知, 则必须<xref:System.Diagnostics.EventLog.EnableRaisingEvents%2A>将`true`设置为。 仅当在本地计算机上写入条目时, 才能接收事件通知。 您无法接收到在远程计算机上写入的条目的通知。  
  
 创建 <xref:System.Diagnostics.EventLog.EntryWritten> 委托时，需要标识将要处理该事件的方法。 若要将事件与事件处理程序关联，请将该委托的一个实例添加到事件中。 事件发生时, 将调用事件处理程序, 直到删除委托。 有关用委托处理事件的详细信息, 请参阅[处理和引发事件](~/docs/standard/events/index.md)。  
  
 <xref:System.Diagnostics.EventLog.WriteEntry%2A>仅当上一次写入事件至少发生六秒钟时, 系统才会响应。 这意味着, 即使发生了多<xref:System.Diagnostics.EventLog.EntryWritten>个事件日志更改, 也只会在六秒钟的时间间隔内接收一个事件通知。 如果在对的调用<xref:System.Diagnostics.EventLog.WriteEntry%2A>之间插入足够长的睡眠间隔 (大约10秒), 则不太可能会错过某个事件。 但是, 如果写入事件的发生频率更高, 则在下一个间隔之前, 可能不会收到事件通知。 通常, 丢失的事件通知不会丢失, 但会延迟。  
  
   
  
## Examples  
 下面的示例处理进入写入的事件。  
  
 [!code-cpp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.EntryWritten Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.EntryWritten Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.EntryWritten Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.EnableRaisingEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Exists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>确定指定的日志是否存在。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName);" />
      <MemberSignature Language="F#" Value="static member Exists : string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists logName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜索的日志的名称。 可能的值包括：“应用程序”、“安全性”、“系统”、其他应用程序特定的日志（如与 Active Directory 关联的日志）或计算机上的任何自定义日志。</param>
        <summary>确定该日志是否存在于本地计算机上。</summary>
        <returns>如果该日志存在于本地计算机上，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来确定本地计算机上是否存在日志。 如果要确定本地计算机上是否存在源, 请使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 由于此方法访问注册表, 因此你必须在本地计算机上具有相应的注册表权限;否则, 查询将返回`false`。  
  
 由于不能在同一台计算机上为新日志指定现有日志的名称, 因此请在创建新日志之前使用此方法来确定本地计算机`logName`上是否已存在指定的日志。 `logName`参数不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>是一个`static`方法, 因此它可以在类本身上调用。 不需要创建的<xref:System.Diagnostics.EventLog>实例来调用。 <xref:System.Diagnostics.EventLog.Exists%2A>  
  
   
  
## Examples  
 [!code-cpp[EventLog_Exists_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_Exists_1/CPP/eventlog_exists_1.cpp#1)]
 [!code-csharp[EventLog_Exists_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_Exists_1/CS/eventlog_exists_1.cs#1)]
 [!code-vb[EventLog_Exists_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_Exists_1/VB/eventlog_exists_1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">logName 为 <see langword="null" /> 或该值为空。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string logName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string logName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.Exists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists (logName As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Exists(System::String ^ logName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member Exists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.Exists (logName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="logName">要搜索的日志。 可能的值包括：“应用程序”、“安全性”、“系统”、其他应用程序特定的日志（如与 Active Directory 关联的日志）或计算机上的任何自定义日志。</param>
        <param name="machineName">要在其上搜索日志的计算机的名称，对于本地计算机则为“.”。</param>
        <summary>确定该日志是否存在于指定计算机上。</summary>
        <returns>如果该日志存在于指定的计算机上，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来确定远程计算机上是否存在日志。 如果要确定远程计算机上是否存在源, 请使用<xref:System.Diagnostics.EventLog.SourceExists%2A>。  
  
 由于此方法访问注册表, 因此你必须在指定的计算机上具有相应的注册表权限;否则, 查询将返回`false`。  
  
 由于不能在同一台计算机上为新日志提供现有日志的名称, 因此请在创建新日志之前使用此方法, 以确定`logName` `machineName`参数指定的服务器上是否已存在具有指定的日志。 `logName` 和`machineName`参数不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.Exists%2A>是一个`static`方法, 因此它可以在类本身上调用。 不需要创建要调用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.Exists%2A>的的新实例。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数的格式无效。 请确保对在其上执行搜索的计算机使用了正确的语法。  
  
或 
<paramref name="logName" /> 为 <see langword="null" /> 或该值为空。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEventLogs">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>创建事件日志的数组。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs () As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs();" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : unit -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>在本地计算机上搜索所有的事件日志并创建一个包含该列表的 <see cref="T:System.Diagnostics.EventLog" /> 对象数组。</summary>
        <returns><see cref="T:System.Diagnostics.EventLog" /> 类型的数组，表示本地计算机上的日志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog>对象的数组是对进行<xref:System.Diagnostics.EventLog.GetEventLogs%2A>调用时, 本地计算机上所有事件日志的快照。 这不是动态集合, 因此它不会实时反映日志的删除或创建。 在读取或写入之前, 应验证阵列中的日志是否存在。 该数组通常至少包含三个日志:应用程序、系统和安全性。 如果在本地计算机上创建了自定义日志, 则它们也会显示在该数组中。  
  
 若要检索事件日志列表, 必须具有相应的注册表权限。 这些权限与调用<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>所需的权限完全相同。  
  
   
  
## Examples  
 下面的示例枚举本地计算机上定义的事件日志, 并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">您对注册表没有读访问权。  
  
 或  
  
 计算机上没有事件日志服务。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
      </Docs>
    </Member>
    <Member MemberName="GetEventLogs">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.EventLog[] GetEventLogs (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.EventLog[] GetEventLogs(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.GetEventLogs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEventLogs (machineName As String) As EventLog()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::EventLog ^&gt; ^ GetEventLogs(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetEventLogs : string -&gt; System.Diagnostics.EventLog[]" Usage="System.Diagnostics.EventLog.GetEventLogs machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">在其上搜索事件日志的计算机。</param>
        <summary>在给定计算机上搜索所有事件日志并创建一个包含该列表的 <see cref="T:System.Diagnostics.EventLog" /> 对象数组。</summary>
        <returns><see cref="T:System.Diagnostics.EventLog" /> 类型的数组，表示给定计算机上的日志。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog>对象的数组是对进行调用<xref:System.Diagnostics.EventLog.GetEventLogs%2A>时`machineName`由参数指定的计算机上所有事件日志的快照。 这不是动态集合, 因此它不会实时反映日志的删除或创建。 在读取或写入之前, 应验证阵列中的日志是否存在。 该数组通常至少包含三个日志:应用程序、系统和安全性。 如果在指定的计算机上创建了自定义日志, 则它们也会显示在该数组中。  
  
 <xref:System.Diagnostics.EventLog.GetEventLogs%2A>是一个`static`方法, 因此它可以<xref:System.Diagnostics.EventLog>在类本身上调用。 不需要创建<xref:System.Diagnostics.EventLog>对象的实例, 就可以调用方法。  
  
 若要检索事件日志列表, 必须具有相应的注册表权限。 这些权限与调用<xref:System.Diagnostics.EventLog.Exists%2A>和<xref:System.Diagnostics.EventLog.SourceExists%2A>所需的权限完全相同。  
  
   
  
## Examples  
 下面的示例获取计算机 "myServer" 上的日志列表。 然后输出每个日志的名称。  
  
 [!code-cpp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.GetEventLogs1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.GetEventLogs1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 参数是无效的计算机名称。</exception>
        <exception cref="T:System.InvalidOperationException">您对注册表没有读访问权。  
  
 - 或 -  
  
 计算机上没有事件日志服务。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public string Log { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Log" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Log" />
      <MemberSignature Language="VB.NET" Value="Public Property Log As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Log { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Log : string with get, set" Usage="System.Diagnostics.EventLog.Log" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the log that is read and written.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogLog")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.LogConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置读取或写入的日志名称。</summary>
        <value>日志的名称。 这可以是“应用程序”、“系统”、“安全性”或一个自定义的日志名称。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 默认情况下, 服务器上存在三个日志文件:应用程序、系统和安全性。 应用程序和服务使用应用程序日志文件。 设备驱动程序使用系统日志文件。 当启用了审核功能时, 系统将在安全日志中生成成功和失败审核事件。 如果安装了其他应用程序, 例如 Windows server 上的 Active Directory, 则可能存在其他默认的日志文件。 此外, 你可以在本地或远程计算机上创建自定义日志文件。 自定义日志可帮助你在组件将事件写入默认应用程序日志时更详细地组织条目。  
  
> [!NOTE]
>  日志名称不能超过八个字符。 根据系统, MyLogSample1 和 MyLogSample2 是相同的日志。  
  
 如果写入事件日志, 则无法指定<xref:System.Diagnostics.EventLog.Log%2A>属性。 必须将<xref:System.Diagnostics.EventLog.Source%2A>属性与事件日志资源相关联, 以将其连接到特定日志。 仅从日志中读取<xref:System.Diagnostics.EventLog.Source%2A>时, 无需指定, 但事件源必须与服务器的注册表中的事件日志资源相关联。 你可以仅指定要<xref:System.Diagnostics.EventLog.Log%2A>从中读取<xref:System.Diagnostics.EventLog.MachineName%2A>的名称和 (服务器计算机名称)。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志, 则不需要指定。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>, 则假定为本地计算机 (".")。  
  
 如果未指定<xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.Log%2A>属性, 则对的调用将返回空字符串 (如果未显式设置, 则设置属性或通过构造函数)。 <xref:System.Diagnostics.EventLog.Source%2A> 如果已指定, <xref:System.Diagnostics.EventLog.Log%2A>则将返回该源注册到的日志的名称。 <xref:System.Diagnostics.EventLog.Source%2A>  
  
 一次只能向一个日志注册一个源。 如果为<xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog>实例设置了该属性<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> , 则不能更改的属性, 不会更改的值, 也不能首先调用。 <xref:System.Diagnostics.EventLog> 如果在设置了<xref:System.Diagnostics.EventLog.Log%2A> <xref:System.Diagnostics.EventLog.Source%2A>属性后更改属性, 则写入日志项会引发异常。  
  
 操作系统将事件日志存储为文件。 使用<xref:System.Diagnostics.EventLogInstaller> 或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>创建新的事件日志时, 关联的文件将存储在指定计算机上的%SystemRoot%\System32\Config 目录中。 文件名的设置方法是将<xref:System.Diagnostics.EventLog.Log%2A>属性的前8个字符追加到文件扩展名 ".evt"。  
  
 不能单独使用<xref:System.Diagnostics.EventLog.Log%2A>属性创建新日志 (无需指定日志的源)。 可以调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>, 将新的日志名称作为参数传入, 然后调用<xref:System.Diagnostics.EventLog.DeleteEventSource%2A>。 但是, 此目的通常是创建 (并写入) 新的特定于应用程序的日志, 或从现有日志中读取。  
  
 <xref:System.Diagnostics.EventLog.Log%2A>如果值发生更改, 则关闭事件日志并释放所有事件句柄。  
  
> [!CAUTION]
>  如果将<xref:System.Diagnostics.EventLog.Log%2A>属性设置为不存在的日志的名称, 系统会将<xref:System.Diagnostics.EventLog>连接到应用程序日志, 但不会警告你使用的日志不是指定的日志。  
  
   
  
## Examples  
 下面的示例读取本地计算机上的事件日志 "NewEventLog" 中的条目。  
  
 [!code-cpp[Classic EventLog.Log Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Log Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Log Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Log Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Log Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="T:System.Diagnostics.EventLogEntryCollection" />
      </Docs>
    </Member>
    <Member MemberName="LogDisplayName">
      <MemberSignature Language="C#" Value="public string LogDisplayName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LogDisplayName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.LogDisplayName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogDisplayName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LogDisplayName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogDisplayName : string" Usage="System.Diagnostics.EventLog.LogDisplayName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取事件日志的友好名称。</summary>
        <value>一个表示系统的事件查看器中事件日志的名称。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  在 Windows Vista 和更高版本中, 用户没有访问安全日志的权限。 如果以用户身份运行 Windows Vista 或更高版本, 则在尝试访问<xref:System.Security.SecurityException>安全日志中的事件的显示名称时, 会收到。  
>   
>  在 Windows Vista 或更高版本中，用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问安全日志的代码, 必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
   
  
## Examples  
 下面的示例枚举本地计算机上定义的事件日志, 并<xref:System.Diagnostics.EventLog.LogDisplayName%2A>为每个事件日志显示。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">此计算机的注册表中不存在指定的 <see cref="P:System.Diagnostics.EventLog.Log" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <permission cref="T:System.Security.Permissions.RegistryPermission">用于读取指定的注册表项。 关联的枚举:<see cref="F:System.Security.Permissions.RegistryPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于访问指定注册表项 (如果它是远程密钥) 的功能。 关联的枚举:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName="LogNameFromSourceName">
      <MemberSignature Language="C#" Value="public static string LogNameFromSourceName (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string LogNameFromSourceName(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.LogNameFromSourceName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LogNameFromSourceName (source As String, machineName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LogNameFromSourceName(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member LogNameFromSourceName : string * string -&gt; string" Usage="System.Diagnostics.EventLog.LogNameFromSourceName (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <param name="machineName">要从中删除日志的计算机名称，对于本地计算机则为“.”。</param>
        <summary>获取指定的源注册到的日志的名称。</summary>
        <returns>与注册表中的指定源关联的日志名称。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件源指示记录事件的内容。 它通常是应用程序的名称, 或者应用程序的子组件的名称 (如果应用程序很大)。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应该写入系统日志。  
  
 当您创建一个新的源 (该源只能一次写入一个日志) 时, 系统会将您的应用程序和事件日志注册为条目的有效源。 <xref:System.Diagnostics.EventLog.Source%2A>属性可以是任何字符串, 但计算机上的其他源不能使用该名称。 尝试创建一个重复<xref:System.Diagnostics.EventLog.Source%2A>的值会引发异常。 不过, 单个事件日志可能会写入多个不同的源。  
  
   
  
## Examples  
 以下示例从本地计算机中删除源。 该示例从其源确定日志, 然后删除日志。  
  
> [!NOTE]
>  多个源可能会写入事件日志。 删除自定义日志之前, 请确保没有其他源写入该日志。  
  
 [!code-cpp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.DeleteEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.DeleteEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string with get, set" Usage="System.Diagnostics.EventLog.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(".")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Name of the machine that this log get written to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogMachineName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在其上读取或写入事件的计算机的名称。</summary>
        <value>事件日志驻留的服务器的名称。 默认为本地计算机 (".")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果写入事件日志, 则必须将<xref:System.Diagnostics.EventLog.Source%2A>与事件日志对象相关联, 以将其连接到特定日志。 仅从日志中读取时, <xref:System.Diagnostics.EventLog.Source%2A>无需指定属性。 只能指定<xref:System.Diagnostics.EventLog.Log%2A>名称和<xref:System.Diagnostics.EventLog.MachineName%2A> (服务器计算机名称)。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到日志, 则不需要指定。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>, 则假定为本地计算机 (".")。  
  
 一次只能向一个日志注册一个源。 如果为<xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.Source%2A> <xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog>实例设置了该属性<xref:System.Diagnostics.EventLog.DeleteEventSource%2A> , 则不能更改的属性, 不会更改的值, 也不能首先调用。 <xref:System.Diagnostics.EventLog> 如果更改<xref:System.Diagnostics.EventLog.MachineName%2A>属性, 将<xref:System.Diagnostics.EventLog>关闭所有句柄并重新附加到新计算机上的日志和源。  
  
 <xref:System.Diagnostics.EventLog.MachineName%2A>该值不能为空字符串。 如果未显式设置, 则默认为本地计算机 (".")。  
  
   
  
## Examples  
 下面的示例读取指定计算机上的事件日志 "NewEventLog" 中的条目。  
  
 [!code-cpp[Classic EventLog.MachineName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.MachineName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.MachineName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.MachineName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">计算机名称无效。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Delete(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.GetEventLogs" />
      </Docs>
    </Member>
    <Member MemberName="MaximumKilobytes">
      <MemberSignature Language="C#" Value="public long MaximumKilobytes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumKilobytes" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximumKilobytes As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MaximumKilobytes { long get(); void set(long value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumKilobytes : int64 with get, set" Usage="System.Diagnostics.EventLog.MaximumKilobytes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置最大事件日志大小（以 KB 为单位）。</summary>
        <value>最大事件日志大小（以 KB 为单位）。 默认值为 512，表示最大文件大小为 512 KB。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>属性表示事件日志文件的大小限制。 当事件日志达到大小限制时, 配置<xref:System.Diagnostics.EventLog.OverflowAction%2A>的值将确定是否丢弃新条目, 或新条目是否覆盖旧条目。  
  
> [!NOTE]
>  此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大值时, 此属性指定操作系统如何处理为事件日志注册的所有事件源写入的新项。  
  
   
  
## Examples  
 下面的示例枚举本地计算机上定义的事件日志, 并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">指定值小于 64，或大于 4194240，或不是 64 的偶数倍。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
- 或 - 
事件日志的注册表项无法在目标计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MinimumRetentionDays">
      <MemberSignature Language="C#" Value="public int MinimumRetentionDays { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MinimumRetentionDays" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MinimumRetentionDays As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MinimumRetentionDays { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MinimumRetentionDays : int" Usage="System.Diagnostics.EventLog.MinimumRetentionDays" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取要在事件日志中保留项的天数。</summary>
        <value>事件日志中的项被保留的天数。 默认值为 7。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>使用属性检查事件日志的当前设置。 使用<xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>更改必须保留事件日志中每个条目的最小天数。  
  
 此<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值取决于事件日志的已配置溢出行为。 如果事件<xref:System.Diagnostics.OverflowAction>日志的属性设置为<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, 则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>该值为0。 如果事件<xref:System.Diagnostics.OverflowAction>日志的属性设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, 则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>值为-1。 如果事件<xref:System.Diagnostics.OverflowAction>日志的属性设置为<xref:System.Diagnostics.OverflowAction.OverwriteOlder>, 则<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>该值大于零, 并且表示在事件日志已满时保留事件日志条目的天数。  
  
 仅当事件日志达到其大小限制时才会发生溢出行为。 如果将设置为<xref:System.Diagnostics.OverflowAction.OverwriteOlder>, 并且事件日志达到其最大大小, 则仅在新条目可以替换其年龄超过该<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>时间段的条目时才写入新条目。 <xref:System.Diagnostics.EventLog.OverflowAction%2A> <xref:System.Diagnostics.EventLog> 如果定期存档事件日志, 则可在最短时间内保留事件条目。 否则, 当事件日志达到其限制时, 可能会丢失新条目。 若要避免丢失新的事件信息, 请根据特定事件日志的存档计划设置事件的最短保持天数。  
  
   
  
## Examples  
 下面的示例枚举本地计算机上定义的事件日志, 并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
      </Docs>
    </Member>
    <Member MemberName="ModifyOverflowPolicy">
      <MemberSignature Language="C#" Value="public void ModifyOverflowPolicy (System.Diagnostics.OverflowAction action, int retentionDays);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ModifyOverflowPolicy(valuetype System.Diagnostics.OverflowAction action, int32 retentionDays) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ModifyOverflowPolicy (action As OverflowAction, retentionDays As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ModifyOverflowPolicy(System::Diagnostics::OverflowAction action, int retentionDays);" />
      <MemberSignature Language="F#" Value="member this.ModifyOverflowPolicy : System.Diagnostics.OverflowAction * int -&gt; unit" Usage="eventLog.ModifyOverflowPolicy (action, retentionDays)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Diagnostics.OverflowAction" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="retentionDays" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="action">向事件日志写入新项的溢出行为。</param>
        <param name="retentionDays">每个事件日志项要保留的最小天数。 只有在 <paramref name="action" /> 设置为 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" /> 时，才使用此参数。</param>
        <summary>更改已配置的行为，以便在事件日志达到其最大文件大小时写入新项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件日志的溢出行为指定将新条目写入到已达到其最大文件大小的日志时会发生的情况。  
  
> [!NOTE]
>  仅当事件日志达到其最大文件大小时, 溢出行为才会生效。 溢出行为不影响将新条目写入到可容纳其他事件日志条目的日志。  
  
 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>方法配置事件日志的溢出行为。 <xref:System.Diagnostics.EventLog>实例. 为<xref:System.Diagnostics.EventLog.Log%2A>属性指定的事件日志调用此方法后<xref:System.Diagnostics.EventLog.OverflowAction%2A> , 和<xref:System.Diagnostics.EventLog.MinimumRetentionDays%2A>属性值将反映新配置的溢出行为。  
  
> [!NOTE]
>  此属性表示此实例所表示的事件日志的配置设置。 当事件日志达到其最大值时, 此属性指定操作系统如何处理为事件日志注册的所有事件源写入的新项。  
  
 将参数设置为<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded> , 以指示新项在<xref:System.Diagnostics.EventLog>达到其最大大小时覆盖最旧的条目。 `action` 如果参数设置为<xref:System.Diagnostics.OverflowAction.OverwriteAsNeeded>, `retentionDays`则忽略参数值。 `action`  
  
 将参数设置为<xref:System.Diagnostics.OverflowAction.OverwriteOlder> , 以指示当<xref:System.Diagnostics.EventLog>达到其最大值时, 每个新条目都将覆盖旧条目。 `action` 指定使用`retentionDays`参数在日志中保留事件的天数。 保留范围内写入的事件不会被新条目覆盖。  
  
 将参数设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite> , 以在达到最大日志大小时放弃新事件。 `action` 如果参数设置为<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>, `retentionDays`则忽略参数值。 `action`  
  
> [!CAUTION]
>  设置溢出策略以<xref:System.Diagnostics.OverflowAction.DoNotOverwrite>指定在事件日志已满时放弃新条目。 如果使用此设置, 请确保定期存档和清除事件日志, 以避免达到其最大大小限制。  
  
   
  
## Examples  
 下面的示例显示指定事件日志的已配置溢出策略, 并允许用户为事件日志选择新的溢出策略设置。  
  
 [!code-cpp[EventLogProperties#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#3)]
 [!code-csharp[EventLogProperties#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#3)]
 [!code-vb[EventLogProperties#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="action" /> 不是有效的 <see cref="P:System.Diagnostics.EventLog.OverflowAction" /> 值。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="retentionDays" /> 小于 1 或大于 365。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
或 
事件日志的注册表项无法在目标计算机上打开。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="P:System.Diagnostics.EventLog.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="OverflowAction">
      <MemberSignature Language="C#" Value="public System.Diagnostics.OverflowAction OverflowAction { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.OverflowAction OverflowAction" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.OverflowAction" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OverflowAction As OverflowAction" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::OverflowAction OverflowAction { System::Diagnostics::OverflowAction get(); };" />
      <MemberSignature Language="F#" Value="member this.OverflowAction : System.Diagnostics.OverflowAction" Usage="System.Diagnostics.EventLog.OverflowAction" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.OverflowAction</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取已配置的行为，以便在事件日志达到其最大文件大小时存储新项。</summary>
        <value><see cref="T:System.Diagnostics.OverflowAction" /> 值，指定在事件日志达到其最大日志大小时存储新项的已配置行为。 默认值为 <see cref="F:System.Diagnostics.OverflowAction.OverwriteOlder" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当向事件日志写入新事件时, 事件日志的大小会增长。 每个事件日志都具有配置的最大大小限制;<xref:System.Diagnostics.EventLog.MaximumKilobytes%2A>属性定义事件日志文件大小所允许的最大 kb 数。  
  
 <xref:System.Diagnostics.EventLog.OverflowAction%2A>使用属性值检查事件日志的已配置溢出行为是否达到其最大大小。 <xref:System.Diagnostics.EventLog.ModifyOverflowPolicy%2A>使用方法可更改事件日志的溢出行为。  
  
> [!NOTE]
>  仅当事件日志达到其最大文件大小时, 溢出行为才会生效。 溢出行为不影响将新条目写入到可容纳其他事件日志条目的日志。  
  
   
  
## Examples  
 下面的示例枚举本地计算机上定义的事件日志, 并显示每个事件日志的配置详细信息。  
  
 [!code-cpp[EventLogProperties#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLogProperties/CPP/source.cpp#2)]
 [!code-csharp[EventLogProperties#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLogProperties/CS/source.cs#2)]
 [!code-vb[EventLogProperties#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLogProperties/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="T:System.Diagnostics.OverflowAction" />
        <altmember cref="P:System.Diagnostics.EventLog.MaximumKilobytes" />
        <altmember cref="M:System.Diagnostics.EventLog.ModifyOverflowPolicy(System.Diagnostics.OverflowAction,System.Int32)" />
        <altmember cref="P:System.Diagnostics.EventLog.MinimumRetentionDays" />
      </Docs>
    </Member>
    <Member MemberName="RegisterDisplayName">
      <MemberSignature Language="C#" Value="public void RegisterDisplayName (string resourceFile, long resourceId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterDisplayName(string resourceFile, int64 resourceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.RegisterDisplayName(System.String,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterDisplayName (resourceFile As String, resourceId As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterDisplayName(System::String ^ resourceFile, long resourceId);" />
      <MemberSignature Language="F#" Value="member this.RegisterDisplayName : string * int64 -&gt; unit" Usage="eventLog.RegisterDisplayName (resourceFile, resourceId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceFile" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="resourceId" Type="System.Int64" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="resourceFile">本地化资源文件的完全指定的路径。</param>
        <param name="resourceId">在资源文件内指明一个本地化字符串的资源标识符。</param>
        <summary>指定该事件日志的本地化名称，它显示在服务器事件查看器中。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Diagnostics.EventLog.RegisterDisplayName%2A>在事件查看器中注册并显示自定义事件日志的本地化名称。  
  
 指定的资源标识符必须与资源文件中定义的本地化字符串相对应。 事件查看器使用本地化字符串和当前区域性设置显示自定义事件日志的名称。 例如, 可以为资源文件中的不同区域性定义多个本地化的事件日志名称。 事件查看器显示与当前用户的区域性设置相对应的本地化字符串。  
  
 如果事件查看器无法从资源文件加载本地化的字符串, 或者如果没有为事件日志注册显示名称, 则事件查看器将显示在中<xref:System.Diagnostics.EventLog.Log%2A>定义的事件日志名称。  
  
> [!NOTE]
>  无需注册预定义的事件日志的显示名称。 操作系统将为应用程序、系统和安全事件日志注册本地化的显示名称。  
  
   
  
## Examples  
 下面的示例确定是否在本地计算机上`SampleApplicationSource`注册了名为的事件源。 如果事件源不存在, 则此示例将为源设置消息资源文件并创建新的事件源。 最后, 该示例使用中`DisplayNameMsgId`的资源标识符值和中`messageFile`的资源文件路径, 为事件日志设置本地化的显示名称。  
  
 [!code-cpp[EventLog_WriteEvent#6](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#6)]
 [!code-csharp[EventLog_WriteEvent#6](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#6)]
 [!code-vb[EventLog_WriteEvent#6](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#6)]  
  
 该示例使用资源库 EventLogMsgs 中内置的以下消息文本文件。 消息文本文件是从中创建消息资源文件的源。 消息文本文件定义类别、事件消息和参数插入字符串的资源标识符和文本。 具体而言, 为事件日志的本地化名称定义了资源标识符5001。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Diagnostics.EventLog.Log" /> 值不是有效的日志名。  
  
- 或 - 
事件日志的注册表项无法在目标计算机上打开。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="resourceFile" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于管理计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Administer" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.LogDisplayName" />
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public string Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Source" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Source { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : string with get, set" Usage="System.Diagnostics.EventLog.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.ReadOnly(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;xamarinmac-3.0">
          <AttributeName>System.ComponentModel.RecommendedAsConfigurable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The application name that writes the log.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSource")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置在写入事件日志时要注册和使用的源名称。</summary>
        <value>在事件日志中注册为项源的名称。 默认值为空字符串("")。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 事件源指示记录事件的内容。 它通常是应用程序的名称, 或者应用程序的子组件的名称 (如果应用程序很大)。 应用程序和服务应写入应用程序日志或自定义日志。 设备驱动程序应该写入系统日志。  
  
 只需在写入事件日志时指定事件源。 向事件日志写入条目之前, 必须将事件源作为事件的有效源注册到事件日志。 当你编写日志项时, 系统会使用<xref:System.Diagnostics.EventLog.Source%2A>属性来查找适当的日志, 以便在其中放置你的条目。 如果要读取事件日志, 可以指定<xref:System.Diagnostics.EventLog.Source%2A>、 <xref:System.Diagnostics.EventLog.Log%2A>或<xref:System.Diagnostics.EventLog.MachineName%2A>。  
  
> [!NOTE]
>  <xref:System.Diagnostics.EventLog.MachineName%2A>如果要连接到本地计算机上的日志, 则不需要指定。 如果未指定<xref:System.Diagnostics.EventLog.MachineName%2A>, 则假定为本地计算机 (".")。  
  
 使用<xref:System.Diagnostics.EventLog.WriteEvent%2A> 和<xref:System.Diagnostics.EventLog.WriteEntry%2A>将事件写入事件日志。 您必须指定事件源以写入事件;在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 可以为现有事件日志或新的事件日志创建事件源。 为新的事件日志创建新源时, 系统将为该日志注册源, 但在向其中写入第一个条目之前, 不会创建日志。  
  
 源在本地计算机上必须唯一;新的源名称不能与现有的源名称或现有的事件日志名称相匹配。 每个源一次只能写入一个事件日志;但是, 应用程序可以使用多个源来写入多个事件日志。 例如, 你的应用程序可能需要为不同的事件日志或不同的资源文件配置多个源。  
  
 如果更改此<xref:System.Diagnostics.EventLog.Source%2A>值<xref:System.Diagnostics.EventLog> , 则将关闭它所注册到的, 并释放所有事件句柄。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
 若要更改现有源的配置详细信息, 必须删除该源, 并使用新配置创建它。 如果其他应用程序或组件使用现有源, 请使用更新的配置创建新的源, 而不是删除现有源。  
  
> [!NOTE]
>  如果源已映射到日志, 并将其重新映射到新日志, 则必须重新启动计算机才能使更改生效。  
  
   
  
## Examples  
 如果源尚不存在, `MySource`则下面的示例将创建源, 并将项写入事件日志。 `MyNewLog`  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Log" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SourceExists">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>在计算机的注册表中搜索给定的事件源。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <summary>确定事件源是否已在本地计算机上注册。</summary>
        <returns>如果事件源已在本地计算机上注册，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法来确定本地计算机上是否存在某个事件源。 如果要确定本地计算机上是否存在日志, 请使用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 由于此方法访问注册表, 因此你必须在本地计算机上具有相应的注册表权限;否则, <xref:System.Security.SecurityException>将引发。  
  
> [!NOTE]
>  若要在 Windows Vista 及更高版本或 Windows Server 2003 中搜索事件源, 您必须具有管理权限。  
>   
>  此要求的原因是必须搜索所有事件日志 (包括安全性), 以确定事件源是否唯一。 从 Windows Vista 开始, 用户没有访问安全日志的权限;因此, <xref:System.Security.SecurityException>将引发。  
>   
>  从 Windows Vista 开始, 用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码, 必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  在该<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帐户下执行的服务没有执行此方法所需的权限。 解决方法是检查中<xref:System.ServiceProcess.ServiceInstaller>是否存在事件源, 如果不存在, 则在安装程序中创建源。  
  
 由于不能为新源提供同一台计算机上的现有源的名称, 因此在尝试调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以确保本地计算机上尚不存在具有`source`指定名称的源之前, 请使用此方法。 `source`参数不区分大小写。  
  
   
  
## Examples  
 如果源尚不存在, `MySource`则下面的示例将创建源, 并将项写入事件日志。 `MyNewLog`  
  
 [!code-cpp[Classic EventLog.Source Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.Source Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.Source Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.Source Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.Source Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">未找到 <paramref name="source" />，无法搜索部分或全部事件日志。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="SourceExists">
      <MemberSignature Language="C#" Value="public static bool SourceExists (string source, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SourceExists(string source, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.SourceExists(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SourceExists (source As String, machineName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SourceExists(System::String ^ source, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member SourceExists : string * string -&gt; bool" Usage="System.Diagnostics.EventLog.SourceExists (source, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("remote machine is not supported")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">事件源的名称。</param>
        <param name="machineName">在其上查看的计算机的名称，对于本地计算机则为“.”。</param>
        <summary>确定事件源是否已在指定的计算机上注册。</summary>
        <returns>如果事件源已在给定计算机上注册，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以确定`machineName`参数指定的计算机上是否存在事件源。 如果要确定指定计算机上是否存在日志, 请使用<xref:System.Diagnostics.EventLog.Exists%2A>。  
  
 由于此方法访问注册表, 因此你必须在给定服务器上具有相应的注册表权限;否则, <xref:System.Security.SecurityException>将引发。  
  
> [!NOTE]
>  若要在 Windows Vista 及更高版本或 Windows Server 2003 中搜索事件源, 您必须具有管理权限。  
>   
>  此要求的原因是必须搜索所有事件日志 (包括安全性), 以确定事件源是否唯一。 从 Windows Vista 开始, 用户没有访问安全日志的权限;因此, <xref:System.Security.SecurityException>将引发。  
>   
>  从 Windows Vista 开始, 用户帐户控制 (UAC) 决定用户的特权。 如果您是内置的 Administrators 组的成员，将为您分配两个运行时访问令牌：一个标准用户访问令牌和一个管理员访问令牌。 默认情况下，您拥有标准用户角色。 若要执行访问性能计数器的代码, 必须首先将你的特权从标准用户提升到管理员。 你可以通过以下方式执行此操作：右键单击应用程序图标并指示需以管理员身份运行。  
  
> [!NOTE]
>  在该<xref:System.ServiceProcess.ServiceAccount.LocalSystem>帐户下执行的服务没有执行此方法所需的权限。 解决方法是检查中<xref:System.ServiceProcess.ServiceInstaller>是否存在事件源, 如果不存在, 则在安装程序中创建源。  
  
 由于不能为新源提供同一台计算机上的现有源的名称, 因此在尝试调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>以确保计算机上尚不存在具有`source`指定名称的源之前, 请使用此方法。 `source` 和`machineName`参数不区分大小写。  
  
 <xref:System.Diagnostics.EventLog.SourceExists%2A>是一个`static`方法, 因此它可以在类本身上调用。 不需要创建的<xref:System.Diagnostics.EventLog>实例来调用。 <xref:System.Diagnostics.EventLog.SourceExists%2A>  
  
   
  
## Examples  
 下面的示例在计算机`MySource` `MyServer`上创建源, 并将项写入事件日志`MyNewLog`。  
  
 [!code-cpp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.SourceExists1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.SourceExists1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="machineName" /> 是无效的计算机名称。</exception>
        <exception cref="T:System.Security.SecurityException">未找到 <paramref name="source" />，无法搜索部分或全部事件日志。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.Exists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.MachineName" />
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.EventLog.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netcore-2.1;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.2;netcore-3.0;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("An object that synchronizes event handler calls.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("LogSynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取或设置用于封送事件处理程序调用的对象，该调用在有 <see cref="T:System.Diagnostics.EventLog" /> 项写入事件时发出。</summary>
        <value><see cref="T:System.ComponentModel.ISynchronizeInvoke" />，用于封送由事件日志上的 <see cref="E:System.Diagnostics.EventLog.EntryWritten" /> 事件引发的事件处理程序调用。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>为`null`时, 处理事件<xref:System.Diagnostics.EventLog.EntryWritten>的方法将在系统线程池中的线程上调用。 有关系统线程池的详细信息, 请<xref:System.Threading.ThreadPool>参阅。  
  
 <xref:System.Diagnostics.EventLog.EntryWritten>当事件由 visual Windows 窗体组件 (如按钮) 处理时, 通过系统线程池访问组件可能不起作用, 或可能会导致异常。 通过将设置<xref:System.Diagnostics.EventLog.SynchronizingObject%2A>为 Windows 窗体组件来避免此问题, 这会导致<xref:System.Diagnostics.EventLog.EntryWritten>处理事件的方法在创建该组件的同一线程上进行调用。  
  
 如果在 Windows 窗体设计器[!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)]内使用, <xref:System.Diagnostics.EventLog.SynchronizingObject%2A>则将自动设置为包含的<xref:System.Diagnostics.EventLog>控件。 <xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog>例如, 如果将设置为 form1 的设计器 (继承自<xref:System.Windows.Forms.Form>) <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> , 则将的属性<xref:System.Diagnostics.EventLog>设置为 form1 的实例。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="E:System.Diagnostics.EventLog.EntryWritten" />
        <altmember cref="T:System.Threading.ThreadPool" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEntry">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将项写入事件日志。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string -&gt; unit" Usage="eventLog.WriteEntry message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <summary>将信息类型项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法将信息项写入与此<xref:System.Diagnostics.EventLog>实例关联的事件日志中。 如果要指定任何其他<xref:System.Diagnostics.EventLogEntryType>, 请使用的其他<xref:System.Diagnostics.EventLog.WriteEntry%2A>重载。  
  
> [!NOTE]
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
 你必须在<xref:System.Diagnostics.EventLog>组件<xref:System.Diagnostics.EventLog.Source%2A>上设置属性, 然后才能将条目写入日志。 在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 <xref:System.Diagnostics.EventLog.Source%2A>如果此<xref:System.Diagnostics.EventLog>实例的属性中指定的源未在您的组件写入的计算机上注册, <xref:System.Diagnostics.EventLog.WriteEntry%2A>则调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。  
  
> [!NOTE]
>  如果<xref:System.Diagnostics.EventLog.MachineName%2A>在调用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.CreateEventSource%2A>或之前未为实例指定,则假定为本地计算机(".")。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果系统<xref:System.Diagnostics.EventLog.Source%2A>需要通过对的<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用注册, 并且<xref:System.Diagnostics.EventLog.Log%2A>未在<xref:System.Diagnostics.EventLog>实例上设置属性, 则日志默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由注册<xref:System.Diagnostics.EventLog.Source%2A>过程中引发的错误生成。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  如果将条目写入远程计算机, 则当远程计算机未运行 .NET Framework 时, 消息的值 (文本字符串) 可能不是预期的值。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
  
   
  
## Examples  
 如果源尚不存在, `MySource`则下面的示例将创建源, 并将项写入事件日志。 `MyNewLog`  
  
 [!code-cpp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.CreateEventSource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.CreateEventSource Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
或 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
或 
已为其他事件日志注册了该源。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="eventLog.WriteEntry (message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <summary>将错误、警告、信息、成功审核或失败审核项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可将指定<xref:System.Diagnostics.EventLogEntryType>的的条目写入事件日志。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。  
  
> [!NOTE]
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
 你必须在<xref:System.Diagnostics.EventLog>组件<xref:System.Diagnostics.EventLog.Source%2A>上设置属性, 然后才能将条目写入日志。 在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 <xref:System.Diagnostics.EventLog.Source%2A>如果此<xref:System.Diagnostics.EventLog>实例的属性中指定的源未在您的组件写入的计算机上注册, <xref:System.Diagnostics.EventLog.WriteEntry%2A>则调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。  
  
> [!NOTE]
>  如果<xref:System.Diagnostics.EventLog.MachineName%2A>在调用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.CreateEventSource%2A>或之前未为实例指定,则假定为本地计算机(".")。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果系统<xref:System.Diagnostics.EventLog.Source%2A>需要通过对的<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用注册, 并且<xref:System.Diagnostics.EventLog.Log%2A>未在<xref:System.Diagnostics.EventLog>实例上设置属性, 则日志默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由在注册<xref:System.Diagnostics.EventLog.Source%2A>过程中引发的错误生成。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  如果将条目写入远程计算机, 则当远程计算机未运行 .NET Framework 时, 消息的值 (文本字符串) 可能不是预期的值。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
  
   
  
## Examples  
 下面的示例将一个警告项写入到本地计算机上的事件日志 "MyNewLog"。  
  
 [!code-cpp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
或 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
或 
已为其他事件日志注册了该源。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <summary>使用指定的注册事件源将信息类型项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以将信息条目写入事件日志, 使用已注册为相应日志的事件源的源。 如果要指定任何其他<xref:System.Diagnostics.EventLogEntryType>, 请使用的其他<xref:System.Diagnostics.EventLog.WriteEntry%2A>重载。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
>   
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
   
  
## Examples  
 如果源尚不存在, `MySource`则下面的示例将创建源, 并将项写入事件日志。 `MyNewLog`  
  
 [!code-cpp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
或 
<paramref name="source" /> 值为 <see langword="null" />。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <summary>将一个具有给定消息文本和应用程序定义的事件标识符的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以将应用程序定义`eventID`的条目写入事件日志。 与`eventID`源一起唯一标识事件。 每个应用程序都可以定义自己的编号事件以及它们映射到的描述字符串。 事件查看器显示这些字符串值, 以帮助用户了解发生了什么问题, 并建议采取什么操作。  
  
> [!NOTE]
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
 除了事件标识符以外, 还可以<xref:System.Diagnostics.EventLogEntryType>为写入事件日志的事件指定。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。 此参数指示事件类型是否为错误、警告、信息、成功审核或失败审核。  
  
 你必须在<xref:System.Diagnostics.EventLog>组件<xref:System.Diagnostics.EventLog.Source%2A>上设置属性, 然后才能将条目写入日志。 在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 <xref:System.Diagnostics.EventLog.Source%2A>如果此<xref:System.Diagnostics.EventLog>实例的属性中指定的源未在您的组件写入的计算机上注册, <xref:System.Diagnostics.EventLog.WriteEntry%2A>则调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。  
  
> [!NOTE]
>  如果<xref:System.Diagnostics.EventLog.MachineName%2A>在调用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.CreateEventSource%2A>或之前未为实例指定,则假定为本地计算机(".")。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果系统<xref:System.Diagnostics.EventLog.Source%2A>需要通过对的<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用注册, 并且<xref:System.Diagnostics.EventLog.Log%2A>未在<xref:System.Diagnostics.EventLog>实例上设置属性, 则日志默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由在注册<xref:System.Diagnostics.EventLog.Source%2A>过程中引发的错误生成。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  如果将条目写入远程计算机, 则当远程计算机未运行 .NET Framework 时, 消息的值 (文本字符串) 可能不是预期的值。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
或 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <summary>使用指定的注册事件源，将错误、警告、信息、成功审核或失败审核项与给定的消息文本一起写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可将指定<xref:System.Diagnostics.EventLogEntryType>的的条目写入事件日志, 使用已注册为相应日志的事件源的源。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。  
  
> [!NOTE]
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
  
   
  
## Examples  
 下面的示例将一个警告项写入到本地计算机上的事件日志 "MyNewLog"。  
  
 [!code-cpp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/CS/source.cs#1)]
 [!code-vb[Classic EventLog.WriteEntry3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic EventLog.WriteEntry3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
或 
<paramref name="source" /> 值为 <see langword="null" />。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <summary>将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以将应用程序定义`category`的条目写入事件日志。 事件查看器使用类别来筛选由事件源写入的事件。 事件查看器可以将类别显示为数值, 也可以将类别用作资源标识符以显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为事件查看器中的互补正数。 例如,-10 显示为 65526, a-1 显示为65535。  
  
> [!NOTE]
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
 若要在事件查看器中显示本地化的类别字符串, 必须使用配置有类别资源文件的事件源, 并将设置`category`为类别资源文件中的资源标识符。 如果事件源没有已配置的类别资源文件, 或者指定`category`的不为类别资源文件中的字符串编制索引, 则事件查看器将显示该条目的数字类别值。 <xref:System.Diagnostics.EventLogInstaller> 使用<xref:System.Diagnostics.EventSourceCreationData>或类配置类别资源文件以及资源文件中的类别字符串的数目。  
  
 除了类别外, 还可以指定写入事件日志的事件的事件标识符。 事件标识符与事件源一起唯一标识事件。 每个应用程序都可以定义自己的编号事件以及它们映射到的描述字符串。 事件查看器显示这些字符串值, 以帮助用户了解发生了什么问题, 并建议采取什么操作。  
  
 最后, 你可以<xref:System.Diagnostics.EventLogEntryType>为写入事件日志的事件指定。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。 此参数指示事件类型是否为错误、警告、信息、成功审核或失败审核。  
  
 你必须在<xref:System.Diagnostics.EventLog>组件<xref:System.Diagnostics.EventLog.Source%2A>上设置属性, 然后才能将条目写入日志。 在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 <xref:System.Diagnostics.EventLog.Source%2A>如果此<xref:System.Diagnostics.EventLog>实例的属性中指定的源未在您的组件写入的计算机上注册, <xref:System.Diagnostics.EventLog.WriteEntry%2A>则调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。  
  
> [!NOTE]
>  如果<xref:System.Diagnostics.EventLog.MachineName%2A>在调用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.CreateEventSource%2A>或之前未为实例指定,则假定为本地计算机(".")。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果系统<xref:System.Diagnostics.EventLog.Source%2A>需要通过对的<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用注册, 并且<xref:System.Diagnostics.EventLog.Log%2A>未在<xref:System.Diagnostics.EventLog>实例上设置属性, 则日志默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由在注册<xref:System.Diagnostics.EventLog.Source%2A>过程中引发的错误生成。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  如果将条目写入远程计算机, 则当远程计算机未运行 .NET Framework 时, 消息的值 (文本字符串) 可能不是预期的值。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#3](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#3)]
 [!code-csharp[EventLog_WriteEntry_1_3#3](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#3)]
 [!code-vb[EventLog_WriteEntry_1_3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
或 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
或 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <summary>使用指定的注册事件源，将一个具有给定消息文本和应用程序定义的事件标识符的项写入事件日志。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以将具有应用程序定义`eventID`的条目写入事件日志, 使用已注册为相应日志的事件源的源。 `eventID`与源一起唯一标识事件。 每个应用程序都可以定义自己的编号事件以及它们映射到的描述字符串。 事件查看器向用户显示这些字符串, 以帮助用户了解发生了什么问题, 并建议采取什么操作。  
  
> [!NOTE]
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
 除了事件标识符, 的<xref:System.Diagnostics.EventLog.WriteEntry%2A>此重载还允许您<xref:System.Diagnostics.EventLogEntryType>为写入事件日志的事件指定。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。 此参数指示事件类型是否为错误、警告、信息、成功审核或失败审核。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_4#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_4/CPP/eventlog_writeentry_4.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_4#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_4/CS/eventlog_writeentry_4.cs#1)]
 [!code-vb[EventLog_WriteEntry_4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_4/VB/eventlog_writeentry_4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public void WriteEntry (string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEntry(string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEntry (message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEntry(System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="member this.WriteEntry : string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="eventLog.WriteEntry (message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <param name="rawData">包含与此项关联的二进制数据的字节数组。</param>
        <summary>将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志，并向消息追加二进制数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此重载将应用程序定义的特定于事件的数据写入事件日志。 事件查看器不会解释此数据;它仅以组合的十六进制和文本格式显示原始数据。 请谨慎使用特定于事件的数据, 仅当你确定此数据对调试问题的人员非常有用时才使用。 你还可以使用特定于事件的数据存储应用程序可以独立于事件查看器处理的信息。 例如, 您可以专门为您的事件编写查看器, 或者编写一个程序来扫描日志文件, 并创建包含特定于事件的数据的信息的报表。  
  
 除了二进制数据之外, 还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器使用类别来筛选由事件源写入的事件。 事件查看器可以将类别显示为数值, 也可以将类别用作资源标识符以显示本地化的类别字符串。  
  
> [!NOTE]
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为事件查看器中的互补正数。 例如,-10 显示为 65526, a-1 显示为65535。  
  
 若要在事件查看器中显示本地化的类别字符串, 必须使用配置有类别资源文件的事件源, 并将设置`category`为类别资源文件中的资源标识符。 如果事件源没有已配置的类别资源文件, 或者指定`category`的不为类别资源文件中的字符串编制索引, 则事件查看器将显示该条目的数字类别值。 <xref:System.Diagnostics.EventLogInstaller> 使用<xref:System.Diagnostics.EventSourceCreationData>或类配置类别资源文件以及资源文件中的类别字符串的数目。  
  
 事件标识符与事件源一起唯一标识事件。 每个应用程序都可以定义自己的编号事件以及它们映射到的描述字符串。 事件查看器显示这些字符串值, 以帮助用户了解发生了什么问题, 并建议采取什么操作。  
  
 最后, 你可以<xref:System.Diagnostics.EventLogEntryType>为写入事件日志的事件指定。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。 此参数指示事件类型是否为错误、警告、信息、成功审核或失败审核。  
  
 你必须在<xref:System.Diagnostics.EventLog>组件<xref:System.Diagnostics.EventLog.Source%2A>上设置属性, 然后才能将条目写入日志。 在写入包含源的第一个条目之前, 必须创建并配置事件源。  
  
 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 <xref:System.Diagnostics.EventLog.Source%2A>如果此<xref:System.Diagnostics.EventLog>实例的属性中指定的源未在您的组件写入的计算机上注册, <xref:System.Diagnostics.EventLog.WriteEntry%2A>则调用<xref:System.Diagnostics.EventLog.CreateEventSource%2A>并注册该源。  
  
> [!NOTE]
>  如果<xref:System.Diagnostics.EventLog.MachineName%2A>在调用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.CreateEventSource%2A>或之前未为实例指定,则假定为本地计算机(".")。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果系统<xref:System.Diagnostics.EventLog.Source%2A>需要通过对的<xref:System.Diagnostics.EventLog.WriteEntry%2A>调用注册, 并且<xref:System.Diagnostics.EventLog.Log%2A>未在<xref:System.Diagnostics.EventLog>实例上设置属性, 则日志默认为应用程序日志。  
  
> [!NOTE]
>  上面列出的许多异常由在注册<xref:System.Diagnostics.EventLog.Source%2A>过程中引发的错误生成。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  如果将条目写入远程计算机, 则当远程计算机未运行 .NET Framework 时, 消息的值 (文本字符串) 可能不是预期的值。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_5#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_5/CPP/eventlog_writeentry_5.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_5#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_5/CS/eventlog_writeentry_5.cs#1)]
 [!code-vb[EventLog_WriteEntry_5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_5/VB/eventlog_writeentry_5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
- 或 - 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <summary>通过使用指定的注册事件源，将一个具有给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志。 事件查看器可使用 <paramref name="category" /> 筛选日志中的事件。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法, 使用已注册为相应日志的事件`category`源的源, 将应用程序定义的条目写入事件日志。 事件查看器使用类别来筛选由事件源写入的事件。 事件查看器可以将类别显示为数值, 也可以将类别用作资源标识符以显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为事件查看器中的互补正数。 例如,-10 显示为 65526, a-1 显示为65535。  
  
 若要在事件查看器中显示本地化的类别字符串, 必须使用配置有类别资源文件的事件源, 并将设置`category`为类别资源文件中的资源标识符。 如果事件源没有已配置的类别资源文件, 或者指定`category`的不为类别资源文件中的字符串编制索引, 则事件查看器将显示该条目的数字类别值。 <xref:System.Diagnostics.EventLogInstaller> 使用<xref:System.Diagnostics.EventSourceCreationData>或类配置类别资源文件以及资源文件中的类别字符串的数目。  
  
 除了类别外, 还可以指定写入事件日志的事件的事件标识符。 事件标识符与事件源一起唯一标识事件。 每个应用程序都可以定义自己的编号事件以及它们映射到的描述字符串。 事件查看器显示这些字符串值, 以帮助用户了解发生了什么问题, 并建议采取什么操作。  
  
 最后, 你可以<xref:System.Diagnostics.EventLogEntryType>为写入事件日志的事件指定。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。 此参数指示事件类型是否为错误、警告、信息、成功审核或失败审核。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
>   
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#1)]
 [!code-csharp[EventLog_WriteEntry_1_3#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#1)]
 [!code-vb[EventLog_WriteEntry_1_3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
或 
<paramref name="source" /> 值为 <see langword="null" />。  
  
或 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <Member MemberName="WriteEntry">
      <MemberSignature Language="C#" Value="public static void WriteEntry (string source, string message, System.Diagnostics.EventLogEntryType type, int eventID, short category, byte[] rawData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEntry(string source, string message, valuetype System.Diagnostics.EventLogEntryType type, int32 eventID, int16 category, unsigned int8[] rawData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEntry(System.String,System.String,System.Diagnostics.EventLogEntryType,System.Int32,System.Int16,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEntry (source As String, message As String, type As EventLogEntryType, eventID As Integer, category As Short, rawData As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEntry(System::String ^ source, System::String ^ message, System::Diagnostics::EventLogEntryType type, int eventID, short category, cli::array &lt;System::Byte&gt; ^ rawData);" />
      <MemberSignature Language="F#" Value="static member WriteEntry : string * string * System.Diagnostics.EventLogEntryType * int * int16 * byte[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEntry (source, message, type, eventID, category, rawData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" />
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="type" Type="System.Diagnostics.EventLogEntryType" />
        <Parameter Name="eventID" Type="System.Int32" />
        <Parameter Name="category" Type="System.Int16" />
        <Parameter Name="rawData" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="source">应用程序在指定计算机上注册时所采用的源。</param>
        <param name="message">要写入事件日志的字符串。</param>
        <param name="type"><see cref="T:System.Diagnostics.EventLogEntryType" /> 值之一。</param>
        <param name="eventID">事件的应用程序特定标识符。</param>
        <param name="category">与消息关联的应用程序特定子类别。</param>
        <param name="rawData">包含与此项关联的二进制数据的字节数组。</param>
        <summary>（使用指定的注册事件源）将一个包含给定消息文本、应用程序定义的事件标识符和应用程序定义的类别的项写入事件日志，并向消息追加二进制数据。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以将应用程序定义的特定于事件的数据写入事件日志, 使用已注册为相应日志的事件源的源。 事件查看器不会解释此数据;它仅以组合的十六进制和文本格式显示原始数据。 谨慎使用特定于事件的数据;仅当你确定它将有用时才包含它。 你还可以使用特定于事件的数据存储应用程序可以独立于事件查看器处理的信息。 例如, 您可以专门为您的事件编写查看器, 或者编写一个程序来扫描日志文件, 并创建包含特定于事件的数据的信息的报表。  
  
 除了二进制数据之外, 还可以指定应用程序定义的类别和应用程序定义的事件标识符。 事件查看器使用类别来筛选由事件源写入的事件。 事件查看器可以将类别显示为数值, 也可以将类别用作资源标识符以显示本地化的类别字符串。  
  
> [!NOTE]
>  `category`参数应为正值。 负类别值显示为事件查看器中的互补正数。 例如,-10 将显示为 65526, 将-1 显示为65535。  
  
 若要在事件查看器中显示本地化的类别字符串, 必须使用配置有类别资源文件的事件源, 并将设置`category`为类别资源文件中的资源标识符。 如果事件源没有已配置的类别资源文件, 或者指定`category`的不为类别资源文件中的字符串编制索引, 则事件查看器将显示该条目的数字类别值。 <xref:System.Diagnostics.EventLogInstaller> 使用<xref:System.Diagnostics.EventSourceCreationData>或类配置类别资源文件以及资源文件中的类别字符串的数目。  
  
 事件标识符与事件源一起唯一标识事件。 每个应用程序都可以定义自己的编号事件以及它们映射到的描述字符串。 事件查看器显示这些字符串值, 以帮助用户了解发生了什么问题, 并建议采取什么操作。  
  
 最后, 你可以<xref:System.Diagnostics.EventLogEntryType>为写入事件日志的事件指定。 `type`用于日志的事件查看器中的 "类型" 列中的图标和文本指示。 此参数指示事件类型是否为错误、警告、信息、成功审核或失败审核。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 <xref:System.Diagnostics.EventLog.WriteEntry%2A>方法将给定字符串直接写入事件日志; 它不使用可本地化的消息资源文件。 <xref:System.Diagnostics.EventLog.WriteEvent%2A>使用方法可使用本地化消息资源文件编写事件。  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  `message`如果参数包含 nul 字符, 则事件日志中的消息将以 nul 字符终止。  
>   
>  字符串不能包含%*n*, 其中 n 是一个整数值 (例如,% 1), 因为事件查看器将其视为插入字符串。  `message` 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
   
  
## Examples  
 [!code-cpp[EventLog_WriteEntry_1_3#2](~/samples/snippets/cpp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CPP/eventlog_writeentry_1_3.cpp#2)]
 [!code-csharp[EventLog_WriteEntry_1_3#2](~/samples/snippets/csharp/VS_Snippets_CLR/EventLog_WriteEntry_1_3/CS/eventlog_writeentry_1_3.cs#2)]
 [!code-vb[EventLog_WriteEntry_1_3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventLog_WriteEntry_1_3/VB/eventlog_writeentry_1_3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
- 或 - 
<paramref name="source" /> 值为 <see langword="null" />。  
  
或 
 <paramref name="eventID" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
消息字符串长于 31,839 字节（在 Windows Vista 之前，在 Windows 操作系统上为 32,766 字节)。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><paramref name="type" /> 不是有效的 <see cref="T:System.Diagnostics.EventLogEntryType" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="T:System.Diagnostics.EventLogEntryType" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="M:System.Diagnostics.EventLog.DeleteEventSource(System.String)" />
        <altmember cref="M:System.Diagnostics.EventLog.SourceExists(System.String)" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteEvent">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>向事件日志写入本地化事件项。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>向事件日志写入本地化项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可将本地化项写入事件日志。 用资源标识符而不是字符串值指定事件属性。 事件查看器使用资源标识符显示的本地化资源文件<xref:System.Diagnostics.EventLog.Source%2A>中的相应字符串。 必须先向相应的资源文件注册源, 然后才能使用资源标识符编写事件。  
  
 输入`instance`实例指定事件消息和属性。 设置源消息资源文件中已定义消息的输入的。`instance` <xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A> `instance`输入<xref:System.Diagnostics.EventInstance.EntryType%2A>的和, 以定义事件项的类别和事件类型。 还可以指定要插入到本地化消息文本中的与语言无关的字符串数组。 如果`values`事件`null`消息不包含替换字符串的格式设置占位符, 则设置为。  
  
 使用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.Source%2A> 之前,必须在组件<xref:System.Diagnostics.EventLog.WriteEvent%2A>上设置属性。 指定的源必须配置为将本地化项写入日志;源必须至少定义了一个消息资源文件。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果你的应用程序将字符串值直接写入事件日志, 请使用方法。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  如果将条目写入远程计算机, 则如果远程计算机未运行 .NET Framework `message` , 则字符串的值可能不是预期的值。 而且, 该`message`字符串不能包含%*n*, 其中*n*是一个整数值 (例如% 1), 因为事件查看器将其视为插入字符串。 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
   
  
## Examples  
 下面的示例将两个审核项写入事件日志`myNewLog`。 该示例创建一个新的事件源和一个新的事件日志 (如果它们不存在于本地计算机上)。 使用资源文件中的资源标识符指定事件消息文本。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 该示例使用资源库 EventLogMsgs 中内置的以下消息文本文件。 消息文本文件是从中创建消息资源文件的源。 消息文本文件定义类别、事件消息和参数插入字符串的资源标识符和文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
或 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
或 
已为其他事件日志注册了该源。  
  
- 或 - 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
 <paramref name="values" /> 超过了 256 个元素。  
  
- 或 - 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public void WriteEvent (System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteEvent(class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteEvent (instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteEvent(System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="member this.WriteEvent : System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="eventLog.WriteEvent (instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="data">包含与此项关联的二进制数据的字节数组。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>写入包含给定的事件数据、消息替换字符串和关联的二进制数据的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可以向事件日志写入包含附加事件特定数据的本地化项。 用资源标识符而不是字符串值指定事件属性。 事件查看器使用资源标识符显示的本地化资源文件<xref:System.Diagnostics.EventLog.Source%2A>中的相应字符串。 必须先向相应的资源文件注册源, 然后才能使用资源标识符编写事件。  
  
 输入`instance`实例指定事件消息和属性。 设置源消息资源文件中已定义消息的输入的。`instance` <xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A> `instance`输入<xref:System.Diagnostics.EventInstance.EntryType%2A>的和, 以定义事件项的类别和事件类型。 还可以指定要插入到本地化消息文本中的与语言无关的字符串数组。 如果`values`事件`null`消息不包含替换字符串的格式设置占位符, 则设置为。  
  
 如果有必要提供事件的更多详细信息, 请指定包含事件的二进制数据。 例如, 使用`data`参数包含有关特定错误的信息。 事件查看器不解释关联的事件数据;它以组合的十六进制和文本格式显示数据。 谨慎使用特定于事件的数据;仅当你确定它将有用时才包含它。 你还可以使用特定于事件的数据存储应用程序可以独立于事件查看器处理的信息。 例如, 您可以专门为您的事件编写查看器, 或编写扫描事件日志的程序, 并创建包含特定于事件的数据的信息的报表。  
  
 使用<xref:System.Diagnostics.EventLog> <xref:System.Diagnostics.EventLog.Source%2A> 之前,必须先在组件之前设置<xref:System.Diagnostics.EventLog.WriteEvent%2A>组件的属性。 指定的源必须配置为将本地化项写入日志;源必须至少定义了一个消息资源文件。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
> [!NOTE]
>  如果在调用<xref:System.Diagnostics.EventLog.MachineName%2A> <xref:System.Diagnostics.EventLog> 之前未为实例指定,则假定为本地计算机("<xref:System.Diagnostics.EventLog.WriteEvent%2A>.")。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果你的应用程序将字符串值直接写入事件日志, 请使用方法。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
> [!NOTE]
>  如果将条目写入远程计算机, 则如果远程计算机未运行 .NET Framework `message` , 则字符串的值可能不是预期的值。 而且, 该`message`字符串不能包含%*n*, 其中*n*是一个整数值 (例如% 1), 因为事件查看器将其视为插入字符串。 由于 Internet 协议版本 6 (IPv6) 地址可以包含此字符序列, 因此无法记录包含 IPv6 地址的事件消息。  
  
   
  
## Examples  
 下面的示例将两个审核项写入事件日志`myNewLog`。 该示例创建一个新的事件源和一个新的事件日志 (如果它们不存在于本地计算机上)。 使用资源文件中的资源标识符指定事件消息文本。  
  
 [!code-cpp[EventLog_WriteEvent#7](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#7)]
 [!code-csharp[EventLog_WriteEvent#7](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#7)]
 [!code-vb[EventLog_WriteEvent#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#7)]  
  
 该示例使用资源库 EventLogMsgs 中内置的以下消息文本文件。 消息文本文件是从中创建消息资源文件的源。 消息文本文件定义类别、事件消息和参数插入字符串的资源标识符和文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><see cref="P:System.Diagnostics.EventLog.Source" /> 的 <see cref="T:System.Diagnostics.EventLog" /> 属性尚未设置。  
  
- 或 - 
该方法尝试注册新的事件源，但 <see cref="P:System.Diagnostics.EventLog.MachineName" /> 中的计算机名称无效。  
  
或 
已为其他事件日志注册了该源。  
  
或 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
 <paramref name="values" /> 超过了 256 个元素。  
  
或 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
- 或 - 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">在指定的计算机上为应用程序注册的事件源的名称。</param>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>使用指定的已注册事件源写入包含给定事件数据和消息替换字符串的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法可将本地化项写入事件日志, 使用已注册为相应日志的事件源的源。 用资源标识符而不是字符串值指定事件属性。 事件查看器使用资源标识符显示源的本地化资源文件中的相应字符串。 必须先向相应的资源文件注册源, 然后才能使用资源标识符编写事件。  
  
 输入`instance`实例指定事件消息和属性。 设置源消息资源文件中已定义消息的输入的。`instance` <xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A> `instance`输入<xref:System.Diagnostics.EventInstance.EntryType%2A>的和, 以定义事件项的类别和事件类型。 还可以指定要插入到本地化消息文本中的与语言无关的字符串数组。 如果`values`事件`null`消息不包含替换字符串的格式设置占位符, 则设置为。  
  
 在使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>之前, 必须为事件日志注册指定的源。 指定的源必须配置为将本地化项写入日志;源必须至少定义了一个消息资源文件。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果你的应用程序将字符串值直接写入事件日志, 请使用方法。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
   
  
## Examples  
 下面的示例将信息性事件项和警告事件项写入现有的事件日志。 使用资源文件中的资源标识符指定事件消息文本。 该示例假设已为源注册了相应的资源文件。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 该示例使用资源库 EventLogMsgs 中内置的以下消息文本文件。 消息文本文件是从中创建消息资源文件的源。 消息文本文件定义类别、事件消息和参数插入字符串的资源标识符和文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
或 
<paramref name="source" /> 值为 <see langword="null" />。  
  
或 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
或 
 <paramref name="values" /> 超过了 256 个元素。  
  
或 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
    <Member MemberName="WriteEvent">
      <MemberSignature Language="C#" Value="public static void WriteEvent (string source, System.Diagnostics.EventInstance instance, byte[] data, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteEvent(string source, class System.Diagnostics.EventInstance instance, unsigned int8[] data, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.EventLog.WriteEvent(System.String,System.Diagnostics.EventInstance,System.Byte[],System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteEvent (source As String, instance As EventInstance, data As Byte(), ParamArray values As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteEvent(System::String ^ source, System::Diagnostics::EventInstance ^ instance, cli::array &lt;System::Byte&gt; ^ data, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member WriteEvent : string * System.Diagnostics.EventInstance * byte[] * obj[] -&gt; unit" Usage="System.Diagnostics.EventLog.WriteEvent (source, instance, data, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.EventLog</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="instance" Type="System.Diagnostics.EventInstance" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="data" Type="System.Byte[]" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="3" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">在指定的计算机上为应用程序注册的事件源的名称。</param>
        <param name="instance">表示本地化事件日志项的 <see cref="T:System.Diagnostics.EventInstance" /> 实例。</param>
        <param name="data">包含与此项关联的二进制数据的字节数组。</param>
        <param name="values">要合并到事件日志项的消息文本中的字符串数组。</param>
        <summary>使用指定的已注册事件源，写入包含给定的事件数据、消息替换字符串和关联的二进制数据的事件日志项。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用此方法, 使用已注册为相应日志的事件源的源, 将具有附加事件特定数据的本地化项写入事件日志。 用资源标识符而不是字符串值指定事件属性。 事件查看器使用资源标识符显示源的本地化资源文件中的相应字符串。 必须先向相应的资源文件注册源, 然后才能使用资源标识符编写事件。  
  
 输入`instance`实例指定事件消息和属性。 设置源消息资源文件中已定义消息的输入的。`instance` <xref:System.Diagnostics.EventInstance.InstanceId%2A> 您可以选择性地设置<xref:System.Diagnostics.EventInstance.CategoryId%2A> `instance`输入<xref:System.Diagnostics.EventInstance.EntryType%2A>的和, 以定义事件项的类别和事件类型。 还可以指定要插入到本地化消息文本中的与语言无关的字符串数组。 如果`values`事件`null`消息不包含替换字符串的格式设置占位符, 则设置为。  
  
 如果有必要提供事件的更多详细信息, 请指定包含事件的二进制数据。 例如, 使用`data`参数包含有关特定错误的信息。 事件查看器不解释关联的事件数据;它以组合的十六进制和文本格式显示数据。 谨慎使用特定于事件的数据;仅当你确定它将有用时才包含它。 你还可以使用特定于事件的数据存储应用程序可以独立于事件查看器处理的信息。 例如, 您可以专门为您的事件编写查看器, 或编写扫描事件日志的程序, 并创建包含特定于事件的数据的信息的报表。  
  
 在使用<xref:System.Diagnostics.EventLog.WriteEvent%2A>之前, 必须为事件日志注册指定的源。 指定的源必须配置为将本地化项写入日志;源必须至少定义了一个消息资源文件。  
  
 在写入包含源的第一个条目之前, 必须创建并配置事件源。 在应用程序安装过程中创建新的事件源。 这样, 操作系统就可以刷新其已注册的事件源的列表及其配置。 如果操作系统尚未刷新其事件源列表, 而你尝试使用新源写入事件, 则写入操作将失败。 您可以使用<xref:System.Diagnostics.EventLogInstaller>或<xref:System.Diagnostics.EventLog.CreateEventSource%2A>方法来配置新源。 您必须对该计算机具有管理权限才能创建新的事件源。  
  
 源必须配置为写入本地化项或写入直接字符串。 如果你的应用程序将字符串值直接写入事件日志, 请使用方法。<xref:System.Diagnostics.EventLog.WriteEntry%2A>  
  
 如果应用程序使用资源标识符和字符串值写入条目, 则必须注册两个不同的源。 例如, 使用资源文件配置一个源, 然后在<xref:System.Diagnostics.EventLog.WriteEvent%2A>方法中使用该源, 将使用资源标识符的项写入事件日志。 然后, 创建一个没有资源文件的不同源, 并在<xref:System.Diagnostics.EventLog.WriteEntry%2A>方法中使用该源, 使用该源直接将字符串写入事件日志。  
  
   
  
## Examples  
 下面的示例将信息性事件项和警告事件项写入现有的事件日志。 使用资源文件中的资源标识符指定事件消息文本。 该示例假设已为源注册了相应的资源文件。  
  
 [!code-cpp[EventLog_WriteEvent#8](~/samples/snippets/cpp/VS_Snippets_CLR/eventlog_WriteEvent/CPP/source.cpp#8)]
 [!code-csharp[EventLog_WriteEvent#8](~/samples/snippets/csharp/VS_Snippets_CLR/eventlog_WriteEvent/CS/source.cs#8)]
 [!code-vb[EventLog_WriteEvent#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/eventlog_WriteEvent/VB/source.vb#8)]  
  
 该示例使用资源库 EventLogMsgs 中内置的以下消息文本文件。 消息文本文件是从中创建消息资源文件的源。 消息文本文件定义类别、事件消息和参数插入字符串的资源标识符和文本。  
  
```  
; // EventLogMsgs.mc  
; // ********************************************************  
  
; // Use the following commands to build this file:  
  
; //   mc -s EventLogMsgs.mc  
; //   rc EventLogMsgs.rc  
; //   link /DLL /SUBSYSTEM:WINDOWS /NOENTRY /MACHINE:x86 EventLogMsgs.Res   
; // ********************************************************  
  
; // - Event categories -  
; // Categories must be numbered consecutively starting at 1.  
; // ********************************************************  
  
MessageId=0x1  
Severity=Success  
SymbolicName=INSTALL_CATEGORY  
Language=English  
Installation  
.  
  
MessageId=0x2  
Severity=Success  
SymbolicName=QUERY_CATEGORY  
Language=English  
Database Query  
.  
  
MessageId=0x3  
Severity=Success  
SymbolicName=REFRESH_CATEGORY  
Language=English  
Data Refresh  
.  
  
; // - Event messages -  
; // *********************************  
  
MessageId = 1000  
Severity = Success  
Facility = Application  
SymbolicName = AUDIT_SUCCESS_MESSAGE_ID_1000  
Language=English  
My application message text, in English, for message id 1000, called from %1.  
.  
  
MessageId = 1001  
Severity = Warning  
Facility = Application  
SymbolicName = AUDIT_FAILED_MESSAGE_ID_1001  
Language=English  
My application message text, in English, for message id 1001, called from %1.  
.  
  
MessageId = 1002  
Severity = Success  
Facility = Application  
SymbolicName = GENERIC_INFO_MESSAGE_ID_1002  
Language=English  
My generic information message in English, for message id 1002.  
.  
  
MessageId = 1003  
Severity = Warning  
Facility = Application  
SymbolicName = GENERIC_WARNING_MESSAGE_ID_1003  
Language=English  
My generic warning message in English, for message id 1003, called from %1.  
.  
  
MessageId = 1004  
Severity = Success  
Facility = Application  
SymbolicName = UPDATE_CYCLE_COMPLETE_MESSAGE_ID_1004  
Language=English  
The update cycle is complete for %%5002.  
.  
  
MessageId = 1005  
Severity = Warning  
Facility = Application  
SymbolicName = SERVER_CONNECTION_DOWN_MESSAGE_ID_1005  
Language=English  
The refresh operation did not complete because the connection to server %1 could not be established.  
.  
  
; // - Event log display name -  
; // ********************************************************  
  
MessageId = 5001  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_DISPLAY_NAME_MSGID  
Language=English  
Sample Event Log  
.  
  
; // - Event message parameters -  
; //   Language independent insertion strings  
; // ********************************************************  
  
MessageId = 5002  
Severity = Success  
Facility = Application  
SymbolicName = EVENT_LOG_SERVICE_NAME_MSGID  
Language=English  
SVC_UPDATE.EXE  
.  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="source" /> 值是空字符串 ("")。  
  
或 
<paramref name="source" /> 值为 <see langword="null" />。  
  
或 
 <paramref name="instance.InstanceId" /> 小于零或大于 <see cref="F:System.UInt16.MaxValue" />。  
  
- 或 - 
 <paramref name="values" /> 超过了 256 个元素。  
  
- 或 - 
<paramref name="values" /> 元素中有一个超过了 32766 个字节。  
  
或 
此源名称导致注册表项路径的长度超过 254 个字符。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="instance" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.InvalidOperationException">事件日志的注册表项未能打开。</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">将事件项写入事件日志时，操作系统报告了一个错误。 一个 Windows 错误代码不可用。</exception>
        <permission cref="T:System.Diagnostics.EventLogPermission">用于写入计算机上的事件日志信息。 关联的枚举:<see cref="F:System.Diagnostics.EventLogPermissionAccess.Write" /></permission>
        <altmember cref="Overload:System.Diagnostics.EventLog.CreateEventSource" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="P:System.Diagnostics.EventLog.Entries" />
        <altmember cref="T:System.Diagnostics.EventInstance" />
      </Docs>
    </Member>
  </Members>
</Type>
