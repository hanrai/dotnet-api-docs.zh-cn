<Type Name="LockRecursionPolicy" FullName="System.Threading.LockRecursionPolicy">
  <Metadata><Meta Name="ms.openlocfilehash" Value="10f198950a05a65cdcb41789afb11fd7ff96c016" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69144113" /></Metadata><TypeSignature Language="C#" Value="public enum LockRecursionPolicy" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed LockRecursionPolicy extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LockRecursionPolicy" />
  <TypeSignature Language="VB.NET" Value="Public Enum LockRecursionPolicy" />
  <TypeSignature Language="C++ CLI" Value="public enum class LockRecursionPolicy" />
  <TypeSignature Language="F#" Value="type LockRecursionPolicy = " />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Docs>
    <summary><span data-ttu-id="551c2-101">指定同一个线程是否可以多次进入一个锁定状态。</span><span class="sxs-lookup"><span data-stu-id="551c2-101">Specifies whether a lock can be entered multiple times by the same thread.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="551c2-102">默认递归策略取决于锁的类型。</span><span class="sxs-lookup"><span data-stu-id="551c2-102">The default recursion policy depends on the type of lock.</span></span> <span data-ttu-id="551c2-103">对于任何给定锁类型的默认策略和锁递归的精确行为, 请参阅类型的文档。</span><span class="sxs-lookup"><span data-stu-id="551c2-103">For the default policy and the precise behavior of lock recursion for any given lock type, see the documentation for the type.</span></span> <span data-ttu-id="551c2-104">例如, <xref:System.Threading.ReaderWriterLockSlim>如果某个线程已进入读取模式锁定状态, 则该类不允许线程进入写入模式锁定状态, 这种情况下, 不考虑锁定策略设置, 从而减少死锁的几率。</span><span class="sxs-lookup"><span data-stu-id="551c2-104">For example, the <xref:System.Threading.ReaderWriterLockSlim> class does not allow a thread to enter the lock in write mode if it already entered the lock in read mode, regardless of the lock policy setting, in order to reduce the chance of deadlocks.</span></span>  
  
 <span data-ttu-id="551c2-105">目前只有一个锁使用此枚举:</span><span class="sxs-lookup"><span data-stu-id="551c2-105">Currently only one lock uses this enumeration:</span></span>  
  
-   <span data-ttu-id="551c2-106"><xref:System.Threading.ReaderWriterLockSlim>。</span><span class="sxs-lookup"><span data-stu-id="551c2-106"><xref:System.Threading.ReaderWriterLockSlim>.</span></span> <span data-ttu-id="551c2-107">有关更多信息，请参见 <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> 属性。</span><span class="sxs-lookup"><span data-stu-id="551c2-107">For more information, see the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="551c2-108">下面的示例演示两个异常方案, 一个依赖于设置<xref:System.Threading.LockRecursionPolicy> , 另一个不是。</span><span class="sxs-lookup"><span data-stu-id="551c2-108">The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.</span></span>  
  
 <span data-ttu-id="551c2-109">在第一个方案中, 线程进入读取模式锁定状态, 然后尝试以递归方式进入读取模式。</span><span class="sxs-lookup"><span data-stu-id="551c2-109">In the first scenario, the thread enters the lock in read mode and then tries to enter read mode recursively.</span></span> <span data-ttu-id="551c2-110"><xref:System.Threading.ReaderWriterLockSlim>如果是使用无参数构造函数创建的, 而该构造函数将递归策略设置为 NoRecursion, 则会引发异常。</span><span class="sxs-lookup"><span data-stu-id="551c2-110">If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the parameterless constructor, which sets recursion policy to NoRecursion, an exception is thrown.</span></span> <span data-ttu-id="551c2-111">如果使用 SupportsRecursion 创建<xref:System.Threading.ReaderWriterLockSlim>, 则不会引发异常。</span><span class="sxs-lookup"><span data-stu-id="551c2-111">If SupportsRecursion is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.</span></span>  
  
 <span data-ttu-id="551c2-112">在第二种情况下, 线程进入读取模式锁定状态, 然后尝试进入写入模式锁定状态。</span><span class="sxs-lookup"><span data-stu-id="551c2-112">In the second scenario, the thread enters the lock in read mode and then tries to enter the lock in write mode.</span></span> <span data-ttu-id="551c2-113"><xref:System.Threading.LockRecursionException>无论锁递归策略如何, 都将引发。</span><span class="sxs-lookup"><span data-stu-id="551c2-113"><xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.</span></span>  
  
 [!code-csharp[System.Threading.LockRecursionPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/example1.cs#1)]
 [!code-vb[System.Threading.LockRecursionPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="NoRecursion">
      <MemberSignature Language="C#" Value="NoRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy NoRecursion = int32(0)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.NoRecursion" />
      <MemberSignature Language="VB.NET" Value="NoRecursion" />
      <MemberSignature Language="C++ CLI" Value="NoRecursion" />
      <MemberSignature Language="F#" Value="NoRecursion = 0" Usage="System.Threading.LockRecursionPolicy.NoRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary><span data-ttu-id="551c2-114">如果线程尝试以递归方式进入锁定状态，将引发异常。</span><span class="sxs-lookup"><span data-stu-id="551c2-114">If a thread tries to enter a lock recursively, an exception is thrown.</span></span> <span data-ttu-id="551c2-115">某些类可能会在此设置生效时允许使用特定的递归方式。</span><span class="sxs-lookup"><span data-stu-id="551c2-115">Some classes may allow certain recursions when this setting is in effect.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="SupportsRecursion">
      <MemberSignature Language="C#" Value="SupportsRecursion" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Threading.LockRecursionPolicy SupportsRecursion = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.LockRecursionPolicy.SupportsRecursion" />
      <MemberSignature Language="VB.NET" Value="SupportsRecursion" />
      <MemberSignature Language="C++ CLI" Value="SupportsRecursion" />
      <MemberSignature Language="F#" Value="SupportsRecursion = 1" Usage="System.Threading.LockRecursionPolicy.SupportsRecursion" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockRecursionPolicy</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="551c2-116">线程可以采用递归方式进入锁定状态。</span><span class="sxs-lookup"><span data-stu-id="551c2-116">A thread can enter a lock recursively.</span></span> <span data-ttu-id="551c2-117">某些类可能会限制此功能。</span><span class="sxs-lookup"><span data-stu-id="551c2-117">Some classes may restrict this capability.</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>
