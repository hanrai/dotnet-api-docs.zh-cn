<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8063b9e725920384ee53d2c274685bfa60015f9f" /><Meta Name="ms.sourcegitcommit" Value="634678f7ccd2928c6b2cf792a301b079b63639af" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="zh-CN" /><Meta Name="ms.lasthandoff" Value="07/26/2019" /><Meta Name="ms.locfileid" Value="68541848" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>提供一个线程池，该线程池可用于执行任务、发送工作项、处理异步 I/O、代表其他线程等待以及处理计时器。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 许多应用程序创建线程, 在休眠状态中花费大量时间等待事件发生。 其他线程可能会进入休眠状态, 只需要定期唤醒才能轮询更改或更新状态信息。 使用线程池, 可以通过向应用程序提供由系统管理的工作线程池, 来更有效地使用线程。 使用线程池线程的操作示例包括:  
  
-   当你创建<xref:System.Threading.Tasks.Task>或<xref:System.Threading.Tasks.Task%601>对象以异步执行某些任务时, 默认情况下, 任务计划在线程池线程上运行。  
  
-   异步计时器使用线程池。 线程池线程执行来自类的<xref:System.Threading.Timer?displayProperty=nameWithType>回调并引发来自类的<xref:System.Timers.Timer?displayProperty=nameWithType>事件。  
  
-   使用已注册的等待句柄时, 系统线程会监视等待句柄的状态。 等待操作完成后, 线程池中的工作线程会执行相应的回调函数。  
  
-   调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法以将方法排队以便在线程池线程上执行。 为<xref:System.Threading.WaitCallback>此, 可将方法传递给委托。   委托具有签名  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     其中`state` , 是包含要由委托使用的数据的对象。 通过调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>方法, 可以将实际数据传递到委托。  
  
> [!NOTE]
>  托管线程池中的线程是后台线程。 也就是说, 其<xref:System.Threading.Thread.IsBackground%2A>属性为`true`。 这意味着, 在<xref:System.Threading.ThreadPool>所有前台线程退出后, 线程不会使应用程序保持运行。  
  
> [!IMPORTANT]
>  当线程池重用某个线程时, 它不会清除线程本地存储区中的数据或用<xref:System.ThreadStaticAttribute>特性标记的字段中的数据。 因此, 当某个方法检查线程本地存储区或用<xref:System.ThreadStaticAttribute>特性标记的字段时, 它所找到的值可能会从先前使用线程池线程的过程中遗留。  
  
 你还可以将与等待操作无关的工作项排队到线程池。 若要请求由线程池中的线程处理工作项, 请调用<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>方法。 此方法将引用从线程池中选择的线程调用的方法或委托作为参数。 在工作项排队后, 无法取消该工作项。  
  
 计时器-队列计时器和已注册的等待操作也使用线程池。 它们的回调函数将排队到线程池。  
  
 每个进程都有一个线程池。 从 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] 开始，进程的线程池的默认大小取决于若干因素，例如虚拟地址空间的大小。 进程可以调用 <xref:System.Threading.ThreadPool.GetMaxThreads%2A> 方法，以确定线程数。 可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>方法更改线程池中的线程数。 每个线程都使用默认堆栈大小, 并按默认优先级运行。  
  
> [!NOTE]
>  承载 .NET Framework 的非托管代码可以使用在 mscoree.dll 文件中定义的`CorSetMaxThreads`函数更改线程池的大小。  
  
 线程池按需提供新的工作线程或 i/o 完成线程, 直到达到每个类别的最小值。 达到最小值时, 线程池可以在该类别中创建更多的线程, 或等待某些任务完成。 从 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 开始，线程池创建和销毁工作线程以优化吞吐量，吞吐量被定义为每个单位时间完成的任务数。 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
> [!NOTE]
>  需求较低时，线程池线程的实际数量可以低于最小值。  
  
 可以使用 <xref:System.Threading.ThreadPool.GetMinThreads%2A> 方法来获取这些最小值。  
  
> [!CAUTION]
>  您可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小线程数。 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，则所有任务均可能会很慢。 大多数情况下，使用自己的分配线程算法，线程池将更好地执行任务。  
  
   
  
## Examples  
 在下面的示例中, 主应用程序线程将一个名`ThreadProc`为的方法排队, 使其在线程池线程上执行, 休眠一秒钟, 然后退出。 `ThreadProc`方法只是显示一条消息。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 如果注释掉对<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>方法的调用, 则在线程池线程上运行方法之前, 主线程将退出。  线程池使用后台线程, 如果所有前台线程均已终止, 则不会使应用程序保持运行。  (这是争用条件的一个简单示例。)  
  
 ]]></format>
    </remarks>
    <threadsafe>此类型是线程安全的。</threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md">线程与线程处理</related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="osHandle">持有句柄的 <see cref="T:System.IntPtr" />。 在非托管端必须为重叠 I/O 打开该句柄。</param>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于调用非托管代码。 关联的枚举<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />:。</permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="osHandle">保存操作系统句柄的 <see cref="T:System.Runtime.InteropServices.SafeHandle" />。 在非托管端必须为重叠 I/O 打开该句柄。</param>
        <summary>将操作系统句柄绑定到 <see cref="T:System.Threading.ThreadPool" />。</summary>
        <returns>如果绑定了句柄，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参数应为从抽象<xref:System.Runtime.InteropServices.SafeHandle>类派生的。 <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> `osHandle`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="osHandle" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于调用非托管代码。 关联枚举：<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />。</permission>
      </Docs>
    </Member>
    <Member MemberName="CompletedWorkItemCount">
      <MemberSignature Language="C#" Value="public static long CompletedWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 CompletedWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompletedWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long CompletedWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CompletedWorkItemCount : int64" Usage="System.Threading.ThreadPool.CompletedWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取迄今为止已处理的工作项数。</summary>
        <value>到目前为止已处理的工作项的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

如果线程池实现可能具有不同类型的工作项, 则计数将包括所有类型。

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">可用辅助线程的数目。</param>
        <param name="completionPortThreads">可用异步 I/O 线程的数目。</param>
        <summary>检索由 <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> 方法返回的最大线程池线程数和当前活动线程数之间的差值。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Threading.ThreadPool.GetAvailableThreads%2A>返回时, 由`workerThreads`指定的变量包含可启动的附加工作线程的数目, 并且由`completionPortThreads`指定的变量包含其他可首先.  
  
 如果没有可用的线程, 附加的线程池请求将保持排队状态, 直到线程池线程变为可用。  
  
   
  
## Examples  
 下面的示例显示了启动简单应用时可用的工作线程和 i/o 线程的数目。  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">线程池中辅助线程的最大数目。</param>
        <param name="completionPortThreads">线程池中异步 I/O 线程的最大数目。</param>
        <summary>检索可以同时处于活动状态的线程池请求的数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 当<xref:System.Threading.ThreadPool.GetMaxThreads%2A>返回时, 由`workerThreads`指定的变量包含线程池中允许的最大工作线程数, 由`completionPortThreads`指定的变量包含允许在线程池。  
  
 在任意给定时间<xref:System.Threading.ThreadPool.GetAvailableThreads%2A> , 都可以使用方法来确定线程池中的实际线程数。  
  
 你可以使用<xref:System.Threading.ThreadPool.SetMaxThreads%2A>来设置线程池中的最大工作线程数和异步 i/o 线程数。  
  
 可以将任意数量的线程池请求排队, 因为系统内存允许。 如果请求数超过线程池线程数, 则在线程池线程变得可用之前, 附加请求将保持排队。  
  
   
  
## Examples  
 下面的代码示例演示如何检索线程池中的最大和可用线程数的计数。 将使用`FileStream`异步写入两个文件的工作项排队。 回调方法被计时为重叠。 工作线程处理工作项, 并根据计算机上的处理器速度和数量, 一个或两个完成端口线程处理写入操作。  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">当此方法返回时，将包含线程池根据需要创建的最少数量的辅助线程。</param>
        <param name="completionPortThreads">当此方法返回时，将包含线程池根据需要创建的最少数量的异步 I/O 线程。</param>
        <summary>发出新的请求时，在切换到管理线程创建和销毁的算法之前检索线程池按需创建的线程的最小数量。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程池按需提供新的工作线程或 i/o 完成线程, 直到达到每个类别的最小值。 默认情况下, 最小线程数设置为系统上的处理器数。 达到最小值时, 线程池可以在该类别中创建更多的线程, 或等待某些任务完成。 从开始, 线程池创建并销毁线程, 以优化吞吐量, 定义为每个时间单位完成的任务数。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
> [!NOTE]
>  需求较低时，线程池线程的实际数量可以低于最小值。  
  
   
  
## Examples  
 下面的示例将最小工作线程数设置为 4, 并保留最小异步 i/o 完成线程数的原始值。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="PendingWorkItemCount">
      <MemberSignature Language="C#" Value="public static long PendingWorkItemCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 PendingWorkItemCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property PendingWorkItemCount As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long PendingWorkItemCount { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PendingWorkItemCount : int64" Usage="System.Threading.ThreadPool.PendingWorkItemCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前已加入处理队列的工作项数。</summary>
        <value>当前排队等候处理的工作项的数目。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

如果线程池实现可能具有不同类型的工作项, 则计数将包括可以跟踪的所有类型, 这些类型只能是用户工作项 (包括任务)。 某些实现可能还包括队列中的计时器和等待回调。 在 Windows 上, 计数不太可能包含挂起的 IO 完成次数, 因为它们直接发送到 IO 完成端口。

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>将方法排入队列以便执行。 此方法在有线程池线程变得可用时执行。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack">一个 <see cref="T:System.Threading.WaitCallback" />，表示要执行的方法。</param>
        <summary>将方法排入队列以便执行。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可以在定义方法的类的实例字段中放置排队方法所需的数据, 也可以使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29>接受包含所需数据的对象的重载。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数, 并且只需在将回调方法传递给<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>时`AddressOf`使用运算符。 Visual Basic 自动调用正确的委托构造函数。  
  
## <a name="version-information"></a>版本信息  
 在 .NET Framework 版本2.0 中, 属性<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>值将传播到<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>使用方法排队的工作线程。 在早期版本中, 不传播主体信息。  
  
   
  
## Examples  
 下面的示例使用<xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29>方法重载对任务进行排队, 该任务`ThreadProc`由方法表示, 以便在线程变为可用时执行。 此重载未提供任何任务信息。 因此, 可用于`ThreadProc`方法的信息仅限于该方法所属的对象。  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">承载公共语言运行时 (CLR) 的宿主不支持此操作。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><see cref="T:System.Threading.WaitCallback" />，它表示要执行的方法。</param>
        <param name="state">包含方法所用数据的对象。</param>
        <summary>将方法排入队列以便执行，并指定包含该方法所用数据的对象。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 如果回调方法需要复杂数据, 则可以定义一个包含数据的类。  
  
> [!NOTE]
>  Visual Basic 用户可以省略<xref:System.Threading.WaitCallback>构造函数, 并且只需在将回调方法传递给<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>时`AddressOf`使用运算符。 Visual Basic 自动调用正确的委托构造函数。  
  
## <a name="version-information"></a>版本信息  
 在 .NET Framework 版本2.0 中, 属性<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>值将传播到<xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>使用方法排队的工作线程。 在早期版本中, 不传播主体信息。  
  
   
  
## Examples  
 下面的示例使用 .net 线程池来计算介于 20 `Fibonacci`和40之间的5个数字的结果。 每个 `Fibonacci` 结果都由 `Fibonacci` 类表示，该类提供一个名为 `ThreadPoolCallback` 的方法，用于执行计算。 创建表示每个 `Fibonacci` 值的对象，并将 `ThreadPoolCallback` 方法传递给 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>，它分配池中的一个可用线程来执行此方法。  
  
 由于为`Fibonacci`每个对象提供了半随机值计算, 并且每个线程都将争用处理器时间, 因此您无法提前知道要计算所有五个结果所需的时间。 这就是在构造期间为每个 `Fibonacci` 对象传递 <xref:System.Threading.ManualResetEvent> 类的一个实例的原因。 在计算完成后, 每个对象都向提供的事件对象发出信号, 这允许主线程阻止<xref:System.Threading.WaitHandle.WaitAll%2A>执行, 直到`Fibonacci`所有五个对象都计算出结果。 然后 `Main` 方法会显示每个 `Fibonacci` 结果。
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">承载公共语言运行时 (CLR) 的宿主不支持此操作。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><paramref name="state" /> 的元素类型。</typeparam>
        <param name="callBack"><see cref="T:System.Action`1" />，它表示要执行的方法。</param>
        <param name="state">包含方法所用数据的对象。</param>
        <param name="preferLocal"><see langword="true" /> 表示首选在靠近当前线程的队列中对工作项进行排队；<see langword="false" /> 则表示首选将工作项排队到线程池的共享队列中。</param>
        <summary>将 <see cref="T:System.Action`1" /> 委托指定的方法排入队列以便执行，并提供该方法使用的数据。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册正在等待 <see cref="T:System.Threading.WaitHandle" /> 的委托。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 32 位有符号整数来表示超时值（以毫秒为单位）。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法将指定的委托排队到线程池。 当发生以下情况之一时, 工作线程将执行委托:  
  
-   指定的对象处于终止状态。  
  
-   超时间隔已过去。  
  
 方法检查指定对象的<xref:System.Threading.WaitHandle>的当前状态。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 如果对象的状态为信号, 则该方法将注册等待操作。 等待操作由线程池中的一个线程执行。 当对象的状态变为 "已终止" 或超时间隔结束时, 工作线程会执行委托。 如果参数不为 0 (零) `executeOnlyOnce` , 并且参数为`false`, 则在每次事件终止或超时间隔结束时, 将重置计时器。 `timeOutInterval`  
  
> [!IMPORTANT]
>  <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。 使用最大计数为1的,而不是。<xref:System.Threading.Mutex> <xref:System.Threading.Semaphore>  
  
 若要取消等待操作, 请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32 `WaitForMultipleObjects`函数监视已注册的等待操作。 因此, 如果必须在多个调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>中使用相同的本机操作系统句柄, 则必须使用 Win32 `DuplicateHandle`函数复制句柄。 请注意, 不应脉冲传递给<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象, 因为等待线程可能检测不到事件在重置前已发出信号。  
  
 在返回之前, 函数会修改某些类型的同步对象的状态。 仅对其终止状态导致等待条件得到满足的对象进行修改。 例如, 信号量的计数减少1。  
  
## <a name="version-information"></a>版本信息  
 从 .NET Framework 版本2.0 开始, 属性值<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>将传播到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>使用方法排队的工作线程。 在早期版本中, 不传播主体信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法将指定的委托排队到线程池。 当发生以下情况之一时, 工作线程将执行委托:  
  
-   指定的对象处于终止状态。  
  
-   超时间隔已过去。  
  
 方法检查指定对象的<xref:System.Threading.WaitHandle>的当前状态。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 如果对象的状态为信号, 则该方法将注册等待操作。 等待操作由线程池中的一个线程执行。 当对象的状态变为 "已终止" 或超时间隔结束时, 工作线程会执行委托。 如果参数不为 0 (零) `executeOnlyOnce` , 并且参数为`false`, 则在每次事件终止或超时间隔结束时, 将重置计时器。 `timeOutInterval`  
  
> [!IMPORTANT]
>  <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。 使用最大计数为1的,而不是。<xref:System.Threading.Mutex> <xref:System.Threading.Semaphore>  
  
 若要取消等待操作, 请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32 `WaitForMultipleObjects`函数监视已注册的等待操作。 因此, 如果必须在多个调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>中使用相同的本机操作系统句柄, 则必须使用 Win32 `DuplicateHandle`函数复制句柄。 请注意, 不应脉冲传递给<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象, 因为等待线程可能检测不到事件在重置前已发出信号。  
  
 在返回之前, 函数会修改某些类型的同步对象的状态。 仅对其终止状态导致等待条件得到满足的对象进行修改。 例如, 信号量的计数减少1。  
  
## <a name="version-information"></a>版本信息  
 从 .NET Framework 版本2.0 开始, 属性值<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>将传播到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>使用方法排队的工作线程。 在早期版本中, 不传播主体信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> 表示的超时时间。 如果 <paramref name="timeout" /> 为 0（零），则函数将测试对象的状态并立即返回。 如果 <paramref name="timeout" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。</summary>
        <returns>封装本机句柄的 <see cref="T:System.Threading.RegisteredWaitHandle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法将指定的委托排队到线程池。 当发生以下情况之一时, 工作线程将执行委托:  
  
-   指定的对象处于终止状态。  
  
-   超时间隔已过去。  
  
 方法检查指定对象的<xref:System.Threading.WaitHandle>的当前状态。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 如果对象的状态为信号, 则该方法将注册等待操作。 等待操作由线程池中的一个线程执行。 当对象的状态变为 "已终止" 或超时间隔结束时, 工作线程会执行委托。 如果参数不为 0 (零) `executeOnlyOnce` , 并且参数为`false`, 则在每次事件终止或超时间隔结束时, 将重置计时器。 `timeOutInterval`  
  
> [!IMPORTANT]
>  <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。 使用最大计数为1的,而不是。<xref:System.Threading.Mutex> <xref:System.Threading.Semaphore>  
  
 若要取消等待操作, 请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32 `WaitForMultipleObjects`函数监视已注册的等待操作。 因此, 如果必须在多个调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>中使用相同的本机操作系统句柄, 则必须使用 Win32 `DuplicateHandle`函数复制句柄。 请注意, 不应脉冲传递给<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象, 因为等待线程可能检测不到事件在重置前已发出信号。  
  
 在返回之前, 函数会修改某些类型的同步对象的状态。 仅对其终止状态导致等待条件得到满足的对象进行修改。 例如, 信号量的计数减少1。  
  
## <a name="version-information"></a>版本信息  
 从 .NET Framework 版本2.0 开始, 属性值<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>将传播到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>使用方法排队的工作线程。 在早期版本中, 不传播主体信息。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 参数小于 -1。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的 <see cref="T:System.Threading.WaitOrTimerCallback" /> 委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" />，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法将指定的委托排队到线程池。 当发生以下情况之一时, 工作线程将执行委托:  
  
-   指定的对象处于终止状态。  
  
-   超时间隔已过去。  
  
 方法检查指定对象的<xref:System.Threading.WaitHandle>的当前状态。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 如果对象的状态为信号, 则该方法将注册等待操作。 等待操作由线程池中的一个线程执行。 当对象的状态变为 "已终止" 或超时间隔结束时, 工作线程会执行委托。 如果参数不为 0 (零) `executeOnlyOnce` , 并且参数为`false`, 则在每次事件终止或超时间隔结束时, 将重置计时器。 `timeOutInterval`  
  
> [!IMPORTANT]
>  <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。 使用最大计数为1的,而不是。<xref:System.Threading.Mutex> <xref:System.Threading.Semaphore>  
  
 若要取消等待操作, 请调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法。  
  
 等待线程使用 Win32 `WaitForMultipleObjects`函数监视已注册的等待操作。 因此, 如果必须在多个调用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>中使用相同的本机操作系统句柄, 则必须使用 Win32 `DuplicateHandle`函数复制句柄。 请注意, 不应脉冲传递给<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>的事件对象, 因为等待线程可能检测不到事件在重置前已发出信号。  
  
 在返回之前, 函数会修改某些类型的同步对象的状态。 仅对其终止状态导致等待条件得到满足的对象进行修改。 例如, 信号量的计数减少1。  
  
## <a name="version-information"></a>版本信息  
 从 .NET Framework 版本2.0 开始, 属性值<xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType>将传播到<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>使用方法排队的工作线程。 在早期版本中, 不传播主体信息。  
  
   
  
## Examples  
 下面的示例演示如何使用<xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>方法在指定的等待句柄收到信号时执行指定的回调方法。 在此示例中, 回调方法为`WaitProc`, 等待句柄<xref:System.Threading.AutoResetEvent>是。  
  
 该示例定义了`TaskInfo`一个类, 用于保存在执行时传递给回调的信息。 该示例创建一个`TaskInfo`对象, 并为其分配一些字符串数据。 <xref:System.Threading.RegisteredWaitHandle> <xref:System.Threading.RegisteredWaitHandle>方法返回的将分配`TaskInfo`给对象的字段,以便回调方法有权访问。`Handle` <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>  
  
 除了`TaskInfo`指定作为要传递给回调方法的对象, <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>对方法的调用还指定<xref:System.Threading.AutoResetEvent>了任务将`WaitProc`等待的, <xref:System.Threading.WaitOrTimerCallback>委托表示回调方法,1秒的超时间隔和多个回调。  
  
 当主线程<xref:System.Threading.AutoResetEvent>通过调用其<xref:System.Threading.EventWaitHandle.Set%2A>方法发出信号时, <xref:System.Threading.WaitOrTimerCallback>将调用委托。 `WaitProc`方法测试<xref:System.Threading.RegisteredWaitHandle>以确定是否发生了超时。 如果回调是由于等待句柄已发出信号而调用的`WaitProc` , 则该<xref:System.Threading.RegisteredWaitHandle>方法将注销, 并停止其他回调。 在超时情况下, 任务将继续等待。 `WaitProc`方法通过将消息打印到控制台来结束。  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">线程池中辅助线程的最大数目。</param>
        <param name="completionPortThreads">线程池中异步 I/O 线程的最大数目。</param>
        <summary>设置可以同时处于活动状态的线程池的请求数目。 所有大于此数目的请求将保持排队状态，直到线程池线程变为可用。</summary>
        <returns>如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 不能将工作线程或 i/o 完成线程的最大数目设置为小于计算机上的处理器数。 若要确定有多少个处理器, 可检索<xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType>属性的值。 此外, 不能将最大工作线程或 i/o 完成线程的最大数目设置为小于工作线程或 i/o 完成线程对应的最小数目的数字。 若要确定最小线程池大小, 请<xref:System.Threading.ThreadPool.GetMinThreads%2A>调用方法。  
  
 如果托管公共语言运行时 (例如 Internet Information Services (IIS) 或 SQL Server), 则宿主可能会限制或阻止对线程池大小所做的更改。  
  
 更改线程池中线程的最大数量时, 请务必小心。 虽然你的代码可能会受益, 但所做的更改可能会对你使用的代码库产生不利影响。  
  
 将线程池大小设置得太大可能会导致性能问题。 如果同时执行的线程太多, 任务切换开销会成为一个重要因素。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于控制线程。 权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="completionPortThreads" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="workerThreads">要由线程池根据需要创建的新的最小工作程序线程数。</param>
        <param name="completionPortThreads">要由线程池根据需要创建的新的最小空闲异步 I/O 线程数。</param>
        <summary>发出新的请求时，在切换到管理线程创建和销毁的算法之前设置线程池按需创建的线程的最小数量。</summary>
        <returns>如果更改成功，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 线程池按需提供新的工作线程或 i/o 完成线程, 直到达到每个类别的最小值。 达到最小值时, 线程池可以在该类别中创建更多的线程, 或等待某些任务完成。 从开始, 线程池创建并销毁线程, 以优化吞吐量, 定义为每个时间单位完成的任务数。 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] 线程过少可能无法实现可用资源的最优利用，而线程过多则可能增加资源争用。  
  
 需求较低时，线程池线程的实际数量可以低于最小值。  
  
 如果指定一个负数或一个大于活动线程池线程的最大数目 (使用<xref:System.Threading.ThreadPool.GetMaxThreads%2A>获得) 的数字, <xref:System.Threading.ThreadPool.SetMinThreads%2A>则返回`false` , 并且不会更改任何一个最小值。  
  
> [!CAUTION]
>  默认情况下, 最小线程数设置为系统上的处理器数。 您可以使用<xref:System.Threading.ThreadPool.SetMinThreads%2A>方法来增加最小线程数。 但是，不必要地增加这些值可能导致性能问题。 如果在同一时间开始太多的任务，则所有任务均可能会很慢。 在大多数情况下, 线程池可通过其自身用于分配线程的算法来更好地执行。 将最小值减小到小于处理器数量也可能会影响性能。  
  
   
  
## Examples  
 下面的示例将最小工作线程数设置为 4, 并保留最小异步 i/o 完成线程数的原始值。  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">用于控制线程。 权限值:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="ThreadCount">
      <MemberSignature Language="C#" Value="public static int ThreadCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ThreadCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ThreadPool.ThreadCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ThreadCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ThreadCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadCount : int" Usage="System.Threading.ThreadPool.ThreadCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>获取当前存在的线程池线程数。</summary>
        <value>当前存在的线程池线程数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

如果线程池实现可能具有不同类型的线程, 则计数将包括所有类型。

        ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="overlapped">要排队的 <see cref="T:System.Threading.NativeOverlapped" /> 结构。</param>
        <summary>将重叠的 I/O 操作排队以便执行。</summary>
        <returns>如果成功地将此操作排队到 I/O 完成端口，则为 <see langword="true" />；否则为 <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 有关使用本机 Win32 重叠 i/o 的信息, 请参阅 Win32 平台<xref:System.Threading.Overlapped> SDK 中的<xref:System.Threading.NativeOverlapped>类、结构和`OVERLAPPED`结构。  
  
> [!CAUTION]
>  <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>使用方法可能会无意中打开安全漏洞。 代码访问安全性根据堆栈上所有调用方的权限检查其权限。 当工作在线程池线程上使用<xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>排队时, 线程池线程的堆栈没有实际调用方的上下文。 恶意代码可以利用此漏洞来避免权限检查。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">当线程池中的线程选择工作项时调用的工作项。</param>
        <param name="preferLocal"><see langword="true" /> 表示首选在靠近当前线程的队列中对工作项进行排队；<see langword="false" /> 则表示首选将工作项排队到线程池的共享队列中。</param>
        <summary>将指定的工作项对象排队到线程池。</summary>
        <returns>如果方法成功，则为 <see langword="true" />；如果未能将该工作项排队，则引发 <see cref="T:System.OutOfMemoryException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

线程池将调用工作项的<xref:System.Threading.IThreadPoolWorkItem.Execute>方法。 如果需要, 该工作项负责传播<xref:System.Threading.ExecutionContext> , 而线程池则不会执行此操作。

         ]]></format>
       </remarks>
         <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> 为 <see langword="null" />。</exception>
         <exception cref="T:System.ArgumentOutOfRangeException">该工作项是一个 <see cref="T:System.Threading.Tasks.Task" />。</exception>
         <exception cref="T:System.OutOfMemoryException">未能将该工作项排队。</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="callBack">一个 <see cref="T:System.Threading.WaitCallback" />，表示当线程池中的线程选择工作项时调用的委托。</param>
        <param name="state">在接受线程池服务时传递给委托的对象。</param>
        <summary>将指定的委托排队到线程池，但不会将调用堆栈传播到辅助线程。</summary>
        <returns>如果方法成功，则为 <see langword="true" />；如果未能将该工作项排队，则引发 <see cref="T:System.OutOfMemoryException" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与方法不同, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>不会将调用堆栈传播到辅助线程。 <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> 这允许代码丢失调用堆栈, 从而提升其安全权限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>可能会无意中打开安全漏洞。 代码访问安全性根据堆栈上所有调用方的权限检查其权限。 当工作在线程池线程上使用<xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>排队时, 线程池线程的堆栈将不具有实际调用方的上下文。 恶意代码可以利用此漏洞来避免权限检查。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <exception cref="T:System.ApplicationException">遇到了内存不足的情况。</exception>
        <exception cref="T:System.OutOfMemoryException">未能将该工作项排队。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="callBack" /> 为 <see langword="null" />。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState"><paramref name="state" /> 的元素类型。</typeparam>
        <param name="callBack">表示要执行的方法的委托。</param>
        <param name="state">包含方法所用数据的对象。</param>
        <param name="preferLocal"><see langword="true" /> 表示首选在靠近当前线程的队列中对工作项进行排队；<see langword="false" /> 则表示首选将工作项排队到线程池的共享队列中。</param>
        <summary>将 <see cref="T:System.Action`1" /> 委托指定的方法排入队列以便执行，并指定包含该方法使用的数据的对象。 此方法在有线程池线程变得可用时执行。</summary>
        <returns>如果此方法成功排队，则为 <see langword="true" />；如果无法将该工作项排队，则引发 <see cref="T:System.NotSupportedException" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="callback" /> 为 <see langword="null" />。</exception>
        <exception cref="T:System.NotSupportedException">未能将该工作项排队。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>注册委托以等待 <see cref="T:System.Threading.WaitHandle" />，但不会将调用堆栈传播到辅助线程。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并使用一个 32 位带符号整数来表示超时时间（以毫秒为单位）。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与方法不同, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会将调用堆栈传播到辅助线程。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这允许代码丢失调用堆栈, 从而提升其安全权限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性根据堆栈上所有调用方的权限检查其权限。 当工作在线程池线程上使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>排队时, 线程池线程的堆栈将不具有实际调用方的上下文。 恶意代码可以利用此漏洞来避免权限检查。  
  
 <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。  
  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 64 位有符号整数来表示超时值（以毫秒为单位）。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与方法不同, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会将调用堆栈传播到辅助线程。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这允许代码丢失调用堆栈, 从而提升其安全权限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性根据堆栈上所有调用方的权限检查其权限。 当工作在线程池线程上使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>排队时, 线程池线程的堆栈将不具有实际调用方的上下文。 恶意代码可以利用此漏洞来避免权限检查。  
  
 <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。  
  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeOutInterval" /> 参数小于 -1。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="timeout" Type="System.TimeSpan" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="timeout"><see cref="T:System.TimeSpan" /> 表示的超时时间。 如果 <paramref name="timeout" /> 为 0（零），则函数将测试对象的状态并立即返回。 如果 <paramref name="timeout" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>注册一个等待 <see cref="T:System.Threading.WaitHandle" /> 的委托，并指定一个 <see cref="T:System.TimeSpan" /> 值来表示超时时间。此方法不将调用堆栈传播到辅助线程。</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与方法不同, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会将调用堆栈传播到辅助线程。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这允许代码丢失调用堆栈, 从而提升其安全权限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性根据堆栈上所有调用方的权限检查其权限。 当工作在线程池线程上使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>排队时, 线程池线程的堆栈将不具有实际调用方的上下文。 恶意代码可以利用此漏洞来避免权限检查。  
  
 <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。  
  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout" /> 参数小于 -1。</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="timeout" /> 参数大于 <see cref="F:System.Int32.MaxValue" />。</exception>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="waitObject">要注册的 <see cref="T:System.Threading.WaitHandle" />。 使用 <see cref="T:System.Threading.WaitHandle" /> 而非 <see cref="T:System.Threading.Mutex" />。</param>
        <param name="callBack">向 <paramref name="waitObject" /> 参数发出信号时调用的委托。</param>
        <param name="state">传递给委托的对象。</param>
        <param name="millisecondsTimeOutInterval">以毫秒为单位的超时。 如果 <paramref name="millisecondsTimeOutInterval" /> 参数为 0（零），函数将测试对象的状态并立即返回。 如果 <paramref name="millisecondsTimeOutInterval" /> 为 -1，则函数的超时间隔永远不过期。</param>
        <param name="executeOnlyOnce">如果为 <see langword="true" />，表示在调用了委托后，线程将不再在 <paramref name="waitObject" /> 参数上等待；如果为 <see langword="false" />，表示每次完成等待操作后都重置计时器，直到注销等待。</param>
        <summary>指定表示超时（以毫秒为单位）的 32 位无符号整数，注册一个委托等待 <see cref="T:System.Threading.WaitHandle" />。 此方法不将调用堆栈传播到辅助线程。</summary>
        <returns><see cref="T:System.Threading.RegisteredWaitHandle" /> 对象，可用于取消已注册的等待操作。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 与方法不同, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>不会将调用堆栈传播到辅助线程。 <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> 这允许代码丢失调用堆栈, 从而提升其安全权限。  
  
> [!CAUTION]
>  使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>可能会无意中打开安全漏洞。 代码访问安全性根据堆栈上所有调用方的权限检查其权限。 当工作在线程池线程上使用<xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>排队时, 线程池线程的堆栈将不具有实际调用方的上下文。 恶意代码可以利用此漏洞来避免权限检查。  
  
 <xref:System.Threading.Mutex>使用 for `waitObject`不会为回调提供互斥, 因为基础 Windows API 使用默认`WT_EXECUTEDEFAULT`标志, 因此每个回调都在单独的线程池线程上进行调度。  
  
 使用<xref:System.Threading.RegisteredWaitHandle>完此方法返回的后, 调用其<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法以释放对等待句柄的引用。 建议你始终调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 即使你为`executeOnlyOnce`指定`true` 。 如果调用<xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType>方法, 而不是根据注册的等待句柄的终结器, 则垃圾回收的工作效率更高。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">调用方没有所要求的权限。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">需要对直接调用方的完全信任。 部分受信任的或透明的代码不能使用此成员。</permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md">托管线程池</related>
      </Docs>
    </Member>
  </Members>
</Type>